import { g as getDefaultExportFromCjs, c as commonjsGlobal, a as commonjsRequire } from "./index-396531f4.js";
function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e = m[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n)) {
          const d = Object.getOwnPropertyDescriptor(e, k);
          if (d) {
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: () => e[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
var hypnsBundle$2 = { exports: {} };
(function(module, exports) {
  (function(f) {
    {
      module.exports = f();
    }
  })(function() {
    return function() {
      function r(e, n, t) {
        function o(i2, f) {
          if (!n[i2]) {
            if (!e[i2]) {
              var c = "function" == typeof commonjsRequire && commonjsRequire;
              if (!f && c)
                return c(i2, true);
              if (u)
                return u(i2, true);
              var a = new Error("Cannot find module '" + i2 + "'");
              throw a.code = "MODULE_NOT_FOUND", a;
            }
            var p = n[i2] = { exports: {} };
            e[i2][0].call(p.exports, function(r2) {
              var n2 = e[i2][1][r2];
              return o(n2 || r2);
            }, p, p.exports, r, e, n, t);
          }
          return n[i2].exports;
        }
        for (var u = "function" == typeof commonjsRequire && commonjsRequire, i = 0; i < t.length; i++)
          o(t[i]);
        return o;
      }
      return r;
    }()({ 1: [function(require2, module2, exports2) {
      var EventEmitter = require2("events").EventEmitter;
      var collect = require2("collect-stream");
      var through = require2("through2");
      var readonly = require2("read-only-stream");
      var makeView = require2("kappa-view");
      module2.exports = List;
      function List(db, mapFn, opts) {
        var events = new EventEmitter();
        return makeView(db, function(ldb) {
          var idx = {
            map: function map(msgs, next) {
              var allOps = [];
              var pending = msgs.length + 1;
              for (var i = 0; i < msgs.length; i++) {
                var msg = msgs[i];
                mapFn(msg, function(err, ops) {
                  if (!ops)
                    ops = [];
                  ops = ops.map(function(op) {
                    return {
                      type: "put",
                      key: op,
                      value: msg.key + "@" + msg.seq
                    };
                  });
                  done(err, ops);
                });
              }
              done(null, []);
              function done(err, ops) {
                if (err) {
                  pending = Infinity;
                  return next(err);
                }
                allOps.push.apply(allOps, ops);
                if (!--pending)
                  ldb.batch(allOps, next);
              }
            },
            indexed: function indexed(msgs) {
              for (var i = 0; i < msgs.length; i++) {
                mapFn(msgs[i], function(err, ops) {
                  if (err)
                    return;
                  events.emit("insert", msgs[i]);
                });
              }
            },
            api: {
              read: function read(core, opts2, cb) {
                if (typeof opts2 === "function" && !cb) {
                  cb = opts2;
                  opts2 = {};
                }
                opts2 = opts2 || {};
                var t = through.obj(function(entry, _, next) {
                  var id = entry.value;
                  var feed = core._logs.feed(id.split("@")[0]);
                  var seq = Number(id.split("@")[1]);
                  feed.get(seq, function(err, value) {
                    if (err)
                      return next(err);
                    next(null, {
                      key: feed.key.toString("hex"),
                      seq,
                      value
                    });
                  });
                });
                core.ready(function() {
                  ldb.createReadStream(opts2).pipe(t);
                });
                if (cb)
                  collect(t, cb);
                else
                  return readonly(t);
              },
              onInsert: function onInsert(core, cb) {
                events.on("insert", cb);
              },
              tail: function tail(core, size, fn) {
                events.on("insert", function(msg) {
                  idx.api.read(core, {
                    limit: size,
                    reverse: true
                  }, function(err, msgs) {
                    var found = msgs.filter(function(m) {
                      return msg.key === m.key && msg.seq === m.seq;
                    }).length > 0;
                    if (found)
                      fn(msgs.reverse());
                  });
                });
              }
            }
          };
          return idx;
        });
      }
    }, { "collect-stream": 95, "events": 193, "kappa-view": 266, "read-only-stream": 386, "through2": 2 }], 2: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          var Transform = require2("readable-stream").Transform, inherits = require2("inherits");
          function DestroyableTransform(opts) {
            Transform.call(this, opts);
            this._destroyed = false;
          }
          inherits(DestroyableTransform, Transform);
          DestroyableTransform.prototype.destroy = function(err) {
            if (this._destroyed)
              return;
            this._destroyed = true;
            var self2 = this;
            process.nextTick(function() {
              if (err)
                self2.emit("error", err);
              self2.emit("close");
            });
          };
          function noop(chunk, enc, callback) {
            callback(null, chunk);
          }
          function through2(construct) {
            return function(options, transform, flush) {
              if (typeof options == "function") {
                flush = transform;
                transform = options;
                options = {};
              }
              if (typeof transform != "function")
                transform = noop;
              if (typeof flush != "function")
                flush = null;
              return construct(options, transform, flush);
            };
          }
          module2.exports = through2(function(options, transform, flush) {
            var t2 = new DestroyableTransform(options);
            t2._transform = transform;
            if (flush)
              t2._flush = flush;
            return t2;
          });
          module2.exports.ctor = through2(function(options, transform, flush) {
            function Through2(override) {
              if (!(this instanceof Through2))
                return new Through2(override);
              this.options = Object.assign({}, options, override);
              DestroyableTransform.call(this, this.options);
            }
            inherits(Through2, DestroyableTransform);
            Through2.prototype._transform = transform;
            if (flush)
              Through2.prototype._flush = flush;
            return Through2;
          });
          module2.exports.obj = through2(function(options, transform, flush) {
            var t2 = new DestroyableTransform(Object.assign({
              objectMode: true,
              highWaterMark: 16
            }, options));
            t2._transform = transform;
            if (flush)
              t2._flush = flush;
            return t2;
          });
        }).call(this);
      }).call(this, require2("_process"));
    }, { "_process": 361, "inherits": 256, "readable-stream": 412 }], 3: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var RandomAccess = require2("random-access-storage");
          var inherits = require2("inherits");
          var nextTick = require2("next-tick");
          var once = require2("once");
          var blocks = require2("./lib/blocks.js");
          var bufferFrom = require2("buffer-from");
          var bufferAlloc = require2("buffer-alloc");
          var DELIM = "\0";
          module2.exports = function(dbname, xopts) {
            if (!xopts)
              xopts = {};
            var win = typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {};
            var idb = xopts.idb || (typeof win !== "undefined" ? win.indexedDB || win.mozIndexedDB || win.webkitIndexedDB || win.msIndexedDB : null);
            if (!idb)
              throw new Error("indexedDB not present and not given");
            var db = null;
            var dbqueue = [];
            if (typeof idb.open === "function") {
              var req = idb.open(dbname);
              req.addEventListener("upgradeneeded", function() {
                db = req.result;
                db.createObjectStore("data");
              });
              req.addEventListener("success", function() {
                db = req.result;
                dbqueue.forEach(function(cb) {
                  cb(db);
                });
                dbqueue = null;
              });
            } else {
              db = idb;
            }
            return function(name, opts) {
              if (typeof name === "object") {
                opts = name;
                name = opts.name;
              }
              if (!opts)
                opts = {};
              opts.name = name;
              return new Store(Object.assign({
                db: getdb
              }, xopts, opts));
            };
            function getdb(cb) {
              if (db)
                nextTick(function() {
                  cb(db);
                });
              else
                dbqueue.push(cb);
            }
          };
          function Store(opts) {
            if (!(this instanceof Store))
              return new Store(opts);
            RandomAccess.call(this);
            if (!opts)
              opts = {};
            if (typeof opts === "string")
              opts = {
                name: opts
              };
            this.size = opts.size || 4096;
            this.name = opts.name;
            this.length = opts.length || 0;
            this._getdb = opts.db;
          }
          inherits(Store, RandomAccess);
          Store.prototype._blocks = function(i, j) {
            return blocks(this.size, i, j);
          };
          Store.prototype._read = function(req) {
            var self2 = this;
            var buffers = [];
            self2._store("readonly", function(err, store) {
              if ((self2.length || 0) < req.offset + req.size) {
                return req.callback(new Error("Could not satisfy length"), null);
              }
              if (err)
                return req.callback(err);
              var offsets = self2._blocks(req.offset, req.offset + req.size);
              var pending = offsets.length + 1;
              var firstBlock = offsets.length > 0 ? offsets[0].block : 0;
              for (var i = 0; i < offsets.length; i++) {
                (function(o) {
                  var key = self2.name + DELIM + o.block;
                  backify(store.get(key), function(err2, ev) {
                    if (err2)
                      return req.callback(err2);
                    buffers[o.block - firstBlock] = ev.target.result ? bufferFrom(ev.target.result.subarray(o.start, o.end)) : bufferAlloc(o.end - o.start);
                    if (--pending === 0)
                      req.callback(null, Buffer.concat(buffers));
                  });
                })(offsets[i]);
              }
              if (--pending === 0)
                req.callback(null, Buffer.concat(buffers));
            });
          };
          Store.prototype._write = function(req) {
            var self2 = this;
            self2._store("readwrite", function(err, store) {
              if (err)
                return req.callback(err);
              var offsets = self2._blocks(req.offset, req.offset + req.data.length);
              var pending = 1;
              var buffers = {};
              for (var i = 0; i < offsets.length; i++) {
                (function(o, i2) {
                  if (o.end - o.start === self2.size)
                    return;
                  pending++;
                  var key = self2.name + DELIM + o.block;
                  backify(store.get(key), function(err2, ev) {
                    if (err2)
                      return req.callback(err2);
                    buffers[i2] = bufferFrom(ev.target.result || bufferAlloc(self2.size));
                    if (--pending === 0)
                      write(store, offsets, buffers);
                  });
                })(offsets[i], i);
              }
              if (--pending === 0)
                write(store, offsets, buffers);
            });
            function write(store, offsets, buffers) {
              var block;
              for (var i = 0, j = 0; i < offsets.length; i++) {
                var o = offsets[i];
                var len = o.end - o.start;
                if (len === self2.size) {
                  block = bufferFrom(req.data.slice(j, j + len));
                } else {
                  block = buffers[i];
                  req.data.copy(block, o.start, j, j + len);
                }
                store.put(block, self2.name + DELIM + o.block);
                j += len;
              }
              var length = Math.max(self2.length || 0, req.offset + req.data.length);
              store.put(length, self2.name + DELIM + "length");
              store.transaction.addEventListener("complete", function() {
                self2.length = length;
                req.callback(null);
              });
              store.transaction.addEventListener("error", function(err) {
                req.callback(err);
              });
            }
          };
          Store.prototype._store = function(mode, cb) {
            cb = once(cb);
            var self2 = this;
            self2._getdb(function(db) {
              var tx = db.transaction(["data"], mode);
              var store = tx.objectStore("data");
              tx.addEventListener("error", cb);
              cb(null, store);
            });
          };
          Store.prototype._open = function(req) {
            var self2 = this;
            this._getdb(function(db) {
              self2._store("readonly", function(err, store) {
                if (err)
                  return req.callback(err);
                backify(store.get(self2.name + DELIM + "length"), function(err2, ev) {
                  if (err2)
                    return req.callback(err2);
                  self2.length = ev.target.result || 0;
                  req.callback(null);
                });
              });
            });
          };
          Store.prototype._close = function(req) {
            this._getdb(function(db) {
              req.callback();
            });
          };
          Store.prototype._stat = function(req) {
            var self2 = this;
            nextTick(function() {
              req.callback(null, {
                size: self2.length
              });
            });
          };
          function backify(r, cb) {
            r.addEventListener("success", function(ev) {
              cb(null, ev);
            });
            r.addEventListener("error", cb);
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "./lib/blocks.js": 4, "buffer": 82, "buffer-alloc": 84, "buffer-from": 5, "inherits": 256, "next-tick": 329, "once": 339, "random-access-storage": 381 }], 4: [function(require2, module2, exports2) {
      module2.exports = function(size, start, end) {
        var result = [];
        for (var n = Math.floor(start / size) * size; n < end; n += size) {
          result.push({
            block: Math.floor(n / size),
            start: Math.max(n, start) % size,
            end: Math.min(n + size, end) % size || size
          });
        }
        return result;
      };
    }, {}], 5: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var toString = Object.prototype.toString;
          var isModern = typeof Buffer.alloc === "function" && typeof Buffer.allocUnsafe === "function" && typeof Buffer.from === "function";
          function isArrayBuffer(input) {
            return toString.call(input).slice(8, -1) === "ArrayBuffer";
          }
          function fromArrayBuffer(obj, byteOffset, length) {
            byteOffset >>>= 0;
            var maxLength = obj.byteLength - byteOffset;
            if (maxLength < 0) {
              throw new RangeError("'offset' is out of bounds");
            }
            if (length === void 0) {
              length = maxLength;
            } else {
              length >>>= 0;
              if (length > maxLength) {
                throw new RangeError("'length' is out of bounds");
              }
            }
            return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)));
          }
          function fromString(string, encoding) {
            if (typeof encoding !== "string" || encoding === "") {
              encoding = "utf8";
            }
            if (!Buffer.isEncoding(encoding)) {
              throw new TypeError('"encoding" must be a valid string encoding');
            }
            return isModern ? Buffer.from(string, encoding) : new Buffer(string, encoding);
          }
          function bufferFrom(value, encodingOrOffset, length) {
            if (typeof value === "number") {
              throw new TypeError('"value" argument must not be a number');
            }
            if (isArrayBuffer(value)) {
              return fromArrayBuffer(value, encodingOrOffset, length);
            }
            if (typeof value === "string") {
              return fromString(value, encodingOrOffset);
            }
            return isModern ? Buffer.from(value) : new Buffer(value);
          }
          module2.exports = bufferFrom;
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82 }], 6: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
            try {
              var info = gen[key](arg);
              var value = info.value;
            } catch (error) {
              reject(error);
              return;
            }
            if (info.done) {
              resolve(value);
            } else {
              Promise.resolve(value).then(_next, _throw);
            }
          }
          function _asyncToGenerator(fn) {
            return function() {
              var self2 = this, args = arguments;
              return new Promise(function(resolve, reject) {
                var gen = fn.apply(self2, args);
                function _next(value) {
                  asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
                }
                function _throw(err) {
                  asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
                }
                _next(void 0);
              });
            };
          }
          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              if (enumerableOnly)
                symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
              keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              if (i % 2) {
                ownKeys(Object(source), true).forEach(function(key) {
                  _defineProperty(target, key, source[key]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys(Object(source)).forEach(function(key) {
                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
              }
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var {
            NanoresourcePromise: Nanoresource
          } = require2("nanoresource-promise/emitter");
          var HypercoreProtocol = require2("hypercore-protocol");
          var hyperswarm = require2("hyperswarm-web");
          var codecs = require2("codecs");
          var pump = require2("pump");
          var maybe = require2("call-me-maybe");
          var STREAM_PEER = Symbol("networker-stream-peer");
          class CorestoreNetworker extends Nanoresource {
            constructor(corestore) {
              var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              super();
              this.corestore = corestore;
              this.opts = opts;
              this.keyPair = opts.keyPair || HypercoreProtocol.keyPair();
              this._replicationOpts = {
                encrypt: true,
                live: true,
                keyPair: this.keyPair
              };
              this.streams = /* @__PURE__ */ new Set();
              this.peers = /* @__PURE__ */ new Set();
              this._joined = /* @__PURE__ */ new Set();
              this._flushed = /* @__PURE__ */ new Set();
              this._configurations = /* @__PURE__ */ new Map();
              this._extensions = /* @__PURE__ */ new Set();
              this._streamsProcessing = 0;
              this._streamsProcessed = 0;
              this.swarm = null;
              this.setMaxListeners(0);
            }
            _replicate(protocolStream) {
              this.corestore.replicate(false, _objectSpread(_objectSpread({}, this._replicationOpts), {}, {
                stream: protocolStream
              }));
            }
            _flush(keyString, keyBuf) {
              var _this = this;
              return _asyncToGenerator(function* () {
                yield new Promise((resolve, reject) => {
                  _this.swarm.flush((err) => {
                    if (err)
                      reject(err);
                    else
                      resolve();
                  });
                });
                if (!_this._joined.has(keyString)) {
                  return;
                }
                var processingAfterFlush = _this._streamsProcessing;
                if (_this._streamsProcessed >= processingAfterFlush) {
                  _this._flushed.add(keyString);
                  _this.emit("flushed", keyBuf);
                } else {
                  var processedListener = () => {
                    if (!_this._joined.has(keyString)) {
                      _this.removeListener("stream-processed", processedListener);
                      return;
                    }
                    if (_this._streamsProcessed >= processingAfterFlush) {
                      _this._flushed.add(keyString);
                      _this.emit("flushed", keyBuf);
                      _this.removeListener("stream-processed", processedListener);
                    }
                  };
                  _this.on("stream-processed", processedListener);
                }
              })();
            }
            _join(discoveryKey) {
              var _arguments = arguments, _this2 = this;
              return _asyncToGenerator(function* () {
                var opts = _arguments.length > 1 && _arguments[1] !== void 0 ? _arguments[1] : {};
                var keyString = toString(discoveryKey);
                var keyBuf = discoveryKey instanceof Buffer ? discoveryKey : Buffer.from(discoveryKey, "hex");
                _this2._joined.add(keyString);
                _this2.emit("joined", keyBuf);
                _this2.swarm.join(keyBuf, {
                  announce: opts.announce,
                  lookup: opts.lookup
                });
                var flushedProm = _this2._flush(keyString, keyBuf);
                if (opts.flush !== false)
                  yield flushedProm;
                else
                  flushedProm.catch(() => {
                  });
              })();
            }
            _leave(discoveryKey) {
              var keyString = toString(discoveryKey);
              var keyBuf = discoveryKey instanceof Buffer ? discoveryKey : Buffer.from(discoveryKey, "hex");
              this._joined.delete(keyString);
              return new Promise((resolve, reject) => {
                this.swarm.leave(keyBuf, (err) => {
                  if (err)
                    return reject(err);
                  return resolve();
                });
              });
            }
            _registerAllExtensions(peer) {
              for (var ext of this._extensions) {
                ext._registerExtension(peer);
              }
            }
            _unregisterAllExtensions(peer) {
              for (var ext of this._extensions) {
                ext._unregisterExtension(peer);
              }
            }
            _addStream(stream) {
              this._replicate(stream);
              this.streams.add(stream);
              var peer = intoPeer(stream);
              this.peers.add(peer);
              stream[STREAM_PEER] = peer;
              this._registerAllExtensions(peer);
              this.emit("peer-add", peer);
              this.emit("handshake", stream);
            }
            _removeStream(stream) {
              this.streams.delete(stream);
              if (stream[STREAM_PEER]) {
                var peer = stream[STREAM_PEER];
                this._unregisterAllExtensions(peer);
                this.peers.delete(peer);
                this.emit("peer-remove", peer);
              }
            }
            _open() {
              var self2 = this;
              if (this.swarm)
                return;
              this.swarm = hyperswarm(_objectSpread(_objectSpread({}, this.opts), {}, {
                announceLocalNetwork: true,
                queue: {
                  multiplex: true
                }
              }));
              this.swarm.on("error", (err) => this.emit("error", err));
              this.swarm.on("connection", (socket, info) => {
                var isInitiator = !!info.client;
                if (socket.remoteAddress === "::ffff:127.0.0.1" || socket.remoteAddress === "127.0.0.1")
                  return null;
                var finishedHandshake = false;
                var processed = false;
                var protocolStream = new HypercoreProtocol(isInitiator, _objectSpread({}, this._replicationOpts));
                protocolStream.on("handshake", () => {
                  var deduped = info.deduplicate(protocolStream.publicKey, protocolStream.remotePublicKey);
                  if (!deduped) {
                    finishedHandshake = true;
                    self2._addStream(protocolStream);
                  }
                  if (!processed) {
                    processed = true;
                    this._streamsProcessed++;
                    this.emit("stream-processed");
                  }
                });
                protocolStream.on("close", () => {
                  this.emit("stream-closed", protocolStream, info, finishedHandshake);
                  if (!processed) {
                    processed = true;
                    this._streamsProcessed++;
                    this.emit("stream-processed");
                  }
                });
                pump(socket, protocolStream, socket, (err) => {
                  if (err)
                    this.emit("replication-error", err);
                  this._removeStream(protocolStream);
                });
                this.emit("stream-opened", protocolStream, info);
                this._streamsProcessing++;
              });
            }
            _close() {
              var _this3 = this;
              return _asyncToGenerator(function* () {
                if (!_this3.swarm)
                  return null;
                for (var ext of _this3._extensions) {
                  ext.destroy();
                }
                _this3._extensions.clear();
                for (var stream of _this3.streams) {
                  stream.destroy();
                }
                return new Promise((resolve, reject) => {
                  _this3.swarm.destroy((err) => {
                    if (err)
                      return reject(err);
                    _this3.swarm = null;
                    return resolve();
                  });
                });
              })();
            }
            listen() {
              return this.open();
            }
            status(discoveryKey) {
              if (Buffer.isBuffer(discoveryKey))
                discoveryKey = discoveryKey.toString("hex");
              return this._configurations.get(discoveryKey);
            }
            allStatuses() {
              return [...this._configurations].map((_ref) => {
                var [k, v] = _ref;
                return _objectSpread({
                  discoveryKey: Buffer.from(k, "hex")
                }, v);
              });
            }
            configure(discoveryKey) {
              var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              var cb = arguments.length > 2 ? arguments[2] : void 0;
              return maybeOptional(cb, this._configure(discoveryKey, opts));
            }
            _configure(discoveryKey, opts) {
              var _this4 = this;
              return _asyncToGenerator(function* () {
                if (!_this4.swarm)
                  _this4.open();
                if (_this4.swarm && _this4.swarm.destroyed)
                  return;
                var config = {
                  announce: opts.announce !== false,
                  lookup: opts.lookup !== false
                };
                opts = _objectSpread(_objectSpread({}, opts), config);
                var keyString = toString(discoveryKey);
                var prev = _this4._configurations.get(keyString);
                var joining = config.announce || config.lookup;
                if (joining)
                  _this4._configurations.set(keyString, opts);
                else
                  _this4._configurations.delete(keyString);
                if (joining) {
                  if (opts.rejoin === false && prev && prev.lookup === config.lookup && prev.announce === config.announce)
                    return;
                  return _this4._join(discoveryKey, opts);
                } else {
                  return _this4._leave(discoveryKey);
                }
              })();
            }
            joined(discoveryKey) {
              if (typeof discoveryKey !== "string")
                discoveryKey = discoveryKey.toString("hex");
              return this._joined.has(discoveryKey);
            }
            flushed(discoveryKey) {
              if (typeof discoveryKey !== "string")
                discoveryKey = discoveryKey.toString("hex");
              return this._flushed.has(discoveryKey);
            }
            registerExtension(name, handlers) {
              if (name && typeof name === "object")
                return this.registerExtension(null, name);
              var ext = new SwarmExtension(this, name || handlers.name, handlers);
              this._extensions.add(ext);
              for (var peer of this.peers) {
                ext._registerExtension(peer);
              }
              return ext;
            }
          }
          module2.exports = CorestoreNetworker;
          class SwarmExtension {
            constructor(networker, name, opts) {
              if (typeof opts === "function")
                opts = opts(this);
              this.networker = networker;
              this.name = name;
              this.encoding = codecs(opts && opts.encoding || "binary");
              this._peerExtensions = /* @__PURE__ */ new Map();
              this.onmessage = opts.onmessage;
              this.onerror = opts.onerror;
            }
            _registerExtension(peer) {
              peer.stream.extensions.exclusive = false;
              var peerExt = peer.stream.registerExtension(this.name, {
                encoding: this.encoding,
                onmessage: this.onmessage && ((message) => this.onmessage(message, peer)),
                onerror: this.onerror && ((err) => this.onerror(err))
              });
              this._peerExtensions.set(peer, peerExt);
            }
            _unregisterExtension(peer) {
              if (!this._peerExtensions.has(peer))
                return;
              var peerExt = this._peerExtensions.get(peer);
              peerExt.destroy();
              this._peerExtensions.delete(peer);
            }
            broadcast(message) {
              for (var peerExt of this._peerExtensions.values()) {
                peerExt.send(message);
              }
            }
            send(message, peer) {
              var peerExt = this._peerExtensions.get(peer);
              if (!peer)
                throw new Error("Peer must be specified.");
              if (!peerExt)
                throw new Error("Extension not registered for peer " + peer.remotePublicKey.toString("hex"));
              peerExt.send(message);
            }
            destroy() {
              for (var peerExt of this._peerExtensions.values()) {
                peerExt.destroy();
              }
              this._peerExtensions.clear();
              this.onmessage = null;
              this.onerror = null;
            }
          }
          function intoPeer(stream) {
            return {
              remotePublicKey: stream.remotePublicKey,
              remoteAddress: stream.remoteAddress,
              type: stream.remoteType,
              stream
            };
          }
          function toString(dk) {
            return typeof dk === "string" ? dk : dk.toString("hex");
          }
          function noop() {
          }
          function maybeOptional(cb, prom) {
            if (cb)
              maybe(cb, prom);
            else
              prom.catch(noop);
            return prom;
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82, "call-me-maybe": 90, "codecs": 94, "hypercore-protocol": 228, "hyperswarm-web": 248, "nanoresource-promise/emitter": 7, "pump": 376 }], 7: [function(require2, module2, exports2) {
      function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator(fn) {
        return function() {
          var self2 = this, args = arguments;
          return new Promise(function(resolve, reject) {
            var gen = fn.apply(self2, args);
            function _next(value) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(void 0);
          });
        };
      }
      var {
        EventEmitter
      } = require2("events");
      var nanoresource = require2(".");
      var kNanoresource = Symbol("nanosignal.nanoresource");
      class NanoresourcePromise extends EventEmitter {
        constructor() {
          var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          super();
          this[kNanoresource] = nanoresource({
            open: opts.open || this._open.bind(this),
            close: opts.close || this._close.bind(this)
          });
        }
        get opened() {
          return this[kNanoresource].opened;
        }
        get opening() {
          return this[kNanoresource].opening;
        }
        get closed() {
          return this[kNanoresource].closed;
        }
        get closing() {
          return this[kNanoresource].closing;
        }
        get actives() {
          return this[kNanoresource].actives;
        }
        open() {
          var _this = this;
          return _asyncToGenerator(function* () {
            yield _this[kNanoresource].open();
            _this.emit("opened");
          })();
        }
        close(allowActive) {
          var _this2 = this;
          return _asyncToGenerator(function* () {
            yield _this2[kNanoresource].close(allowActive);
            _this2.emit("closed");
          })();
        }
        active() {
          return this[kNanoresource].active();
        }
        inactive(err, value) {
          return this[kNanoresource].inactive(err, value);
        }
        _open() {
          return _asyncToGenerator(function* () {
          })();
        }
        _close() {
          return _asyncToGenerator(function* () {
          })();
        }
      }
      module2.exports = (opts) => new NanoresourcePromise(opts);
      module2.exports.NanoresourcePromise = NanoresourcePromise;
    }, { ".": 8, "events": 193 }], 8: [function(require2, module2, exports2) {
      function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator(fn) {
        return function() {
          var self2 = this, args = arguments;
          return new Promise(function(resolve, reject) {
            var gen = fn.apply(self2, args);
            function _next(value) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(void 0);
          });
        };
      }
      var nanoresource = require2("nanoresource");
      function callbackPromise() {
        var callback;
        var promise = new Promise((resolve, reject) => {
          callback = (err, value) => {
            if (err)
              reject(err);
            else
              resolve(value);
          };
        });
        callback.promise = promise;
        return callback;
      }
      var kProcessPromise = Symbol("processpromise");
      class NanoresourcePromise extends nanoresource {
        constructor(opts) {
          super(opts);
          var prevOpen = this._open.bind(this);
          var prevClose = this._close.bind(this);
          this._open = (cb) => this[kProcessPromise](prevOpen, cb);
          this._close = (cb) => this[kProcessPromise](prevClose, cb);
        }
        open() {
          var callback = callbackPromise();
          super.open(callback);
          return callback.promise;
        }
        close() {
          var allowActive = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
          var callback;
          if (typeof allowActive === "function") {
            callback = allowActive;
            allowActive = false;
          } else {
            callback = callbackPromise();
          }
          super.close(allowActive, callback);
          return callback.promise;
        }
        active() {
          var callback = nanoresource.callbackPromise();
          super.active(callback);
          return callback.promise;
        }
        inactive(err, val) {
          var callback = nanoresource.callbackPromise();
          super.inactive(callback, err, val);
          return callback.promise;
        }
        _open() {
          return _asyncToGenerator(function* () {
          })();
        }
        _close() {
          return _asyncToGenerator(function* () {
          })();
        }
        [kProcessPromise](fnPromise, cb) {
          return _asyncToGenerator(function* () {
            try {
              yield fnPromise();
              cb();
            } catch (err) {
              cb(err);
            }
          })();
        }
      }
      module2.exports = (opts) => new NanoresourcePromise(opts);
      module2.exports.NanoresourcePromise = NanoresourcePromise;
    }, { "nanoresource": 328 }], 9: [function(require2, module2, exports2) {
      (function(process, Buffer) {
        (function() {
          function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
            try {
              var info = gen[key](arg);
              var value = info.value;
            } catch (error) {
              reject(error);
              return;
            }
            if (info.done) {
              resolve(value);
            } else {
              Promise.resolve(value).then(_next, _throw);
            }
          }
          function _asyncToGenerator(fn) {
            return function() {
              var self2 = this, args = arguments;
              return new Promise(function(resolve, reject) {
                var gen = fn.apply(self2, args);
                function _next(value) {
                  asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
                }
                function _throw(err) {
                  asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
                }
                _next(void 0);
              });
            };
          }
          var {
            EventEmitter
          } = require2("events");
          var crypto = require2("crypto");
          var assert = require2("nanocustomassert");
          var pump = require2("pump");
          var log = require2("debug")("discovery-swarm-webrtc");
          var MMSTSignalClient = require2("./lib/mmst-signal-client");
          var {
            toHex,
            callbackPromise,
            resolveCallback
          } = require2("./lib/utils");
          var errors = require2("./lib/errors");
          var {
            ERR_CONNECTION_DUPLICATED
          } = errors;
          var assertChannel = (channel) => assert(Buffer.isBuffer(channel) && channel.length === 32, "Channel must be a buffer of 32 bytes");
          class DiscoverySwarmWebrtc extends EventEmitter {
            constructor() {
              var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              super();
              log("opts", opts);
              var {
                id = crypto.randomBytes(32),
                bootstrap,
                stream,
                simplePeer,
                maxPeers = 5,
                timeout = 15 * 1e3,
                signal
              } = opts;
              assert(Array.isArray(bootstrap) && bootstrap.length > 0, "The `bootstrap` options is required.");
              assert(Buffer.isBuffer(id) && id.length === 32, "The `id` option needs to be a Buffer of 32 bytes.");
              this.id = id;
              var queueTimeout = timeout * 2;
              this.signal = signal || new MMSTSignalClient({
                id: this.id,
                bootstrap,
                createConnection: (peer) => this._createConnection(peer),
                mmstOpts: {
                  maxPeers,
                  queueTimeout,
                  lookupTimeout: timeout
                },
                requestTimeout: timeout,
                simplePeer,
                reconnectingWebsocket: {
                  connectionTimeout: timeout
                }
              });
              this._maxPeers = maxPeers;
              this._stream = stream;
              this._destroyed = false;
              this._initialize(opts);
            }
            get connected() {
              return this.signal.peersConnected;
            }
            get connecting() {
              return this.signal.peersConnecting;
            }
            listen() {
            }
            getPeers(channel) {
              if (channel)
                return this.signal.getPeersByTopic(channel);
              return this.signal.peersConnected;
            }
            join(channel) {
              this.signal.join(channel);
            }
            leave(channel) {
              var cb = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : callbackPromise();
              assertChannel(channel);
              resolveCallback(this.signal.leave(channel), cb);
              return cb.promise;
            }
            close() {
              var cb = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : callbackPromise();
              resolveCallback(this._close(), cb);
              return cb.promise;
            }
            connect(channel, peerId) {
              var _this = this;
              return _asyncToGenerator(function* () {
                assert(channel && Buffer.isBuffer(channel), "channel must be a buffer");
                assert(peerId && Buffer.isBuffer(peerId), "peerId must be a buffer");
                var peer = _this.signal.connect(channel, peerId);
                peer.subscribeMediaStream = true;
                yield peer.ready();
                return peer.stream;
              })();
            }
            _close() {
              var _this2 = this;
              return _asyncToGenerator(function* () {
                if (_this2._destroyed)
                  return;
                _this2._destroyed = true;
                yield _this2.signal.close();
                _this2.emit("close");
              })();
            }
            _initialize() {
              var _this3 = this;
              var signal = this.signal;
              this.on("error", function() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                return log("error", ...args);
              });
              signal.on("peer-error", (err) => this.emit("error", err));
              signal.on("error", (err) => this.emit("error", err));
              signal.open().catch((err) => process.nextTick(() => this.emit("error", err)));
              signal.on("candidates-updated", function() {
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = arguments[_key2];
                }
                return _this3.emit("candidates-updated", ...args);
              });
            }
            _createConnection(peer) {
              peer.subscribeMediaStream = true;
              peer.channel = peer.topic;
              peer.getInfo = () => ({
                id: peer.id,
                channel: peer.topic,
                initiator: peer.initiator
              });
              peer.printInfo = () => ({
                id: toHex(peer.id),
                channel: toHex(peer.topic),
                initiator: peer.initiator
              });
              peer.stream.addStream = (stream) => peer.addStream(stream);
              log("createConnection", {
                info: peer.printInfo()
              });
              try {
                var duplicate = this._checkForDuplicate(peer);
                if (duplicate) {
                  if (duplicate === peer) {
                    throw new ERR_CONNECTION_DUPLICATED(toHex(this.id), toHex(peer.id));
                  } else {
                    duplicate.destroy();
                  }
                }
                this._bindSocketEvents(peer);
                return peer;
              } catch (err) {
                this.emit("connect-failed", err, peer.getInfo());
                throw err;
              }
            }
            _bindSocketEvents(peer) {
              var info = peer.getInfo();
              peer.on("error", (err) => {
                log("error", err);
                this.emit("connection-error", err, info);
              });
              peer.on("connect", () => {
                log("connect", {
                  peer
                });
                if (peer.stream.destroyed) {
                  return;
                }
                if (!this._stream) {
                  this._handleConnection(peer.stream, info);
                  return;
                }
                var conn = this._stream(info);
                this.emit("handshaking", conn, info);
                conn.on("handshake", this._handshake.bind(this, conn, info));
                pump(peer.stream, conn, peer.stream);
              });
              peer.on("close", () => {
                log("close", {
                  peer
                });
                this.emit("connection-closed", peer.stream, info);
              });
            }
            _handshake(conn, info) {
              this._handleConnection(conn, info);
            }
            _handleConnection(conn, info) {
              this.emit("connection", conn, info);
            }
            _checkForDuplicate(peer) {
              var oldPeer = this.getPeers(peer.channel).find((p) => p.id.equals(peer.id) && !p.sessionId.equals(peer.sessionId));
              if (!oldPeer) {
                return;
              }
              var connections = [peer, oldPeer];
              if (peer.initiator && oldPeer.initiator || !peer.initiator && !oldPeer.initiator) {
                return connections.sort((a, b) => Buffer.compare(a.sessionId, b.sessionId))[0];
              }
              var toDestroy = [this.id, peer.id].sort(Buffer.compare)[0];
              return connections.find((p) => p.id.equals(toDestroy));
            }
          }
          module2.exports = function() {
            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = arguments[_key3];
            }
            return new DiscoverySwarmWebrtc(...args);
          };
          module2.exports.errors = errors;
        }).call(this);
      }).call(this, require2("_process"), require2("buffer").Buffer);
    }, { "./lib/errors": 10, "./lib/mmst-signal-client": 11, "./lib/utils": 13, "_process": 361, "buffer": 82, "crypto": 117, "debug": 119, "events": 193, "nanocustomassert": 309, "pump": 376 }], 10: [function(require2, module2, exports2) {
      var nanoerror = require2("nanoerror");
      function createError(code, message) {
        exports2[code] = nanoerror(code, message);
      }
      createError("ERR_MAX_PEERS_REACHED", "max peers reached: %s");
      createError("ERR_INVALID_CHANNEL", "invalid channel: %s");
      createError("ERR_CONNECTION_DUPLICATED", "connection duplicated: %s -> %s");
    }, { "nanoerror": 310 }], 11: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
            try {
              var info = gen[key](arg);
              var value = info.value;
            } catch (error) {
              reject(error);
              return;
            }
            if (info.done) {
              resolve(value);
            } else {
              Promise.resolve(value).then(_next, _throw);
            }
          }
          function _asyncToGenerator(fn) {
            return function() {
              var self2 = this, args = arguments;
              return new Promise(function(resolve, reject) {
                var gen = fn.apply(self2, args);
                function _next(value) {
                  asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
                }
                function _throw(err) {
                  asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
                }
                _next(void 0);
              });
            };
          }
          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              if (enumerableOnly)
                symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
              keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              if (i % 2) {
                ownKeys(Object(source), true).forEach(function(key) {
                  _defineProperty(target, key, source[key]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys(Object(source)).forEach(function(key) {
                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
              }
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          function _objectWithoutProperties(source, excluded) {
            if (source == null)
              return {};
            var target = _objectWithoutPropertiesLoose(source, excluded);
            var key, i;
            if (Object.getOwnPropertySymbols) {
              var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
              for (i = 0; i < sourceSymbolKeys.length; i++) {
                key = sourceSymbolKeys[i];
                if (excluded.indexOf(key) >= 0)
                  continue;
                if (!Object.prototype.propertyIsEnumerable.call(source, key))
                  continue;
                target[key] = source[key];
              }
            }
            return target;
          }
          function _objectWithoutPropertiesLoose(source, excluded) {
            if (source == null)
              return {};
            var target = {};
            var sourceKeys = Object.keys(source);
            var key, i;
            for (i = 0; i < sourceKeys.length; i++) {
              key = sourceKeys[i];
              if (excluded.indexOf(key) >= 0)
                continue;
              target[key] = source[key];
            }
            return target;
          }
          var {
            SocketSignalWebsocketClient
          } = require2("socket-signal-websocket");
          var MMST = require2("mostly-minimal-spanning-tree");
          var assert = require2("nanocustomassert");
          var {
            Readable
          } = require2("stream");
          var log = require2("debug")("discovery-swarm-webrtc:mmst-signal");
          var {
            toHex
          } = require2("./utils");
          var {
            ERR_INVALID_CHANNEL,
            ERR_MAX_PEERS_REACHED
          } = require2("./errors");
          var Scheduler = require2("./scheduler");
          var assertChannel = (channel) => assert(Buffer.isBuffer(channel) && channel.length === 32, "Channel must be a buffer of 32 bytes");
          var kOnConnected = Symbol("mmstsignal.onconnected");
          var kGetCandidates = Symbol("mmstsignal.getcandidates");
          module2.exports = class MMSTSignal extends SocketSignalWebsocketClient {
            constructor() {
              var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              var {
                bootstrap,
                createConnection,
                mmstOpts = {},
                strict = true
              } = opts, clientOpts = _objectWithoutProperties(opts, ["bootstrap", "createConnection", "mmstOpts", "strict"]);
              super(bootstrap, clientOpts);
              this._createConnection = createConnection;
              this._mmstOpts = mmstOpts;
              this._strict = strict;
              this._channels = /* @__PURE__ */ new Map();
              this._mmsts = /* @__PURE__ */ new Map();
              this._candidates = /* @__PURE__ */ new Map();
              this._scheduler = new Scheduler();
              this[kOnConnected] = this[kOnConnected].bind(this);
            }
            join(channel) {
              var _this = this;
              assertChannel(channel);
              var channelStr = toHex(channel);
              if (this._channels.has(channelStr)) {
                return;
              }
              this._channels.set(channelStr, channel);
              var mmst = new MMST(_objectSpread(_objectSpread({}, this._mmstOpts), {}, {
                id: this.id,
                lookup: () => this._lookup(channel),
                connect: function() {
                  var _connect = _asyncToGenerator(function* (to) {
                    yield _this.open();
                    try {
                      var peer = _this.connect(channel, to);
                      _this._runCreateConnection(peer);
                      yield peer.ready();
                      return peer.stream;
                    } catch (err) {
                      var candidates = _this[kGetCandidates](channel);
                      candidates.list = candidates.list.filter((candidate) => !candidate.equals(to));
                      if (candidates.list.length === 0) {
                        candidates.lookup = true;
                      }
                      throw err;
                    }
                  });
                  function connect(_x) {
                    return _connect.apply(this, arguments);
                  }
                  return connect;
                }()
              }));
              this._mmsts.set(channelStr, mmst);
              if (this.connected) {
                super.join(channel).catch(() => {
                });
              }
            }
            leave(channel) {
              var _superprop_getLeave = () => super.leave, _superprop_getCloseConnectionsByTopic = () => super.closeConnectionsByTopic, _this2 = this;
              return _asyncToGenerator(function* () {
                assertChannel(channel);
                var channelStr = toHex(channel);
                _this2._scheduler.delete(channelStr);
                _this2._mmsts.get(channelStr).destroy();
                _this2._mmsts.delete(channelStr);
                _this2._channels.delete(channelStr);
                _this2._candidates.delete(channelStr);
                yield _superprop_getLeave().call(_this2, channel);
                yield _superprop_getCloseConnectionsByTopic().call(_this2, channel);
              })();
            }
            _open() {
              var _superprop_get_open = () => super._open, _this3 = this;
              return _asyncToGenerator(function* () {
                _this3.on("connected", _this3[kOnConnected]);
                _this3.on("join", /* @__PURE__ */ function() {
                  var _ref = _asyncToGenerator(function* (channel, peers) {
                    log("discover", {
                      channel
                    });
                    if (!_this3.hasChannel(channel))
                      return;
                    yield _this3._updateCandidates(channel, peers);
                    yield _this3._run(channel);
                    _this3._scheduler.add(channel.toString("hex"), /* @__PURE__ */ _asyncToGenerator(function* () {
                      var candidates = _this3[kGetCandidates](channel);
                      if (candidates.list.length === 0 || _this3.getPeersByTopic(channel).length === 0) {
                        candidates.lookup = true;
                        yield _this3._updateCandidates(channel);
                        yield _this3._run(channel);
                      }
                    }));
                  });
                  return function(_x2, _x3) {
                    return _ref.apply(this, arguments);
                  };
                }());
                _this3.onIncomingPeer((peer) => _this3._runCreateConnection(peer));
                yield _superprop_get_open().call(_this3);
              })();
            }
            hasChannel(channel) {
              return this._channels.has(toHex(channel));
            }
            _runCreateConnection(peer) {
              if (!this.hasChannel(peer.topic)) {
                throw new ERR_INVALID_CHANNEL(toHex(peer.topic));
              }
              var mmst = this._getMMST(peer.topic);
              if (this._strict && !peer.initiator && !mmst.shouldHandleIncoming()) {
                throw new ERR_MAX_PEERS_REACHED(this._mmstOpts.maxPeers);
              }
              this._createConnection(peer);
              if (!peer.initiator) {
                mmst.addConnection(peer.id, peer.stream);
              }
              return peer;
            }
            _close() {
              var _superprop_get_close = () => super._close, _this4 = this;
              return _asyncToGenerator(function* () {
                yield _superprop_get_close().call(_this4);
                _this4.removeListener("connected", _this4[kOnConnected]);
                _this4._mmsts.forEach((mmst) => mmst.destroy());
                _this4._mmsts.clear();
                _this4._channels.clear();
                _this4._candidates.clear();
                _this4._scheduler.clear();
              })();
            }
            _run(channel) {
              var _this5 = this;
              return _asyncToGenerator(function* () {
                if (!_this5.connected)
                  return;
                if (_this5.getPeersByTopic(channel).filter((p) => p.initiator).length > 0)
                  return;
                try {
                  if (_this5.hasChannel(channel)) {
                    yield _this5._getMMST(channel).run();
                  }
                } catch (err) {
                  log("run error", err.message);
                }
              })();
            }
            _getMMST(channel) {
              return this._mmsts.get(toHex(channel));
            }
            _lookup(channel) {
              var stream = new Readable({
                read() {
                },
                objectMode: true
              });
              this._updateCandidates(channel).finally(() => {
                stream.push(this[kGetCandidates](channel).list);
                stream.push(null);
              });
              return stream;
            }
            [kOnConnected](reconnected) {
              var _superprop_getJoin = () => super.join, _this6 = this;
              return _asyncToGenerator(function* () {
                if (reconnected) {
                  _this6._channels.forEach((channel) => {
                    return _superprop_getJoin().call(_this6, channel).catch(() => {
                    });
                  });
                }
              })();
            }
            _updateCandidates(channel, peers) {
              var _this7 = this;
              return _asyncToGenerator(function* () {
                var candidates = _this7[kGetCandidates](channel);
                var list = candidates.list;
                if (peers) {
                  list = peers;
                } else if (candidates.lookup) {
                  candidates.lookup = false;
                  try {
                    list = yield _this7.lookup(channel);
                  } catch (err) {
                  }
                }
                candidates.list = list.filter((id) => !id.equals(_this7.id));
                _this7.emit("candidates-updated", channel, list);
              })();
            }
            [kGetCandidates](channel) {
              assert(Buffer.isBuffer(channel));
              var candidates = this._candidates.get(toHex(channel));
              if (candidates) {
                return candidates;
              }
              candidates = {
                list: [],
                lookup: false
              };
              this._candidates.set(toHex(channel), candidates);
              return candidates;
            }
          };
        }).call(this);
      }).call(this, { "isBuffer": require2("../../../is-buffer/index.js") });
    }, { "../../../is-buffer/index.js": 259, "./errors": 10, "./scheduler": 12, "./utils": 13, "debug": 119, "mostly-minimal-spanning-tree": 304, "nanocustomassert": 309, "socket-signal-websocket": 448, "stream": 480 }], 12: [function(require2, module2, exports2) {
      function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator(fn) {
        return function() {
          var self2 = this, args = arguments;
          return new Promise(function(resolve, reject) {
            var gen = fn.apply(self2, args);
            function _next(value) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(void 0);
          });
        };
      }
      var delay = (ms) => {
        var cancel;
        var finished = false;
        var p = new Promise((resolve, reject) => {
          var timer = setTimeout(() => {
            finished = true;
            resolve();
          }, ms);
          cancel = () => {
            if (finished)
              return;
            clearTimeout(timer);
            reject(new Error("timeout"));
          };
        });
        p.cancel = cancel;
        return p;
      };
      class Task {
        constructor(fn) {
          this._fn = fn;
          this._stop = false;
          this.run();
        }
        run() {
          var _this = this;
          _asyncToGenerator(function* () {
            while (!_this._stop) {
              _this._time = delay(Math.floor(Math.random() * 11) * 1e3);
              yield _this._time;
              yield _this._fn();
            }
          })().catch(() => {
          });
        }
        stop() {
          this._time && this._time.cancel();
          this._stop = false;
        }
      }
      module2.exports = class Scheduler {
        constructor() {
          this._tasks = /* @__PURE__ */ new Map();
        }
        add(id, fn) {
          this._tasks.set(id, new Task(fn));
        }
        delete(id) {
          var task = this._tasks.get(id);
          task && task.stop();
          this._tasks.delete(id);
        }
        clear() {
          this._tasks.forEach((task) => {
            task.stop();
          });
          this._tasks.clear();
        }
      };
    }, {}], 13: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var toHex = (buff) => {
            if (typeof buff === "string") {
              return buff;
            }
            if (Buffer.isBuffer(buff)) {
              return buff.toString("hex");
            }
            throw new Error("Cannot convert the buffer to hex: ", buff);
          };
          var toBuffer = (str) => {
            if (Buffer.isBuffer(str)) {
              return str;
            }
            if (typeof str === "string") {
              return Buffer.from(str, "hex");
            }
            throw new Error("Cannot convert the string to buffer: ", str);
          };
          var callbackPromise = () => {
            var callback;
            var promise = new Promise((resolve, reject) => {
              callback = (err, value) => {
                if (err)
                  reject(err);
                else
                  resolve(value);
              };
            });
            callback.promise = promise;
            return callback;
          };
          var resolveCallback = (promise, cb) => {
            if (!promise.then) {
              promise = Promise.resolve();
            }
            return promise.then((result) => cb(null, result)).catch(cb);
          };
          module2.exports = {
            toHex,
            toBuffer,
            callbackPromise,
            resolveCallback
          };
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82 }], 14: [function(require2, module2, exports2) {
      var codecs = require2("codecs");
      class AbstractExtension {
        constructor(local, name) {
          var handlers = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          this.id = 0;
          this.name = name;
          this.encoding = codecs(handlers.encoding || "binary");
          this.handlers = handlers;
          this.local = local;
        }
        encode(message) {
          return this.encoding.encode(message);
        }
        remoteSupports() {
          return !!(this.local && this.local.map && this.local.map[this.id] === this);
        }
        onmessage(buf, context) {
          if (!this.handlers.onmessage)
            return;
          var message;
          try {
            message = this.encoding.decode(buf);
          } catch (err) {
            if (this.handlers.onerror)
              this.handlers.onerror(err, context);
            return;
          }
          this.handlers.onmessage(message, context);
        }
        get destroyed() {
          return this.local === null;
        }
        destroy() {
          if (this.local === null)
            return;
          this.local._remove(this);
          this.local = null;
        }
        static createLocal() {
          var handlers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          return new Local(handlers, this);
        }
      }
      class Remote {
        constructor(local) {
          this.local = local;
          this.names = null;
          this.map = null;
          this.changes = 0;
        }
        update(names) {
          this.names = names;
          this.changes = 0;
        }
        onmessage(id, message) {
          var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          if (this.changes !== this.local.changes) {
            this.map = this.names ? match(this.local.messages, this.names) : null;
            this.changes = this.local.changes;
          }
          var m = this.map && this.map[id];
          if (m)
            m.onmessage(message, context);
        }
      }
      class Local {
        constructor() {
          var handlers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          var M = arguments.length > 1 ? arguments[1] : void 0;
          this.messages = [];
          this.handlers = handlers;
          this.Extension = M;
          this.changes = 1;
          this.exclusive = true;
        }
        get length() {
          return this.messages.length;
        }
        [Symbol.iterator]() {
          return this.messages[Symbol.iterator]();
        }
        get(name) {
          for (var m of this.messages) {
            if (m.name === name)
              return m;
          }
          return null;
        }
        add(name, handlers) {
          var m;
          if (typeof handlers !== "function") {
            m = new this.Extension(this, name, handlers);
          } else {
            m = new this.Extension(this, name, {});
            m.handlers = handlers(m) || {};
            m.encoding = codecs(m.handlers.encoding || "binary");
          }
          this.changes++;
          this.messages.push(m);
          this.messages.sort(sortMessages);
          for (var i = 0; i < this.messages.length; i++) {
            this.messages[i].id = i;
          }
          if (this.exclusive) {
            if (m.id > 0 && this.messages[m.id - 1].name === m.name || m.id < this.messages.length - 1 && this.messages[m.id + 1].name === m.name) {
              this._remove(m);
              throw new Error("Cannot add multiple messages with the same name");
            }
          }
          if (this.handlers && this.handlers.onextensionupdate)
            this.handlers.onextensionupdate();
          return m;
        }
        remote() {
          return new Remote(this);
        }
        _remove(m) {
          this.changes++;
          this.messages.splice(m.id, 1);
          m.id = -1;
          if (this.handlers && this.handlers.onextensionupdate)
            this.handlers.onextensionupdate();
        }
        names() {
          var names = new Array(this.messages.length);
          for (var i = 0; i < names.length; i++) {
            names[i] = this.messages[i].name;
          }
          return names;
        }
      }
      function sortMessages(a, b) {
        return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
      }
      function match(local, remote) {
        var i = 0;
        var j = 0;
        var map = new Array(remote.length);
        while (i < local.length && j < remote.length) {
          var l = local[i].name;
          var r = remote[j];
          if (l < r)
            i++;
          else if (l > r)
            j++;
          else
            map[j++] = local[i];
        }
        return map;
      }
      module2.exports = AbstractExtension;
    }, { "codecs": 94 }], 15: [function(require2, module2, exports2) {
      var nextTick = require2("./next-tick");
      function AbstractChainedBatch(db) {
        if (typeof db !== "object" || db === null) {
          throw new TypeError("First argument must be an abstract-leveldown compliant store");
        }
        this.db = db;
        this._operations = [];
        this._written = false;
      }
      AbstractChainedBatch.prototype._checkWritten = function() {
        if (this._written) {
          throw new Error("write() already called on this batch");
        }
      };
      AbstractChainedBatch.prototype.put = function(key, value) {
        this._checkWritten();
        var err = this.db._checkKey(key) || this.db._checkValue(value);
        if (err)
          throw err;
        key = this.db._serializeKey(key);
        value = this.db._serializeValue(value);
        this._put(key, value);
        return this;
      };
      AbstractChainedBatch.prototype._put = function(key, value) {
        this._operations.push({
          type: "put",
          key,
          value
        });
      };
      AbstractChainedBatch.prototype.del = function(key) {
        this._checkWritten();
        var err = this.db._checkKey(key);
        if (err)
          throw err;
        key = this.db._serializeKey(key);
        this._del(key);
        return this;
      };
      AbstractChainedBatch.prototype._del = function(key) {
        this._operations.push({
          type: "del",
          key
        });
      };
      AbstractChainedBatch.prototype.clear = function() {
        this._checkWritten();
        this._clear();
        return this;
      };
      AbstractChainedBatch.prototype._clear = function() {
        this._operations = [];
      };
      AbstractChainedBatch.prototype.write = function(options, callback) {
        this._checkWritten();
        if (typeof options === "function") {
          callback = options;
        }
        if (typeof callback !== "function") {
          throw new Error("write() requires a callback argument");
        }
        if (typeof options !== "object" || options === null) {
          options = {};
        }
        this._written = true;
        this._write(options, callback);
      };
      AbstractChainedBatch.prototype._write = function(options, callback) {
        this.db._batch(this._operations, options, callback);
      };
      AbstractChainedBatch.prototype._nextTick = nextTick;
      module2.exports = AbstractChainedBatch;
    }, { "./next-tick": 19 }], 16: [function(require2, module2, exports2) {
      var nextTick = require2("./next-tick");
      function AbstractIterator(db) {
        if (typeof db !== "object" || db === null) {
          throw new TypeError("First argument must be an abstract-leveldown compliant store");
        }
        this.db = db;
        this._ended = false;
        this._nexting = false;
      }
      AbstractIterator.prototype.next = function(callback) {
        var self2 = this;
        if (typeof callback !== "function") {
          throw new Error("next() requires a callback argument");
        }
        if (self2._ended) {
          nextTick(callback, new Error("cannot call next() after end()"));
          return self2;
        }
        if (self2._nexting) {
          nextTick(callback, new Error("cannot call next() before previous next() has completed"));
          return self2;
        }
        self2._nexting = true;
        self2._next(function() {
          self2._nexting = false;
          callback.apply(null, arguments);
        });
        return self2;
      };
      AbstractIterator.prototype._next = function(callback) {
        nextTick(callback);
      };
      AbstractIterator.prototype.seek = function(target) {
        if (this._ended) {
          throw new Error("cannot call seek() after end()");
        }
        if (this._nexting) {
          throw new Error("cannot call seek() before next() has completed");
        }
        target = this.db._serializeKey(target);
        this._seek(target);
      };
      AbstractIterator.prototype._seek = function(target) {
      };
      AbstractIterator.prototype.end = function(callback) {
        if (typeof callback !== "function") {
          throw new Error("end() requires a callback argument");
        }
        if (this._ended) {
          return nextTick(callback, new Error("end() already called on iterator"));
        }
        this._ended = true;
        this._end(callback);
      };
      AbstractIterator.prototype._end = function(callback) {
        nextTick(callback);
      };
      AbstractIterator.prototype._nextTick = nextTick;
      module2.exports = AbstractIterator;
    }, { "./next-tick": 19 }], 17: [function(require2, module2, exports2) {
      var xtend = require2("xtend");
      var supports = require2("level-supports");
      var Buffer = require2("buffer").Buffer;
      var AbstractIterator = require2("./abstract-iterator");
      var AbstractChainedBatch = require2("./abstract-chained-batch");
      var nextTick = require2("./next-tick");
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var rangeOptions = "start end gt gte lt lte".split(" ");
      function AbstractLevelDOWN(manifest) {
        this.status = "new";
        this.supports = supports(manifest, {
          status: true
        });
      }
      AbstractLevelDOWN.prototype.open = function(options, callback) {
        var self2 = this;
        var oldStatus = this.status;
        if (typeof options === "function")
          callback = options;
        if (typeof callback !== "function") {
          throw new Error("open() requires a callback argument");
        }
        if (typeof options !== "object" || options === null)
          options = {};
        options.createIfMissing = options.createIfMissing !== false;
        options.errorIfExists = !!options.errorIfExists;
        this.status = "opening";
        this._open(options, function(err) {
          if (err) {
            self2.status = oldStatus;
            return callback(err);
          }
          self2.status = "open";
          callback();
        });
      };
      AbstractLevelDOWN.prototype._open = function(options, callback) {
        nextTick(callback);
      };
      AbstractLevelDOWN.prototype.close = function(callback) {
        var self2 = this;
        var oldStatus = this.status;
        if (typeof callback !== "function") {
          throw new Error("close() requires a callback argument");
        }
        this.status = "closing";
        this._close(function(err) {
          if (err) {
            self2.status = oldStatus;
            return callback(err);
          }
          self2.status = "closed";
          callback();
        });
      };
      AbstractLevelDOWN.prototype._close = function(callback) {
        nextTick(callback);
      };
      AbstractLevelDOWN.prototype.get = function(key, options, callback) {
        if (typeof options === "function")
          callback = options;
        if (typeof callback !== "function") {
          throw new Error("get() requires a callback argument");
        }
        var err = this._checkKey(key);
        if (err)
          return nextTick(callback, err);
        key = this._serializeKey(key);
        if (typeof options !== "object" || options === null)
          options = {};
        options.asBuffer = options.asBuffer !== false;
        this._get(key, options, callback);
      };
      AbstractLevelDOWN.prototype._get = function(key, options, callback) {
        nextTick(function() {
          callback(new Error("NotFound"));
        });
      };
      AbstractLevelDOWN.prototype.put = function(key, value, options, callback) {
        if (typeof options === "function")
          callback = options;
        if (typeof callback !== "function") {
          throw new Error("put() requires a callback argument");
        }
        var err = this._checkKey(key) || this._checkValue(value);
        if (err)
          return nextTick(callback, err);
        key = this._serializeKey(key);
        value = this._serializeValue(value);
        if (typeof options !== "object" || options === null)
          options = {};
        this._put(key, value, options, callback);
      };
      AbstractLevelDOWN.prototype._put = function(key, value, options, callback) {
        nextTick(callback);
      };
      AbstractLevelDOWN.prototype.del = function(key, options, callback) {
        if (typeof options === "function")
          callback = options;
        if (typeof callback !== "function") {
          throw new Error("del() requires a callback argument");
        }
        var err = this._checkKey(key);
        if (err)
          return nextTick(callback, err);
        key = this._serializeKey(key);
        if (typeof options !== "object" || options === null)
          options = {};
        this._del(key, options, callback);
      };
      AbstractLevelDOWN.prototype._del = function(key, options, callback) {
        nextTick(callback);
      };
      AbstractLevelDOWN.prototype.batch = function(array, options, callback) {
        if (!arguments.length)
          return this._chainedBatch();
        if (typeof options === "function")
          callback = options;
        if (typeof array === "function")
          callback = array;
        if (typeof callback !== "function") {
          throw new Error("batch(array) requires a callback argument");
        }
        if (!Array.isArray(array)) {
          return nextTick(callback, new Error("batch(array) requires an array argument"));
        }
        if (array.length === 0) {
          return nextTick(callback);
        }
        if (typeof options !== "object" || options === null)
          options = {};
        var serialized = new Array(array.length);
        for (var i = 0; i < array.length; i++) {
          if (typeof array[i] !== "object" || array[i] === null) {
            return nextTick(callback, new Error("batch(array) element must be an object and not `null`"));
          }
          var e = xtend(array[i]);
          if (e.type !== "put" && e.type !== "del") {
            return nextTick(callback, new Error("`type` must be 'put' or 'del'"));
          }
          var err = this._checkKey(e.key);
          if (err)
            return nextTick(callback, err);
          e.key = this._serializeKey(e.key);
          if (e.type === "put") {
            var valueErr = this._checkValue(e.value);
            if (valueErr)
              return nextTick(callback, valueErr);
            e.value = this._serializeValue(e.value);
          }
          serialized[i] = e;
        }
        this._batch(serialized, options, callback);
      };
      AbstractLevelDOWN.prototype._batch = function(array, options, callback) {
        nextTick(callback);
      };
      AbstractLevelDOWN.prototype.clear = function(options, callback) {
        if (typeof options === "function") {
          callback = options;
        } else if (typeof callback !== "function") {
          throw new Error("clear() requires a callback argument");
        }
        options = cleanRangeOptions(this, options);
        options.reverse = !!options.reverse;
        options.limit = "limit" in options ? options.limit : -1;
        this._clear(options, callback);
      };
      AbstractLevelDOWN.prototype._clear = function(options, callback) {
        options.keys = true;
        options.values = false;
        options.keyAsBuffer = true;
        options.valueAsBuffer = true;
        var iterator = this._iterator(options);
        var emptyOptions = {};
        var self2 = this;
        var next = function next2(err) {
          if (err) {
            return iterator.end(function() {
              callback(err);
            });
          }
          iterator.next(function(err2, key) {
            if (err2)
              return next2(err2);
            if (key === void 0)
              return iterator.end(callback);
            self2._del(key, emptyOptions, next2);
          });
        };
        next();
      };
      AbstractLevelDOWN.prototype._setupIteratorOptions = function(options) {
        options = cleanRangeOptions(this, options);
        options.reverse = !!options.reverse;
        options.keys = options.keys !== false;
        options.values = options.values !== false;
        options.limit = "limit" in options ? options.limit : -1;
        options.keyAsBuffer = options.keyAsBuffer !== false;
        options.valueAsBuffer = options.valueAsBuffer !== false;
        return options;
      };
      function cleanRangeOptions(db, options) {
        var result = {};
        for (var k in options) {
          if (!hasOwnProperty.call(options, k))
            continue;
          var opt = options[k];
          if (isRangeOption(k)) {
            opt = db._serializeKey(opt);
          }
          result[k] = opt;
        }
        return result;
      }
      function isRangeOption(k) {
        return rangeOptions.indexOf(k) !== -1;
      }
      AbstractLevelDOWN.prototype.iterator = function(options) {
        if (typeof options !== "object" || options === null)
          options = {};
        options = this._setupIteratorOptions(options);
        return this._iterator(options);
      };
      AbstractLevelDOWN.prototype._iterator = function(options) {
        return new AbstractIterator(this);
      };
      AbstractLevelDOWN.prototype._chainedBatch = function() {
        return new AbstractChainedBatch(this);
      };
      AbstractLevelDOWN.prototype._serializeKey = function(key) {
        return key;
      };
      AbstractLevelDOWN.prototype._serializeValue = function(value) {
        return value;
      };
      AbstractLevelDOWN.prototype._checkKey = function(key) {
        if (key === null || key === void 0) {
          return new Error("key cannot be `null` or `undefined`");
        } else if (Buffer.isBuffer(key) && key.length === 0) {
          return new Error("key cannot be an empty Buffer");
        } else if (key === "") {
          return new Error("key cannot be an empty String");
        } else if (Array.isArray(key) && key.length === 0) {
          return new Error("key cannot be an empty Array");
        }
      };
      AbstractLevelDOWN.prototype._checkValue = function(value) {
        if (value === null || value === void 0) {
          return new Error("value cannot be `null` or `undefined`");
        }
      };
      AbstractLevelDOWN.prototype._nextTick = nextTick;
      module2.exports = AbstractLevelDOWN;
    }, { "./abstract-chained-batch": 15, "./abstract-iterator": 16, "./next-tick": 19, "buffer": 82, "level-supports": 278, "xtend": 539 }], 18: [function(require2, module2, exports2) {
      exports2.AbstractLevelDOWN = require2("./abstract-leveldown");
      exports2.AbstractIterator = require2("./abstract-iterator");
      exports2.AbstractChainedBatch = require2("./abstract-chained-batch");
    }, { "./abstract-chained-batch": 15, "./abstract-iterator": 16, "./abstract-leveldown": 17 }], 19: [function(require2, module2, exports2) {
      module2.exports = require2("immediate");
    }, { "immediate": 250 }], 20: [function(require2, module2, exports2) {
      module2.exports = function(arr, fn, self2) {
        if (arr.filter)
          return arr.filter(fn, self2);
        if (void 0 === arr || null === arr)
          throw new TypeError();
        if ("function" != typeof fn)
          throw new TypeError();
        var ret = [];
        for (var i = 0; i < arr.length; i++) {
          if (!hasOwn.call(arr, i))
            continue;
          var val = arr[i];
          if (fn.call(self2, val, i, arr))
            ret.push(val);
        }
        return ret;
      };
      var hasOwn = Object.prototype.hasOwnProperty;
    }, {}], 21: [function(require2, module2, exports2) {
      var asn1 = exports2;
      asn1.bignum = require2("bn.js");
      asn1.define = require2("./asn1/api").define;
      asn1.base = require2("./asn1/base");
      asn1.constants = require2("./asn1/constants");
      asn1.decoders = require2("./asn1/decoders");
      asn1.encoders = require2("./asn1/encoders");
    }, { "./asn1/api": 22, "./asn1/base": 24, "./asn1/constants": 28, "./asn1/decoders": 30, "./asn1/encoders": 33, "bn.js": 35 }], 22: [function(require2, module2, exports2) {
      var encoders = require2("./encoders");
      var decoders = require2("./decoders");
      var inherits = require2("inherits");
      var api = exports2;
      api.define = function define(name, body) {
        return new Entity(name, body);
      };
      function Entity(name, body) {
        this.name = name;
        this.body = body;
        this.decoders = {};
        this.encoders = {};
      }
      Entity.prototype._createNamed = function createNamed(Base) {
        var name = this.name;
        function Generated(entity) {
          this._initNamed(entity, name);
        }
        inherits(Generated, Base);
        Generated.prototype._initNamed = function _initNamed(entity, name2) {
          Base.call(this, entity, name2);
        };
        return new Generated(this);
      };
      Entity.prototype._getDecoder = function _getDecoder(enc) {
        enc = enc || "der";
        if (!this.decoders.hasOwnProperty(enc))
          this.decoders[enc] = this._createNamed(decoders[enc]);
        return this.decoders[enc];
      };
      Entity.prototype.decode = function decode(data, enc, options) {
        return this._getDecoder(enc).decode(data, options);
      };
      Entity.prototype._getEncoder = function _getEncoder(enc) {
        enc = enc || "der";
        if (!this.encoders.hasOwnProperty(enc))
          this.encoders[enc] = this._createNamed(encoders[enc]);
        return this.encoders[enc];
      };
      Entity.prototype.encode = function encode(data, enc, reporter) {
        return this._getEncoder(enc).encode(data, reporter);
      };
    }, { "./decoders": 30, "./encoders": 33, "inherits": 256 }], 23: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Reporter = require2("../base/reporter").Reporter;
      var Buffer = require2("safer-buffer").Buffer;
      function DecoderBuffer(base, options) {
        Reporter.call(this, options);
        if (!Buffer.isBuffer(base)) {
          this.error("Input not Buffer");
          return;
        }
        this.base = base;
        this.offset = 0;
        this.length = base.length;
      }
      inherits(DecoderBuffer, Reporter);
      exports2.DecoderBuffer = DecoderBuffer;
      DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
        if (data instanceof DecoderBuffer) {
          return true;
        }
        var isCompatible = typeof data === "object" && Buffer.isBuffer(data.base) && data.constructor.name === "DecoderBuffer" && typeof data.offset === "number" && typeof data.length === "number" && typeof data.save === "function" && typeof data.restore === "function" && typeof data.isEmpty === "function" && typeof data.readUInt8 === "function" && typeof data.skip === "function" && typeof data.raw === "function";
        return isCompatible;
      };
      DecoderBuffer.prototype.save = function save() {
        return {
          offset: this.offset,
          reporter: Reporter.prototype.save.call(this)
        };
      };
      DecoderBuffer.prototype.restore = function restore(save) {
        var res = new DecoderBuffer(this.base);
        res.offset = save.offset;
        res.length = this.offset;
        this.offset = save.offset;
        Reporter.prototype.restore.call(this, save.reporter);
        return res;
      };
      DecoderBuffer.prototype.isEmpty = function isEmpty() {
        return this.offset === this.length;
      };
      DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
        if (this.offset + 1 <= this.length)
          return this.base.readUInt8(this.offset++, true);
        else
          return this.error(fail || "DecoderBuffer overrun");
      };
      DecoderBuffer.prototype.skip = function skip(bytes, fail) {
        if (!(this.offset + bytes <= this.length))
          return this.error(fail || "DecoderBuffer overrun");
        var res = new DecoderBuffer(this.base);
        res._reporterState = this._reporterState;
        res.offset = this.offset;
        res.length = this.offset + bytes;
        this.offset += bytes;
        return res;
      };
      DecoderBuffer.prototype.raw = function raw(save) {
        return this.base.slice(save ? save.offset : this.offset, this.length);
      };
      function EncoderBuffer(value, reporter) {
        if (Array.isArray(value)) {
          this.length = 0;
          this.value = value.map(function(item) {
            if (!EncoderBuffer.isEncoderBuffer(item))
              item = new EncoderBuffer(item, reporter);
            this.length += item.length;
            return item;
          }, this);
        } else if (typeof value === "number") {
          if (!(0 <= value && value <= 255))
            return reporter.error("non-byte EncoderBuffer value");
          this.value = value;
          this.length = 1;
        } else if (typeof value === "string") {
          this.value = value;
          this.length = Buffer.byteLength(value);
        } else if (Buffer.isBuffer(value)) {
          this.value = value;
          this.length = value.length;
        } else {
          return reporter.error("Unsupported type: " + typeof value);
        }
      }
      exports2.EncoderBuffer = EncoderBuffer;
      EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
        if (data instanceof EncoderBuffer) {
          return true;
        }
        var isCompatible = typeof data === "object" && data.constructor.name === "EncoderBuffer" && typeof data.length === "number" && typeof data.join === "function";
        return isCompatible;
      };
      EncoderBuffer.prototype.join = function join(out, offset) {
        if (!out)
          out = Buffer.alloc(this.length);
        if (!offset)
          offset = 0;
        if (this.length === 0)
          return out;
        if (Array.isArray(this.value)) {
          this.value.forEach(function(item) {
            item.join(out, offset);
            offset += item.length;
          });
        } else {
          if (typeof this.value === "number")
            out[offset] = this.value;
          else if (typeof this.value === "string")
            out.write(this.value, offset);
          else if (Buffer.isBuffer(this.value))
            this.value.copy(out, offset);
          offset += this.length;
        }
        return out;
      };
    }, { "../base/reporter": 26, "inherits": 256, "safer-buffer": 418 }], 24: [function(require2, module2, exports2) {
      var base = exports2;
      base.Reporter = require2("./reporter").Reporter;
      base.DecoderBuffer = require2("./buffer").DecoderBuffer;
      base.EncoderBuffer = require2("./buffer").EncoderBuffer;
      base.Node = require2("./node");
    }, { "./buffer": 23, "./node": 25, "./reporter": 26 }], 25: [function(require2, module2, exports2) {
      var Reporter = require2("../base/reporter").Reporter;
      var EncoderBuffer = require2("../base/buffer").EncoderBuffer;
      var DecoderBuffer = require2("../base/buffer").DecoderBuffer;
      var assert = require2("minimalistic-assert");
      var tags = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"];
      var methods = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(tags);
      var overrided = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
      function Node(enc, parent, name) {
        var state = {};
        this._baseState = state;
        state.name = name;
        state.enc = enc;
        state.parent = parent || null;
        state.children = null;
        state.tag = null;
        state.args = null;
        state.reverseArgs = null;
        state.choice = null;
        state.optional = false;
        state.any = false;
        state.obj = false;
        state.use = null;
        state.useDecoder = null;
        state.key = null;
        state["default"] = null;
        state.explicit = null;
        state.implicit = null;
        state.contains = null;
        if (!state.parent) {
          state.children = [];
          this._wrap();
        }
      }
      module2.exports = Node;
      var stateProps = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
      Node.prototype.clone = function clone() {
        var state = this._baseState;
        var cstate = {};
        stateProps.forEach(function(prop) {
          cstate[prop] = state[prop];
        });
        var res = new this.constructor(cstate.parent);
        res._baseState = cstate;
        return res;
      };
      Node.prototype._wrap = function wrap() {
        var state = this._baseState;
        methods.forEach(function(method) {
          this[method] = function _wrappedMethod() {
            var clone = new this.constructor(this);
            state.children.push(clone);
            return clone[method].apply(clone, arguments);
          };
        }, this);
      };
      Node.prototype._init = function init(body) {
        var state = this._baseState;
        assert(state.parent === null);
        body.call(this);
        state.children = state.children.filter(function(child) {
          return child._baseState.parent === this;
        }, this);
        assert.equal(state.children.length, 1, "Root node can have only one child");
      };
      Node.prototype._useArgs = function useArgs(args) {
        var state = this._baseState;
        var children = args.filter(function(arg) {
          return arg instanceof this.constructor;
        }, this);
        args = args.filter(function(arg) {
          return !(arg instanceof this.constructor);
        }, this);
        if (children.length !== 0) {
          assert(state.children === null);
          state.children = children;
          children.forEach(function(child) {
            child._baseState.parent = this;
          }, this);
        }
        if (args.length !== 0) {
          assert(state.args === null);
          state.args = args;
          state.reverseArgs = args.map(function(arg) {
            if (typeof arg !== "object" || arg.constructor !== Object)
              return arg;
            var res = {};
            Object.keys(arg).forEach(function(key) {
              if (key == (key | 0))
                key |= 0;
              var value = arg[key];
              res[value] = key;
            });
            return res;
          });
        }
      };
      overrided.forEach(function(method) {
        Node.prototype[method] = function _overrided() {
          var state = this._baseState;
          throw new Error(method + " not implemented for encoding: " + state.enc);
        };
      });
      tags.forEach(function(tag) {
        Node.prototype[tag] = function _tagMethod() {
          var state = this._baseState;
          var args = Array.prototype.slice.call(arguments);
          assert(state.tag === null);
          state.tag = tag;
          this._useArgs(args);
          return this;
        };
      });
      Node.prototype.use = function use(item) {
        assert(item);
        var state = this._baseState;
        assert(state.use === null);
        state.use = item;
        return this;
      };
      Node.prototype.optional = function optional() {
        var state = this._baseState;
        state.optional = true;
        return this;
      };
      Node.prototype.def = function def(val) {
        var state = this._baseState;
        assert(state["default"] === null);
        state["default"] = val;
        state.optional = true;
        return this;
      };
      Node.prototype.explicit = function explicit(num) {
        var state = this._baseState;
        assert(state.explicit === null && state.implicit === null);
        state.explicit = num;
        return this;
      };
      Node.prototype.implicit = function implicit(num) {
        var state = this._baseState;
        assert(state.explicit === null && state.implicit === null);
        state.implicit = num;
        return this;
      };
      Node.prototype.obj = function obj() {
        var state = this._baseState;
        var args = Array.prototype.slice.call(arguments);
        state.obj = true;
        if (args.length !== 0)
          this._useArgs(args);
        return this;
      };
      Node.prototype.key = function key(newKey) {
        var state = this._baseState;
        assert(state.key === null);
        state.key = newKey;
        return this;
      };
      Node.prototype.any = function any() {
        var state = this._baseState;
        state.any = true;
        return this;
      };
      Node.prototype.choice = function choice(obj) {
        var state = this._baseState;
        assert(state.choice === null);
        state.choice = obj;
        this._useArgs(Object.keys(obj).map(function(key) {
          return obj[key];
        }));
        return this;
      };
      Node.prototype.contains = function contains(item) {
        var state = this._baseState;
        assert(state.use === null);
        state.contains = item;
        return this;
      };
      Node.prototype._decode = function decode(input, options) {
        var state = this._baseState;
        if (state.parent === null)
          return input.wrapResult(state.children[0]._decode(input, options));
        var result = state["default"];
        var present = true;
        var prevKey = null;
        if (state.key !== null)
          prevKey = input.enterKey(state.key);
        if (state.optional) {
          var tag = null;
          if (state.explicit !== null)
            tag = state.explicit;
          else if (state.implicit !== null)
            tag = state.implicit;
          else if (state.tag !== null)
            tag = state.tag;
          if (tag === null && !state.any) {
            var save = input.save();
            try {
              if (state.choice === null)
                this._decodeGeneric(state.tag, input, options);
              else
                this._decodeChoice(input, options);
              present = true;
            } catch (e) {
              present = false;
            }
            input.restore(save);
          } else {
            present = this._peekTag(input, tag, state.any);
            if (input.isError(present))
              return present;
          }
        }
        var prevObj;
        if (state.obj && present)
          prevObj = input.enterObject();
        if (present) {
          if (state.explicit !== null) {
            var explicit = this._decodeTag(input, state.explicit);
            if (input.isError(explicit))
              return explicit;
            input = explicit;
          }
          var start = input.offset;
          if (state.use === null && state.choice === null) {
            var _save;
            if (state.any)
              _save = input.save();
            var body = this._decodeTag(input, state.implicit !== null ? state.implicit : state.tag, state.any);
            if (input.isError(body))
              return body;
            if (state.any)
              result = input.raw(_save);
            else
              input = body;
          }
          if (options && options.track && state.tag !== null)
            options.track(input.path(), start, input.length, "tagged");
          if (options && options.track && state.tag !== null)
            options.track(input.path(), input.offset, input.length, "content");
          if (state.any)
            ;
          else if (state.choice === null) {
            result = this._decodeGeneric(state.tag, input, options);
          } else {
            result = this._decodeChoice(input, options);
          }
          if (input.isError(result))
            return result;
          if (!state.any && state.choice === null && state.children !== null) {
            state.children.forEach(function decodeChildren(child) {
              child._decode(input, options);
            });
          }
          if (state.contains && (state.tag === "octstr" || state.tag === "bitstr")) {
            var data = new DecoderBuffer(result);
            result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
          }
        }
        if (state.obj && present)
          result = input.leaveObject(prevObj);
        if (state.key !== null && (result !== null || present === true))
          input.leaveKey(prevKey, state.key, result);
        else if (prevKey !== null)
          input.exitKey(prevKey);
        return result;
      };
      Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
        var state = this._baseState;
        if (tag === "seq" || tag === "set")
          return null;
        if (tag === "seqof" || tag === "setof")
          return this._decodeList(input, tag, state.args[0], options);
        else if (/str$/.test(tag))
          return this._decodeStr(input, tag, options);
        else if (tag === "objid" && state.args)
          return this._decodeObjid(input, state.args[0], state.args[1], options);
        else if (tag === "objid")
          return this._decodeObjid(input, null, null, options);
        else if (tag === "gentime" || tag === "utctime")
          return this._decodeTime(input, tag, options);
        else if (tag === "null_")
          return this._decodeNull(input, options);
        else if (tag === "bool")
          return this._decodeBool(input, options);
        else if (tag === "objDesc")
          return this._decodeStr(input, tag, options);
        else if (tag === "int" || tag === "enum")
          return this._decodeInt(input, state.args && state.args[0], options);
        if (state.use !== null) {
          return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
        } else {
          return input.error("unknown tag: " + tag);
        }
      };
      Node.prototype._getUse = function _getUse(entity, obj) {
        var state = this._baseState;
        state.useDecoder = this._use(entity, obj);
        assert(state.useDecoder._baseState.parent === null);
        state.useDecoder = state.useDecoder._baseState.children[0];
        if (state.implicit !== state.useDecoder._baseState.implicit) {
          state.useDecoder = state.useDecoder.clone();
          state.useDecoder._baseState.implicit = state.implicit;
        }
        return state.useDecoder;
      };
      Node.prototype._decodeChoice = function decodeChoice(input, options) {
        var state = this._baseState;
        var result = null;
        var match = false;
        Object.keys(state.choice).some(function(key) {
          var save = input.save();
          var node = state.choice[key];
          try {
            var value = node._decode(input, options);
            if (input.isError(value))
              return false;
            result = {
              type: key,
              value
            };
            match = true;
          } catch (e) {
            input.restore(save);
            return false;
          }
          return true;
        }, this);
        if (!match)
          return input.error("Choice not matched");
        return result;
      };
      Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
        return new EncoderBuffer(data, this.reporter);
      };
      Node.prototype._encode = function encode(data, reporter, parent) {
        var state = this._baseState;
        if (state["default"] !== null && state["default"] === data)
          return;
        var result = this._encodeValue(data, reporter, parent);
        if (result === void 0)
          return;
        if (this._skipDefault(result, reporter, parent))
          return;
        return result;
      };
      Node.prototype._encodeValue = function encode(data, reporter, parent) {
        var state = this._baseState;
        if (state.parent === null)
          return state.children[0]._encode(data, reporter || new Reporter());
        var result = null;
        this.reporter = reporter;
        if (state.optional && data === void 0) {
          if (state["default"] !== null)
            data = state["default"];
          else
            return;
        }
        var content = null;
        var primitive = false;
        if (state.any) {
          result = this._createEncoderBuffer(data);
        } else if (state.choice) {
          result = this._encodeChoice(data, reporter);
        } else if (state.contains) {
          content = this._getUse(state.contains, parent)._encode(data, reporter);
          primitive = true;
        } else if (state.children) {
          content = state.children.map(function(child2) {
            if (child2._baseState.tag === "null_")
              return child2._encode(null, reporter, data);
            if (child2._baseState.key === null)
              return reporter.error("Child should have a key");
            var prevKey = reporter.enterKey(child2._baseState.key);
            if (typeof data !== "object")
              return reporter.error("Child expected, but input is not object");
            var res = child2._encode(data[child2._baseState.key], reporter, data);
            reporter.leaveKey(prevKey);
            return res;
          }, this).filter(function(child2) {
            return child2;
          });
          content = this._createEncoderBuffer(content);
        } else {
          if (state.tag === "seqof" || state.tag === "setof") {
            if (!(state.args && state.args.length === 1))
              return reporter.error("Too many args for : " + state.tag);
            if (!Array.isArray(data))
              return reporter.error("seqof/setof, but data is not Array");
            var child = this.clone();
            child._baseState.implicit = null;
            content = this._createEncoderBuffer(data.map(function(item) {
              var state2 = this._baseState;
              return this._getUse(state2.args[0], data)._encode(item, reporter);
            }, child));
          } else if (state.use !== null) {
            result = this._getUse(state.use, parent)._encode(data, reporter);
          } else {
            content = this._encodePrimitive(state.tag, data);
            primitive = true;
          }
        }
        if (!state.any && state.choice === null) {
          var tag = state.implicit !== null ? state.implicit : state.tag;
          var cls = state.implicit === null ? "universal" : "context";
          if (tag === null) {
            if (state.use === null)
              reporter.error("Tag could be omitted only for .use()");
          } else {
            if (state.use === null)
              result = this._encodeComposite(tag, primitive, cls, content);
          }
        }
        if (state.explicit !== null)
          result = this._encodeComposite(state.explicit, false, "context", result);
        return result;
      };
      Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
        var state = this._baseState;
        var node = state.choice[data.type];
        if (!node) {
          assert(false, data.type + " not found in " + JSON.stringify(Object.keys(state.choice)));
        }
        return node._encode(data.value, reporter);
      };
      Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
        var state = this._baseState;
        if (/str$/.test(tag))
          return this._encodeStr(data, tag);
        else if (tag === "objid" && state.args)
          return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
        else if (tag === "objid")
          return this._encodeObjid(data, null, null);
        else if (tag === "gentime" || tag === "utctime")
          return this._encodeTime(data, tag);
        else if (tag === "null_")
          return this._encodeNull();
        else if (tag === "int" || tag === "enum")
          return this._encodeInt(data, state.args && state.reverseArgs[0]);
        else if (tag === "bool")
          return this._encodeBool(data);
        else if (tag === "objDesc")
          return this._encodeStr(data, tag);
        else
          throw new Error("Unsupported tag: " + tag);
      };
      Node.prototype._isNumstr = function isNumstr(str) {
        return /^[0-9 ]*$/.test(str);
      };
      Node.prototype._isPrintstr = function isPrintstr(str) {
        return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
      };
    }, { "../base/buffer": 23, "../base/reporter": 26, "minimalistic-assert": 302 }], 26: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      function Reporter(options) {
        this._reporterState = {
          obj: null,
          path: [],
          options: options || {},
          errors: []
        };
      }
      exports2.Reporter = Reporter;
      Reporter.prototype.isError = function isError(obj) {
        return obj instanceof ReporterError;
      };
      Reporter.prototype.save = function save() {
        var state = this._reporterState;
        return {
          obj: state.obj,
          pathLen: state.path.length
        };
      };
      Reporter.prototype.restore = function restore(data) {
        var state = this._reporterState;
        state.obj = data.obj;
        state.path = state.path.slice(0, data.pathLen);
      };
      Reporter.prototype.enterKey = function enterKey(key) {
        return this._reporterState.path.push(key);
      };
      Reporter.prototype.exitKey = function exitKey(index) {
        var state = this._reporterState;
        state.path = state.path.slice(0, index - 1);
      };
      Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
        var state = this._reporterState;
        this.exitKey(index);
        if (state.obj !== null)
          state.obj[key] = value;
      };
      Reporter.prototype.path = function path() {
        return this._reporterState.path.join("/");
      };
      Reporter.prototype.enterObject = function enterObject() {
        var state = this._reporterState;
        var prev = state.obj;
        state.obj = {};
        return prev;
      };
      Reporter.prototype.leaveObject = function leaveObject(prev) {
        var state = this._reporterState;
        var now = state.obj;
        state.obj = prev;
        return now;
      };
      Reporter.prototype.error = function error(msg) {
        var err;
        var state = this._reporterState;
        var inherited = msg instanceof ReporterError;
        if (inherited) {
          err = msg;
        } else {
          err = new ReporterError(state.path.map(function(elem) {
            return "[" + JSON.stringify(elem) + "]";
          }).join(""), msg.message || msg, msg.stack);
        }
        if (!state.options.partial)
          throw err;
        if (!inherited)
          state.errors.push(err);
        return err;
      };
      Reporter.prototype.wrapResult = function wrapResult(result) {
        var state = this._reporterState;
        if (!state.options.partial)
          return result;
        return {
          result: this.isError(result) ? null : result,
          errors: state.errors
        };
      };
      function ReporterError(path, msg) {
        this.path = path;
        this.rethrow(msg);
      }
      inherits(ReporterError, Error);
      ReporterError.prototype.rethrow = function rethrow(msg) {
        this.message = msg + " at: " + (this.path || "(shallow)");
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, ReporterError);
        if (!this.stack) {
          try {
            throw new Error(this.message);
          } catch (e) {
            this.stack = e.stack;
          }
        }
        return this;
      };
    }, { "inherits": 256 }], 27: [function(require2, module2, exports2) {
      function reverse(map) {
        var res = {};
        Object.keys(map).forEach(function(key) {
          if ((key | 0) == key)
            key = key | 0;
          var value = map[key];
          res[value] = key;
        });
        return res;
      }
      exports2.tagClass = {
        0: "universal",
        1: "application",
        2: "context",
        3: "private"
      };
      exports2.tagClassByName = reverse(exports2.tagClass);
      exports2.tag = {
        0: "end",
        1: "bool",
        2: "int",
        3: "bitstr",
        4: "octstr",
        5: "null_",
        6: "objid",
        7: "objDesc",
        8: "external",
        9: "real",
        10: "enum",
        11: "embed",
        12: "utf8str",
        13: "relativeOid",
        16: "seq",
        17: "set",
        18: "numstr",
        19: "printstr",
        20: "t61str",
        21: "videostr",
        22: "ia5str",
        23: "utctime",
        24: "gentime",
        25: "graphstr",
        26: "iso646str",
        27: "genstr",
        28: "unistr",
        29: "charstr",
        30: "bmpstr"
      };
      exports2.tagByName = reverse(exports2.tag);
    }, {}], 28: [function(require2, module2, exports2) {
      var constants = exports2;
      constants._reverse = function reverse(map) {
        var res = {};
        Object.keys(map).forEach(function(key) {
          if ((key | 0) == key)
            key = key | 0;
          var value = map[key];
          res[value] = key;
        });
        return res;
      };
      constants.der = require2("./der");
    }, { "./der": 27 }], 29: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var bignum = require2("bn.js");
      var DecoderBuffer = require2("../base/buffer").DecoderBuffer;
      var Node = require2("../base/node");
      var der = require2("../constants/der");
      function DERDecoder(entity) {
        this.enc = "der";
        this.name = entity.name;
        this.entity = entity;
        this.tree = new DERNode();
        this.tree._init(entity.body);
      }
      module2.exports = DERDecoder;
      DERDecoder.prototype.decode = function decode(data, options) {
        if (!DecoderBuffer.isDecoderBuffer(data)) {
          data = new DecoderBuffer(data, options);
        }
        return this.tree._decode(data, options);
      };
      function DERNode(parent) {
        Node.call(this, "der", parent);
      }
      inherits(DERNode, Node);
      DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
        if (buffer.isEmpty())
          return false;
        var state = buffer.save();
        var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
        if (buffer.isError(decodedTag))
          return decodedTag;
        buffer.restore(state);
        return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + "of" === tag || any;
      };
      DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
        var decodedTag = derDecodeTag(buffer, 'Failed to decode tag of "' + tag + '"');
        if (buffer.isError(decodedTag))
          return decodedTag;
        var len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of "' + tag + '"');
        if (buffer.isError(len))
          return len;
        if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag) {
          return buffer.error('Failed to match tag: "' + tag + '"');
        }
        if (decodedTag.primitive || len !== null)
          return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
        var state = buffer.save();
        var res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: "' + this.tag + '"');
        if (buffer.isError(res))
          return res;
        len = buffer.offset - state.offset;
        buffer.restore(state);
        return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
      };
      DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
        for (; ; ) {
          var tag = derDecodeTag(buffer, fail);
          if (buffer.isError(tag))
            return tag;
          var len = derDecodeLen(buffer, tag.primitive, fail);
          if (buffer.isError(len))
            return len;
          var res = void 0;
          if (tag.primitive || len !== null)
            res = buffer.skip(len);
          else
            res = this._skipUntilEnd(buffer, fail);
          if (buffer.isError(res))
            return res;
          if (tag.tagStr === "end")
            break;
        }
      };
      DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder, options) {
        var result = [];
        while (!buffer.isEmpty()) {
          var possibleEnd = this._peekTag(buffer, "end");
          if (buffer.isError(possibleEnd))
            return possibleEnd;
          var res = decoder.decode(buffer, "der", options);
          if (buffer.isError(res) && possibleEnd)
            break;
          result.push(res);
        }
        return result;
      };
      DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
        if (tag === "bitstr") {
          var unused = buffer.readUInt8();
          if (buffer.isError(unused))
            return unused;
          return {
            unused,
            data: buffer.raw()
          };
        } else if (tag === "bmpstr") {
          var raw = buffer.raw();
          if (raw.length % 2 === 1)
            return buffer.error("Decoding of string type: bmpstr length mismatch");
          var str = "";
          for (var i = 0; i < raw.length / 2; i++) {
            str += String.fromCharCode(raw.readUInt16BE(i * 2));
          }
          return str;
        } else if (tag === "numstr") {
          var numstr = buffer.raw().toString("ascii");
          if (!this._isNumstr(numstr)) {
            return buffer.error("Decoding of string type: numstr unsupported characters");
          }
          return numstr;
        } else if (tag === "octstr") {
          return buffer.raw();
        } else if (tag === "objDesc") {
          return buffer.raw();
        } else if (tag === "printstr") {
          var printstr = buffer.raw().toString("ascii");
          if (!this._isPrintstr(printstr)) {
            return buffer.error("Decoding of string type: printstr unsupported characters");
          }
          return printstr;
        } else if (/str$/.test(tag)) {
          return buffer.raw().toString();
        } else {
          return buffer.error("Decoding of string type: " + tag + " unsupported");
        }
      };
      DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
        var result;
        var identifiers = [];
        var ident = 0;
        var subident = 0;
        while (!buffer.isEmpty()) {
          subident = buffer.readUInt8();
          ident <<= 7;
          ident |= subident & 127;
          if ((subident & 128) === 0) {
            identifiers.push(ident);
            ident = 0;
          }
        }
        if (subident & 128)
          identifiers.push(ident);
        var first = identifiers[0] / 40 | 0;
        var second = identifiers[0] % 40;
        if (relative)
          result = identifiers;
        else
          result = [first, second].concat(identifiers.slice(1));
        if (values) {
          var tmp = values[result.join(" ")];
          if (tmp === void 0)
            tmp = values[result.join(".")];
          if (tmp !== void 0)
            result = tmp;
        }
        return result;
      };
      DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
        var str = buffer.raw().toString();
        var year;
        var mon;
        var day;
        var hour;
        var min;
        var sec;
        if (tag === "gentime") {
          year = str.slice(0, 4) | 0;
          mon = str.slice(4, 6) | 0;
          day = str.slice(6, 8) | 0;
          hour = str.slice(8, 10) | 0;
          min = str.slice(10, 12) | 0;
          sec = str.slice(12, 14) | 0;
        } else if (tag === "utctime") {
          year = str.slice(0, 2) | 0;
          mon = str.slice(2, 4) | 0;
          day = str.slice(4, 6) | 0;
          hour = str.slice(6, 8) | 0;
          min = str.slice(8, 10) | 0;
          sec = str.slice(10, 12) | 0;
          if (year < 70)
            year = 2e3 + year;
          else
            year = 1900 + year;
        } else {
          return buffer.error("Decoding " + tag + " time is not supported yet");
        }
        return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
      };
      DERNode.prototype._decodeNull = function decodeNull() {
        return null;
      };
      DERNode.prototype._decodeBool = function decodeBool(buffer) {
        var res = buffer.readUInt8();
        if (buffer.isError(res))
          return res;
        else
          return res !== 0;
      };
      DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
        var raw = buffer.raw();
        var res = new bignum(raw);
        if (values)
          res = values[res.toString(10)] || res;
        return res;
      };
      DERNode.prototype._use = function use(entity, obj) {
        if (typeof entity === "function")
          entity = entity(obj);
        return entity._getDecoder("der").tree;
      };
      function derDecodeTag(buf, fail) {
        var tag = buf.readUInt8(fail);
        if (buf.isError(tag))
          return tag;
        var cls = der.tagClass[tag >> 6];
        var primitive = (tag & 32) === 0;
        if ((tag & 31) === 31) {
          var oct = tag;
          tag = 0;
          while ((oct & 128) === 128) {
            oct = buf.readUInt8(fail);
            if (buf.isError(oct))
              return oct;
            tag <<= 7;
            tag |= oct & 127;
          }
        } else {
          tag &= 31;
        }
        var tagStr = der.tag[tag];
        return {
          cls,
          primitive,
          tag,
          tagStr
        };
      }
      function derDecodeLen(buf, primitive, fail) {
        var len = buf.readUInt8(fail);
        if (buf.isError(len))
          return len;
        if (!primitive && len === 128)
          return null;
        if ((len & 128) === 0) {
          return len;
        }
        var num = len & 127;
        if (num > 4)
          return buf.error("length octect is too long");
        len = 0;
        for (var i = 0; i < num; i++) {
          len <<= 8;
          var j = buf.readUInt8(fail);
          if (buf.isError(j))
            return j;
          len |= j;
        }
        return len;
      }
    }, { "../base/buffer": 23, "../base/node": 25, "../constants/der": 27, "bn.js": 35, "inherits": 256 }], 30: [function(require2, module2, exports2) {
      var decoders = exports2;
      decoders.der = require2("./der");
      decoders.pem = require2("./pem");
    }, { "./der": 29, "./pem": 31 }], 31: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Buffer = require2("safer-buffer").Buffer;
      var DERDecoder = require2("./der");
      function PEMDecoder(entity) {
        DERDecoder.call(this, entity);
        this.enc = "pem";
      }
      inherits(PEMDecoder, DERDecoder);
      module2.exports = PEMDecoder;
      PEMDecoder.prototype.decode = function decode(data, options) {
        var lines = data.toString().split(/[\r\n]+/g);
        var label = options.label.toUpperCase();
        var re = /^-----(BEGIN|END) ([^-]+)-----$/;
        var start = -1;
        var end = -1;
        for (var i = 0; i < lines.length; i++) {
          var match = lines[i].match(re);
          if (match === null)
            continue;
          if (match[2] !== label)
            continue;
          if (start === -1) {
            if (match[1] !== "BEGIN")
              break;
            start = i;
          } else {
            if (match[1] !== "END")
              break;
            end = i;
            break;
          }
        }
        if (start === -1 || end === -1)
          throw new Error("PEM section not found for: " + label);
        var base64 = lines.slice(start + 1, end).join("");
        base64.replace(/[^a-z0-9+/=]+/gi, "");
        var input = Buffer.from(base64, "base64");
        return DERDecoder.prototype.decode.call(this, input, options);
      };
    }, { "./der": 29, "inherits": 256, "safer-buffer": 418 }], 32: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Buffer = require2("safer-buffer").Buffer;
      var Node = require2("../base/node");
      var der = require2("../constants/der");
      function DEREncoder(entity) {
        this.enc = "der";
        this.name = entity.name;
        this.entity = entity;
        this.tree = new DERNode();
        this.tree._init(entity.body);
      }
      module2.exports = DEREncoder;
      DEREncoder.prototype.encode = function encode(data, reporter) {
        return this.tree._encode(data, reporter).join();
      };
      function DERNode(parent) {
        Node.call(this, "der", parent);
      }
      inherits(DERNode, Node);
      DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
        var encodedTag = encodeTag(tag, primitive, cls, this.reporter);
        if (content.length < 128) {
          var _header = Buffer.alloc(2);
          _header[0] = encodedTag;
          _header[1] = content.length;
          return this._createEncoderBuffer([_header, content]);
        }
        var lenOctets = 1;
        for (var i = content.length; i >= 256; i >>= 8) {
          lenOctets++;
        }
        var header = Buffer.alloc(1 + 1 + lenOctets);
        header[0] = encodedTag;
        header[1] = 128 | lenOctets;
        for (var _i = 1 + lenOctets, j = content.length; j > 0; _i--, j >>= 8) {
          header[_i] = j & 255;
        }
        return this._createEncoderBuffer([header, content]);
      };
      DERNode.prototype._encodeStr = function encodeStr(str, tag) {
        if (tag === "bitstr") {
          return this._createEncoderBuffer([str.unused | 0, str.data]);
        } else if (tag === "bmpstr") {
          var buf = Buffer.alloc(str.length * 2);
          for (var i = 0; i < str.length; i++) {
            buf.writeUInt16BE(str.charCodeAt(i), i * 2);
          }
          return this._createEncoderBuffer(buf);
        } else if (tag === "numstr") {
          if (!this._isNumstr(str)) {
            return this.reporter.error("Encoding of string type: numstr supports only digits and space");
          }
          return this._createEncoderBuffer(str);
        } else if (tag === "printstr") {
          if (!this._isPrintstr(str)) {
            return this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark");
          }
          return this._createEncoderBuffer(str);
        } else if (/str$/.test(tag)) {
          return this._createEncoderBuffer(str);
        } else if (tag === "objDesc") {
          return this._createEncoderBuffer(str);
        } else {
          return this.reporter.error("Encoding of string type: " + tag + " unsupported");
        }
      };
      DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
        if (typeof id === "string") {
          if (!values)
            return this.reporter.error("string objid given, but no values map found");
          if (!values.hasOwnProperty(id))
            return this.reporter.error("objid not found in values map");
          id = values[id].split(/[\s.]+/g);
          for (var i = 0; i < id.length; i++) {
            id[i] |= 0;
          }
        } else if (Array.isArray(id)) {
          id = id.slice();
          for (var _i2 = 0; _i2 < id.length; _i2++) {
            id[_i2] |= 0;
          }
        }
        if (!Array.isArray(id)) {
          return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(id));
        }
        if (!relative) {
          if (id[1] >= 40)
            return this.reporter.error("Second objid identifier OOB");
          id.splice(0, 2, id[0] * 40 + id[1]);
        }
        var size = 0;
        for (var _i3 = 0; _i3 < id.length; _i3++) {
          var ident = id[_i3];
          for (size++; ident >= 128; ident >>= 7) {
            size++;
          }
        }
        var objid = Buffer.alloc(size);
        var offset = objid.length - 1;
        for (var _i4 = id.length - 1; _i4 >= 0; _i4--) {
          var _ident = id[_i4];
          objid[offset--] = _ident & 127;
          while ((_ident >>= 7) > 0) {
            objid[offset--] = 128 | _ident & 127;
          }
        }
        return this._createEncoderBuffer(objid);
      };
      function two(num) {
        if (num < 10)
          return "0" + num;
        else
          return num;
      }
      DERNode.prototype._encodeTime = function encodeTime(time, tag) {
        var str;
        var date = new Date(time);
        if (tag === "gentime") {
          str = [two(date.getUTCFullYear()), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), "Z"].join("");
        } else if (tag === "utctime") {
          str = [two(date.getUTCFullYear() % 100), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), "Z"].join("");
        } else {
          this.reporter.error("Encoding " + tag + " time is not supported yet");
        }
        return this._encodeStr(str, "octstr");
      };
      DERNode.prototype._encodeNull = function encodeNull() {
        return this._createEncoderBuffer("");
      };
      DERNode.prototype._encodeInt = function encodeInt(num, values) {
        if (typeof num === "string") {
          if (!values)
            return this.reporter.error("String int or enum given, but no values map");
          if (!values.hasOwnProperty(num)) {
            return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
          }
          num = values[num];
        }
        if (typeof num !== "number" && !Buffer.isBuffer(num)) {
          var numArray = num.toArray();
          if (!num.sign && numArray[0] & 128) {
            numArray.unshift(0);
          }
          num = Buffer.from(numArray);
        }
        if (Buffer.isBuffer(num)) {
          var _size = num.length;
          if (num.length === 0)
            _size++;
          var _out = Buffer.alloc(_size);
          num.copy(_out);
          if (num.length === 0)
            _out[0] = 0;
          return this._createEncoderBuffer(_out);
        }
        if (num < 128)
          return this._createEncoderBuffer(num);
        if (num < 256)
          return this._createEncoderBuffer([0, num]);
        var size = 1;
        for (var i = num; i >= 256; i >>= 8) {
          size++;
        }
        var out = new Array(size);
        for (var _i5 = out.length - 1; _i5 >= 0; _i5--) {
          out[_i5] = num & 255;
          num >>= 8;
        }
        if (out[0] & 128) {
          out.unshift(0);
        }
        return this._createEncoderBuffer(Buffer.from(out));
      };
      DERNode.prototype._encodeBool = function encodeBool(value) {
        return this._createEncoderBuffer(value ? 255 : 0);
      };
      DERNode.prototype._use = function use(entity, obj) {
        if (typeof entity === "function")
          entity = entity(obj);
        return entity._getEncoder("der").tree;
      };
      DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
        var state = this._baseState;
        var i;
        if (state["default"] === null)
          return false;
        var data = dataBuffer.join();
        if (state.defaultBuffer === void 0)
          state.defaultBuffer = this._encodeValue(state["default"], reporter, parent).join();
        if (data.length !== state.defaultBuffer.length)
          return false;
        for (i = 0; i < data.length; i++) {
          if (data[i] !== state.defaultBuffer[i])
            return false;
        }
        return true;
      };
      function encodeTag(tag, primitive, cls, reporter) {
        var res;
        if (tag === "seqof")
          tag = "seq";
        else if (tag === "setof")
          tag = "set";
        if (der.tagByName.hasOwnProperty(tag))
          res = der.tagByName[tag];
        else if (typeof tag === "number" && (tag | 0) === tag)
          res = tag;
        else
          return reporter.error("Unknown tag: " + tag);
        if (res >= 31)
          return reporter.error("Multi-octet tag encoding unsupported");
        if (!primitive)
          res |= 32;
        res |= der.tagClassByName[cls || "universal"] << 6;
        return res;
      }
    }, { "../base/node": 25, "../constants/der": 27, "inherits": 256, "safer-buffer": 418 }], 33: [function(require2, module2, exports2) {
      var encoders = exports2;
      encoders.der = require2("./der");
      encoders.pem = require2("./pem");
    }, { "./der": 32, "./pem": 34 }], 34: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var DEREncoder = require2("./der");
      function PEMEncoder(entity) {
        DEREncoder.call(this, entity);
        this.enc = "pem";
      }
      inherits(PEMEncoder, DEREncoder);
      module2.exports = PEMEncoder;
      PEMEncoder.prototype.encode = function encode(data, options) {
        var buf = DEREncoder.prototype.encode.call(this, data);
        var p = buf.toString("base64");
        var out = ["-----BEGIN " + options.label + "-----"];
        for (var i = 0; i < p.length; i += 64) {
          out.push(p.slice(i, i + 64));
        }
        out.push("-----END " + options.label + "-----");
        return out.join("\n");
      };
    }, { "./der": 32, "inherits": 256 }], 35: [function(require2, module2, exports2) {
      (function(module3, exports3) {
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function TempCtor2() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN(number, base, endian) {
          if (BN.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
          }
        }
        if (typeof module3 === "object") {
          module3.exports = BN;
        } else {
          exports3.BN = BN;
        }
        BN.BN = BN;
        BN.wordSize = 26;
        var Buffer;
        try {
          Buffer = require2("buffer").Buffer;
        } catch (e) {
        }
        BN.isBN = function isBN(num) {
          if (num instanceof BN) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
        };
        BN.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN.prototype._init = function init(number, base, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert(base === (base | 0) && base >= 2 && base <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
          }
          if (base === 16) {
            this._parseHex(number, start);
          } else {
            this._parseBase(number, base, start);
          }
          if (number[0] === "-") {
            this.negative = 1;
          }
          this.strip();
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN.prototype._initNumber = function _initNumber(number, base, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [number & 67108863, number / 67108864 & 67108863];
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            this.words = [number & 67108863, number / 67108864 & 67108863, 1];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN.prototype._initArray = function _initArray(number, base, endian) {
          assert(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          if (endian === "be") {
            for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
              w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number.length; i += 3) {
              w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this.strip();
        };
        function parseHex(str, start, end) {
          var r = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r <<= 4;
            if (c >= 49 && c <= 54) {
              r |= c - 49 + 10;
            } else if (c >= 17 && c <= 22) {
              r |= c - 17 + 10;
            } else {
              r |= c & 15;
            }
          }
          return r;
        }
        BN.prototype._parseHex = function _parseHex(number, start) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          for (i = number.length - 6, j = 0; i >= start; i -= 6) {
            w = parseHex(number, i, i + 6);
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] |= w >>> 26 - off & 4194303;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
          if (i + 6 !== start) {
            w = parseHex(number, start, i + 6);
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] |= w >>> 26 - off & 4194303;
          }
          this.strip();
        };
        function parseBase(str, start, end, mul) {
          var r = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              r += c - 49 + 10;
            } else if (c >= 17) {
              r += c - 17 + 10;
            } else {
              r += c;
            }
          }
          return r;
        }
        BN.prototype._parseBase = function _parseBase(number, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for (i = 0; i < mod; i++) {
              pow *= base;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
        };
        BN.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        BN.prototype.clone = function clone() {
          var r = new BN(null);
          this.copy(r);
          return r;
        };
        BN.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        BN.prototype.inspect = function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"];
        var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
        var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        BN.prototype.toString = function toString(base, padding) {
          base = base || 10;
          padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off | carry) & 16777215).toString(16);
              carry = w >>> 24 - off & 16777215;
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
              off += 2;
              if (off >= 26) {
                off -= 26;
                i--;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modn(groupBase).toString(base);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN.prototype.toJSON = function toJSON() {
          return this.toString(16);
        };
        BN.prototype.toBuffer = function toBuffer(endian, length) {
          assert(typeof Buffer !== "undefined");
          return this.toArrayLike(Buffer, endian, length);
        };
        BN.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert(byteLength <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          this.strip();
          var littleEndian = endian === "le";
          var res = new ArrayType(reqLength);
          var b, i;
          var q = this.clone();
          if (!littleEndian) {
            for (i = 0; i < reqLength - byteLength; i++) {
              res[i] = 0;
            }
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[reqLength - i - 1] = b;
            }
          } else {
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[i] = b;
            }
            for (; i < reqLength; i++) {
              res[i] = 0;
            }
          }
          return res;
        };
        if (Math.clz32) {
          BN.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN.prototype._countBits = function _countBits(w) {
            var t = w;
            var r = 0;
            if (t >= 4096) {
              r += 13;
              t >>>= 13;
            }
            if (t >= 64) {
              r += 7;
              t >>>= 7;
            }
            if (t >= 8) {
              r += 4;
              t >>>= 4;
            }
            if (t >= 2) {
              r += 2;
              t >>>= 2;
            }
            return r + t;
          };
        }
        BN.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0)
            return 26;
          var t = w;
          var r = 0;
          if ((t & 8191) === 0) {
            r += 13;
            t >>>= 13;
          }
          if ((t & 127) === 0) {
            r += 7;
            t >>>= 7;
          }
          if ((t & 15) === 0) {
            r += 4;
            t >>>= 4;
          }
          if ((t & 3) === 0) {
            r += 2;
            t >>>= 2;
          }
          if ((t & 1) === 0) {
            r++;
          }
          return r;
        };
        BN.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
          }
          return w;
        }
        BN.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26)
              break;
          }
          return r;
        };
        BN.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this.strip();
        };
        BN.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this.strip();
        };
        BN.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this.strip();
        };
        BN.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this.strip();
        };
        BN.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this.strip();
        };
        BN.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this.strip();
        };
        BN.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self2.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self2.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM();
          return fftm.mulp(self2, num, out);
        }
        BN.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y) {
          this.x = x;
          this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N);
          var l = BN.prototype._countBits(N) - 1;
          for (var i = 0; i < N; i++) {
            t[i] = this.revBin(i, l, N);
          }
          return t;
        };
        FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1)
            return x;
          var rb = 0;
          for (var i = 0; i < l; i++) {
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i = 0; i < N; i++) {
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1; s < N; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1;
          var odd = N & 1;
          var i = 0;
          for (N = N / 2 | 0; N; N = N >>> 1) {
            i++;
          }
          return 1 << i + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1)
            return;
          for (var i = 0; i < N / 2; i++) {
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i = 0; i < N / 2; i++) {
            var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 67108863;
            if (w < 67108864) {
              carry = 0;
            } else {
              carry = w / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
          var carry = 0;
          for (var i = 0; i < len; i++) {
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i = 2 * len; i < N; ++i) {
            rws[i] = 0;
          }
          assert(carry === 0);
          assert((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i = 0; i < N; i++) {
            ph[i] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length);
          var rbt = this.makeRBT(N);
          var _ = this.stub(N);
          var rws = new Array(N);
          var rwst = new Array(N);
          var iwst = new Array(N);
          var nrws = new Array(N);
          var nrwst = new Array(N);
          var niwst = new Array(N);
          var rmws = out.words;
          rmws.length = N;
          this.convert13b(x.words, x.length, rws, N);
          this.convert13b(y.words, y.length, nrws, N);
          this.transform(rws, _, rwst, iwst, N, rbt);
          this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i = 0; i < N; i++) {
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
          }
          this.conjugate(rwst, iwst, N);
          this.transform(rwst, iwst, rmws, _, N, rbt);
          this.conjugate(rmws, _, N);
          this.normalize13b(rmws, N);
          out.negative = x.negative ^ y.negative;
          out.length = x.length + y.length;
          return out.strip();
        };
        BN.prototype.mul = function mul(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN.prototype.mulf = function mulf(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN.prototype.imuln = function imuln(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0)
            return new BN(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0)
              break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this.strip();
        };
        BN.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0)
            ;
          else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this.strip();
        };
        BN.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s)
            return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this.strip();
        };
        BN.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this.strip();
        };
        BN.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry === 0)
            return this.strip();
          assert(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this.strip();
        };
        BN.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q.strip();
          }
          a.strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN(0),
              mod: new BN(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN(this.modn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN.prototype.modn = function modn(num) {
          assert(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return acc;
        };
        BN.prototype.idivn = function idivn(num) {
          assert(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w / num | 0;
            carry = w % num;
          }
          return this.strip();
        };
        BN.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN.prototype.egcd = function egcd(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN(1);
          var B = new BN(0);
          var C = new BN(0);
          var D = new BN(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) {
            }
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) {
            }
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y.iushln(g)
          };
        };
        BN.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN(1);
          var x2 = new BN(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) {
            }
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) {
            }
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b;
              b = t;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this.strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN.red = function red(num) {
          return new Red(num);
        };
        BN.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name, p) {
          this.name = name;
          this.p = new BN(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output.words[i] = input.words[i];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives");
          assert(a.red && a.red === b.red, "red works only with red numbers");
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          return a.umod(this.m)._forceRed(this);
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert(!q.isZero());
          var one = new BN(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t = this.pow(a, q);
          var m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t = a.imul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN(0)._forceRed(this);
          var t = a.mul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module2 === "undefined" || module2, void 0);
    }, { "buffer": 53 }], 36: [function(require2, module2, exports2) {
      (function(global) {
        (function() {
          var objectAssign = require2("object-assign");
          /*!
           * The buffer module from node.js, for the browser.
           *
           * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
           * @license  MIT
           */
          function compare(a, b) {
            if (a === b) {
              return 0;
            }
            var x = a.length;
            var y = b.length;
            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
              if (a[i] !== b[i]) {
                x = a[i];
                y = b[i];
                break;
              }
            }
            if (x < y) {
              return -1;
            }
            if (y < x) {
              return 1;
            }
            return 0;
          }
          function isBuffer(b) {
            if (global.Buffer && typeof global.Buffer.isBuffer === "function") {
              return global.Buffer.isBuffer(b);
            }
            return !!(b != null && b._isBuffer);
          }
          var util = require2("../util/util.js");
          var hasOwn = Object.prototype.hasOwnProperty;
          var pSlice = Array.prototype.slice;
          var functionsHaveNames = function() {
            return function foo() {
            }.name === "foo";
          }();
          function pToString(obj) {
            return Object.prototype.toString.call(obj);
          }
          function isView(arrbuf) {
            if (isBuffer(arrbuf)) {
              return false;
            }
            if (typeof global.ArrayBuffer !== "function") {
              return false;
            }
            if (typeof ArrayBuffer.isView === "function") {
              return ArrayBuffer.isView(arrbuf);
            }
            if (!arrbuf) {
              return false;
            }
            if (arrbuf instanceof DataView) {
              return true;
            }
            if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
              return true;
            }
            return false;
          }
          var assert = module2.exports = ok;
          var regex = /\s*function\s+([^\(\s]*)\s*/;
          function getName(func) {
            if (!util.isFunction(func)) {
              return;
            }
            if (functionsHaveNames) {
              return func.name;
            }
            var str = func.toString();
            var match = str.match(regex);
            return match && match[1];
          }
          assert.AssertionError = function AssertionError(options) {
            this.name = "AssertionError";
            this.actual = options.actual;
            this.expected = options.expected;
            this.operator = options.operator;
            if (options.message) {
              this.message = options.message;
              this.generatedMessage = false;
            } else {
              this.message = getMessage(this);
              this.generatedMessage = true;
            }
            var stackStartFunction = options.stackStartFunction || fail;
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, stackStartFunction);
            } else {
              var err = new Error();
              if (err.stack) {
                var out = err.stack;
                var fn_name = getName(stackStartFunction);
                var idx = out.indexOf("\n" + fn_name);
                if (idx >= 0) {
                  var next_line = out.indexOf("\n", idx + 1);
                  out = out.substring(next_line + 1);
                }
                this.stack = out;
              }
            }
          };
          util.inherits(assert.AssertionError, Error);
          function truncate(s, n) {
            if (typeof s === "string") {
              return s.length < n ? s : s.slice(0, n);
            } else {
              return s;
            }
          }
          function inspect(something) {
            if (functionsHaveNames || !util.isFunction(something)) {
              return util.inspect(something);
            }
            var rawname = getName(something);
            var name = rawname ? ": " + rawname : "";
            return "[Function" + name + "]";
          }
          function getMessage(self2) {
            return truncate(inspect(self2.actual), 128) + " " + self2.operator + " " + truncate(inspect(self2.expected), 128);
          }
          function fail(actual, expected, message, operator, stackStartFunction) {
            throw new assert.AssertionError({
              message,
              actual,
              expected,
              operator,
              stackStartFunction
            });
          }
          assert.fail = fail;
          function ok(value, message) {
            if (!value)
              fail(value, true, message, "==", assert.ok);
          }
          assert.ok = ok;
          assert.equal = function equal(actual, expected, message) {
            if (actual != expected)
              fail(actual, expected, message, "==", assert.equal);
          };
          assert.notEqual = function notEqual(actual, expected, message) {
            if (actual == expected) {
              fail(actual, expected, message, "!=", assert.notEqual);
            }
          };
          assert.deepEqual = function deepEqual(actual, expected, message) {
            if (!_deepEqual(actual, expected, false)) {
              fail(actual, expected, message, "deepEqual", assert.deepEqual);
            }
          };
          assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
            if (!_deepEqual(actual, expected, true)) {
              fail(actual, expected, message, "deepStrictEqual", assert.deepStrictEqual);
            }
          };
          function _deepEqual(actual, expected, strict2, memos) {
            if (actual === expected) {
              return true;
            } else if (isBuffer(actual) && isBuffer(expected)) {
              return compare(actual, expected) === 0;
            } else if (util.isDate(actual) && util.isDate(expected)) {
              return actual.getTime() === expected.getTime();
            } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
              return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
            } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
              return strict2 ? actual === expected : actual == expected;
            } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
              return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0;
            } else if (isBuffer(actual) !== isBuffer(expected)) {
              return false;
            } else {
              memos = memos || {
                actual: [],
                expected: []
              };
              var actualIndex = memos.actual.indexOf(actual);
              if (actualIndex !== -1) {
                if (actualIndex === memos.expected.indexOf(expected)) {
                  return true;
                }
              }
              memos.actual.push(actual);
              memos.expected.push(expected);
              return objEquiv(actual, expected, strict2, memos);
            }
          }
          function isArguments(object) {
            return Object.prototype.toString.call(object) == "[object Arguments]";
          }
          function objEquiv(a, b, strict2, actualVisitedObjects) {
            if (a === null || a === void 0 || b === null || b === void 0)
              return false;
            if (util.isPrimitive(a) || util.isPrimitive(b))
              return a === b;
            if (strict2 && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
              return false;
            var aIsArgs = isArguments(a);
            var bIsArgs = isArguments(b);
            if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
              return false;
            if (aIsArgs) {
              a = pSlice.call(a);
              b = pSlice.call(b);
              return _deepEqual(a, b, strict2);
            }
            var ka = objectKeys(a);
            var kb = objectKeys(b);
            var key, i;
            if (ka.length !== kb.length)
              return false;
            ka.sort();
            kb.sort();
            for (i = ka.length - 1; i >= 0; i--) {
              if (ka[i] !== kb[i])
                return false;
            }
            for (i = ka.length - 1; i >= 0; i--) {
              key = ka[i];
              if (!_deepEqual(a[key], b[key], strict2, actualVisitedObjects))
                return false;
            }
            return true;
          }
          assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
            if (_deepEqual(actual, expected, false)) {
              fail(actual, expected, message, "notDeepEqual", assert.notDeepEqual);
            }
          };
          assert.notDeepStrictEqual = notDeepStrictEqual;
          function notDeepStrictEqual(actual, expected, message) {
            if (_deepEqual(actual, expected, true)) {
              fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
            }
          }
          assert.strictEqual = function strictEqual(actual, expected, message) {
            if (actual !== expected) {
              fail(actual, expected, message, "===", assert.strictEqual);
            }
          };
          assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
            if (actual === expected) {
              fail(actual, expected, message, "!==", assert.notStrictEqual);
            }
          };
          function expectedException(actual, expected) {
            if (!actual || !expected) {
              return false;
            }
            if (Object.prototype.toString.call(expected) == "[object RegExp]") {
              return expected.test(actual);
            }
            try {
              if (actual instanceof expected) {
                return true;
              }
            } catch (e) {
            }
            if (Error.isPrototypeOf(expected)) {
              return false;
            }
            return expected.call({}, actual) === true;
          }
          function _tryBlock(block) {
            var error;
            try {
              block();
            } catch (e) {
              error = e;
            }
            return error;
          }
          function _throws(shouldThrow, block, expected, message) {
            var actual;
            if (typeof block !== "function") {
              throw new TypeError('"block" argument must be a function');
            }
            if (typeof expected === "string") {
              message = expected;
              expected = null;
            }
            actual = _tryBlock(block);
            message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
            if (shouldThrow && !actual) {
              fail(actual, expected, "Missing expected exception" + message);
            }
            var userProvidedMessage = typeof message === "string";
            var isUnwantedException = !shouldThrow && util.isError(actual);
            var isUnexpectedException = !shouldThrow && actual && !expected;
            if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
              fail(actual, expected, "Got unwanted exception" + message);
            }
            if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
              throw actual;
            }
          }
          assert.throws = function(block, error, message) {
            _throws(true, block, error, message);
          };
          assert.doesNotThrow = function(block, error, message) {
            _throws(false, block, error, message);
          };
          assert.ifError = function(err) {
            if (err)
              throw err;
          };
          function strict(value, message) {
            if (!value)
              fail(value, true, message, "==", strict);
          }
          assert.strict = objectAssign(strict, assert, {
            equal: assert.strictEqual,
            deepEqual: assert.deepStrictEqual,
            notEqual: assert.notStrictEqual,
            notDeepEqual: assert.notDeepStrictEqual
          });
          assert.strict.strict = assert.strict;
          var objectKeys = Object.keys || function(obj) {
            var keys = [];
            for (var key in obj) {
              if (hasOwn.call(obj, key))
                keys.push(key);
            }
            return keys;
          };
        }).call(this);
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "../util/util.js": 514, "object-assign": 338 }], 37: [function(require2, module2, exports2) {
      module2.exports = batcher;
      function batcher(run) {
        var running = false;
        var pendingBatch = null;
        var pendingCallbacks = null;
        var callbacks = null;
        return append;
        function done(err) {
          if (callbacks)
            callAll(callbacks, err);
          running = false;
          callbacks = pendingCallbacks;
          var nextBatch = pendingBatch;
          pendingBatch = null;
          pendingCallbacks = null;
          if (!nextBatch || !nextBatch.length) {
            if (!callbacks || !callbacks.length) {
              callbacks = null;
              return;
            }
            if (!nextBatch)
              nextBatch = [];
          }
          running = true;
          run(nextBatch, done);
        }
        function append(val, cb) {
          if (running) {
            if (!pendingBatch) {
              pendingBatch = [];
              pendingCallbacks = [];
            }
            pushAll(pendingBatch, val);
            if (cb)
              pendingCallbacks.push(cb);
          } else {
            if (cb)
              callbacks = [cb];
            running = true;
            run(Array.isArray(val) ? val : [val], done);
          }
        }
      }
      function pushAll(list, val) {
        if (Array.isArray(val))
          pushArray(list, val);
        else
          list.push(val);
      }
      function pushArray(list, val) {
        for (var i = 0; i < val.length; i++) {
          list.push(val[i]);
        }
      }
      function callAll(list, err) {
        for (var i = 0; i < list.length; i++) {
          list[i](err);
        }
      }
    }, {}], 38: [function(require2, module2, exports2) {
      (function(global) {
        (function() {
          var filter = require2("array-filter");
          module2.exports = function availableTypedArrays() {
            return filter(["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], function(typedArray) {
              return typeof global[typedArray] === "function";
            });
          };
        }).call(this);
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "array-filter": 20 }], 39: [function(require2, module2, exports2) {
      exports2.byteLength = byteLength;
      exports2.toByteArray = toByteArray;
      exports2.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
        }
        return parts.join("");
      }
    }, {}], 40: [function(require2, module2, exports2) {
      var varint = require2("varint");
      var alloc = require2("buffer-alloc-unsafe");
      module2.exports = align(1);
      function align(n) {
        var exports3 = {};
        exports3.align = align;
        exports3.encode = encode;
        exports3.encode.bytes = 0;
        exports3.encodingLength = encodingLength;
        exports3.decode = decode;
        exports3.decode.bytes = 0;
        exports3.decodingLength = decodingLength;
        return exports3;
        function State(input, output, offset) {
          this.inputOffset = 0;
          this.inputLength = input.length;
          this.input = input;
          this.outputOffset = offset;
          this.output = output;
        }
        function encode(bitfield, buffer, offset) {
          if (!offset)
            offset = 0;
          if (!buffer)
            buffer = alloc(encodingLength(bitfield));
          var state = new State(bitfield, buffer, offset);
          rle(state);
          encode.bytes = state.outputOffset - offset;
          return buffer;
        }
        function encodingLength(bitfield) {
          var state = new State(bitfield, null, 0);
          rle(state);
          return state.outputOffset;
        }
        function decode(buffer, offset) {
          if (!offset)
            offset = 0;
          var bitfield = alloc(decodingLength(buffer, offset));
          var ptr = 0;
          while (offset < buffer.length) {
            var next = varint.decode(buffer, offset);
            var repeat = next & 1;
            var len = repeat ? (next - (next & 3)) / 4 : next / 2;
            offset += varint.decode.bytes;
            if (repeat) {
              bitfield.fill(next & 2 ? 255 : 0, ptr, ptr + len);
            } else {
              buffer.copy(bitfield, ptr, offset, offset + len);
              offset += len;
            }
            ptr += len;
          }
          bitfield.fill(0, ptr);
          decode.bytes = buffer.length - offset;
          return bitfield;
        }
        function decodingLength(buffer, offset) {
          if (!offset)
            offset = 0;
          var len = 0;
          while (offset < buffer.length) {
            var next = varint.decode(buffer, offset);
            offset += varint.decode.bytes;
            var repeat = next & 1;
            var slice = repeat ? (next - (next & 3)) / 4 : next / 2;
            len += slice;
            if (!repeat)
              offset += slice;
          }
          if (offset > buffer.length)
            throw new Error("Invalid RLE bitfield");
          if (len & n - 1)
            return len + (n - (len & n - 1));
          return len;
        }
        function rle(state) {
          var len = 0;
          var bits = 0;
          var input = state.input;
          while (state.inputLength > 0 && !input[state.inputLength - 1]) {
            state.inputLength--;
          }
          for (var i = 0; i < state.inputLength; i++) {
            if (input[i] === bits) {
              len++;
              continue;
            }
            if (len)
              encodeUpdate(state, i, len, bits);
            if (input[i] === 0 || input[i] === 255) {
              bits = input[i];
              len = 1;
            } else {
              len = 0;
            }
          }
          if (len)
            encodeUpdate(state, state.inputLength, len, bits);
          encodeFinal(state);
        }
        function encodeHead(state, end) {
          var headLength = end - state.inputOffset;
          varint.encode(2 * headLength, state.output, state.outputOffset);
          state.outputOffset += varint.encode.bytes;
          state.input.copy(state.output, state.outputOffset, state.inputOffset, end);
          state.outputOffset += headLength;
        }
        function encodeFinal(state) {
          var headLength = state.inputLength - state.inputOffset;
          if (!headLength)
            return;
          if (!state.output) {
            state.outputOffset += headLength + varint.encodingLength(2 * headLength);
          } else {
            encodeHead(state, state.inputLength);
          }
          state.inputOffset = state.inputLength;
        }
        function encodeUpdate(state, i, len, bit) {
          var headLength = i - len - state.inputOffset;
          var headCost = headLength ? varint.encodingLength(2 * headLength) + headLength : 0;
          var enc = 4 * len + (bit ? 2 : 0) + 1;
          var encCost = headCost + varint.encodingLength(enc);
          var baseCost = varint.encodingLength(2 * (i - state.inputOffset)) + i - state.inputOffset;
          if (encCost >= baseCost)
            return;
          if (!state.output) {
            state.outputOffset += encCost;
            state.inputOffset = i;
            return;
          }
          if (headLength)
            encodeHead(state, i - len);
          varint.encode(enc, state.output, state.outputOffset);
          state.outputOffset += varint.encode.bytes;
          state.inputOffset = i;
        }
      }
    }, { "buffer-alloc-unsafe": 83, "varint": 43 }], 41: [function(require2, module2, exports2) {
      module2.exports = read;
      var MSB = 128, REST = 127;
      function read(buf, offset) {
        var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
        do {
          if (counter >= l) {
            read.bytes = 0;
            read.bytesRead = 0;
            return void 0;
          }
          b = buf[counter++];
          res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
          shift += 7;
        } while (b >= MSB);
        read.bytes = counter - offset;
        return res;
      }
    }, {}], 42: [function(require2, module2, exports2) {
      module2.exports = encode;
      var MSB = 128, REST = 127, MSBALL = ~REST, INT = Math.pow(2, 31);
      function encode(num, out, offset) {
        out = out || [];
        offset = offset || 0;
        var oldOffset = offset;
        while (num >= INT) {
          out[offset++] = num & 255 | MSB;
          num /= 128;
        }
        while (num & MSBALL) {
          out[offset++] = num & 255 | MSB;
          num >>>= 7;
        }
        out[offset] = num | 0;
        encode.bytes = offset - oldOffset + 1;
        return out;
      }
    }, {}], 43: [function(require2, module2, exports2) {
      module2.exports = {
        encode: require2("./encode.js"),
        decode: require2("./decode.js"),
        encodingLength: require2("./length.js")
      };
    }, { "./decode.js": 41, "./encode.js": 42, "./length.js": 44 }], 44: [function(require2, module2, exports2) {
      var N1 = Math.pow(2, 7);
      var N2 = Math.pow(2, 14);
      var N3 = Math.pow(2, 21);
      var N4 = Math.pow(2, 28);
      var N5 = Math.pow(2, 35);
      var N6 = Math.pow(2, 42);
      var N7 = Math.pow(2, 49);
      var N8 = Math.pow(2, 56);
      var N9 = Math.pow(2, 63);
      module2.exports = function(value) {
        return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
      };
    }, {}], 45: [function(require2, module2, exports2) {
      var blake2b = require2("blake2b");
      module2.exports = function(out, data, key) {
        blake2b(out.length, key).update(data).digest(out);
      };
      module2.exports.batch = function(out, batch, key) {
        var b = blake2b(out.length, key);
        for (var i = 0; i < batch.length; i++) {
          b.update(batch[i]);
        }
        b.digest(out);
      };
    }, { "blake2b": 49 }], 46: [function(require2, module2, exports2) {
      module2.exports = loadWebAssembly;
      loadWebAssembly.supported = typeof WebAssembly !== "undefined";
      function loadWebAssembly(opts) {
        if (!loadWebAssembly.supported)
          return null;
        var imp = opts && opts.imports;
        var wasm = toUint8Array("AGFzbQEAAAABEANgAn9/AGADf39/AGABfwADBQQAAQICBQUBAQroBwdNBQZtZW1vcnkCAAxibGFrZTJiX2luaXQAAA5ibGFrZTJiX3VwZGF0ZQABDWJsYWtlMmJfZmluYWwAAhBibGFrZTJiX2NvbXByZXNzAAMK00AElgMAIABCADcDACAAQQhqQgA3AwAgAEEQakIANwMAIABBGGpCADcDACAAQSBqQgA3AwAgAEEoakIANwMAIABBMGpCADcDACAAQThqQgA3AwAgAEHAAGpCADcDACAAQcgAakIANwMAIABB0ABqQgA3AwAgAEHYAGpCADcDACAAQeAAakIANwMAIABB6ABqQgA3AwAgAEHwAGpCADcDACAAQfgAakIANwMAIABBgAFqQoiS853/zPmE6gBBACkDAIU3AwAgAEGIAWpCu86qptjQ67O7f0EIKQMAhTcDACAAQZABakKr8NP0r+68tzxBECkDAIU3AwAgAEGYAWpC8e30+KWn/aelf0EYKQMAhTcDACAAQaABakLRhZrv+s+Uh9EAQSApAwCFNwMAIABBqAFqQp/Y+dnCkdqCm39BKCkDAIU3AwAgAEGwAWpC6/qG2r+19sEfQTApAwCFNwMAIABBuAFqQvnC+JuRo7Pw2wBBOCkDAIU3AwAgAEHAAWpCADcDACAAQcgBakIANwMAIABB0AFqQgA3AwALbQEDfyAAQcABaiEDIABByAFqIQQgBCkDAKchBQJAA0AgASACRg0BIAVBgAFGBEAgAyADKQMAIAWtfDcDAEEAIQUgABADCyAAIAVqIAEtAAA6AAAgBUEBaiEFIAFBAWohAQwACwsgBCAFrTcDAAtkAQN/IABBwAFqIQEgAEHIAWohAiABIAEpAwAgAikDAHw3AwAgAEHQAWpCfzcDACACKQMApyEDAkADQCADQYABRg0BIAAgA2pBADoAACADQQFqIQMMAAsLIAIgA603AwAgABADC+U7AiB+CX8gAEGAAWohISAAQYgBaiEiIABBkAFqISMgAEGYAWohJCAAQaABaiElIABBqAFqISYgAEGwAWohJyAAQbgBaiEoICEpAwAhASAiKQMAIQIgIykDACEDICQpAwAhBCAlKQMAIQUgJikDACEGICcpAwAhByAoKQMAIQhCiJLznf/M+YTqACEJQrvOqqbY0Ouzu38hCkKr8NP0r+68tzwhC0Lx7fT4paf9p6V/IQxC0YWa7/rPlIfRACENQp/Y+dnCkdqCm38hDkLr+obav7X2wR8hD0L5wvibkaOz8NsAIRAgACkDACERIABBCGopAwAhEiAAQRBqKQMAIRMgAEEYaikDACEUIABBIGopAwAhFSAAQShqKQMAIRYgAEEwaikDACEXIABBOGopAwAhGCAAQcAAaikDACEZIABByABqKQMAIRogAEHQAGopAwAhGyAAQdgAaikDACEcIABB4ABqKQMAIR0gAEHoAGopAwAhHiAAQfAAaikDACEfIABB+ABqKQMAISAgDSAAQcABaikDAIUhDSAPIABB0AFqKQMAhSEPIAEgBSARfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgEnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBN8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAUfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgFXx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBZ8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAXfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggGHx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBl8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAafHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgG3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBx8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAdfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHnx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB98fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAgfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgH3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBt8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAVfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGXx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBp8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAgfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggHnx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBd8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiASfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgHXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBF8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByATfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBh8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAWfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBx8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAZfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgHXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBF8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAWfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgE3x8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIICB8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAefHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgG3x8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB98fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAUfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgF3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBh8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCASfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgGnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBV8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAYfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgGnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBR8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiASfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgHnx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIB18fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAcfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggH3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBN8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAXfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgFnx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBt8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAVfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggEXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFICB8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAZfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgGnx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBF8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAWfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGHx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBN8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAVfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggG3x8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIICB8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAffHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgEnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBx8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAdfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggF3x8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBl8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAUfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgHnx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBN8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAdfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgF3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBt8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByARfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgHHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBl8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAUfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgFXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB58fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAYfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgFnx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIICB8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAffHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgEnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBp8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAdfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgFnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBJ8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAgfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgH3x8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIB58fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAVfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggG3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBF8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAYfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgF3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBR8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAafHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggE3x8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBl8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAcfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgHnx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBx8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAYfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgH3x8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIB18fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByASfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggFHx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBp8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAWfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgEXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHICB8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAVfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggGXx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBd8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSATfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgG3x8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBd8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAgfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgH3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBp8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAcfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgFHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBF8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAZfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgHXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBN8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAefHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgGHx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBJ8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAVfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgG3x8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBZ8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAbfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgE3x8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBl8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAVfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgGHx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBd8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCASfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggFnx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGICB8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAcfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgGnx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIB98fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAUfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB58fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSARfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgEXx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBJ8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiATfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgFHx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBV8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAWfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggF3x8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBh8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAZfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgGnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBt8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAcfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHXx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIB58fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAffHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgIHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIB98fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAbfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgFXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBl8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAafHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgIHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIB58fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAXfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgEnx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB18fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByARfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgE3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBx8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAYfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgFnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBR8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFICEgISkDACABIAmFhTcDACAiICIpAwAgAiAKhYU3AwAgIyAjKQMAIAMgC4WFNwMAICQgJCkDACAEIAyFhTcDACAlICUpAwAgBSANhYU3AwAgJiAmKQMAIAYgDoWFNwMAICcgJykDACAHIA+FhTcDACAoICgpAwAgCCAQhYU3AwAL");
        var ready = null;
        var mod = {
          buffer: wasm,
          memory: null,
          exports: null,
          realloc,
          onload
        };
        onload(function() {
        });
        return mod;
        function realloc(size) {
          mod.exports.memory.grow(Math.ceil(Math.abs(size - mod.memory.length) / 65536));
          mod.memory = new Uint8Array(mod.exports.memory.buffer);
        }
        function onload(cb) {
          if (mod.exports)
            return cb();
          if (ready) {
            ready.then(cb.bind(null, null)).catch(cb);
            return;
          }
          try {
            if (opts && opts.async)
              throw new Error("async");
            setup({
              instance: new WebAssembly.Instance(new WebAssembly.Module(wasm), imp)
            });
          } catch (err) {
            ready = WebAssembly.instantiate(wasm, imp).then(setup);
          }
          onload(cb);
        }
        function setup(w) {
          mod.exports = w.instance.exports;
          mod.memory = mod.exports.memory && mod.exports.memory.buffer && new Uint8Array(mod.exports.memory.buffer);
        }
      }
      function toUint8Array(s) {
        if (typeof atob === "function")
          return new Uint8Array(atob(s).split("").map(charCodeAt));
        return new (require2("buffer")).Buffer(s, "base64");
      }
      function charCodeAt(c) {
        return c.charCodeAt(0);
      }
    }, {}], 47: [function(require2, module2, exports2) {
      var assert = require2("nanoassert");
      var wasm = require2("./blake2b")();
      var head = 64;
      var freeList = [];
      module2.exports = Blake2b;
      var BYTES_MIN = module2.exports.BYTES_MIN = 16;
      var BYTES_MAX = module2.exports.BYTES_MAX = 64;
      module2.exports.BYTES = 32;
      var KEYBYTES_MIN = module2.exports.KEYBYTES_MIN = 16;
      var KEYBYTES_MAX = module2.exports.KEYBYTES_MAX = 64;
      module2.exports.KEYBYTES = 32;
      var SALTBYTES = module2.exports.SALTBYTES = 16;
      var PERSONALBYTES = module2.exports.PERSONALBYTES = 16;
      function Blake2b(digestLength, key, salt, personal, noAssert) {
        if (!(this instanceof Blake2b))
          return new Blake2b(digestLength, key, salt, personal, noAssert);
        if (!(wasm && wasm.exports))
          throw new Error("WASM not loaded. Wait for Blake2b.ready(cb)");
        if (!digestLength)
          digestLength = 32;
        if (noAssert !== true) {
          assert(digestLength >= BYTES_MIN, "digestLength must be at least " + BYTES_MIN + ", was given " + digestLength);
          assert(digestLength <= BYTES_MAX, "digestLength must be at most " + BYTES_MAX + ", was given " + digestLength);
          if (key != null)
            assert(key.length >= KEYBYTES_MIN, "key must be at least " + KEYBYTES_MIN + ", was given " + key.length);
          if (key != null)
            assert(key.length <= KEYBYTES_MAX, "key must be at least " + KEYBYTES_MAX + ", was given " + key.length);
          if (salt != null)
            assert(salt.length === SALTBYTES, "salt must be exactly " + SALTBYTES + ", was given " + salt.length);
          if (personal != null)
            assert(personal.length === PERSONALBYTES, "personal must be exactly " + PERSONALBYTES + ", was given " + personal.length);
        }
        if (!freeList.length) {
          freeList.push(head);
          head += 216;
        }
        this.digestLength = digestLength;
        this.finalized = false;
        this.pointer = freeList.pop();
        wasm.memory.fill(0, 0, 64);
        wasm.memory[0] = this.digestLength;
        wasm.memory[1] = key ? key.length : 0;
        wasm.memory[2] = 1;
        wasm.memory[3] = 1;
        if (salt)
          wasm.memory.set(salt, 32);
        if (personal)
          wasm.memory.set(personal, 48);
        if (this.pointer + 216 > wasm.memory.length)
          wasm.realloc(this.pointer + 216);
        wasm.exports.blake2b_init(this.pointer, this.digestLength);
        if (key) {
          this.update(key);
          wasm.memory.fill(0, head, head + key.length);
          wasm.memory[this.pointer + 200] = 128;
        }
      }
      Blake2b.prototype.update = function(input) {
        assert(this.finalized === false, "Hash instance finalized");
        assert(input, "input must be TypedArray or Buffer");
        if (head + input.length > wasm.memory.length)
          wasm.realloc(head + input.length);
        wasm.memory.set(input, head);
        wasm.exports.blake2b_update(this.pointer, head, head + input.length);
        return this;
      };
      Blake2b.prototype.digest = function(enc) {
        assert(this.finalized === false, "Hash instance finalized");
        this.finalized = true;
        freeList.push(this.pointer);
        wasm.exports.blake2b_final(this.pointer);
        if (!enc || enc === "binary") {
          return wasm.memory.slice(this.pointer + 128, this.pointer + 128 + this.digestLength);
        }
        if (enc === "hex") {
          return hexSlice(wasm.memory, this.pointer + 128, this.digestLength);
        }
        assert(enc.length >= this.digestLength, "input must be TypedArray or Buffer");
        for (var i = 0; i < this.digestLength; i++) {
          enc[i] = wasm.memory[this.pointer + 128 + i];
        }
        return enc;
      };
      Blake2b.prototype.final = Blake2b.prototype.digest;
      Blake2b.WASM = wasm && wasm.buffer;
      Blake2b.SUPPORTED = typeof WebAssembly !== "undefined";
      Blake2b.ready = function(cb) {
        if (!cb)
          cb = noop;
        if (!wasm)
          return cb(new Error("WebAssembly not supported"));
        var p = new Promise(function(reject, resolve) {
          wasm.onload(function(err) {
            if (err)
              resolve();
            else
              reject();
            cb(err);
          });
        });
        return p;
      };
      Blake2b.prototype.ready = Blake2b.ready;
      function noop() {
      }
      function hexSlice(buf, start, len) {
        var str = "";
        for (var i = 0; i < len; i++) {
          str += toHex(buf[start + i]);
        }
        return str;
      }
      function toHex(n) {
        if (n < 16)
          return "0" + n.toString(16);
        return n.toString(16);
      }
    }, { "./blake2b": 46, "nanoassert": 48 }], 48: [function(require2, module2, exports2) {
      assert.notEqual = notEqual;
      assert.notOk = notOk;
      assert.equal = equal;
      assert.ok = assert;
      module2.exports = assert;
      function equal(a, b, m) {
        assert(a == b, m);
      }
      function notEqual(a, b, m) {
        assert(a != b, m);
      }
      function notOk(t, m) {
        assert(!t, m);
      }
      function assert(t, m) {
        if (!t)
          throw new Error(m || "AssertionError");
      }
    }, {}], 49: [function(require2, module2, exports2) {
      var assert = require2("nanoassert");
      var b2wasm = require2("blake2b-wasm");
      function ADD64AA(v2, a, b) {
        var o0 = v2[a] + v2[b];
        var o1 = v2[a + 1] + v2[b + 1];
        if (o0 >= 4294967296) {
          o1++;
        }
        v2[a] = o0;
        v2[a + 1] = o1;
      }
      function ADD64AC(v2, a, b0, b1) {
        var o0 = v2[a] + b0;
        if (b0 < 0) {
          o0 += 4294967296;
        }
        var o1 = v2[a + 1] + b1;
        if (o0 >= 4294967296) {
          o1++;
        }
        v2[a] = o0;
        v2[a + 1] = o1;
      }
      function B2B_GET32(arr, i) {
        return arr[i] ^ arr[i + 1] << 8 ^ arr[i + 2] << 16 ^ arr[i + 3] << 24;
      }
      function B2B_G(a, b, c, d, ix, iy) {
        var x0 = m[ix];
        var x1 = m[ix + 1];
        var y0 = m[iy];
        var y1 = m[iy + 1];
        ADD64AA(v, a, b);
        ADD64AC(v, a, x0, x1);
        var xor0 = v[d] ^ v[a];
        var xor1 = v[d + 1] ^ v[a + 1];
        v[d] = xor1;
        v[d + 1] = xor0;
        ADD64AA(v, c, d);
        xor0 = v[b] ^ v[c];
        xor1 = v[b + 1] ^ v[c + 1];
        v[b] = xor0 >>> 24 ^ xor1 << 8;
        v[b + 1] = xor1 >>> 24 ^ xor0 << 8;
        ADD64AA(v, a, b);
        ADD64AC(v, a, y0, y1);
        xor0 = v[d] ^ v[a];
        xor1 = v[d + 1] ^ v[a + 1];
        v[d] = xor0 >>> 16 ^ xor1 << 16;
        v[d + 1] = xor1 >>> 16 ^ xor0 << 16;
        ADD64AA(v, c, d);
        xor0 = v[b] ^ v[c];
        xor1 = v[b + 1] ^ v[c + 1];
        v[b] = xor1 >>> 31 ^ xor0 << 1;
        v[b + 1] = xor0 >>> 31 ^ xor1 << 1;
      }
      var BLAKE2B_IV32 = new Uint32Array([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225]);
      var SIGMA8 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3];
      var SIGMA82 = new Uint8Array(SIGMA8.map(function(x) {
        return x * 2;
      }));
      var v = new Uint32Array(32);
      var m = new Uint32Array(32);
      function blake2bCompress(ctx, last) {
        var i = 0;
        for (i = 0; i < 16; i++) {
          v[i] = ctx.h[i];
          v[i + 16] = BLAKE2B_IV32[i];
        }
        v[24] = v[24] ^ ctx.t;
        v[25] = v[25] ^ ctx.t / 4294967296;
        if (last) {
          v[28] = ~v[28];
          v[29] = ~v[29];
        }
        for (i = 0; i < 32; i++) {
          m[i] = B2B_GET32(ctx.b, 4 * i);
        }
        for (i = 0; i < 12; i++) {
          B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
          B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
          B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
          B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
          B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
          B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
          B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
          B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
        }
        for (i = 0; i < 16; i++) {
          ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16];
        }
      }
      var parameter_block = new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ]);
      function Blake2b(outlen, key, salt, personal) {
        parameter_block.fill(0);
        this.b = new Uint8Array(128);
        this.h = new Uint32Array(16);
        this.t = 0;
        this.c = 0;
        this.outlen = outlen;
        parameter_block[0] = outlen;
        if (key)
          parameter_block[1] = key.length;
        parameter_block[2] = 1;
        parameter_block[3] = 1;
        if (salt)
          parameter_block.set(salt, 32);
        if (personal)
          parameter_block.set(personal, 48);
        for (var i = 0; i < 16; i++) {
          this.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameter_block, i * 4);
        }
        if (key) {
          blake2bUpdate(this, key);
          this.c = 128;
        }
      }
      Blake2b.prototype.update = function(input) {
        assert(input != null, "input must be Uint8Array or Buffer");
        blake2bUpdate(this, input);
        return this;
      };
      Blake2b.prototype.digest = function(out) {
        var buf = !out || out === "binary" || out === "hex" ? new Uint8Array(this.outlen) : out;
        assert(buf.length >= this.outlen, "out must have at least outlen bytes of space");
        blake2bFinal(this, buf);
        if (out === "hex")
          return hexSlice(buf);
        return buf;
      };
      Blake2b.prototype.final = Blake2b.prototype.digest;
      Blake2b.ready = function(cb) {
        b2wasm.ready(function() {
          cb();
        });
      };
      function blake2bUpdate(ctx, input) {
        for (var i = 0; i < input.length; i++) {
          if (ctx.c === 128) {
            ctx.t += ctx.c;
            blake2bCompress(ctx, false);
            ctx.c = 0;
          }
          ctx.b[ctx.c++] = input[i];
        }
      }
      function blake2bFinal(ctx, out) {
        ctx.t += ctx.c;
        while (ctx.c < 128) {
          ctx.b[ctx.c++] = 0;
        }
        blake2bCompress(ctx, true);
        for (var i = 0; i < ctx.outlen; i++) {
          out[i] = ctx.h[i >> 2] >> 8 * (i & 3);
        }
        return out;
      }
      function hexSlice(buf) {
        var str = "";
        for (var i = 0; i < buf.length; i++) {
          str += toHex(buf[i]);
        }
        return str;
      }
      function toHex(n) {
        if (n < 16)
          return "0" + n.toString(16);
        return n.toString(16);
      }
      var Proto = Blake2b;
      module2.exports = function createHash(outlen, key, salt, personal, noAssert) {
        if (noAssert !== true) {
          assert(outlen >= BYTES_MIN, "outlen must be at least " + BYTES_MIN + ", was given " + outlen);
          assert(outlen <= BYTES_MAX, "outlen must be at most " + BYTES_MAX + ", was given " + outlen);
          if (key != null)
            assert(key.length >= KEYBYTES_MIN, "key must be at least " + KEYBYTES_MIN + ", was given " + key.length);
          if (key != null)
            assert(key.length <= KEYBYTES_MAX, "key must be at most " + KEYBYTES_MAX + ", was given " + key.length);
          if (salt != null)
            assert(salt.length === SALTBYTES, "salt must be exactly " + SALTBYTES + ", was given " + salt.length);
          if (personal != null)
            assert(personal.length === PERSONALBYTES, "personal must be exactly " + PERSONALBYTES + ", was given " + personal.length);
        }
        return new Proto(outlen, key, salt, personal);
      };
      module2.exports.ready = function(cb) {
        b2wasm.ready(function() {
          cb();
        });
      };
      module2.exports.WASM_SUPPORTED = b2wasm.SUPPORTED;
      module2.exports.WASM_LOADED = false;
      var BYTES_MIN = module2.exports.BYTES_MIN = 16;
      var BYTES_MAX = module2.exports.BYTES_MAX = 64;
      module2.exports.BYTES = 32;
      var KEYBYTES_MIN = module2.exports.KEYBYTES_MIN = 16;
      var KEYBYTES_MAX = module2.exports.KEYBYTES_MAX = 64;
      module2.exports.KEYBYTES = 32;
      var SALTBYTES = module2.exports.SALTBYTES = 16;
      var PERSONALBYTES = module2.exports.PERSONALBYTES = 16;
      b2wasm.ready(function(err) {
        if (!err) {
          module2.exports.WASM_LOADED = true;
          Proto = b2wasm;
        }
      });
    }, { "blake2b-wasm": 47, "nanoassert": 50 }], 50: [function(require2, module2, exports2) {
      arguments[4][48][0].apply(exports2, arguments);
    }, { "dup": 48 }], 51: [function(require2, module2, exports2) {
      (function(module3, exports3) {
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function TempCtor2() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN(number, base, endian) {
          if (BN.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
          }
        }
        if (typeof module3 === "object") {
          module3.exports = BN;
        } else {
          exports3.BN = BN;
        }
        BN.BN = BN;
        BN.wordSize = 26;
        var Buffer;
        try {
          Buffer = require2("buffer").Buffer;
        } catch (e) {
        }
        BN.isBN = function isBN(num) {
          if (num instanceof BN) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
        };
        BN.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN.prototype._init = function init(number, base, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert(base === (base | 0) && base >= 2 && base <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
          }
          if (base === 16) {
            this._parseHex(number, start);
          } else {
            this._parseBase(number, base, start);
          }
          if (number[0] === "-") {
            this.negative = 1;
          }
          this._strip();
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN.prototype._initNumber = function _initNumber(number, base, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [number & 67108863, number / 67108864 & 67108863];
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            this.words = [number & 67108863, number / 67108864 & 67108863, 1];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN.prototype._initArray = function _initArray(number, base, endian) {
          assert(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          if (endian === "be") {
            for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
              w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number.length; i += 3) {
              w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this._strip();
        };
        function parseHex(str, start, end) {
          var r = 0;
          var len = Math.min(str.length, end);
          var z = 0;
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r <<= 4;
            var b;
            if (c >= 49 && c <= 54) {
              b = c - 49 + 10;
            } else if (c >= 17 && c <= 22) {
              b = c - 17 + 10;
            } else {
              b = c;
            }
            r |= b;
            z |= b;
          }
          assert(!(z & 240), "Invalid character in " + str);
          return r;
        }
        BN.prototype._parseHex = function _parseHex(number, start) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          for (i = number.length - 6, j = 0; i >= start; i -= 6) {
            w = parseHex(number, i, i + 6);
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] |= w >>> 26 - off & 4194303;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
          if (i + 6 !== start) {
            w = parseHex(number, start, i + 6);
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] |= w >>> 26 - off & 4194303;
          }
          this._strip();
        };
        function parseBase(str, start, end, mul) {
          var r = 0;
          var b = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              b = c - 49 + 10;
            } else if (c >= 17) {
              b = c - 17 + 10;
            } else {
              b = c;
            }
            assert(c >= 0 && b < mul, "Invalid character");
            r += b;
          }
          return r;
        }
        BN.prototype._parseBase = function _parseBase(number, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for (i = 0; i < mod; i++) {
              pow *= base;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
        };
        BN.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        function move(dest, src) {
          dest.words = src.words;
          dest.length = src.length;
          dest.negative = src.negative;
          dest.red = src.red;
        }
        BN.prototype._move = function _move(dest) {
          move(dest, this);
        };
        BN.prototype.clone = function clone() {
          var r = new BN(null);
          this.copy(r);
          return r;
        };
        BN.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN.prototype._strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
          try {
            BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
          } catch (e) {
            BN.prototype.inspect = inspect;
          }
        } else {
          BN.prototype.inspect = inspect;
        }
        function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"];
        var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
        var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        BN.prototype.toString = function toString(base, padding) {
          base = base || 10;
          padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off | carry) & 16777215).toString(16);
              carry = w >>> 24 - off & 16777215;
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
              off += 2;
              if (off >= 26) {
                off -= 26;
                i--;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modrn(groupBase).toString(base);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN.prototype.toJSON = function toJSON() {
          return this.toString(16, 2);
        };
        if (Buffer) {
          BN.prototype.toBuffer = function toBuffer(endian, length) {
            return this.toArrayLike(Buffer, endian, length);
          };
        }
        BN.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        var allocate = function allocate2(ArrayType, size) {
          if (ArrayType.allocUnsafe) {
            return ArrayType.allocUnsafe(size);
          }
          return new ArrayType(size);
        };
        BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          this._strip();
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert(byteLength <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          var res = allocate(ArrayType, reqLength);
          var postfix = endian === "le" ? "LE" : "BE";
          this["_toArrayLike" + postfix](res, byteLength);
          return res;
        };
        BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
          var position = 0;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position++] = word & 255;
            if (position < res.length) {
              res[position++] = word >> 8 & 255;
            }
            if (position < res.length) {
              res[position++] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position < res.length) {
                res[position++] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position < res.length) {
            res[position++] = carry;
            while (position < res.length) {
              res[position++] = 0;
            }
          }
        };
        BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
          var position = res.length - 1;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position--] = word & 255;
            if (position >= 0) {
              res[position--] = word >> 8 & 255;
            }
            if (position >= 0) {
              res[position--] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position >= 0) {
                res[position--] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position >= 0) {
            res[position--] = carry;
            while (position >= 0) {
              res[position--] = 0;
            }
          }
        };
        if (Math.clz32) {
          BN.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN.prototype._countBits = function _countBits(w) {
            var t = w;
            var r = 0;
            if (t >= 4096) {
              r += 13;
              t >>>= 13;
            }
            if (t >= 64) {
              r += 7;
              t >>>= 7;
            }
            if (t >= 8) {
              r += 4;
              t >>>= 4;
            }
            if (t >= 2) {
              r += 2;
              t >>>= 2;
            }
            return r + t;
          };
        }
        BN.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0)
            return 26;
          var t = w;
          var r = 0;
          if ((t & 8191) === 0) {
            r += 13;
            t >>>= 13;
          }
          if ((t & 127) === 0) {
            r += 7;
            t >>>= 7;
          }
          if ((t & 15) === 0) {
            r += 4;
            t >>>= 4;
          }
          if ((t & 3) === 0) {
            r += 2;
            t >>>= 2;
          }
          if ((t & 1) === 0) {
            r++;
          }
          return r;
        };
        BN.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = num.words[off] >>> wbit & 1;
          }
          return w;
        }
        BN.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26)
              break;
          }
          return r;
        };
        BN.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this._strip();
        };
        BN.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this._strip();
        };
        BN.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this._strip();
        };
        BN.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this._strip();
        };
        BN.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this._strip();
        };
        BN.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this._strip();
        };
        BN.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self2.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out._strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self2.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out._strip();
        }
        function jumboMulTo(self2, num, out) {
          return bigMulTo(self2, num, out);
        }
        BN.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        BN.prototype.mul = function mul(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN.prototype.mulf = function mulf(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN.prototype.imuln = function imuln(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return isNegNum ? this.ineg() : this;
        };
        BN.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0)
            return new BN(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0)
              break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this._strip();
        };
        BN.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0)
            ;
          else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this._strip();
        };
        BN.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s)
            return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this._strip();
        };
        BN.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this._strip();
        };
        BN.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry === 0)
            return this._strip();
          assert(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this._strip();
        };
        BN.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q._strip();
          }
          a._strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN(0),
              mod: new BN(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN(this.modrn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN(this.modrn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN.prototype.modrn = function modrn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return isNegNum ? -acc : acc;
        };
        BN.prototype.modn = function modn(num) {
          return this.modrn(num);
        };
        BN.prototype.idivn = function idivn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w / num | 0;
            carry = w % num;
          }
          this._strip();
          return isNegNum ? this.ineg() : this;
        };
        BN.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN.prototype.egcd = function egcd(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN(1);
          var B = new BN(0);
          var C = new BN(0);
          var D = new BN(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) {
            }
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) {
            }
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y.iushln(g)
          };
        };
        BN.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN(1);
          var x2 = new BN(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) {
            }
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) {
            }
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b;
              b = t;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this._strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN.red = function red(num) {
          return new Red(num);
        };
        BN.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name, p) {
          this.name = name;
          this.p = new BN(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output.words[i] = input.words[i];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives");
          assert(a.red && a.red === b.red, "red works only with red numbers");
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          move(a, a.umod(this.m)._forceRed(this));
          return a;
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert(!q.isZero());
          var one = new BN(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t = this.pow(a, q);
          var m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t = a.imul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN(0)._forceRed(this);
          var t = a.mul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module2 === "undefined" || module2, void 0);
    }, { "buffer": 53 }], 52: [function(require2, module2, exports2) {
      var r;
      module2.exports = function rand(len) {
        if (!r)
          r = new Rand(null);
        return r.generate(len);
      };
      function Rand(rand) {
        this.rand = rand;
      }
      module2.exports.Rand = Rand;
      Rand.prototype.generate = function generate(len) {
        return this._rand(len);
      };
      Rand.prototype._rand = function _rand(n) {
        if (this.rand.getBytes)
          return this.rand.getBytes(n);
        var res = new Uint8Array(n);
        for (var i = 0; i < res.length; i++) {
          res[i] = this.rand.getByte();
        }
        return res;
      };
      if (typeof self === "object") {
        if (self.crypto && self.crypto.getRandomValues) {
          Rand.prototype._rand = function _rand(n) {
            var arr = new Uint8Array(n);
            self.crypto.getRandomValues(arr);
            return arr;
          };
        } else if (self.msCrypto && self.msCrypto.getRandomValues) {
          Rand.prototype._rand = function _rand(n) {
            var arr = new Uint8Array(n);
            self.msCrypto.getRandomValues(arr);
            return arr;
          };
        } else if (typeof window === "object") {
          Rand.prototype._rand = function() {
            throw new Error("Not implemented yet");
          };
        }
      } else {
        try {
          var crypto = require2("crypto");
          if (typeof crypto.randomBytes !== "function")
            throw new Error("Not supported");
          Rand.prototype._rand = function _rand(n) {
            return crypto.randomBytes(n);
          };
        } catch (e) {
        }
      }
    }, { "crypto": 53 }], 53: [function(require2, module2, exports2) {
    }, {}], 54: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      function asUInt32Array(buf) {
        if (!Buffer.isBuffer(buf))
          buf = Buffer.from(buf);
        var len = buf.length / 4 | 0;
        var out = new Array(len);
        for (var i = 0; i < len; i++) {
          out[i] = buf.readUInt32BE(i * 4);
        }
        return out;
      }
      function scrubVec(v) {
        for (var i = 0; i < v.length; v++) {
          v[i] = 0;
        }
      }
      function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
        var SUB_MIX0 = SUB_MIX[0];
        var SUB_MIX1 = SUB_MIX[1];
        var SUB_MIX2 = SUB_MIX[2];
        var SUB_MIX3 = SUB_MIX[3];
        var s0 = M[0] ^ keySchedule[0];
        var s1 = M[1] ^ keySchedule[1];
        var s2 = M[2] ^ keySchedule[2];
        var s3 = M[3] ^ keySchedule[3];
        var t0, t1, t2, t3;
        var ksRow = 4;
        for (var round = 1; round < nRounds; round++) {
          t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 255] ^ SUB_MIX2[s2 >>> 8 & 255] ^ SUB_MIX3[s3 & 255] ^ keySchedule[ksRow++];
          t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 255] ^ SUB_MIX2[s3 >>> 8 & 255] ^ SUB_MIX3[s0 & 255] ^ keySchedule[ksRow++];
          t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 255] ^ SUB_MIX2[s0 >>> 8 & 255] ^ SUB_MIX3[s1 & 255] ^ keySchedule[ksRow++];
          t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 255] ^ SUB_MIX2[s1 >>> 8 & 255] ^ SUB_MIX3[s2 & 255] ^ keySchedule[ksRow++];
          s0 = t0;
          s1 = t1;
          s2 = t2;
          s3 = t3;
        }
        t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow++];
        t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow++];
        t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow++];
        t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow++];
        t0 = t0 >>> 0;
        t1 = t1 >>> 0;
        t2 = t2 >>> 0;
        t3 = t3 >>> 0;
        return [t0, t1, t2, t3];
      }
      var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      var G = function() {
        var d = new Array(256);
        for (var j = 0; j < 256; j++) {
          if (j < 128) {
            d[j] = j << 1;
          } else {
            d[j] = j << 1 ^ 283;
          }
        }
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX = [[], [], [], []];
        var INV_SUB_MIX = [[], [], [], []];
        var x = 0;
        var xi = 0;
        for (var i = 0; i < 256; ++i) {
          var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
          sx = sx >>> 8 ^ sx & 255 ^ 99;
          SBOX[x] = sx;
          INV_SBOX[sx] = x;
          var x2 = d[x];
          var x4 = d[x2];
          var x8 = d[x4];
          var t = d[sx] * 257 ^ sx * 16843008;
          SUB_MIX[0][x] = t << 24 | t >>> 8;
          SUB_MIX[1][x] = t << 16 | t >>> 16;
          SUB_MIX[2][x] = t << 8 | t >>> 24;
          SUB_MIX[3][x] = t;
          t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
          INV_SUB_MIX[0][sx] = t << 24 | t >>> 8;
          INV_SUB_MIX[1][sx] = t << 16 | t >>> 16;
          INV_SUB_MIX[2][sx] = t << 8 | t >>> 24;
          INV_SUB_MIX[3][sx] = t;
          if (x === 0) {
            x = xi = 1;
          } else {
            x = x2 ^ d[d[d[x8 ^ x2]]];
            xi ^= d[d[xi]];
          }
        }
        return {
          SBOX,
          INV_SBOX,
          SUB_MIX,
          INV_SUB_MIX
        };
      }();
      function AES(key) {
        this._key = asUInt32Array(key);
        this._reset();
      }
      AES.blockSize = 4 * 4;
      AES.keySize = 256 / 8;
      AES.prototype.blockSize = AES.blockSize;
      AES.prototype.keySize = AES.keySize;
      AES.prototype._reset = function() {
        var keyWords = this._key;
        var keySize = keyWords.length;
        var nRounds = keySize + 6;
        var ksRows = (nRounds + 1) * 4;
        var keySchedule = [];
        for (var k = 0; k < keySize; k++) {
          keySchedule[k] = keyWords[k];
        }
        for (k = keySize; k < ksRows; k++) {
          var t = keySchedule[k - 1];
          if (k % keySize === 0) {
            t = t << 8 | t >>> 24;
            t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 | G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255];
            t ^= RCON[k / keySize | 0] << 24;
          } else if (keySize > 6 && k % keySize === 4) {
            t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 | G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255];
          }
          keySchedule[k] = keySchedule[k - keySize] ^ t;
        }
        var invKeySchedule = [];
        for (var ik = 0; ik < ksRows; ik++) {
          var ksR = ksRows - ik;
          var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];
          if (ik < 4 || ksR <= 4) {
            invKeySchedule[ik] = tt;
          } else {
            invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 255]];
          }
        }
        this._nRounds = nRounds;
        this._keySchedule = keySchedule;
        this._invKeySchedule = invKeySchedule;
      };
      AES.prototype.encryptBlockRaw = function(M) {
        M = asUInt32Array(M);
        return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
      };
      AES.prototype.encryptBlock = function(M) {
        var out = this.encryptBlockRaw(M);
        var buf = Buffer.allocUnsafe(16);
        buf.writeUInt32BE(out[0], 0);
        buf.writeUInt32BE(out[1], 4);
        buf.writeUInt32BE(out[2], 8);
        buf.writeUInt32BE(out[3], 12);
        return buf;
      };
      AES.prototype.decryptBlock = function(M) {
        M = asUInt32Array(M);
        var m1 = M[1];
        M[1] = M[3];
        M[3] = m1;
        var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
        var buf = Buffer.allocUnsafe(16);
        buf.writeUInt32BE(out[0], 0);
        buf.writeUInt32BE(out[3], 4);
        buf.writeUInt32BE(out[2], 8);
        buf.writeUInt32BE(out[1], 12);
        return buf;
      };
      AES.prototype.scrub = function() {
        scrubVec(this._keySchedule);
        scrubVec(this._invKeySchedule);
        scrubVec(this._key);
      };
      module2.exports.AES = AES;
    }, { "safe-buffer": 417 }], 55: [function(require2, module2, exports2) {
      var aes = require2("./aes");
      var Buffer = require2("safe-buffer").Buffer;
      var Transform = require2("cipher-base");
      var inherits = require2("inherits");
      var GHASH = require2("./ghash");
      var xor = require2("buffer-xor");
      var incr32 = require2("./incr32");
      function xorTest(a, b) {
        var out = 0;
        if (a.length !== b.length)
          out++;
        var len = Math.min(a.length, b.length);
        for (var i = 0; i < len; ++i) {
          out += a[i] ^ b[i];
        }
        return out;
      }
      function calcIv(self2, iv, ck) {
        if (iv.length === 12) {
          self2._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])]);
          return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])]);
        }
        var ghash = new GHASH(ck);
        var len = iv.length;
        var toPad = len % 16;
        ghash.update(iv);
        if (toPad) {
          toPad = 16 - toPad;
          ghash.update(Buffer.alloc(toPad, 0));
        }
        ghash.update(Buffer.alloc(8, 0));
        var ivBits = len * 8;
        var tail = Buffer.alloc(8);
        tail.writeUIntBE(ivBits, 0, 8);
        ghash.update(tail);
        self2._finID = ghash.state;
        var out = Buffer.from(self2._finID);
        incr32(out);
        return out;
      }
      function StreamCipher(mode, key, iv, decrypt) {
        Transform.call(this);
        var h = Buffer.alloc(4, 0);
        this._cipher = new aes.AES(key);
        var ck = this._cipher.encryptBlock(h);
        this._ghash = new GHASH(ck);
        iv = calcIv(this, iv, ck);
        this._prev = Buffer.from(iv);
        this._cache = Buffer.allocUnsafe(0);
        this._secCache = Buffer.allocUnsafe(0);
        this._decrypt = decrypt;
        this._alen = 0;
        this._len = 0;
        this._mode = mode;
        this._authTag = null;
        this._called = false;
      }
      inherits(StreamCipher, Transform);
      StreamCipher.prototype._update = function(chunk) {
        if (!this._called && this._alen) {
          var rump = 16 - this._alen % 16;
          if (rump < 16) {
            rump = Buffer.alloc(rump, 0);
            this._ghash.update(rump);
          }
        }
        this._called = true;
        var out = this._mode.encrypt(this, chunk);
        if (this._decrypt) {
          this._ghash.update(chunk);
        } else {
          this._ghash.update(out);
        }
        this._len += chunk.length;
        return out;
      };
      StreamCipher.prototype._final = function() {
        if (this._decrypt && !this._authTag)
          throw new Error("Unsupported state or unable to authenticate data");
        var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
        if (this._decrypt && xorTest(tag, this._authTag))
          throw new Error("Unsupported state or unable to authenticate data");
        this._authTag = tag;
        this._cipher.scrub();
      };
      StreamCipher.prototype.getAuthTag = function getAuthTag() {
        if (this._decrypt || !Buffer.isBuffer(this._authTag))
          throw new Error("Attempting to get auth tag in unsupported state");
        return this._authTag;
      };
      StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
        if (!this._decrypt)
          throw new Error("Attempting to set auth tag in unsupported state");
        this._authTag = tag;
      };
      StreamCipher.prototype.setAAD = function setAAD(buf) {
        if (this._called)
          throw new Error("Attempting to set AAD in unsupported state");
        this._ghash.update(buf);
        this._alen += buf.length;
      };
      module2.exports = StreamCipher;
    }, { "./aes": 54, "./ghash": 59, "./incr32": 60, "buffer-xor": 87, "cipher-base": 92, "inherits": 256, "safe-buffer": 417 }], 56: [function(require2, module2, exports2) {
      var ciphers = require2("./encrypter");
      var deciphers = require2("./decrypter");
      var modes = require2("./modes/list.json");
      function getCiphers() {
        return Object.keys(modes);
      }
      exports2.createCipher = exports2.Cipher = ciphers.createCipher;
      exports2.createCipheriv = exports2.Cipheriv = ciphers.createCipheriv;
      exports2.createDecipher = exports2.Decipher = deciphers.createDecipher;
      exports2.createDecipheriv = exports2.Decipheriv = deciphers.createDecipheriv;
      exports2.listCiphers = exports2.getCiphers = getCiphers;
    }, { "./decrypter": 57, "./encrypter": 58, "./modes/list.json": 68 }], 57: [function(require2, module2, exports2) {
      var AuthCipher = require2("./authCipher");
      var Buffer = require2("safe-buffer").Buffer;
      var MODES = require2("./modes");
      var StreamCipher = require2("./streamCipher");
      var Transform = require2("cipher-base");
      var aes = require2("./aes");
      var ebtk = require2("evp_bytestokey");
      var inherits = require2("inherits");
      function Decipher(mode, key, iv) {
        Transform.call(this);
        this._cache = new Splitter();
        this._last = void 0;
        this._cipher = new aes.AES(key);
        this._prev = Buffer.from(iv);
        this._mode = mode;
        this._autopadding = true;
      }
      inherits(Decipher, Transform);
      Decipher.prototype._update = function(data) {
        this._cache.add(data);
        var chunk;
        var thing;
        var out = [];
        while (chunk = this._cache.get(this._autopadding)) {
          thing = this._mode.decrypt(this, chunk);
          out.push(thing);
        }
        return Buffer.concat(out);
      };
      Decipher.prototype._final = function() {
        var chunk = this._cache.flush();
        if (this._autopadding) {
          return unpad(this._mode.decrypt(this, chunk));
        } else if (chunk) {
          throw new Error("data not multiple of block length");
        }
      };
      Decipher.prototype.setAutoPadding = function(setTo) {
        this._autopadding = !!setTo;
        return this;
      };
      function Splitter() {
        this.cache = Buffer.allocUnsafe(0);
      }
      Splitter.prototype.add = function(data) {
        this.cache = Buffer.concat([this.cache, data]);
      };
      Splitter.prototype.get = function(autoPadding) {
        var out;
        if (autoPadding) {
          if (this.cache.length > 16) {
            out = this.cache.slice(0, 16);
            this.cache = this.cache.slice(16);
            return out;
          }
        } else {
          if (this.cache.length >= 16) {
            out = this.cache.slice(0, 16);
            this.cache = this.cache.slice(16);
            return out;
          }
        }
        return null;
      };
      Splitter.prototype.flush = function() {
        if (this.cache.length)
          return this.cache;
      };
      function unpad(last) {
        var padded = last[15];
        if (padded < 1 || padded > 16) {
          throw new Error("unable to decrypt data");
        }
        var i = -1;
        while (++i < padded) {
          if (last[i + (16 - padded)] !== padded) {
            throw new Error("unable to decrypt data");
          }
        }
        if (padded === 16)
          return;
        return last.slice(0, 16 - padded);
      }
      function createDecipheriv(suite, password, iv) {
        var config = MODES[suite.toLowerCase()];
        if (!config)
          throw new TypeError("invalid suite type");
        if (typeof iv === "string")
          iv = Buffer.from(iv);
        if (config.mode !== "GCM" && iv.length !== config.iv)
          throw new TypeError("invalid iv length " + iv.length);
        if (typeof password === "string")
          password = Buffer.from(password);
        if (password.length !== config.key / 8)
          throw new TypeError("invalid key length " + password.length);
        if (config.type === "stream") {
          return new StreamCipher(config.module, password, iv, true);
        } else if (config.type === "auth") {
          return new AuthCipher(config.module, password, iv, true);
        }
        return new Decipher(config.module, password, iv);
      }
      function createDecipher(suite, password) {
        var config = MODES[suite.toLowerCase()];
        if (!config)
          throw new TypeError("invalid suite type");
        var keys = ebtk(password, false, config.key, config.iv);
        return createDecipheriv(suite, keys.key, keys.iv);
      }
      exports2.createDecipher = createDecipher;
      exports2.createDecipheriv = createDecipheriv;
    }, { "./aes": 54, "./authCipher": 55, "./modes": 67, "./streamCipher": 70, "cipher-base": 92, "evp_bytestokey": 194, "inherits": 256, "safe-buffer": 417 }], 58: [function(require2, module2, exports2) {
      var MODES = require2("./modes");
      var AuthCipher = require2("./authCipher");
      var Buffer = require2("safe-buffer").Buffer;
      var StreamCipher = require2("./streamCipher");
      var Transform = require2("cipher-base");
      var aes = require2("./aes");
      var ebtk = require2("evp_bytestokey");
      var inherits = require2("inherits");
      function Cipher(mode, key, iv) {
        Transform.call(this);
        this._cache = new Splitter();
        this._cipher = new aes.AES(key);
        this._prev = Buffer.from(iv);
        this._mode = mode;
        this._autopadding = true;
      }
      inherits(Cipher, Transform);
      Cipher.prototype._update = function(data) {
        this._cache.add(data);
        var chunk;
        var thing;
        var out = [];
        while (chunk = this._cache.get()) {
          thing = this._mode.encrypt(this, chunk);
          out.push(thing);
        }
        return Buffer.concat(out);
      };
      var PADDING = Buffer.alloc(16, 16);
      Cipher.prototype._final = function() {
        var chunk = this._cache.flush();
        if (this._autopadding) {
          chunk = this._mode.encrypt(this, chunk);
          this._cipher.scrub();
          return chunk;
        }
        if (!chunk.equals(PADDING)) {
          this._cipher.scrub();
          throw new Error("data not multiple of block length");
        }
      };
      Cipher.prototype.setAutoPadding = function(setTo) {
        this._autopadding = !!setTo;
        return this;
      };
      function Splitter() {
        this.cache = Buffer.allocUnsafe(0);
      }
      Splitter.prototype.add = function(data) {
        this.cache = Buffer.concat([this.cache, data]);
      };
      Splitter.prototype.get = function() {
        if (this.cache.length > 15) {
          var out = this.cache.slice(0, 16);
          this.cache = this.cache.slice(16);
          return out;
        }
        return null;
      };
      Splitter.prototype.flush = function() {
        var len = 16 - this.cache.length;
        var padBuff = Buffer.allocUnsafe(len);
        var i = -1;
        while (++i < len) {
          padBuff.writeUInt8(len, i);
        }
        return Buffer.concat([this.cache, padBuff]);
      };
      function createCipheriv(suite, password, iv) {
        var config = MODES[suite.toLowerCase()];
        if (!config)
          throw new TypeError("invalid suite type");
        if (typeof password === "string")
          password = Buffer.from(password);
        if (password.length !== config.key / 8)
          throw new TypeError("invalid key length " + password.length);
        if (typeof iv === "string")
          iv = Buffer.from(iv);
        if (config.mode !== "GCM" && iv.length !== config.iv)
          throw new TypeError("invalid iv length " + iv.length);
        if (config.type === "stream") {
          return new StreamCipher(config.module, password, iv);
        } else if (config.type === "auth") {
          return new AuthCipher(config.module, password, iv);
        }
        return new Cipher(config.module, password, iv);
      }
      function createCipher(suite, password) {
        var config = MODES[suite.toLowerCase()];
        if (!config)
          throw new TypeError("invalid suite type");
        var keys = ebtk(password, false, config.key, config.iv);
        return createCipheriv(suite, keys.key, keys.iv);
      }
      exports2.createCipheriv = createCipheriv;
      exports2.createCipher = createCipher;
    }, { "./aes": 54, "./authCipher": 55, "./modes": 67, "./streamCipher": 70, "cipher-base": 92, "evp_bytestokey": 194, "inherits": 256, "safe-buffer": 417 }], 59: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      var ZEROES = Buffer.alloc(16, 0);
      function toArray(buf) {
        return [buf.readUInt32BE(0), buf.readUInt32BE(4), buf.readUInt32BE(8), buf.readUInt32BE(12)];
      }
      function fromArray(out) {
        var buf = Buffer.allocUnsafe(16);
        buf.writeUInt32BE(out[0] >>> 0, 0);
        buf.writeUInt32BE(out[1] >>> 0, 4);
        buf.writeUInt32BE(out[2] >>> 0, 8);
        buf.writeUInt32BE(out[3] >>> 0, 12);
        return buf;
      }
      function GHASH(key) {
        this.h = key;
        this.state = Buffer.alloc(16, 0);
        this.cache = Buffer.allocUnsafe(0);
      }
      GHASH.prototype.ghash = function(block) {
        var i = -1;
        while (++i < block.length) {
          this.state[i] ^= block[i];
        }
        this._multiply();
      };
      GHASH.prototype._multiply = function() {
        var Vi = toArray(this.h);
        var Zi = [0, 0, 0, 0];
        var j, xi, lsbVi;
        var i = -1;
        while (++i < 128) {
          xi = (this.state[~~(i / 8)] & 1 << 7 - i % 8) !== 0;
          if (xi) {
            Zi[0] ^= Vi[0];
            Zi[1] ^= Vi[1];
            Zi[2] ^= Vi[2];
            Zi[3] ^= Vi[3];
          }
          lsbVi = (Vi[3] & 1) !== 0;
          for (j = 3; j > 0; j--) {
            Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;
          }
          Vi[0] = Vi[0] >>> 1;
          if (lsbVi) {
            Vi[0] = Vi[0] ^ 225 << 24;
          }
        }
        this.state = fromArray(Zi);
      };
      GHASH.prototype.update = function(buf) {
        this.cache = Buffer.concat([this.cache, buf]);
        var chunk;
        while (this.cache.length >= 16) {
          chunk = this.cache.slice(0, 16);
          this.cache = this.cache.slice(16);
          this.ghash(chunk);
        }
      };
      GHASH.prototype.final = function(abl, bl) {
        if (this.cache.length) {
          this.ghash(Buffer.concat([this.cache, ZEROES], 16));
        }
        this.ghash(fromArray([0, abl, 0, bl]));
        return this.state;
      };
      module2.exports = GHASH;
    }, { "safe-buffer": 417 }], 60: [function(require2, module2, exports2) {
      function incr32(iv) {
        var len = iv.length;
        var item;
        while (len--) {
          item = iv.readUInt8(len);
          if (item === 255) {
            iv.writeUInt8(0, len);
          } else {
            item++;
            iv.writeUInt8(item, len);
            break;
          }
        }
      }
      module2.exports = incr32;
    }, {}], 61: [function(require2, module2, exports2) {
      var xor = require2("buffer-xor");
      exports2.encrypt = function(self2, block) {
        var data = xor(block, self2._prev);
        self2._prev = self2._cipher.encryptBlock(data);
        return self2._prev;
      };
      exports2.decrypt = function(self2, block) {
        var pad = self2._prev;
        self2._prev = block;
        var out = self2._cipher.decryptBlock(block);
        return xor(out, pad);
      };
    }, { "buffer-xor": 87 }], 62: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      var xor = require2("buffer-xor");
      function encryptStart(self2, data, decrypt) {
        var len = data.length;
        var out = xor(data, self2._cache);
        self2._cache = self2._cache.slice(len);
        self2._prev = Buffer.concat([self2._prev, decrypt ? data : out]);
        return out;
      }
      exports2.encrypt = function(self2, data, decrypt) {
        var out = Buffer.allocUnsafe(0);
        var len;
        while (data.length) {
          if (self2._cache.length === 0) {
            self2._cache = self2._cipher.encryptBlock(self2._prev);
            self2._prev = Buffer.allocUnsafe(0);
          }
          if (self2._cache.length <= data.length) {
            len = self2._cache.length;
            out = Buffer.concat([out, encryptStart(self2, data.slice(0, len), decrypt)]);
            data = data.slice(len);
          } else {
            out = Buffer.concat([out, encryptStart(self2, data, decrypt)]);
            break;
          }
        }
        return out;
      };
    }, { "buffer-xor": 87, "safe-buffer": 417 }], 63: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      function encryptByte(self2, byteParam, decrypt) {
        var pad;
        var i = -1;
        var len = 8;
        var out = 0;
        var bit, value;
        while (++i < len) {
          pad = self2._cipher.encryptBlock(self2._prev);
          bit = byteParam & 1 << 7 - i ? 128 : 0;
          value = pad[0] ^ bit;
          out += (value & 128) >> i % 8;
          self2._prev = shiftIn(self2._prev, decrypt ? bit : value);
        }
        return out;
      }
      function shiftIn(buffer, value) {
        var len = buffer.length;
        var i = -1;
        var out = Buffer.allocUnsafe(buffer.length);
        buffer = Buffer.concat([buffer, Buffer.from([value])]);
        while (++i < len) {
          out[i] = buffer[i] << 1 | buffer[i + 1] >> 7;
        }
        return out;
      }
      exports2.encrypt = function(self2, chunk, decrypt) {
        var len = chunk.length;
        var out = Buffer.allocUnsafe(len);
        var i = -1;
        while (++i < len) {
          out[i] = encryptByte(self2, chunk[i], decrypt);
        }
        return out;
      };
    }, { "safe-buffer": 417 }], 64: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      function encryptByte(self2, byteParam, decrypt) {
        var pad = self2._cipher.encryptBlock(self2._prev);
        var out = pad[0] ^ byteParam;
        self2._prev = Buffer.concat([self2._prev.slice(1), Buffer.from([decrypt ? byteParam : out])]);
        return out;
      }
      exports2.encrypt = function(self2, chunk, decrypt) {
        var len = chunk.length;
        var out = Buffer.allocUnsafe(len);
        var i = -1;
        while (++i < len) {
          out[i] = encryptByte(self2, chunk[i], decrypt);
        }
        return out;
      };
    }, { "safe-buffer": 417 }], 65: [function(require2, module2, exports2) {
      var xor = require2("buffer-xor");
      var Buffer = require2("safe-buffer").Buffer;
      var incr32 = require2("../incr32");
      function getBlock(self2) {
        var out = self2._cipher.encryptBlockRaw(self2._prev);
        incr32(self2._prev);
        return out;
      }
      var blockSize = 16;
      exports2.encrypt = function(self2, chunk) {
        var chunkNum = Math.ceil(chunk.length / blockSize);
        var start = self2._cache.length;
        self2._cache = Buffer.concat([self2._cache, Buffer.allocUnsafe(chunkNum * blockSize)]);
        for (var i = 0; i < chunkNum; i++) {
          var out = getBlock(self2);
          var offset = start + i * blockSize;
          self2._cache.writeUInt32BE(out[0], offset + 0);
          self2._cache.writeUInt32BE(out[1], offset + 4);
          self2._cache.writeUInt32BE(out[2], offset + 8);
          self2._cache.writeUInt32BE(out[3], offset + 12);
        }
        var pad = self2._cache.slice(0, chunk.length);
        self2._cache = self2._cache.slice(chunk.length);
        return xor(chunk, pad);
      };
    }, { "../incr32": 60, "buffer-xor": 87, "safe-buffer": 417 }], 66: [function(require2, module2, exports2) {
      exports2.encrypt = function(self2, block) {
        return self2._cipher.encryptBlock(block);
      };
      exports2.decrypt = function(self2, block) {
        return self2._cipher.decryptBlock(block);
      };
    }, {}], 67: [function(require2, module2, exports2) {
      var modeModules = {
        ECB: require2("./ecb"),
        CBC: require2("./cbc"),
        CFB: require2("./cfb"),
        CFB8: require2("./cfb8"),
        CFB1: require2("./cfb1"),
        OFB: require2("./ofb"),
        CTR: require2("./ctr"),
        GCM: require2("./ctr")
      };
      var modes = require2("./list.json");
      for (var key in modes) {
        modes[key].module = modeModules[modes[key].mode];
      }
      module2.exports = modes;
    }, { "./cbc": 61, "./cfb": 62, "./cfb1": 63, "./cfb8": 64, "./ctr": 65, "./ecb": 66, "./list.json": 68, "./ofb": 69 }], 68: [function(require2, module2, exports2) {
      module2.exports = {
        "aes-128-ecb": {
          "cipher": "AES",
          "key": 128,
          "iv": 0,
          "mode": "ECB",
          "type": "block"
        },
        "aes-192-ecb": {
          "cipher": "AES",
          "key": 192,
          "iv": 0,
          "mode": "ECB",
          "type": "block"
        },
        "aes-256-ecb": {
          "cipher": "AES",
          "key": 256,
          "iv": 0,
          "mode": "ECB",
          "type": "block"
        },
        "aes-128-cbc": {
          "cipher": "AES",
          "key": 128,
          "iv": 16,
          "mode": "CBC",
          "type": "block"
        },
        "aes-192-cbc": {
          "cipher": "AES",
          "key": 192,
          "iv": 16,
          "mode": "CBC",
          "type": "block"
        },
        "aes-256-cbc": {
          "cipher": "AES",
          "key": 256,
          "iv": 16,
          "mode": "CBC",
          "type": "block"
        },
        "aes128": {
          "cipher": "AES",
          "key": 128,
          "iv": 16,
          "mode": "CBC",
          "type": "block"
        },
        "aes192": {
          "cipher": "AES",
          "key": 192,
          "iv": 16,
          "mode": "CBC",
          "type": "block"
        },
        "aes256": {
          "cipher": "AES",
          "key": 256,
          "iv": 16,
          "mode": "CBC",
          "type": "block"
        },
        "aes-128-cfb": {
          "cipher": "AES",
          "key": 128,
          "iv": 16,
          "mode": "CFB",
          "type": "stream"
        },
        "aes-192-cfb": {
          "cipher": "AES",
          "key": 192,
          "iv": 16,
          "mode": "CFB",
          "type": "stream"
        },
        "aes-256-cfb": {
          "cipher": "AES",
          "key": 256,
          "iv": 16,
          "mode": "CFB",
          "type": "stream"
        },
        "aes-128-cfb8": {
          "cipher": "AES",
          "key": 128,
          "iv": 16,
          "mode": "CFB8",
          "type": "stream"
        },
        "aes-192-cfb8": {
          "cipher": "AES",
          "key": 192,
          "iv": 16,
          "mode": "CFB8",
          "type": "stream"
        },
        "aes-256-cfb8": {
          "cipher": "AES",
          "key": 256,
          "iv": 16,
          "mode": "CFB8",
          "type": "stream"
        },
        "aes-128-cfb1": {
          "cipher": "AES",
          "key": 128,
          "iv": 16,
          "mode": "CFB1",
          "type": "stream"
        },
        "aes-192-cfb1": {
          "cipher": "AES",
          "key": 192,
          "iv": 16,
          "mode": "CFB1",
          "type": "stream"
        },
        "aes-256-cfb1": {
          "cipher": "AES",
          "key": 256,
          "iv": 16,
          "mode": "CFB1",
          "type": "stream"
        },
        "aes-128-ofb": {
          "cipher": "AES",
          "key": 128,
          "iv": 16,
          "mode": "OFB",
          "type": "stream"
        },
        "aes-192-ofb": {
          "cipher": "AES",
          "key": 192,
          "iv": 16,
          "mode": "OFB",
          "type": "stream"
        },
        "aes-256-ofb": {
          "cipher": "AES",
          "key": 256,
          "iv": 16,
          "mode": "OFB",
          "type": "stream"
        },
        "aes-128-ctr": {
          "cipher": "AES",
          "key": 128,
          "iv": 16,
          "mode": "CTR",
          "type": "stream"
        },
        "aes-192-ctr": {
          "cipher": "AES",
          "key": 192,
          "iv": 16,
          "mode": "CTR",
          "type": "stream"
        },
        "aes-256-ctr": {
          "cipher": "AES",
          "key": 256,
          "iv": 16,
          "mode": "CTR",
          "type": "stream"
        },
        "aes-128-gcm": {
          "cipher": "AES",
          "key": 128,
          "iv": 12,
          "mode": "GCM",
          "type": "auth"
        },
        "aes-192-gcm": {
          "cipher": "AES",
          "key": 192,
          "iv": 12,
          "mode": "GCM",
          "type": "auth"
        },
        "aes-256-gcm": {
          "cipher": "AES",
          "key": 256,
          "iv": 12,
          "mode": "GCM",
          "type": "auth"
        }
      };
    }, {}], 69: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var xor = require2("buffer-xor");
          function getBlock(self2) {
            self2._prev = self2._cipher.encryptBlock(self2._prev);
            return self2._prev;
          }
          exports2.encrypt = function(self2, chunk) {
            while (self2._cache.length < chunk.length) {
              self2._cache = Buffer.concat([self2._cache, getBlock(self2)]);
            }
            var pad = self2._cache.slice(0, chunk.length);
            self2._cache = self2._cache.slice(chunk.length);
            return xor(chunk, pad);
          };
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82, "buffer-xor": 87 }], 70: [function(require2, module2, exports2) {
      var aes = require2("./aes");
      var Buffer = require2("safe-buffer").Buffer;
      var Transform = require2("cipher-base");
      var inherits = require2("inherits");
      function StreamCipher(mode, key, iv, decrypt) {
        Transform.call(this);
        this._cipher = new aes.AES(key);
        this._prev = Buffer.from(iv);
        this._cache = Buffer.allocUnsafe(0);
        this._secCache = Buffer.allocUnsafe(0);
        this._decrypt = decrypt;
        this._mode = mode;
      }
      inherits(StreamCipher, Transform);
      StreamCipher.prototype._update = function(chunk) {
        return this._mode.encrypt(this, chunk, this._decrypt);
      };
      StreamCipher.prototype._final = function() {
        this._cipher.scrub();
      };
      module2.exports = StreamCipher;
    }, { "./aes": 54, "cipher-base": 92, "inherits": 256, "safe-buffer": 417 }], 71: [function(require2, module2, exports2) {
      var DES = require2("browserify-des");
      var aes = require2("browserify-aes/browser");
      var aesModes = require2("browserify-aes/modes");
      var desModes = require2("browserify-des/modes");
      var ebtk = require2("evp_bytestokey");
      function createCipher(suite, password) {
        suite = suite.toLowerCase();
        var keyLen, ivLen;
        if (aesModes[suite]) {
          keyLen = aesModes[suite].key;
          ivLen = aesModes[suite].iv;
        } else if (desModes[suite]) {
          keyLen = desModes[suite].key * 8;
          ivLen = desModes[suite].iv;
        } else {
          throw new TypeError("invalid suite type");
        }
        var keys = ebtk(password, false, keyLen, ivLen);
        return createCipheriv(suite, keys.key, keys.iv);
      }
      function createDecipher(suite, password) {
        suite = suite.toLowerCase();
        var keyLen, ivLen;
        if (aesModes[suite]) {
          keyLen = aesModes[suite].key;
          ivLen = aesModes[suite].iv;
        } else if (desModes[suite]) {
          keyLen = desModes[suite].key * 8;
          ivLen = desModes[suite].iv;
        } else {
          throw new TypeError("invalid suite type");
        }
        var keys = ebtk(password, false, keyLen, ivLen);
        return createDecipheriv(suite, keys.key, keys.iv);
      }
      function createCipheriv(suite, key, iv) {
        suite = suite.toLowerCase();
        if (aesModes[suite])
          return aes.createCipheriv(suite, key, iv);
        if (desModes[suite])
          return new DES({
            key,
            iv,
            mode: suite
          });
        throw new TypeError("invalid suite type");
      }
      function createDecipheriv(suite, key, iv) {
        suite = suite.toLowerCase();
        if (aesModes[suite])
          return aes.createDecipheriv(suite, key, iv);
        if (desModes[suite])
          return new DES({
            key,
            iv,
            mode: suite,
            decrypt: true
          });
        throw new TypeError("invalid suite type");
      }
      function getCiphers() {
        return Object.keys(desModes).concat(aes.getCiphers());
      }
      exports2.createCipher = exports2.Cipher = createCipher;
      exports2.createCipheriv = exports2.Cipheriv = createCipheriv;
      exports2.createDecipher = exports2.Decipher = createDecipher;
      exports2.createDecipheriv = exports2.Decipheriv = createDecipheriv;
      exports2.listCiphers = exports2.getCiphers = getCiphers;
    }, { "browserify-aes/browser": 56, "browserify-aes/modes": 67, "browserify-des": 72, "browserify-des/modes": 73, "evp_bytestokey": 194 }], 72: [function(require2, module2, exports2) {
      var CipherBase = require2("cipher-base");
      var des = require2("des.js");
      var inherits = require2("inherits");
      var Buffer = require2("safe-buffer").Buffer;
      var modes = {
        "des-ede3-cbc": des.CBC.instantiate(des.EDE),
        "des-ede3": des.EDE,
        "des-ede-cbc": des.CBC.instantiate(des.EDE),
        "des-ede": des.EDE,
        "des-cbc": des.CBC.instantiate(des.DES),
        "des-ecb": des.DES
      };
      modes.des = modes["des-cbc"];
      modes.des3 = modes["des-ede3-cbc"];
      module2.exports = DES;
      inherits(DES, CipherBase);
      function DES(opts) {
        CipherBase.call(this);
        var modeName = opts.mode.toLowerCase();
        var mode = modes[modeName];
        var type;
        if (opts.decrypt) {
          type = "decrypt";
        } else {
          type = "encrypt";
        }
        var key = opts.key;
        if (!Buffer.isBuffer(key)) {
          key = Buffer.from(key);
        }
        if (modeName === "des-ede" || modeName === "des-ede-cbc") {
          key = Buffer.concat([key, key.slice(0, 8)]);
        }
        var iv = opts.iv;
        if (!Buffer.isBuffer(iv)) {
          iv = Buffer.from(iv);
        }
        this._des = mode.create({
          key,
          iv,
          type
        });
      }
      DES.prototype._update = function(data) {
        return Buffer.from(this._des.update(data));
      };
      DES.prototype._final = function() {
        return Buffer.from(this._des.final());
      };
    }, { "cipher-base": 92, "des.js": 132, "inherits": 256, "safe-buffer": 417 }], 73: [function(require2, module2, exports2) {
      exports2["des-ecb"] = {
        key: 8,
        iv: 0
      };
      exports2["des-cbc"] = exports2.des = {
        key: 8,
        iv: 8
      };
      exports2["des-ede3-cbc"] = exports2.des3 = {
        key: 24,
        iv: 8
      };
      exports2["des-ede3"] = {
        key: 24,
        iv: 0
      };
      exports2["des-ede-cbc"] = {
        key: 16,
        iv: 8
      };
      exports2["des-ede"] = {
        key: 16,
        iv: 0
      };
    }, {}], 74: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var BN = require2("bn.js");
          var randomBytes = require2("randombytes");
          function blind(priv) {
            var r = getr(priv);
            var blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();
            return {
              blinder,
              unblinder: r.invm(priv.modulus)
            };
          }
          function getr(priv) {
            var len = priv.modulus.byteLength();
            var r;
            do {
              r = new BN(randomBytes(len));
            } while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2));
            return r;
          }
          function crt(msg, priv) {
            var blinds = blind(priv);
            var len = priv.modulus.byteLength();
            var blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus);
            var c1 = blinded.toRed(BN.mont(priv.prime1));
            var c2 = blinded.toRed(BN.mont(priv.prime2));
            var qinv = priv.coefficient;
            var p = priv.prime1;
            var q = priv.prime2;
            var m1 = c1.redPow(priv.exponent1).fromRed();
            var m2 = c2.redPow(priv.exponent2).fromRed();
            var h = m1.isub(m2).imul(qinv).umod(p).imul(q);
            return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer, "be", len);
          }
          crt.getr = getr;
          module2.exports = crt;
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "bn.js": 51, "buffer": 82, "randombytes": 382 }], 75: [function(require2, module2, exports2) {
      module2.exports = require2("./browser/algorithms.json");
    }, { "./browser/algorithms.json": 76 }], 76: [function(require2, module2, exports2) {
      module2.exports = {
        "sha224WithRSAEncryption": {
          "sign": "rsa",
          "hash": "sha224",
          "id": "302d300d06096086480165030402040500041c"
        },
        "RSA-SHA224": {
          "sign": "ecdsa/rsa",
          "hash": "sha224",
          "id": "302d300d06096086480165030402040500041c"
        },
        "sha256WithRSAEncryption": {
          "sign": "rsa",
          "hash": "sha256",
          "id": "3031300d060960864801650304020105000420"
        },
        "RSA-SHA256": {
          "sign": "ecdsa/rsa",
          "hash": "sha256",
          "id": "3031300d060960864801650304020105000420"
        },
        "sha384WithRSAEncryption": {
          "sign": "rsa",
          "hash": "sha384",
          "id": "3041300d060960864801650304020205000430"
        },
        "RSA-SHA384": {
          "sign": "ecdsa/rsa",
          "hash": "sha384",
          "id": "3041300d060960864801650304020205000430"
        },
        "sha512WithRSAEncryption": {
          "sign": "rsa",
          "hash": "sha512",
          "id": "3051300d060960864801650304020305000440"
        },
        "RSA-SHA512": {
          "sign": "ecdsa/rsa",
          "hash": "sha512",
          "id": "3051300d060960864801650304020305000440"
        },
        "RSA-SHA1": {
          "sign": "rsa",
          "hash": "sha1",
          "id": "3021300906052b0e03021a05000414"
        },
        "ecdsa-with-SHA1": {
          "sign": "ecdsa",
          "hash": "sha1",
          "id": ""
        },
        "sha256": {
          "sign": "ecdsa",
          "hash": "sha256",
          "id": ""
        },
        "sha224": {
          "sign": "ecdsa",
          "hash": "sha224",
          "id": ""
        },
        "sha384": {
          "sign": "ecdsa",
          "hash": "sha384",
          "id": ""
        },
        "sha512": {
          "sign": "ecdsa",
          "hash": "sha512",
          "id": ""
        },
        "DSA-SHA": {
          "sign": "dsa",
          "hash": "sha1",
          "id": ""
        },
        "DSA-SHA1": {
          "sign": "dsa",
          "hash": "sha1",
          "id": ""
        },
        "DSA": {
          "sign": "dsa",
          "hash": "sha1",
          "id": ""
        },
        "DSA-WITH-SHA224": {
          "sign": "dsa",
          "hash": "sha224",
          "id": ""
        },
        "DSA-SHA224": {
          "sign": "dsa",
          "hash": "sha224",
          "id": ""
        },
        "DSA-WITH-SHA256": {
          "sign": "dsa",
          "hash": "sha256",
          "id": ""
        },
        "DSA-SHA256": {
          "sign": "dsa",
          "hash": "sha256",
          "id": ""
        },
        "DSA-WITH-SHA384": {
          "sign": "dsa",
          "hash": "sha384",
          "id": ""
        },
        "DSA-SHA384": {
          "sign": "dsa",
          "hash": "sha384",
          "id": ""
        },
        "DSA-WITH-SHA512": {
          "sign": "dsa",
          "hash": "sha512",
          "id": ""
        },
        "DSA-SHA512": {
          "sign": "dsa",
          "hash": "sha512",
          "id": ""
        },
        "DSA-RIPEMD160": {
          "sign": "dsa",
          "hash": "rmd160",
          "id": ""
        },
        "ripemd160WithRSA": {
          "sign": "rsa",
          "hash": "rmd160",
          "id": "3021300906052b2403020105000414"
        },
        "RSA-RIPEMD160": {
          "sign": "rsa",
          "hash": "rmd160",
          "id": "3021300906052b2403020105000414"
        },
        "md5WithRSAEncryption": {
          "sign": "rsa",
          "hash": "md5",
          "id": "3020300c06082a864886f70d020505000410"
        },
        "RSA-MD5": {
          "sign": "rsa",
          "hash": "md5",
          "id": "3020300c06082a864886f70d020505000410"
        }
      };
    }, {}], 77: [function(require2, module2, exports2) {
      module2.exports = {
        "1.3.132.0.10": "secp256k1",
        "1.3.132.0.33": "p224",
        "1.2.840.10045.3.1.1": "p192",
        "1.2.840.10045.3.1.7": "p256",
        "1.3.132.0.34": "p384",
        "1.3.132.0.35": "p521"
      };
    }, {}], 78: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      var createHash = require2("create-hash");
      var stream = require2("readable-stream");
      var inherits = require2("inherits");
      var sign = require2("./sign");
      var verify = require2("./verify");
      var algorithms = require2("./algorithms.json");
      Object.keys(algorithms).forEach(function(key) {
        algorithms[key].id = Buffer.from(algorithms[key].id, "hex");
        algorithms[key.toLowerCase()] = algorithms[key];
      });
      function Sign(algorithm) {
        stream.Writable.call(this);
        var data = algorithms[algorithm];
        if (!data)
          throw new Error("Unknown message digest");
        this._hashType = data.hash;
        this._hash = createHash(data.hash);
        this._tag = data.id;
        this._signType = data.sign;
      }
      inherits(Sign, stream.Writable);
      Sign.prototype._write = function _write(data, _, done) {
        this._hash.update(data);
        done();
      };
      Sign.prototype.update = function update(data, enc) {
        if (typeof data === "string")
          data = Buffer.from(data, enc);
        this._hash.update(data);
        return this;
      };
      Sign.prototype.sign = function signMethod(key, enc) {
        this.end();
        var hash = this._hash.digest();
        var sig = sign(hash, key, this._hashType, this._signType, this._tag);
        return enc ? sig.toString(enc) : sig;
      };
      function Verify(algorithm) {
        stream.Writable.call(this);
        var data = algorithms[algorithm];
        if (!data)
          throw new Error("Unknown message digest");
        this._hash = createHash(data.hash);
        this._tag = data.id;
        this._signType = data.sign;
      }
      inherits(Verify, stream.Writable);
      Verify.prototype._write = function _write(data, _, done) {
        this._hash.update(data);
        done();
      };
      Verify.prototype.update = function update(data, enc) {
        if (typeof data === "string")
          data = Buffer.from(data, enc);
        this._hash.update(data);
        return this;
      };
      Verify.prototype.verify = function verifyMethod(key, sig, enc) {
        if (typeof sig === "string")
          sig = Buffer.from(sig, enc);
        this.end();
        var hash = this._hash.digest();
        return verify(sig, hash, key, this._signType, this._tag);
      };
      function createSign(algorithm) {
        return new Sign(algorithm);
      }
      function createVerify(algorithm) {
        return new Verify(algorithm);
      }
      module2.exports = {
        Sign: createSign,
        Verify: createVerify,
        createSign,
        createVerify
      };
    }, { "./algorithms.json": 76, "./sign": 79, "./verify": 80, "create-hash": 113, "inherits": 256, "readable-stream": 412, "safe-buffer": 417 }], 79: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      var createHmac = require2("create-hmac");
      var crt = require2("browserify-rsa");
      var EC = require2("elliptic").ec;
      var BN = require2("bn.js");
      var parseKeys = require2("parse-asn1");
      var curves = require2("./curves.json");
      function sign(hash, key, hashType, signType, tag) {
        var priv = parseKeys(key);
        if (priv.curve) {
          if (signType !== "ecdsa" && signType !== "ecdsa/rsa")
            throw new Error("wrong private key type");
          return ecSign(hash, priv);
        } else if (priv.type === "dsa") {
          if (signType !== "dsa")
            throw new Error("wrong private key type");
          return dsaSign(hash, priv, hashType);
        } else {
          if (signType !== "rsa" && signType !== "ecdsa/rsa")
            throw new Error("wrong private key type");
        }
        hash = Buffer.concat([tag, hash]);
        var len = priv.modulus.byteLength();
        var pad = [0, 1];
        while (hash.length + pad.length + 1 < len) {
          pad.push(255);
        }
        pad.push(0);
        var i = -1;
        while (++i < hash.length) {
          pad.push(hash[i]);
        }
        var out = crt(pad, priv);
        return out;
      }
      function ecSign(hash, priv) {
        var curveId = curves[priv.curve.join(".")];
        if (!curveId)
          throw new Error("unknown curve " + priv.curve.join("."));
        var curve = new EC(curveId);
        var key = curve.keyFromPrivate(priv.privateKey);
        var out = key.sign(hash);
        return Buffer.from(out.toDER());
      }
      function dsaSign(hash, priv, algo) {
        var x = priv.params.priv_key;
        var p = priv.params.p;
        var q = priv.params.q;
        var g = priv.params.g;
        var r = new BN(0);
        var k;
        var H = bits2int(hash, q).mod(q);
        var s = false;
        var kv = getKey(x, q, hash, algo);
        while (s === false) {
          k = makeKey(q, kv, algo);
          r = makeR(g, k, p, q);
          s = k.invm(q).imul(H.add(x.mul(r))).mod(q);
          if (s.cmpn(0) === 0) {
            s = false;
            r = new BN(0);
          }
        }
        return toDER(r, s);
      }
      function toDER(r, s) {
        r = r.toArray();
        s = s.toArray();
        if (r[0] & 128)
          r = [0].concat(r);
        if (s[0] & 128)
          s = [0].concat(s);
        var total = r.length + s.length + 4;
        var res = [48, total, 2, r.length];
        res = res.concat(r, [2, s.length], s);
        return Buffer.from(res);
      }
      function getKey(x, q, hash, algo) {
        x = Buffer.from(x.toArray());
        if (x.length < q.byteLength()) {
          var zeros = Buffer.alloc(q.byteLength() - x.length);
          x = Buffer.concat([zeros, x]);
        }
        var hlen = hash.length;
        var hbits = bits2octets(hash, q);
        var v = Buffer.alloc(hlen);
        v.fill(1);
        var k = Buffer.alloc(hlen);
        k = createHmac(algo, k).update(v).update(Buffer.from([0])).update(x).update(hbits).digest();
        v = createHmac(algo, k).update(v).digest();
        k = createHmac(algo, k).update(v).update(Buffer.from([1])).update(x).update(hbits).digest();
        v = createHmac(algo, k).update(v).digest();
        return {
          k,
          v
        };
      }
      function bits2int(obits, q) {
        var bits = new BN(obits);
        var shift = (obits.length << 3) - q.bitLength();
        if (shift > 0)
          bits.ishrn(shift);
        return bits;
      }
      function bits2octets(bits, q) {
        bits = bits2int(bits, q);
        bits = bits.mod(q);
        var out = Buffer.from(bits.toArray());
        if (out.length < q.byteLength()) {
          var zeros = Buffer.alloc(q.byteLength() - out.length);
          out = Buffer.concat([zeros, out]);
        }
        return out;
      }
      function makeKey(q, kv, algo) {
        var t;
        var k;
        do {
          t = Buffer.alloc(0);
          while (t.length * 8 < q.bitLength()) {
            kv.v = createHmac(algo, kv.k).update(kv.v).digest();
            t = Buffer.concat([t, kv.v]);
          }
          k = bits2int(t, q);
          kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer.from([0])).digest();
          kv.v = createHmac(algo, kv.k).update(kv.v).digest();
        } while (k.cmp(q) !== -1);
        return k;
      }
      function makeR(g, k, p, q) {
        return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q);
      }
      module2.exports = sign;
      module2.exports.getKey = getKey;
      module2.exports.makeKey = makeKey;
    }, { "./curves.json": 77, "bn.js": 51, "browserify-rsa": 74, "create-hmac": 115, "elliptic": 167, "parse-asn1": 351, "safe-buffer": 417 }], 80: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      var BN = require2("bn.js");
      var EC = require2("elliptic").ec;
      var parseKeys = require2("parse-asn1");
      var curves = require2("./curves.json");
      function verify(sig, hash, key, signType, tag) {
        var pub = parseKeys(key);
        if (pub.type === "ec") {
          if (signType !== "ecdsa" && signType !== "ecdsa/rsa")
            throw new Error("wrong public key type");
          return ecVerify(sig, hash, pub);
        } else if (pub.type === "dsa") {
          if (signType !== "dsa")
            throw new Error("wrong public key type");
          return dsaVerify(sig, hash, pub);
        } else {
          if (signType !== "rsa" && signType !== "ecdsa/rsa")
            throw new Error("wrong public key type");
        }
        hash = Buffer.concat([tag, hash]);
        var len = pub.modulus.byteLength();
        var pad = [1];
        var padNum = 0;
        while (hash.length + pad.length + 2 < len) {
          pad.push(255);
          padNum++;
        }
        pad.push(0);
        var i = -1;
        while (++i < hash.length) {
          pad.push(hash[i]);
        }
        pad = Buffer.from(pad);
        var red = BN.mont(pub.modulus);
        sig = new BN(sig).toRed(red);
        sig = sig.redPow(new BN(pub.publicExponent));
        sig = Buffer.from(sig.fromRed().toArray());
        var out = padNum < 8 ? 1 : 0;
        len = Math.min(sig.length, pad.length);
        if (sig.length !== pad.length)
          out = 1;
        i = -1;
        while (++i < len) {
          out |= sig[i] ^ pad[i];
        }
        return out === 0;
      }
      function ecVerify(sig, hash, pub) {
        var curveId = curves[pub.data.algorithm.curve.join(".")];
        if (!curveId)
          throw new Error("unknown curve " + pub.data.algorithm.curve.join("."));
        var curve = new EC(curveId);
        var pubkey = pub.data.subjectPrivateKey.data;
        return curve.verify(hash, sig, pubkey);
      }
      function dsaVerify(sig, hash, pub) {
        var p = pub.data.p;
        var q = pub.data.q;
        var g = pub.data.g;
        var y = pub.data.pub_key;
        var unpacked = parseKeys.signature.decode(sig, "der");
        var s = unpacked.s;
        var r = unpacked.r;
        checkValue(s, q);
        checkValue(r, q);
        var montp = BN.mont(p);
        var w = s.invm(q);
        var v = g.toRed(montp).redPow(new BN(hash).mul(w).mod(q)).fromRed().mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed()).mod(p).mod(q);
        return v.cmp(r) === 0;
      }
      function checkValue(b, q) {
        if (b.cmpn(0) <= 0)
          throw new Error("invalid sig");
        if (b.cmp(q) >= q)
          throw new Error("invalid sig");
      }
      module2.exports = verify;
    }, { "./curves.json": 77, "bn.js": 51, "elliptic": 167, "parse-asn1": 351, "safe-buffer": 417 }], 81: [function(require2, module2, exports2) {
      arguments[4][53][0].apply(exports2, arguments);
    }, { "dup": 53 }], 82: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var base64 = require2("base64-js");
          var ieee754 = require2("ieee754");
          exports2.Buffer = Buffer2;
          exports2.SlowBuffer = SlowBuffer;
          exports2.INSPECT_MAX_BYTES = 50;
          var K_MAX_LENGTH = 2147483647;
          exports2.kMaxLength = K_MAX_LENGTH;
          Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
          if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
            console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
          }
          function typedArraySupport() {
            try {
              var arr = new Uint8Array(1);
              arr.__proto__ = {
                __proto__: Uint8Array.prototype,
                foo: function foo() {
                  return 42;
                }
              };
              return arr.foo() === 42;
            } catch (e) {
              return false;
            }
          }
          Object.defineProperty(Buffer2.prototype, "parent", {
            enumerable: true,
            get: function get() {
              if (!Buffer2.isBuffer(this))
                return void 0;
              return this.buffer;
            }
          });
          Object.defineProperty(Buffer2.prototype, "offset", {
            enumerable: true,
            get: function get() {
              if (!Buffer2.isBuffer(this))
                return void 0;
              return this.byteOffset;
            }
          });
          function createBuffer(length) {
            if (length > K_MAX_LENGTH) {
              throw new RangeError('The value "' + length + '" is invalid for option "size"');
            }
            var buf = new Uint8Array(length);
            buf.__proto__ = Buffer2.prototype;
            return buf;
          }
          function Buffer2(arg, encodingOrOffset, length) {
            if (typeof arg === "number") {
              if (typeof encodingOrOffset === "string") {
                throw new TypeError('The "string" argument must be of type string. Received type number');
              }
              return allocUnsafe(arg);
            }
            return from(arg, encodingOrOffset, length);
          }
          if (typeof Symbol !== "undefined" && Symbol.species != null && Buffer2[Symbol.species] === Buffer2) {
            Object.defineProperty(Buffer2, Symbol.species, {
              value: null,
              configurable: true,
              enumerable: false,
              writable: false
            });
          }
          Buffer2.poolSize = 8192;
          function from(value, encodingOrOffset, length) {
            if (typeof value === "string") {
              return fromString(value, encodingOrOffset);
            }
            if (ArrayBuffer.isView(value)) {
              return fromArrayLike(value);
            }
            if (value == null) {
              throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
            }
            if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
              return fromArrayBuffer(value, encodingOrOffset, length);
            }
            if (typeof value === "number") {
              throw new TypeError('The "value" argument must not be of type number. Received type number');
            }
            var valueOf = value.valueOf && value.valueOf();
            if (valueOf != null && valueOf !== value) {
              return Buffer2.from(valueOf, encodingOrOffset, length);
            }
            var b = fromObject(value);
            if (b)
              return b;
            if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
              return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
            }
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
          }
          Buffer2.from = function(value, encodingOrOffset, length) {
            return from(value, encodingOrOffset, length);
          };
          Buffer2.prototype.__proto__ = Uint8Array.prototype;
          Buffer2.__proto__ = Uint8Array;
          function assertSize(size) {
            if (typeof size !== "number") {
              throw new TypeError('"size" argument must be of type number');
            } else if (size < 0) {
              throw new RangeError('The value "' + size + '" is invalid for option "size"');
            }
          }
          function alloc(size, fill, encoding) {
            assertSize(size);
            if (size <= 0) {
              return createBuffer(size);
            }
            if (fill !== void 0) {
              return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
            }
            return createBuffer(size);
          }
          Buffer2.alloc = function(size, fill, encoding) {
            return alloc(size, fill, encoding);
          };
          function allocUnsafe(size) {
            assertSize(size);
            return createBuffer(size < 0 ? 0 : checked(size) | 0);
          }
          Buffer2.allocUnsafe = function(size) {
            return allocUnsafe(size);
          };
          Buffer2.allocUnsafeSlow = function(size) {
            return allocUnsafe(size);
          };
          function fromString(string, encoding) {
            if (typeof encoding !== "string" || encoding === "") {
              encoding = "utf8";
            }
            if (!Buffer2.isEncoding(encoding)) {
              throw new TypeError("Unknown encoding: " + encoding);
            }
            var length = byteLength(string, encoding) | 0;
            var buf = createBuffer(length);
            var actual = buf.write(string, encoding);
            if (actual !== length) {
              buf = buf.slice(0, actual);
            }
            return buf;
          }
          function fromArrayLike(array) {
            var length = array.length < 0 ? 0 : checked(array.length) | 0;
            var buf = createBuffer(length);
            for (var i = 0; i < length; i += 1) {
              buf[i] = array[i] & 255;
            }
            return buf;
          }
          function fromArrayBuffer(array, byteOffset, length) {
            if (byteOffset < 0 || array.byteLength < byteOffset) {
              throw new RangeError('"offset" is outside of buffer bounds');
            }
            if (array.byteLength < byteOffset + (length || 0)) {
              throw new RangeError('"length" is outside of buffer bounds');
            }
            var buf;
            if (byteOffset === void 0 && length === void 0) {
              buf = new Uint8Array(array);
            } else if (length === void 0) {
              buf = new Uint8Array(array, byteOffset);
            } else {
              buf = new Uint8Array(array, byteOffset, length);
            }
            buf.__proto__ = Buffer2.prototype;
            return buf;
          }
          function fromObject(obj) {
            if (Buffer2.isBuffer(obj)) {
              var len = checked(obj.length) | 0;
              var buf = createBuffer(len);
              if (buf.length === 0) {
                return buf;
              }
              obj.copy(buf, 0, 0, len);
              return buf;
            }
            if (obj.length !== void 0) {
              if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                return createBuffer(0);
              }
              return fromArrayLike(obj);
            }
            if (obj.type === "Buffer" && Array.isArray(obj.data)) {
              return fromArrayLike(obj.data);
            }
          }
          function checked(length) {
            if (length >= K_MAX_LENGTH) {
              throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
            }
            return length | 0;
          }
          function SlowBuffer(length) {
            if (+length != length) {
              length = 0;
            }
            return Buffer2.alloc(+length);
          }
          Buffer2.isBuffer = function isBuffer(b) {
            return b != null && b._isBuffer === true && b !== Buffer2.prototype;
          };
          Buffer2.compare = function compare(a, b) {
            if (isInstance(a, Uint8Array))
              a = Buffer2.from(a, a.offset, a.byteLength);
            if (isInstance(b, Uint8Array))
              b = Buffer2.from(b, b.offset, b.byteLength);
            if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
              throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            }
            if (a === b)
              return 0;
            var x = a.length;
            var y = b.length;
            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
              if (a[i] !== b[i]) {
                x = a[i];
                y = b[i];
                break;
              }
            }
            if (x < y)
              return -1;
            if (y < x)
              return 1;
            return 0;
          };
          Buffer2.isEncoding = function isEncoding(encoding) {
            switch (String(encoding).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          };
          Buffer2.concat = function concat(list, length) {
            if (!Array.isArray(list)) {
              throw new TypeError('"list" argument must be an Array of Buffers');
            }
            if (list.length === 0) {
              return Buffer2.alloc(0);
            }
            var i;
            if (length === void 0) {
              length = 0;
              for (i = 0; i < list.length; ++i) {
                length += list[i].length;
              }
            }
            var buffer = Buffer2.allocUnsafe(length);
            var pos = 0;
            for (i = 0; i < list.length; ++i) {
              var buf = list[i];
              if (isInstance(buf, Uint8Array)) {
                buf = Buffer2.from(buf);
              }
              if (!Buffer2.isBuffer(buf)) {
                throw new TypeError('"list" argument must be an Array of Buffers');
              }
              buf.copy(buffer, pos);
              pos += buf.length;
            }
            return buffer;
          };
          function byteLength(string, encoding) {
            if (Buffer2.isBuffer(string)) {
              return string.length;
            }
            if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
              return string.byteLength;
            }
            if (typeof string !== "string") {
              throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
            }
            var len = string.length;
            var mustMatch = arguments.length > 2 && arguments[2] === true;
            if (!mustMatch && len === 0)
              return 0;
            var loweredCase = false;
            for (; ; ) {
              switch (encoding) {
                case "ascii":
                case "latin1":
                case "binary":
                  return len;
                case "utf8":
                case "utf-8":
                  return utf8ToBytes(string).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return len * 2;
                case "hex":
                  return len >>> 1;
                case "base64":
                  return base64ToBytes(string).length;
                default:
                  if (loweredCase) {
                    return mustMatch ? -1 : utf8ToBytes(string).length;
                  }
                  encoding = ("" + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          }
          Buffer2.byteLength = byteLength;
          function slowToString(encoding, start, end) {
            var loweredCase = false;
            if (start === void 0 || start < 0) {
              start = 0;
            }
            if (start > this.length) {
              return "";
            }
            if (end === void 0 || end > this.length) {
              end = this.length;
            }
            if (end <= 0) {
              return "";
            }
            end >>>= 0;
            start >>>= 0;
            if (end <= start) {
              return "";
            }
            if (!encoding)
              encoding = "utf8";
            while (true) {
              switch (encoding) {
                case "hex":
                  return hexSlice(this, start, end);
                case "utf8":
                case "utf-8":
                  return utf8Slice(this, start, end);
                case "ascii":
                  return asciiSlice(this, start, end);
                case "latin1":
                case "binary":
                  return latin1Slice(this, start, end);
                case "base64":
                  return base64Slice(this, start, end);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return utf16leSlice(this, start, end);
                default:
                  if (loweredCase)
                    throw new TypeError("Unknown encoding: " + encoding);
                  encoding = (encoding + "").toLowerCase();
                  loweredCase = true;
              }
            }
          }
          Buffer2.prototype._isBuffer = true;
          function swap(b, n, m) {
            var i = b[n];
            b[n] = b[m];
            b[m] = i;
          }
          Buffer2.prototype.swap16 = function swap16() {
            var len = this.length;
            if (len % 2 !== 0) {
              throw new RangeError("Buffer size must be a multiple of 16-bits");
            }
            for (var i = 0; i < len; i += 2) {
              swap(this, i, i + 1);
            }
            return this;
          };
          Buffer2.prototype.swap32 = function swap32() {
            var len = this.length;
            if (len % 4 !== 0) {
              throw new RangeError("Buffer size must be a multiple of 32-bits");
            }
            for (var i = 0; i < len; i += 4) {
              swap(this, i, i + 3);
              swap(this, i + 1, i + 2);
            }
            return this;
          };
          Buffer2.prototype.swap64 = function swap64() {
            var len = this.length;
            if (len % 8 !== 0) {
              throw new RangeError("Buffer size must be a multiple of 64-bits");
            }
            for (var i = 0; i < len; i += 8) {
              swap(this, i, i + 7);
              swap(this, i + 1, i + 6);
              swap(this, i + 2, i + 5);
              swap(this, i + 3, i + 4);
            }
            return this;
          };
          Buffer2.prototype.toString = function toString() {
            var length = this.length;
            if (length === 0)
              return "";
            if (arguments.length === 0)
              return utf8Slice(this, 0, length);
            return slowToString.apply(this, arguments);
          };
          Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
          Buffer2.prototype.equals = function equals(b) {
            if (!Buffer2.isBuffer(b))
              throw new TypeError("Argument must be a Buffer");
            if (this === b)
              return true;
            return Buffer2.compare(this, b) === 0;
          };
          Buffer2.prototype.inspect = function inspect() {
            var str = "";
            var max = exports2.INSPECT_MAX_BYTES;
            str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
            if (this.length > max)
              str += " ... ";
            return "<Buffer " + str + ">";
          };
          Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
            if (isInstance(target, Uint8Array)) {
              target = Buffer2.from(target, target.offset, target.byteLength);
            }
            if (!Buffer2.isBuffer(target)) {
              throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
            }
            if (start === void 0) {
              start = 0;
            }
            if (end === void 0) {
              end = target ? target.length : 0;
            }
            if (thisStart === void 0) {
              thisStart = 0;
            }
            if (thisEnd === void 0) {
              thisEnd = this.length;
            }
            if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
              throw new RangeError("out of range index");
            }
            if (thisStart >= thisEnd && start >= end) {
              return 0;
            }
            if (thisStart >= thisEnd) {
              return -1;
            }
            if (start >= end) {
              return 1;
            }
            start >>>= 0;
            end >>>= 0;
            thisStart >>>= 0;
            thisEnd >>>= 0;
            if (this === target)
              return 0;
            var x = thisEnd - thisStart;
            var y = end - start;
            var len = Math.min(x, y);
            var thisCopy = this.slice(thisStart, thisEnd);
            var targetCopy = target.slice(start, end);
            for (var i = 0; i < len; ++i) {
              if (thisCopy[i] !== targetCopy[i]) {
                x = thisCopy[i];
                y = targetCopy[i];
                break;
              }
            }
            if (x < y)
              return -1;
            if (y < x)
              return 1;
            return 0;
          };
          function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
            if (buffer.length === 0)
              return -1;
            if (typeof byteOffset === "string") {
              encoding = byteOffset;
              byteOffset = 0;
            } else if (byteOffset > 2147483647) {
              byteOffset = 2147483647;
            } else if (byteOffset < -2147483648) {
              byteOffset = -2147483648;
            }
            byteOffset = +byteOffset;
            if (numberIsNaN(byteOffset)) {
              byteOffset = dir ? 0 : buffer.length - 1;
            }
            if (byteOffset < 0)
              byteOffset = buffer.length + byteOffset;
            if (byteOffset >= buffer.length) {
              if (dir)
                return -1;
              else
                byteOffset = buffer.length - 1;
            } else if (byteOffset < 0) {
              if (dir)
                byteOffset = 0;
              else
                return -1;
            }
            if (typeof val === "string") {
              val = Buffer2.from(val, encoding);
            }
            if (Buffer2.isBuffer(val)) {
              if (val.length === 0) {
                return -1;
              }
              return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
            } else if (typeof val === "number") {
              val = val & 255;
              if (typeof Uint8Array.prototype.indexOf === "function") {
                if (dir) {
                  return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                } else {
                  return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                }
              }
              return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
            }
            throw new TypeError("val must be string, number or Buffer");
          }
          function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
            var indexSize = 1;
            var arrLength = arr.length;
            var valLength = val.length;
            if (encoding !== void 0) {
              encoding = String(encoding).toLowerCase();
              if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                if (arr.length < 2 || val.length < 2) {
                  return -1;
                }
                indexSize = 2;
                arrLength /= 2;
                valLength /= 2;
                byteOffset /= 2;
              }
            }
            function read(buf, i2) {
              if (indexSize === 1) {
                return buf[i2];
              } else {
                return buf.readUInt16BE(i2 * indexSize);
              }
            }
            var i;
            if (dir) {
              var foundIndex = -1;
              for (i = byteOffset; i < arrLength; i++) {
                if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                  if (foundIndex === -1)
                    foundIndex = i;
                  if (i - foundIndex + 1 === valLength)
                    return foundIndex * indexSize;
                } else {
                  if (foundIndex !== -1)
                    i -= i - foundIndex;
                  foundIndex = -1;
                }
              }
            } else {
              if (byteOffset + valLength > arrLength)
                byteOffset = arrLength - valLength;
              for (i = byteOffset; i >= 0; i--) {
                var found = true;
                for (var j = 0; j < valLength; j++) {
                  if (read(arr, i + j) !== read(val, j)) {
                    found = false;
                    break;
                  }
                }
                if (found)
                  return i;
              }
            }
            return -1;
          }
          Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
            return this.indexOf(val, byteOffset, encoding) !== -1;
          };
          Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
          };
          Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
          };
          function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            var remaining = buf.length - offset;
            if (!length) {
              length = remaining;
            } else {
              length = Number(length);
              if (length > remaining) {
                length = remaining;
              }
            }
            var strLen = string.length;
            if (length > strLen / 2) {
              length = strLen / 2;
            }
            for (var i = 0; i < length; ++i) {
              var parsed = parseInt(string.substr(i * 2, 2), 16);
              if (numberIsNaN(parsed))
                return i;
              buf[offset + i] = parsed;
            }
            return i;
          }
          function utf8Write(buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
          }
          function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length);
          }
          function latin1Write(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length);
          }
          function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
          }
          function ucs2Write(buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
          }
          Buffer2.prototype.write = function write(string, offset, length, encoding) {
            if (offset === void 0) {
              encoding = "utf8";
              length = this.length;
              offset = 0;
            } else if (length === void 0 && typeof offset === "string") {
              encoding = offset;
              length = this.length;
              offset = 0;
            } else if (isFinite(offset)) {
              offset = offset >>> 0;
              if (isFinite(length)) {
                length = length >>> 0;
                if (encoding === void 0)
                  encoding = "utf8";
              } else {
                encoding = length;
                length = void 0;
              }
            } else {
              throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            }
            var remaining = this.length - offset;
            if (length === void 0 || length > remaining)
              length = remaining;
            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
              throw new RangeError("Attempt to write outside buffer bounds");
            }
            if (!encoding)
              encoding = "utf8";
            var loweredCase = false;
            for (; ; ) {
              switch (encoding) {
                case "hex":
                  return hexWrite(this, string, offset, length);
                case "utf8":
                case "utf-8":
                  return utf8Write(this, string, offset, length);
                case "ascii":
                  return asciiWrite(this, string, offset, length);
                case "latin1":
                case "binary":
                  return latin1Write(this, string, offset, length);
                case "base64":
                  return base64Write(this, string, offset, length);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return ucs2Write(this, string, offset, length);
                default:
                  if (loweredCase)
                    throw new TypeError("Unknown encoding: " + encoding);
                  encoding = ("" + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          };
          Buffer2.prototype.toJSON = function toJSON() {
            return {
              type: "Buffer",
              data: Array.prototype.slice.call(this._arr || this, 0)
            };
          };
          function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
              return base64.fromByteArray(buf);
            } else {
              return base64.fromByteArray(buf.slice(start, end));
            }
          }
          function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end);
            var res = [];
            var i = start;
            while (i < end) {
              var firstByte = buf[i];
              var codePoint = null;
              var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
              if (i + bytesPerSequence <= end) {
                var secondByte, thirdByte, fourthByte, tempCodePoint;
                switch (bytesPerSequence) {
                  case 1:
                    if (firstByte < 128) {
                      codePoint = firstByte;
                    }
                    break;
                  case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                      tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                      if (tempCodePoint > 127) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                      tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                      if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                      tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                      if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                        codePoint = tempCodePoint;
                      }
                    }
                }
              }
              if (codePoint === null) {
                codePoint = 65533;
                bytesPerSequence = 1;
              } else if (codePoint > 65535) {
                codePoint -= 65536;
                res.push(codePoint >>> 10 & 1023 | 55296);
                codePoint = 56320 | codePoint & 1023;
              }
              res.push(codePoint);
              i += bytesPerSequence;
            }
            return decodeCodePointsArray(res);
          }
          var MAX_ARGUMENTS_LENGTH = 4096;
          function decodeCodePointsArray(codePoints) {
            var len = codePoints.length;
            if (len <= MAX_ARGUMENTS_LENGTH) {
              return String.fromCharCode.apply(String, codePoints);
            }
            var res = "";
            var i = 0;
            while (i < len) {
              res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
            }
            return res;
          }
          function asciiSlice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i] & 127);
            }
            return ret;
          }
          function latin1Slice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i]);
            }
            return ret;
          }
          function hexSlice(buf, start, end) {
            var len = buf.length;
            if (!start || start < 0)
              start = 0;
            if (!end || end < 0 || end > len)
              end = len;
            var out = "";
            for (var i = start; i < end; ++i) {
              out += toHex(buf[i]);
            }
            return out;
          }
          function utf16leSlice(buf, start, end) {
            var bytes = buf.slice(start, end);
            var res = "";
            for (var i = 0; i < bytes.length; i += 2) {
              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
            }
            return res;
          }
          Buffer2.prototype.slice = function slice(start, end) {
            var len = this.length;
            start = ~~start;
            end = end === void 0 ? len : ~~end;
            if (start < 0) {
              start += len;
              if (start < 0)
                start = 0;
            } else if (start > len) {
              start = len;
            }
            if (end < 0) {
              end += len;
              if (end < 0)
                end = 0;
            } else if (end > len) {
              end = len;
            }
            if (end < start)
              end = start;
            var newBuf = this.subarray(start, end);
            newBuf.__proto__ = Buffer2.prototype;
            return newBuf;
          };
          function checkOffset(offset, ext, length) {
            if (offset % 1 !== 0 || offset < 0)
              throw new RangeError("offset is not uint");
            if (offset + ext > length)
              throw new RangeError("Trying to access beyond buffer length");
          }
          Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert)
              checkOffset(offset, byteLength2, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength2 && (mul *= 256)) {
              val += this[offset + i] * mul;
            }
            return val;
          };
          Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert) {
              checkOffset(offset, byteLength2, this.length);
            }
            var val = this[offset + --byteLength2];
            var mul = 1;
            while (byteLength2 > 0 && (mul *= 256)) {
              val += this[offset + --byteLength2] * mul;
            }
            return val;
          };
          Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 1, this.length);
            return this[offset];
          };
          Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            return this[offset] | this[offset + 1] << 8;
          };
          Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            return this[offset] << 8 | this[offset + 1];
          };
          Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
          };
          Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
          };
          Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert)
              checkOffset(offset, byteLength2, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength2 && (mul *= 256)) {
              val += this[offset + i] * mul;
            }
            mul *= 128;
            if (val >= mul)
              val -= Math.pow(2, 8 * byteLength2);
            return val;
          };
          Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert)
              checkOffset(offset, byteLength2, this.length);
            var i = byteLength2;
            var mul = 1;
            var val = this[offset + --i];
            while (i > 0 && (mul *= 256)) {
              val += this[offset + --i] * mul;
            }
            mul *= 128;
            if (val >= mul)
              val -= Math.pow(2, 8 * byteLength2);
            return val;
          };
          Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 1, this.length);
            if (!(this[offset] & 128))
              return this[offset];
            return (255 - this[offset] + 1) * -1;
          };
          Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            var val = this[offset] | this[offset + 1] << 8;
            return val & 32768 ? val | 4294901760 : val;
          };
          Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            var val = this[offset + 1] | this[offset] << 8;
            return val & 32768 ? val | 4294901760 : val;
          };
          Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
          };
          Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
          };
          Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, true, 23, 4);
          };
          Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, false, 23, 4);
          };
          Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, true, 52, 8);
          };
          Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, false, 52, 8);
          };
          function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer2.isBuffer(buf))
              throw new TypeError('"buffer" argument must be a Buffer instance');
            if (value > max || value < min)
              throw new RangeError('"value" argument is out of bounds');
            if (offset + ext > buf.length)
              throw new RangeError("Index out of range");
          }
          Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
              checkInt(this, value, offset, byteLength2, maxBytes, 0);
            }
            var mul = 1;
            var i = 0;
            this[offset] = value & 255;
            while (++i < byteLength2 && (mul *= 256)) {
              this[offset + i] = value / mul & 255;
            }
            return offset + byteLength2;
          };
          Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
              checkInt(this, value, offset, byteLength2, maxBytes, 0);
            }
            var i = byteLength2 - 1;
            var mul = 1;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
              this[offset + i] = value / mul & 255;
            }
            return offset + byteLength2;
          };
          Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 1, 255, 0);
            this[offset] = value & 255;
            return offset + 1;
          };
          Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 65535, 0);
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
            return offset + 2;
          };
          Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 65535, 0);
            this[offset] = value >>> 8;
            this[offset + 1] = value & 255;
            return offset + 2;
          };
          Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 4294967295, 0);
            this[offset + 3] = value >>> 24;
            this[offset + 2] = value >>> 16;
            this[offset + 1] = value >>> 8;
            this[offset] = value & 255;
            return offset + 4;
          };
          Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 4294967295, 0);
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 255;
            return offset + 4;
          };
          Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength2 - 1);
              checkInt(this, value, offset, byteLength2, limit - 1, -limit);
            }
            var i = 0;
            var mul = 1;
            var sub = 0;
            this[offset] = value & 255;
            while (++i < byteLength2 && (mul *= 256)) {
              if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                sub = 1;
              }
              this[offset + i] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength2;
          };
          Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength2 - 1);
              checkInt(this, value, offset, byteLength2, limit - 1, -limit);
            }
            var i = byteLength2 - 1;
            var mul = 1;
            var sub = 0;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
              if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                sub = 1;
              }
              this[offset + i] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength2;
          };
          Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 1, 127, -128);
            if (value < 0)
              value = 255 + value + 1;
            this[offset] = value & 255;
            return offset + 1;
          };
          Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 32767, -32768);
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
            return offset + 2;
          };
          Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 32767, -32768);
            this[offset] = value >>> 8;
            this[offset + 1] = value & 255;
            return offset + 2;
          };
          Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 2147483647, -2147483648);
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
            this[offset + 2] = value >>> 16;
            this[offset + 3] = value >>> 24;
            return offset + 4;
          };
          Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (value < 0)
              value = 4294967295 + value + 1;
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 255;
            return offset + 4;
          };
          function checkIEEE754(buf, value, offset, ext, max, min) {
            if (offset + ext > buf.length)
              throw new RangeError("Index out of range");
            if (offset < 0)
              throw new RangeError("Index out of range");
          }
          function writeFloat(buf, value, offset, littleEndian, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 4);
            }
            ieee754.write(buf, value, offset, littleEndian, 23, 4);
            return offset + 4;
          }
          Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert);
          };
          Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert);
          };
          function writeDouble(buf, value, offset, littleEndian, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 8);
            }
            ieee754.write(buf, value, offset, littleEndian, 52, 8);
            return offset + 8;
          }
          Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert);
          };
          Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert);
          };
          Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
            if (!Buffer2.isBuffer(target))
              throw new TypeError("argument should be a Buffer");
            if (!start)
              start = 0;
            if (!end && end !== 0)
              end = this.length;
            if (targetStart >= target.length)
              targetStart = target.length;
            if (!targetStart)
              targetStart = 0;
            if (end > 0 && end < start)
              end = start;
            if (end === start)
              return 0;
            if (target.length === 0 || this.length === 0)
              return 0;
            if (targetStart < 0) {
              throw new RangeError("targetStart out of bounds");
            }
            if (start < 0 || start >= this.length)
              throw new RangeError("Index out of range");
            if (end < 0)
              throw new RangeError("sourceEnd out of bounds");
            if (end > this.length)
              end = this.length;
            if (target.length - targetStart < end - start) {
              end = target.length - targetStart + start;
            }
            var len = end - start;
            if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
              this.copyWithin(targetStart, start, end);
            } else if (this === target && start < targetStart && targetStart < end) {
              for (var i = len - 1; i >= 0; --i) {
                target[i + targetStart] = this[i + start];
              }
            } else {
              Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
            }
            return len;
          };
          Buffer2.prototype.fill = function fill(val, start, end, encoding) {
            if (typeof val === "string") {
              if (typeof start === "string") {
                encoding = start;
                start = 0;
                end = this.length;
              } else if (typeof end === "string") {
                encoding = end;
                end = this.length;
              }
              if (encoding !== void 0 && typeof encoding !== "string") {
                throw new TypeError("encoding must be a string");
              }
              if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
                throw new TypeError("Unknown encoding: " + encoding);
              }
              if (val.length === 1) {
                var code = val.charCodeAt(0);
                if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                  val = code;
                }
              }
            } else if (typeof val === "number") {
              val = val & 255;
            }
            if (start < 0 || this.length < start || this.length < end) {
              throw new RangeError("Out of range index");
            }
            if (end <= start) {
              return this;
            }
            start = start >>> 0;
            end = end === void 0 ? this.length : end >>> 0;
            if (!val)
              val = 0;
            var i;
            if (typeof val === "number") {
              for (i = start; i < end; ++i) {
                this[i] = val;
              }
            } else {
              var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
              var len = bytes.length;
              if (len === 0) {
                throw new TypeError('The value "' + val + '" is invalid for argument "value"');
              }
              for (i = 0; i < end - start; ++i) {
                this[i + start] = bytes[i % len];
              }
            }
            return this;
          };
          var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
          function base64clean(str) {
            str = str.split("=")[0];
            str = str.trim().replace(INVALID_BASE64_RE, "");
            if (str.length < 2)
              return "";
            while (str.length % 4 !== 0) {
              str = str + "=";
            }
            return str;
          }
          function toHex(n) {
            if (n < 16)
              return "0" + n.toString(16);
            return n.toString(16);
          }
          function utf8ToBytes(string, units) {
            units = units || Infinity;
            var codePoint;
            var length = string.length;
            var leadSurrogate = null;
            var bytes = [];
            for (var i = 0; i < length; ++i) {
              codePoint = string.charCodeAt(i);
              if (codePoint > 55295 && codePoint < 57344) {
                if (!leadSurrogate) {
                  if (codePoint > 56319) {
                    if ((units -= 3) > -1)
                      bytes.push(239, 191, 189);
                    continue;
                  } else if (i + 1 === length) {
                    if ((units -= 3) > -1)
                      bytes.push(239, 191, 189);
                    continue;
                  }
                  leadSurrogate = codePoint;
                  continue;
                }
                if (codePoint < 56320) {
                  if ((units -= 3) > -1)
                    bytes.push(239, 191, 189);
                  leadSurrogate = codePoint;
                  continue;
                }
                codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
              } else if (leadSurrogate) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
              }
              leadSurrogate = null;
              if (codePoint < 128) {
                if ((units -= 1) < 0)
                  break;
                bytes.push(codePoint);
              } else if (codePoint < 2048) {
                if ((units -= 2) < 0)
                  break;
                bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
              } else if (codePoint < 65536) {
                if ((units -= 3) < 0)
                  break;
                bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
              } else if (codePoint < 1114112) {
                if ((units -= 4) < 0)
                  break;
                bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
              } else {
                throw new Error("Invalid code point");
              }
            }
            return bytes;
          }
          function asciiToBytes(str) {
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) {
              byteArray.push(str.charCodeAt(i) & 255);
            }
            return byteArray;
          }
          function utf16leToBytes(str, units) {
            var c, hi, lo;
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) {
              if ((units -= 2) < 0)
                break;
              c = str.charCodeAt(i);
              hi = c >> 8;
              lo = c % 256;
              byteArray.push(lo);
              byteArray.push(hi);
            }
            return byteArray;
          }
          function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str));
          }
          function blitBuffer(src, dst, offset, length) {
            for (var i = 0; i < length; ++i) {
              if (i + offset >= dst.length || i >= src.length)
                break;
              dst[i + offset] = src[i];
            }
            return i;
          }
          function isInstance(obj, type) {
            return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
          }
          function numberIsNaN(obj) {
            return obj !== obj;
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "base64-js": 39, "buffer": 82, "ieee754": 249 }], 83: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          function allocUnsafe(size) {
            if (typeof size !== "number") {
              throw new TypeError('"size" argument must be a number');
            }
            if (size < 0) {
              throw new RangeError('"size" argument must not be negative');
            }
            if (Buffer.allocUnsafe) {
              return Buffer.allocUnsafe(size);
            } else {
              return new Buffer(size);
            }
          }
          module2.exports = allocUnsafe;
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82 }], 84: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var bufferFill = require2("buffer-fill");
          var allocUnsafe = require2("buffer-alloc-unsafe");
          module2.exports = function alloc(size, fill, encoding) {
            if (typeof size !== "number") {
              throw new TypeError('"size" argument must be a number');
            }
            if (size < 0) {
              throw new RangeError('"size" argument must not be negative');
            }
            if (Buffer.alloc) {
              return Buffer.alloc(size, fill, encoding);
            }
            var buffer = allocUnsafe(size);
            if (size === 0) {
              return buffer;
            }
            if (fill === void 0) {
              return bufferFill(buffer, 0);
            }
            if (typeof encoding !== "string") {
              encoding = void 0;
            }
            return bufferFill(buffer, fill, encoding);
          };
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82, "buffer-alloc-unsafe": 83, "buffer-fill": 85 }], 85: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var hasFullSupport = function() {
            try {
              if (!Buffer.isEncoding("latin1")) {
                return false;
              }
              var buf = Buffer.alloc ? Buffer.alloc(4) : new Buffer(4);
              buf.fill("ab", "ucs2");
              return buf.toString("hex") === "61006200";
            } catch (_) {
              return false;
            }
          }();
          function isSingleByte(val) {
            return val.length === 1 && val.charCodeAt(0) < 256;
          }
          function fillWithNumber(buffer, val, start, end) {
            if (start < 0 || end > buffer.length) {
              throw new RangeError("Out of range index");
            }
            start = start >>> 0;
            end = end === void 0 ? buffer.length : end >>> 0;
            if (end > start) {
              buffer.fill(val, start, end);
            }
            return buffer;
          }
          function fillWithBuffer(buffer, val, start, end) {
            if (start < 0 || end > buffer.length) {
              throw new RangeError("Out of range index");
            }
            if (end <= start) {
              return buffer;
            }
            start = start >>> 0;
            end = end === void 0 ? buffer.length : end >>> 0;
            var pos = start;
            var len = val.length;
            while (pos <= end - len) {
              val.copy(buffer, pos);
              pos += len;
            }
            if (pos !== end) {
              val.copy(buffer, pos, 0, end - pos);
            }
            return buffer;
          }
          function fill(buffer, val, start, end, encoding) {
            if (hasFullSupport) {
              return buffer.fill(val, start, end, encoding);
            }
            if (typeof val === "number") {
              return fillWithNumber(buffer, val, start, end);
            }
            if (typeof val === "string") {
              if (typeof start === "string") {
                encoding = start;
                start = 0;
                end = buffer.length;
              } else if (typeof end === "string") {
                encoding = end;
                end = buffer.length;
              }
              if (encoding !== void 0 && typeof encoding !== "string") {
                throw new TypeError("encoding must be a string");
              }
              if (encoding === "latin1") {
                encoding = "binary";
              }
              if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
                throw new TypeError("Unknown encoding: " + encoding);
              }
              if (val === "") {
                return fillWithNumber(buffer, 0, start, end);
              }
              if (isSingleByte(val)) {
                return fillWithNumber(buffer, val.charCodeAt(0), start, end);
              }
              val = new Buffer(val, encoding);
            }
            if (Buffer.isBuffer(val)) {
              return fillWithBuffer(buffer, val, start, end);
            }
            return fillWithNumber(buffer, 0, start, end);
          }
          module2.exports = fill;
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82 }], 86: [function(require2, module2, exports2) {
      arguments[4][5][0].apply(exports2, arguments);
    }, { "buffer": 82, "dup": 5 }], 87: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          module2.exports = function xor(a, b) {
            var length = Math.min(a.length, b.length);
            var buffer = new Buffer(length);
            for (var i = 0; i < length; ++i) {
              buffer[i] = a[i] ^ b[i];
            }
            return buffer;
          };
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82 }], 88: [function(require2, module2, exports2) {
      var GetIntrinsic = require2("get-intrinsic");
      var callBind = require2("./");
      var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
      module2.exports = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = GetIntrinsic(name, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
          return callBind(intrinsic);
        }
        return intrinsic;
      };
    }, { "./": 89, "get-intrinsic": 206 }], 89: [function(require2, module2, exports2) {
      var bind = require2("function-bind");
      var GetIntrinsic = require2("get-intrinsic");
      var $apply = GetIntrinsic("%Function.prototype.apply%");
      var $call = GetIntrinsic("%Function.prototype.call%");
      var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
      var $max = GetIntrinsic("%Math.max%");
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", {
            value: 1
          });
        } catch (e) {
          $defineProperty = null;
        }
      }
      module2.exports = function callBind(originalFunction) {
        var func = $reflectApply(bind, $call, arguments);
        if ($gOPD && $defineProperty) {
          var desc = $gOPD(func, "length");
          if (desc.configurable) {
            $defineProperty(func, "length", {
              value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
            });
          }
        }
        return func;
      };
      var applyBind = function applyBind2() {
        return $reflectApply(bind, $apply, arguments);
      };
      if ($defineProperty) {
        $defineProperty(module2.exports, "apply", {
          value: applyBind
        });
      } else {
        module2.exports.apply = applyBind;
      }
    }, { "function-bind": 203, "get-intrinsic": 206 }], 90: [function(require2, module2, exports2) {
      (function(process, global) {
        (function() {
          var next = global.process && process.nextTick || global.setImmediate || function(f) {
            setTimeout(f, 0);
          };
          module2.exports = function maybe(cb, promise) {
            if (cb) {
              promise.then(function(result) {
                next(function() {
                  cb(null, result);
                });
              }, function(err) {
                next(function() {
                  cb(err);
                });
              });
              return void 0;
            } else {
              return promise;
            }
          };
        }).call(this);
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "_process": 361 }], 91: [function(require2, module2, exports2) {
      var assert = require2("nanoassert");
      module2.exports = Chacha20;
      var constant = [1634760805, 857760878, 2036477234, 1797285236];
      function Chacha20(nonce, key, counter) {
        assert(key.byteLength === 32);
        assert(nonce.byteLength === 8 || nonce.byteLength === 12);
        var n = new Uint32Array(nonce.buffer, nonce.byteOffset, nonce.byteLength / 4);
        var k = new Uint32Array(key.buffer, key.byteOffset, key.byteLength / 4);
        if (!counter)
          counter = 0;
        assert(counter < Number.MAX_SAFE_INTEGER);
        this.finalized = false;
        this.pos = 0;
        this.state = new Uint32Array(16);
        for (var i = 0; i < 4; i++) {
          this.state[i] = constant[i];
        }
        for (var _i = 0; _i < 8; _i++) {
          this.state[4 + _i] = k[_i];
        }
        this.state[12] = counter & 4294967295;
        if (n.byteLength === 8) {
          this.state[13] = (counter && 18446744069414584e3) >> 32;
          this.state[14] = n[0];
          this.state[15] = n[1];
        } else {
          this.state[13] = n[0];
          this.state[14] = n[1];
          this.state[15] = n[2];
        }
        return this;
      }
      Chacha20.prototype.update = function(output, input) {
        assert(!this.finalized, "cipher finalized.");
        assert(output.byteLength >= input.byteLength, "output cannot be shorter than input.");
        var len = input.length;
        var offset = this.pos % 64;
        this.pos += len;
        var j = 0;
        var keyStream = chacha20Block(this.state);
        while (offset > 0 && len > 0) {
          output[j] = input[j++] ^ keyStream[offset];
          offset = offset + 1 & 63;
          if (!offset)
            this.state[12]++;
          len--;
        }
        while (len > 0) {
          keyStream = chacha20Block(this.state);
          if (len < 64) {
            for (var i = 0; i < len; i++) {
              output[j] = input[j++] ^ keyStream[offset++];
              offset &= 63;
            }
            return;
          }
          for (; offset < 64; ) {
            output[j] = input[j++] ^ keyStream[offset++];
          }
          this.state[12]++;
          offset = 0;
          len -= 64;
        }
      };
      Chacha20.prototype.final = function() {
        this.state.fill(0);
        this.pos = 0;
        this.finalized = true;
      };
      function chacha20Block(state) {
        var ws = new Uint32Array(16);
        for (var i = 16; i--; ) {
          ws[i] = state[i];
        }
        for (var _i2 = 0; _i2 < 20; _i2 += 2) {
          QR(ws, 0, 4, 8, 12);
          QR(ws, 1, 5, 9, 13);
          QR(ws, 2, 6, 10, 14);
          QR(ws, 3, 7, 11, 15);
          QR(ws, 0, 5, 10, 15);
          QR(ws, 1, 6, 11, 12);
          QR(ws, 2, 7, 8, 13);
          QR(ws, 3, 4, 9, 14);
        }
        for (var _i3 = 0; _i3 < 16; _i3++) {
          ws[_i3] += state[_i3];
        }
        return new Uint8Array(ws.buffer, ws.byteOffset, ws.byteLength);
      }
      function rotl(a, b) {
        return a << b | a >>> 32 - b;
      }
      function QR(obj, a, b, c, d) {
        obj[a] += obj[b];
        obj[d] ^= obj[a];
        obj[d] = rotl(obj[d], 16);
        obj[c] += obj[d];
        obj[b] ^= obj[c];
        obj[b] = rotl(obj[b], 12);
        obj[a] += obj[b];
        obj[d] ^= obj[a];
        obj[d] = rotl(obj[d], 8);
        obj[c] += obj[d];
        obj[b] ^= obj[c];
        obj[b] = rotl(obj[b], 7);
      }
    }, { "nanoassert": 308 }], 92: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      var Transform = require2("stream").Transform;
      var StringDecoder = require2("string_decoder").StringDecoder;
      var inherits = require2("inherits");
      function CipherBase(hashMode) {
        Transform.call(this);
        this.hashMode = typeof hashMode === "string";
        if (this.hashMode) {
          this[hashMode] = this._finalOrDigest;
        } else {
          this.final = this._finalOrDigest;
        }
        if (this._final) {
          this.__final = this._final;
          this._final = null;
        }
        this._decoder = null;
        this._encoding = null;
      }
      inherits(CipherBase, Transform);
      CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
        if (typeof data === "string") {
          data = Buffer.from(data, inputEnc);
        }
        var outData = this._update(data);
        if (this.hashMode)
          return this;
        if (outputEnc) {
          outData = this._toString(outData, outputEnc);
        }
        return outData;
      };
      CipherBase.prototype.setAutoPadding = function() {
      };
      CipherBase.prototype.getAuthTag = function() {
        throw new Error("trying to get auth tag in unsupported state");
      };
      CipherBase.prototype.setAuthTag = function() {
        throw new Error("trying to set auth tag in unsupported state");
      };
      CipherBase.prototype.setAAD = function() {
        throw new Error("trying to set aad in unsupported state");
      };
      CipherBase.prototype._transform = function(data, _, next) {
        var err;
        try {
          if (this.hashMode) {
            this._update(data);
          } else {
            this.push(this._update(data));
          }
        } catch (e) {
          err = e;
        } finally {
          next(err);
        }
      };
      CipherBase.prototype._flush = function(done) {
        var err;
        try {
          this.push(this.__final());
        } catch (e) {
          err = e;
        }
        done(err);
      };
      CipherBase.prototype._finalOrDigest = function(outputEnc) {
        var outData = this.__final() || Buffer.alloc(0);
        if (outputEnc) {
          outData = this._toString(outData, outputEnc, true);
        }
        return outData;
      };
      CipherBase.prototype._toString = function(value, enc, fin) {
        if (!this._decoder) {
          this._decoder = new StringDecoder(enc);
          this._encoding = enc;
        }
        if (this._encoding !== enc)
          throw new Error("can't switch encodings");
        var out = this._decoder.write(value);
        if (fin) {
          out += this._decoder.end();
        }
        return out;
      };
      module2.exports = CipherBase;
    }, { "inherits": 256, "safe-buffer": 417, "stream": 480, "string_decoder": 499 }], 93: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var clone = function() {
            function _instanceof(obj, type) {
              return type != null && obj instanceof type;
            }
            var nativeMap;
            try {
              nativeMap = Map;
            } catch (_) {
              nativeMap = function nativeMap2() {
              };
            }
            var nativeSet;
            try {
              nativeSet = Set;
            } catch (_) {
              nativeSet = function nativeSet2() {
              };
            }
            var nativePromise;
            try {
              nativePromise = Promise;
            } catch (_) {
              nativePromise = function nativePromise2() {
              };
            }
            function clone2(parent, circular, depth, prototype, includeNonEnumerable) {
              if (typeof circular === "object") {
                depth = circular.depth;
                prototype = circular.prototype;
                includeNonEnumerable = circular.includeNonEnumerable;
                circular = circular.circular;
              }
              var allParents = [];
              var allChildren = [];
              var useBuffer = typeof Buffer != "undefined";
              if (typeof circular == "undefined")
                circular = true;
              if (typeof depth == "undefined")
                depth = Infinity;
              function _clone(parent2, depth2) {
                if (parent2 === null)
                  return null;
                if (depth2 === 0)
                  return parent2;
                var child;
                var proto;
                if (typeof parent2 != "object") {
                  return parent2;
                }
                if (_instanceof(parent2, nativeMap)) {
                  child = new nativeMap();
                } else if (_instanceof(parent2, nativeSet)) {
                  child = new nativeSet();
                } else if (_instanceof(parent2, nativePromise)) {
                  child = new nativePromise(function(resolve, reject) {
                    parent2.then(function(value) {
                      resolve(_clone(value, depth2 - 1));
                    }, function(err) {
                      reject(_clone(err, depth2 - 1));
                    });
                  });
                } else if (clone2.__isArray(parent2)) {
                  child = [];
                } else if (clone2.__isRegExp(parent2)) {
                  child = new RegExp(parent2.source, __getRegExpFlags(parent2));
                  if (parent2.lastIndex)
                    child.lastIndex = parent2.lastIndex;
                } else if (clone2.__isDate(parent2)) {
                  child = new Date(parent2.getTime());
                } else if (useBuffer && Buffer.isBuffer(parent2)) {
                  if (Buffer.allocUnsafe) {
                    child = Buffer.allocUnsafe(parent2.length);
                  } else {
                    child = new Buffer(parent2.length);
                  }
                  parent2.copy(child);
                  return child;
                } else if (_instanceof(parent2, Error)) {
                  child = Object.create(parent2);
                } else {
                  if (typeof prototype == "undefined") {
                    proto = Object.getPrototypeOf(parent2);
                    child = Object.create(proto);
                  } else {
                    child = Object.create(prototype);
                    proto = prototype;
                  }
                }
                if (circular) {
                  var index = allParents.indexOf(parent2);
                  if (index != -1) {
                    return allChildren[index];
                  }
                  allParents.push(parent2);
                  allChildren.push(child);
                }
                if (_instanceof(parent2, nativeMap)) {
                  parent2.forEach(function(value, key) {
                    var keyChild = _clone(key, depth2 - 1);
                    var valueChild = _clone(value, depth2 - 1);
                    child.set(keyChild, valueChild);
                  });
                }
                if (_instanceof(parent2, nativeSet)) {
                  parent2.forEach(function(value) {
                    var entryChild = _clone(value, depth2 - 1);
                    child.add(entryChild);
                  });
                }
                for (var i in parent2) {
                  var attrs;
                  if (proto) {
                    attrs = Object.getOwnPropertyDescriptor(proto, i);
                  }
                  if (attrs && attrs.set == null) {
                    continue;
                  }
                  child[i] = _clone(parent2[i], depth2 - 1);
                }
                if (Object.getOwnPropertySymbols) {
                  var symbols = Object.getOwnPropertySymbols(parent2);
                  for (var i = 0; i < symbols.length; i++) {
                    var symbol = symbols[i];
                    var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
                    if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                      continue;
                    }
                    child[symbol] = _clone(parent2[symbol], depth2 - 1);
                    if (!descriptor.enumerable) {
                      Object.defineProperty(child, symbol, {
                        enumerable: false
                      });
                    }
                  }
                }
                if (includeNonEnumerable) {
                  var allPropertyNames = Object.getOwnPropertyNames(parent2);
                  for (var i = 0; i < allPropertyNames.length; i++) {
                    var propertyName = allPropertyNames[i];
                    var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
                    if (descriptor && descriptor.enumerable) {
                      continue;
                    }
                    child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
                    Object.defineProperty(child, propertyName, {
                      enumerable: false
                    });
                  }
                }
                return child;
              }
              return _clone(parent, depth);
            }
            clone2.clonePrototype = function clonePrototype(parent) {
              if (parent === null)
                return null;
              var c = function c2() {
              };
              c.prototype = parent;
              return new c();
            };
            function __objToStr(o) {
              return Object.prototype.toString.call(o);
            }
            clone2.__objToStr = __objToStr;
            function __isDate(o) {
              return typeof o === "object" && __objToStr(o) === "[object Date]";
            }
            clone2.__isDate = __isDate;
            function __isArray(o) {
              return typeof o === "object" && __objToStr(o) === "[object Array]";
            }
            clone2.__isArray = __isArray;
            function __isRegExp(o) {
              return typeof o === "object" && __objToStr(o) === "[object RegExp]";
            }
            clone2.__isRegExp = __isRegExp;
            function __getRegExpFlags(re) {
              var flags = "";
              if (re.global)
                flags += "g";
              if (re.ignoreCase)
                flags += "i";
              if (re.multiline)
                flags += "m";
              return flags;
            }
            clone2.__getRegExpFlags = __getRegExpFlags;
            return clone2;
          }();
          if (typeof module2 === "object" && module2.exports) {
            module2.exports = clone;
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82 }], 94: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          module2.exports = codecs;
          codecs.ascii = createString("ascii");
          codecs.utf8 = createString("utf-8");
          codecs.hex = createString("hex");
          codecs.base64 = createString("base64");
          codecs.ucs2 = createString("ucs2");
          codecs.utf16le = createString("utf16le");
          codecs.ndjson = createJSON(true);
          codecs.json = createJSON(false);
          codecs.binary = {
            name: "binary",
            encode: function encodeBinary(obj) {
              return typeof obj === "string" ? Buffer.from(obj, "utf-8") : Buffer.isBuffer(obj) ? obj : Buffer.from(obj.buffer, obj.byteOffset, obj.byteLength);
            },
            decode: function decodeBinary(buf) {
              return Buffer.isBuffer(buf) ? buf : Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
            }
          };
          function codecs(fmt, fallback) {
            if (typeof fmt === "object" && fmt && fmt.encode && fmt.decode)
              return fmt;
            switch (fmt) {
              case "ndjson":
                return codecs.ndjson;
              case "json":
                return codecs.json;
              case "ascii":
                return codecs.ascii;
              case "utf-8":
              case "utf8":
                return codecs.utf8;
              case "hex":
                return codecs.hex;
              case "base64":
                return codecs.base64;
              case "ucs-2":
              case "ucs2":
                return codecs.ucs2;
              case "utf16-le":
              case "utf16le":
                return codecs.utf16le;
            }
            return fallback !== void 0 ? fallback : codecs.binary;
          }
          function createJSON(newline) {
            return {
              name: newline ? "ndjson" : "json",
              encode: newline ? encodeNDJSON : encodeJSON,
              decode: function decodeJSON(buf) {
                return JSON.parse(buf.toString());
              }
            };
            function encodeJSON(val) {
              return Buffer.from(JSON.stringify(val));
            }
            function encodeNDJSON(val) {
              return Buffer.from(JSON.stringify(val) + "\n");
            }
          }
          function createString(type) {
            return {
              name: type,
              encode: function encodeString(val) {
                if (typeof val !== "string")
                  val = val.toString();
                return Buffer.from(val, type);
              },
              decode: function decodeString(buf) {
                return buf.toString(type);
              }
            };
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82 }], 95: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2["default"] = collect;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }
      var _concatStream = require2("concat-stream");
      var _concatStream2 = _interopRequireDefault(_concatStream);
      var _once = require2("once");
      var _once2 = _interopRequireDefault(_once);
      function collect(stream, opts, fn) {
        if (typeof opts === "function") {
          fn = opts;
          opts = {};
        }
        fn = (0, _once2["default"])(fn);
        stream.on("error", fn);
        stream.pipe((0, _concatStream2["default"])(opts, function(data) {
          fn(null, data);
        }));
      }
      module2.exports = exports2["default"];
    }, { "concat-stream": 96, "once": 339 }], 96: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var Writable = require2("readable-stream").Writable;
          var inherits = require2("inherits");
          var bufferFrom = require2("buffer-from");
          if (typeof Uint8Array === "undefined") {
            var U8 = require2("typedarray").Uint8Array;
          } else {
            var U8 = Uint8Array;
          }
          function ConcatStream(opts, cb) {
            if (!(this instanceof ConcatStream))
              return new ConcatStream(opts, cb);
            if (typeof opts === "function") {
              cb = opts;
              opts = {};
            }
            if (!opts)
              opts = {};
            var encoding = opts.encoding;
            var shouldInferEncoding = false;
            if (!encoding) {
              shouldInferEncoding = true;
            } else {
              encoding = String(encoding).toLowerCase();
              if (encoding === "u8" || encoding === "uint8") {
                encoding = "uint8array";
              }
            }
            Writable.call(this, {
              objectMode: true
            });
            this.encoding = encoding;
            this.shouldInferEncoding = shouldInferEncoding;
            if (cb)
              this.on("finish", function() {
                cb(this.getBody());
              });
            this.body = [];
          }
          module2.exports = ConcatStream;
          inherits(ConcatStream, Writable);
          ConcatStream.prototype._write = function(chunk, enc, next) {
            this.body.push(chunk);
            next();
          };
          ConcatStream.prototype.inferEncoding = function(buff) {
            var firstBuffer = buff === void 0 ? this.body[0] : buff;
            if (Buffer.isBuffer(firstBuffer))
              return "buffer";
            if (typeof Uint8Array !== "undefined" && firstBuffer instanceof Uint8Array)
              return "uint8array";
            if (Array.isArray(firstBuffer))
              return "array";
            if (typeof firstBuffer === "string")
              return "string";
            if (Object.prototype.toString.call(firstBuffer) === "[object Object]")
              return "object";
            return "buffer";
          };
          ConcatStream.prototype.getBody = function() {
            if (!this.encoding && this.body.length === 0)
              return [];
            if (this.shouldInferEncoding)
              this.encoding = this.inferEncoding();
            if (this.encoding === "array")
              return arrayConcat(this.body);
            if (this.encoding === "string")
              return stringConcat(this.body);
            if (this.encoding === "buffer")
              return bufferConcat(this.body);
            if (this.encoding === "uint8array")
              return u8Concat(this.body);
            return this.body;
          };
          function isArrayish(arr) {
            return /Array\]$/.test(Object.prototype.toString.call(arr));
          }
          function isBufferish(p) {
            return typeof p === "string" || isArrayish(p) || p && typeof p.subarray === "function";
          }
          function stringConcat(parts) {
            var strings = [];
            for (var i = 0; i < parts.length; i++) {
              var p = parts[i];
              if (typeof p === "string") {
                strings.push(p);
              } else if (Buffer.isBuffer(p)) {
                strings.push(p);
              } else if (isBufferish(p)) {
                strings.push(bufferFrom(p));
              } else {
                strings.push(bufferFrom(String(p)));
              }
            }
            if (Buffer.isBuffer(parts[0])) {
              strings = Buffer.concat(strings);
              strings = strings.toString("utf8");
            } else {
              strings = strings.join("");
            }
            return strings;
          }
          function bufferConcat(parts) {
            var bufs = [];
            for (var i = 0; i < parts.length; i++) {
              var p = parts[i];
              if (Buffer.isBuffer(p)) {
                bufs.push(p);
              } else if (isBufferish(p)) {
                bufs.push(bufferFrom(p));
              } else {
                bufs.push(bufferFrom(String(p)));
              }
            }
            return Buffer.concat(bufs);
          }
          function arrayConcat(parts) {
            var res = [];
            for (var i = 0; i < parts.length; i++) {
              res.push.apply(res, parts[i]);
            }
            return res;
          }
          function u8Concat(parts) {
            var len = 0;
            for (var i = 0; i < parts.length; i++) {
              if (typeof parts[i] === "string") {
                parts[i] = bufferFrom(parts[i]);
              }
              len += parts[i].length;
            }
            var u8 = new U8(len);
            for (var i = 0, offset = 0; i < parts.length; i++) {
              var part = parts[i];
              for (var j = 0; j < part.length; j++) {
                u8[offset++] = part[j];
              }
            }
            return u8;
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82, "buffer-from": 86, "inherits": 256, "readable-stream": 105, "typedarray": 507 }], 97: [function(require2, module2, exports2) {
      var pna = require2("process-nextick-args");
      var objectKeys = Object.keys || function(obj) {
        var keys2 = [];
        for (var key in obj) {
          keys2.push(key);
        }
        return keys2;
      };
      module2.exports = Duplex;
      var util = Object.create(require2("core-util-is"));
      util.inherits = require2("inherits");
      var Readable = require2("./_stream_readable");
      var Writable = require2("./_stream_writable");
      util.inherits(Duplex, Readable);
      {
        var keys = objectKeys(Writable.prototype);
        for (var v = 0; v < keys.length; v++) {
          var method = keys[v];
          if (!Duplex.prototype[method])
            Duplex.prototype[method] = Writable.prototype[method];
        }
      }
      function Duplex(options) {
        if (!(this instanceof Duplex))
          return new Duplex(options);
        Readable.call(this, options);
        Writable.call(this, options);
        if (options && options.readable === false)
          this.readable = false;
        if (options && options.writable === false)
          this.writable = false;
        this.allowHalfOpen = true;
        if (options && options.allowHalfOpen === false)
          this.allowHalfOpen = false;
        this.once("end", onend);
      }
      Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      function onend() {
        if (this.allowHalfOpen || this._writableState.ended)
          return;
        pna.nextTick(onEndNT, this);
      }
      function onEndNT(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex.prototype, "destroyed", {
        get: function get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
      Duplex.prototype._destroy = function(err, cb) {
        this.push(null);
        this.end();
        pna.nextTick(cb, err);
      };
    }, { "./_stream_readable": 99, "./_stream_writable": 101, "core-util-is": 108, "inherits": 256, "process-nextick-args": 360 }], 98: [function(require2, module2, exports2) {
      module2.exports = PassThrough;
      var Transform = require2("./_stream_transform");
      var util = Object.create(require2("core-util-is"));
      util.inherits = require2("inherits");
      util.inherits(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough))
          return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }, { "./_stream_transform": 100, "core-util-is": 108, "inherits": 256 }], 99: [function(require2, module2, exports2) {
      (function(process, global) {
        (function() {
          var pna = require2("process-nextick-args");
          module2.exports = Readable;
          var isArray = require2("isarray");
          var Duplex;
          Readable.ReadableState = ReadableState;
          require2("events").EventEmitter;
          var EElistenerCount = function EElistenerCount2(emitter, type) {
            return emitter.listeners(type).length;
          };
          var Stream = require2("./internal/streams/stream");
          var Buffer = require2("safe-buffer").Buffer;
          var OurUint8Array = global.Uint8Array || function() {
          };
          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk);
          }
          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
          }
          var util = Object.create(require2("core-util-is"));
          util.inherits = require2("inherits");
          var debugUtil = require2("../../../../util/util.js");
          var debug = void 0;
          if (debugUtil && debugUtil.debuglog) {
            debug = debugUtil.debuglog("stream");
          } else {
            debug = function debug2() {
            };
          }
          var BufferList = require2("./internal/streams/BufferList");
          var destroyImpl = require2("./internal/streams/destroy");
          var StringDecoder;
          util.inherits(Readable, Stream);
          var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
          function prependListener(emitter, event, fn) {
            if (typeof emitter.prependListener === "function")
              return emitter.prependListener(event, fn);
            if (!emitter._events || !emitter._events[event])
              emitter.on(event, fn);
            else if (isArray(emitter._events[event]))
              emitter._events[event].unshift(fn);
            else
              emitter._events[event] = [fn, emitter._events[event]];
          }
          function ReadableState(options, stream) {
            Duplex = Duplex || require2("./_stream_duplex");
            options = options || {};
            var isDuplex = stream instanceof Duplex;
            this.objectMode = !!options.objectMode;
            if (isDuplex)
              this.objectMode = this.objectMode || !!options.readableObjectMode;
            var hwm = options.highWaterMark;
            var readableHwm = options.readableHighWaterMark;
            var defaultHwm = this.objectMode ? 16 : 16 * 1024;
            if (hwm || hwm === 0)
              this.highWaterMark = hwm;
            else if (isDuplex && (readableHwm || readableHwm === 0))
              this.highWaterMark = readableHwm;
            else
              this.highWaterMark = defaultHwm;
            this.highWaterMark = Math.floor(this.highWaterMark);
            this.buffer = new BufferList();
            this.length = 0;
            this.pipes = null;
            this.pipesCount = 0;
            this.flowing = null;
            this.ended = false;
            this.endEmitted = false;
            this.reading = false;
            this.sync = true;
            this.needReadable = false;
            this.emittedReadable = false;
            this.readableListening = false;
            this.resumeScheduled = false;
            this.destroyed = false;
            this.defaultEncoding = options.defaultEncoding || "utf8";
            this.awaitDrain = 0;
            this.readingMore = false;
            this.decoder = null;
            this.encoding = null;
            if (options.encoding) {
              if (!StringDecoder)
                StringDecoder = require2("string_decoder/").StringDecoder;
              this.decoder = new StringDecoder(options.encoding);
              this.encoding = options.encoding;
            }
          }
          function Readable(options) {
            Duplex = Duplex || require2("./_stream_duplex");
            if (!(this instanceof Readable))
              return new Readable(options);
            this._readableState = new ReadableState(options, this);
            this.readable = true;
            if (options) {
              if (typeof options.read === "function")
                this._read = options.read;
              if (typeof options.destroy === "function")
                this._destroy = options.destroy;
            }
            Stream.call(this);
          }
          Object.defineProperty(Readable.prototype, "destroyed", {
            get: function get() {
              if (this._readableState === void 0) {
                return false;
              }
              return this._readableState.destroyed;
            },
            set: function set(value) {
              if (!this._readableState) {
                return;
              }
              this._readableState.destroyed = value;
            }
          });
          Readable.prototype.destroy = destroyImpl.destroy;
          Readable.prototype._undestroy = destroyImpl.undestroy;
          Readable.prototype._destroy = function(err, cb) {
            this.push(null);
            cb(err);
          };
          Readable.prototype.push = function(chunk, encoding) {
            var state = this._readableState;
            var skipChunkCheck;
            if (!state.objectMode) {
              if (typeof chunk === "string") {
                encoding = encoding || state.defaultEncoding;
                if (encoding !== state.encoding) {
                  chunk = Buffer.from(chunk, encoding);
                  encoding = "";
                }
                skipChunkCheck = true;
              }
            } else {
              skipChunkCheck = true;
            }
            return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
          };
          Readable.prototype.unshift = function(chunk) {
            return readableAddChunk(this, chunk, null, true, false);
          };
          function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
            var state = stream._readableState;
            if (chunk === null) {
              state.reading = false;
              onEofChunk(stream, state);
            } else {
              var er;
              if (!skipChunkCheck)
                er = chunkInvalid(state, chunk);
              if (er) {
                stream.emit("error", er);
              } else if (state.objectMode || chunk && chunk.length > 0) {
                if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                  chunk = _uint8ArrayToBuffer(chunk);
                }
                if (addToFront) {
                  if (state.endEmitted)
                    stream.emit("error", new Error("stream.unshift() after end event"));
                  else
                    addChunk(stream, state, chunk, true);
                } else if (state.ended) {
                  stream.emit("error", new Error("stream.push() after EOF"));
                } else {
                  state.reading = false;
                  if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0)
                      addChunk(stream, state, chunk, false);
                    else
                      maybeReadMore(stream, state);
                  } else {
                    addChunk(stream, state, chunk, false);
                  }
                }
              } else if (!addToFront) {
                state.reading = false;
              }
            }
            return needMoreData(state);
          }
          function addChunk(stream, state, chunk, addToFront) {
            if (state.flowing && state.length === 0 && !state.sync) {
              stream.emit("data", chunk);
              stream.read(0);
            } else {
              state.length += state.objectMode ? 1 : chunk.length;
              if (addToFront)
                state.buffer.unshift(chunk);
              else
                state.buffer.push(chunk);
              if (state.needReadable)
                emitReadable(stream);
            }
            maybeReadMore(stream, state);
          }
          function chunkInvalid(state, chunk) {
            var er;
            if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
              er = new TypeError("Invalid non-string/buffer chunk");
            }
            return er;
          }
          function needMoreData(state) {
            return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
          }
          Readable.prototype.isPaused = function() {
            return this._readableState.flowing === false;
          };
          Readable.prototype.setEncoding = function(enc) {
            if (!StringDecoder)
              StringDecoder = require2("string_decoder/").StringDecoder;
            this._readableState.decoder = new StringDecoder(enc);
            this._readableState.encoding = enc;
            return this;
          };
          var MAX_HWM = 8388608;
          function computeNewHighWaterMark(n) {
            if (n >= MAX_HWM) {
              n = MAX_HWM;
            } else {
              n--;
              n |= n >>> 1;
              n |= n >>> 2;
              n |= n >>> 4;
              n |= n >>> 8;
              n |= n >>> 16;
              n++;
            }
            return n;
          }
          function howMuchToRead(n, state) {
            if (n <= 0 || state.length === 0 && state.ended)
              return 0;
            if (state.objectMode)
              return 1;
            if (n !== n) {
              if (state.flowing && state.length)
                return state.buffer.head.data.length;
              else
                return state.length;
            }
            if (n > state.highWaterMark)
              state.highWaterMark = computeNewHighWaterMark(n);
            if (n <= state.length)
              return n;
            if (!state.ended) {
              state.needReadable = true;
              return 0;
            }
            return state.length;
          }
          Readable.prototype.read = function(n) {
            debug("read", n);
            n = parseInt(n, 10);
            var state = this._readableState;
            var nOrig = n;
            if (n !== 0)
              state.emittedReadable = false;
            if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
              debug("read: emitReadable", state.length, state.ended);
              if (state.length === 0 && state.ended)
                endReadable(this);
              else
                emitReadable(this);
              return null;
            }
            n = howMuchToRead(n, state);
            if (n === 0 && state.ended) {
              if (state.length === 0)
                endReadable(this);
              return null;
            }
            var doRead = state.needReadable;
            debug("need readable", doRead);
            if (state.length === 0 || state.length - n < state.highWaterMark) {
              doRead = true;
              debug("length less than watermark", doRead);
            }
            if (state.ended || state.reading) {
              doRead = false;
              debug("reading or ended", doRead);
            } else if (doRead) {
              debug("do read");
              state.reading = true;
              state.sync = true;
              if (state.length === 0)
                state.needReadable = true;
              this._read(state.highWaterMark);
              state.sync = false;
              if (!state.reading)
                n = howMuchToRead(nOrig, state);
            }
            var ret;
            if (n > 0)
              ret = fromList(n, state);
            else
              ret = null;
            if (ret === null) {
              state.needReadable = true;
              n = 0;
            } else {
              state.length -= n;
            }
            if (state.length === 0) {
              if (!state.ended)
                state.needReadable = true;
              if (nOrig !== n && state.ended)
                endReadable(this);
            }
            if (ret !== null)
              this.emit("data", ret);
            return ret;
          };
          function onEofChunk(stream, state) {
            if (state.ended)
              return;
            if (state.decoder) {
              var chunk = state.decoder.end();
              if (chunk && chunk.length) {
                state.buffer.push(chunk);
                state.length += state.objectMode ? 1 : chunk.length;
              }
            }
            state.ended = true;
            emitReadable(stream);
          }
          function emitReadable(stream) {
            var state = stream._readableState;
            state.needReadable = false;
            if (!state.emittedReadable) {
              debug("emitReadable", state.flowing);
              state.emittedReadable = true;
              if (state.sync)
                pna.nextTick(emitReadable_, stream);
              else
                emitReadable_(stream);
            }
          }
          function emitReadable_(stream) {
            debug("emit readable");
            stream.emit("readable");
            flow(stream);
          }
          function maybeReadMore(stream, state) {
            if (!state.readingMore) {
              state.readingMore = true;
              pna.nextTick(maybeReadMore_, stream, state);
            }
          }
          function maybeReadMore_(stream, state) {
            var len = state.length;
            while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
              debug("maybeReadMore read 0");
              stream.read(0);
              if (len === state.length)
                break;
              else
                len = state.length;
            }
            state.readingMore = false;
          }
          Readable.prototype._read = function(n) {
            this.emit("error", new Error("_read() is not implemented"));
          };
          Readable.prototype.pipe = function(dest, pipeOpts) {
            var src = this;
            var state = this._readableState;
            switch (state.pipesCount) {
              case 0:
                state.pipes = dest;
                break;
              case 1:
                state.pipes = [state.pipes, dest];
                break;
              default:
                state.pipes.push(dest);
                break;
            }
            state.pipesCount += 1;
            debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
            var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
            var endFn = doEnd ? onend : unpipe;
            if (state.endEmitted)
              pna.nextTick(endFn);
            else
              src.once("end", endFn);
            dest.on("unpipe", onunpipe);
            function onunpipe(readable, unpipeInfo) {
              debug("onunpipe");
              if (readable === src) {
                if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                  unpipeInfo.hasUnpiped = true;
                  cleanup();
                }
              }
            }
            function onend() {
              debug("onend");
              dest.end();
            }
            var ondrain = pipeOnDrain(src);
            dest.on("drain", ondrain);
            var cleanedUp = false;
            function cleanup() {
              debug("cleanup");
              dest.removeListener("close", onclose);
              dest.removeListener("finish", onfinish);
              dest.removeListener("drain", ondrain);
              dest.removeListener("error", onerror);
              dest.removeListener("unpipe", onunpipe);
              src.removeListener("end", onend);
              src.removeListener("end", unpipe);
              src.removeListener("data", ondata);
              cleanedUp = true;
              if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
                ondrain();
            }
            var increasedAwaitDrain = false;
            src.on("data", ondata);
            function ondata(chunk) {
              debug("ondata");
              increasedAwaitDrain = false;
              var ret = dest.write(chunk);
              if (false === ret && !increasedAwaitDrain) {
                if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                  debug("false write response, pause", src._readableState.awaitDrain);
                  src._readableState.awaitDrain++;
                  increasedAwaitDrain = true;
                }
                src.pause();
              }
            }
            function onerror(er) {
              debug("onerror", er);
              unpipe();
              dest.removeListener("error", onerror);
              if (EElistenerCount(dest, "error") === 0)
                dest.emit("error", er);
            }
            prependListener(dest, "error", onerror);
            function onclose() {
              dest.removeListener("finish", onfinish);
              unpipe();
            }
            dest.once("close", onclose);
            function onfinish() {
              debug("onfinish");
              dest.removeListener("close", onclose);
              unpipe();
            }
            dest.once("finish", onfinish);
            function unpipe() {
              debug("unpipe");
              src.unpipe(dest);
            }
            dest.emit("pipe", src);
            if (!state.flowing) {
              debug("pipe resume");
              src.resume();
            }
            return dest;
          };
          function pipeOnDrain(src) {
            return function() {
              var state = src._readableState;
              debug("pipeOnDrain", state.awaitDrain);
              if (state.awaitDrain)
                state.awaitDrain--;
              if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
                state.flowing = true;
                flow(src);
              }
            };
          }
          Readable.prototype.unpipe = function(dest) {
            var state = this._readableState;
            var unpipeInfo = {
              hasUnpiped: false
            };
            if (state.pipesCount === 0)
              return this;
            if (state.pipesCount === 1) {
              if (dest && dest !== state.pipes)
                return this;
              if (!dest)
                dest = state.pipes;
              state.pipes = null;
              state.pipesCount = 0;
              state.flowing = false;
              if (dest)
                dest.emit("unpipe", this, unpipeInfo);
              return this;
            }
            if (!dest) {
              var dests = state.pipes;
              var len = state.pipesCount;
              state.pipes = null;
              state.pipesCount = 0;
              state.flowing = false;
              for (var i = 0; i < len; i++) {
                dests[i].emit("unpipe", this, unpipeInfo);
              }
              return this;
            }
            var index = indexOf(state.pipes, dest);
            if (index === -1)
              return this;
            state.pipes.splice(index, 1);
            state.pipesCount -= 1;
            if (state.pipesCount === 1)
              state.pipes = state.pipes[0];
            dest.emit("unpipe", this, unpipeInfo);
            return this;
          };
          Readable.prototype.on = function(ev, fn) {
            var res = Stream.prototype.on.call(this, ev, fn);
            if (ev === "data") {
              if (this._readableState.flowing !== false)
                this.resume();
            } else if (ev === "readable") {
              var state = this._readableState;
              if (!state.endEmitted && !state.readableListening) {
                state.readableListening = state.needReadable = true;
                state.emittedReadable = false;
                if (!state.reading) {
                  pna.nextTick(nReadingNextTick, this);
                } else if (state.length) {
                  emitReadable(this);
                }
              }
            }
            return res;
          };
          Readable.prototype.addListener = Readable.prototype.on;
          function nReadingNextTick(self2) {
            debug("readable nexttick read 0");
            self2.read(0);
          }
          Readable.prototype.resume = function() {
            var state = this._readableState;
            if (!state.flowing) {
              debug("resume");
              state.flowing = true;
              resume(this, state);
            }
            return this;
          };
          function resume(stream, state) {
            if (!state.resumeScheduled) {
              state.resumeScheduled = true;
              pna.nextTick(resume_, stream, state);
            }
          }
          function resume_(stream, state) {
            if (!state.reading) {
              debug("resume read 0");
              stream.read(0);
            }
            state.resumeScheduled = false;
            state.awaitDrain = 0;
            stream.emit("resume");
            flow(stream);
            if (state.flowing && !state.reading)
              stream.read(0);
          }
          Readable.prototype.pause = function() {
            debug("call pause flowing=%j", this._readableState.flowing);
            if (false !== this._readableState.flowing) {
              debug("pause");
              this._readableState.flowing = false;
              this.emit("pause");
            }
            return this;
          };
          function flow(stream) {
            var state = stream._readableState;
            debug("flow", state.flowing);
            while (state.flowing && stream.read() !== null) {
            }
          }
          Readable.prototype.wrap = function(stream) {
            var _this = this;
            var state = this._readableState;
            var paused = false;
            stream.on("end", function() {
              debug("wrapped end");
              if (state.decoder && !state.ended) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length)
                  _this.push(chunk);
              }
              _this.push(null);
            });
            stream.on("data", function(chunk) {
              debug("wrapped data");
              if (state.decoder)
                chunk = state.decoder.write(chunk);
              if (state.objectMode && (chunk === null || chunk === void 0))
                return;
              else if (!state.objectMode && (!chunk || !chunk.length))
                return;
              var ret = _this.push(chunk);
              if (!ret) {
                paused = true;
                stream.pause();
              }
            });
            for (var i in stream) {
              if (this[i] === void 0 && typeof stream[i] === "function") {
                this[i] = function(method) {
                  return function() {
                    return stream[method].apply(stream, arguments);
                  };
                }(i);
              }
            }
            for (var n = 0; n < kProxyEvents.length; n++) {
              stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
            }
            this._read = function(n2) {
              debug("wrapped _read", n2);
              if (paused) {
                paused = false;
                stream.resume();
              }
            };
            return this;
          };
          Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
            enumerable: false,
            get: function get() {
              return this._readableState.highWaterMark;
            }
          });
          Readable._fromList = fromList;
          function fromList(n, state) {
            if (state.length === 0)
              return null;
            var ret;
            if (state.objectMode)
              ret = state.buffer.shift();
            else if (!n || n >= state.length) {
              if (state.decoder)
                ret = state.buffer.join("");
              else if (state.buffer.length === 1)
                ret = state.buffer.head.data;
              else
                ret = state.buffer.concat(state.length);
              state.buffer.clear();
            } else {
              ret = fromListPartial(n, state.buffer, state.decoder);
            }
            return ret;
          }
          function fromListPartial(n, list, hasStrings) {
            var ret;
            if (n < list.head.data.length) {
              ret = list.head.data.slice(0, n);
              list.head.data = list.head.data.slice(n);
            } else if (n === list.head.data.length) {
              ret = list.shift();
            } else {
              ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
            }
            return ret;
          }
          function copyFromBufferString(n, list) {
            var p = list.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    list.head = p.next;
                  else
                    list.head = list.tail = null;
                } else {
                  list.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            list.length -= c;
            return ret;
          }
          function copyFromBuffer(n, list) {
            var ret = Buffer.allocUnsafe(n);
            var p = list.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    list.head = p.next;
                  else
                    list.head = list.tail = null;
                } else {
                  list.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            list.length -= c;
            return ret;
          }
          function endReadable(stream) {
            var state = stream._readableState;
            if (state.length > 0)
              throw new Error('"endReadable()" called on non-empty stream');
            if (!state.endEmitted) {
              state.ended = true;
              pna.nextTick(endReadableNT, state, stream);
            }
          }
          function endReadableNT(state, stream) {
            if (!state.endEmitted && state.length === 0) {
              state.endEmitted = true;
              stream.readable = false;
              stream.emit("end");
            }
          }
          function indexOf(xs, x) {
            for (var i = 0, l = xs.length; i < l; i++) {
              if (xs[i] === x)
                return i;
            }
            return -1;
          }
        }).call(this);
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "../../../../util/util.js": 514, "./_stream_duplex": 97, "./internal/streams/BufferList": 102, "./internal/streams/destroy": 103, "./internal/streams/stream": 104, "_process": 361, "core-util-is": 108, "events": 193, "inherits": 256, "isarray": 263, "process-nextick-args": 360, "safe-buffer": 106, "string_decoder/": 107 }], 100: [function(require2, module2, exports2) {
      module2.exports = Transform;
      var Duplex = require2("./_stream_duplex");
      var util = Object.create(require2("core-util-is"));
      util.inherits = require2("inherits");
      util.inherits(Transform, Duplex);
      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (!cb) {
          return this.emit("error", new Error("write callback called multiple times"));
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform))
          return new Transform(options);
        Duplex.call(this, options);
        this._transformState = {
          afterTransform: afterTransform.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === "function") {
          this._flush(function(er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      };
      Transform.prototype._transform = function(chunk, encoding, cb) {
        throw new Error("_transform() is not implemented");
      };
      Transform.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform.prototype._destroy = function(err, cb) {
        var _this2 = this;
        Duplex.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
          _this2.emit("close");
        });
      };
      function done(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new Error("Calling transform done when ws.length != 0");
        if (stream._transformState.transforming)
          throw new Error("Calling transform done when still transforming");
        return stream.push(null);
      }
    }, { "./_stream_duplex": 97, "core-util-is": 108, "inherits": 256 }], 101: [function(require2, module2, exports2) {
      (function(process, global, setImmediate) {
        (function() {
          var pna = require2("process-nextick-args");
          module2.exports = Writable;
          function CorkedRequest(state) {
            var _this = this;
            this.next = null;
            this.entry = null;
            this.finish = function() {
              onCorkedFinish(_this, state);
            };
          }
          var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
          var Duplex;
          Writable.WritableState = WritableState;
          var util = Object.create(require2("core-util-is"));
          util.inherits = require2("inherits");
          var internalUtil = {
            deprecate: require2("util-deprecate")
          };
          var Stream = require2("./internal/streams/stream");
          var Buffer = require2("safe-buffer").Buffer;
          var OurUint8Array = global.Uint8Array || function() {
          };
          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk);
          }
          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
          }
          var destroyImpl = require2("./internal/streams/destroy");
          util.inherits(Writable, Stream);
          function nop() {
          }
          function WritableState(options, stream) {
            Duplex = Duplex || require2("./_stream_duplex");
            options = options || {};
            var isDuplex = stream instanceof Duplex;
            this.objectMode = !!options.objectMode;
            if (isDuplex)
              this.objectMode = this.objectMode || !!options.writableObjectMode;
            var hwm = options.highWaterMark;
            var writableHwm = options.writableHighWaterMark;
            var defaultHwm = this.objectMode ? 16 : 16 * 1024;
            if (hwm || hwm === 0)
              this.highWaterMark = hwm;
            else if (isDuplex && (writableHwm || writableHwm === 0))
              this.highWaterMark = writableHwm;
            else
              this.highWaterMark = defaultHwm;
            this.highWaterMark = Math.floor(this.highWaterMark);
            this.finalCalled = false;
            this.needDrain = false;
            this.ending = false;
            this.ended = false;
            this.finished = false;
            this.destroyed = false;
            var noDecode = options.decodeStrings === false;
            this.decodeStrings = !noDecode;
            this.defaultEncoding = options.defaultEncoding || "utf8";
            this.length = 0;
            this.writing = false;
            this.corked = 0;
            this.sync = true;
            this.bufferProcessing = false;
            this.onwrite = function(er) {
              onwrite(stream, er);
            };
            this.writecb = null;
            this.writelen = 0;
            this.bufferedRequest = null;
            this.lastBufferedRequest = null;
            this.pendingcb = 0;
            this.prefinished = false;
            this.errorEmitted = false;
            this.bufferedRequestCount = 0;
            this.corkedRequestsFree = new CorkedRequest(this);
          }
          WritableState.prototype.getBuffer = function getBuffer() {
            var current = this.bufferedRequest;
            var out = [];
            while (current) {
              out.push(current);
              current = current.next;
            }
            return out;
          };
          (function() {
            try {
              Object.defineProperty(WritableState.prototype, "buffer", {
                get: internalUtil.deprecate(function() {
                  return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
              });
            } catch (_) {
            }
          })();
          var realHasInstance;
          if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
            realHasInstance = Function.prototype[Symbol.hasInstance];
            Object.defineProperty(Writable, Symbol.hasInstance, {
              value: function value(object) {
                if (realHasInstance.call(this, object))
                  return true;
                if (this !== Writable)
                  return false;
                return object && object._writableState instanceof WritableState;
              }
            });
          } else {
            realHasInstance = function realHasInstance2(object) {
              return object instanceof this;
            };
          }
          function Writable(options) {
            Duplex = Duplex || require2("./_stream_duplex");
            if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
              return new Writable(options);
            }
            this._writableState = new WritableState(options, this);
            this.writable = true;
            if (options) {
              if (typeof options.write === "function")
                this._write = options.write;
              if (typeof options.writev === "function")
                this._writev = options.writev;
              if (typeof options.destroy === "function")
                this._destroy = options.destroy;
              if (typeof options.final === "function")
                this._final = options.final;
            }
            Stream.call(this);
          }
          Writable.prototype.pipe = function() {
            this.emit("error", new Error("Cannot pipe, not readable"));
          };
          function writeAfterEnd(stream, cb) {
            var er = new Error("write after end");
            stream.emit("error", er);
            pna.nextTick(cb, er);
          }
          function validChunk(stream, state, chunk, cb) {
            var valid = true;
            var er = false;
            if (chunk === null) {
              er = new TypeError("May not write null values to stream");
            } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
              er = new TypeError("Invalid non-string/buffer chunk");
            }
            if (er) {
              stream.emit("error", er);
              pna.nextTick(cb, er);
              valid = false;
            }
            return valid;
          }
          Writable.prototype.write = function(chunk, encoding, cb) {
            var state = this._writableState;
            var ret = false;
            var isBuf = !state.objectMode && _isUint8Array(chunk);
            if (isBuf && !Buffer.isBuffer(chunk)) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (typeof encoding === "function") {
              cb = encoding;
              encoding = null;
            }
            if (isBuf)
              encoding = "buffer";
            else if (!encoding)
              encoding = state.defaultEncoding;
            if (typeof cb !== "function")
              cb = nop;
            if (state.ended)
              writeAfterEnd(this, cb);
            else if (isBuf || validChunk(this, state, chunk, cb)) {
              state.pendingcb++;
              ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
            }
            return ret;
          };
          Writable.prototype.cork = function() {
            var state = this._writableState;
            state.corked++;
          };
          Writable.prototype.uncork = function() {
            var state = this._writableState;
            if (state.corked) {
              state.corked--;
              if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
                clearBuffer(this, state);
            }
          };
          Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
            if (typeof encoding === "string")
              encoding = encoding.toLowerCase();
            if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
              throw new TypeError("Unknown encoding: " + encoding);
            this._writableState.defaultEncoding = encoding;
            return this;
          };
          function decodeChunk(state, chunk, encoding) {
            if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
              chunk = Buffer.from(chunk, encoding);
            }
            return chunk;
          }
          Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
            enumerable: false,
            get: function get() {
              return this._writableState.highWaterMark;
            }
          });
          function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
            if (!isBuf) {
              var newChunk = decodeChunk(state, chunk, encoding);
              if (chunk !== newChunk) {
                isBuf = true;
                encoding = "buffer";
                chunk = newChunk;
              }
            }
            var len = state.objectMode ? 1 : chunk.length;
            state.length += len;
            var ret = state.length < state.highWaterMark;
            if (!ret)
              state.needDrain = true;
            if (state.writing || state.corked) {
              var last = state.lastBufferedRequest;
              state.lastBufferedRequest = {
                chunk,
                encoding,
                isBuf,
                callback: cb,
                next: null
              };
              if (last) {
                last.next = state.lastBufferedRequest;
              } else {
                state.bufferedRequest = state.lastBufferedRequest;
              }
              state.bufferedRequestCount += 1;
            } else {
              doWrite(stream, state, false, len, chunk, encoding, cb);
            }
            return ret;
          }
          function doWrite(stream, state, writev, len, chunk, encoding, cb) {
            state.writelen = len;
            state.writecb = cb;
            state.writing = true;
            state.sync = true;
            if (writev)
              stream._writev(chunk, state.onwrite);
            else
              stream._write(chunk, encoding, state.onwrite);
            state.sync = false;
          }
          function onwriteError(stream, state, sync, er, cb) {
            --state.pendingcb;
            if (sync) {
              pna.nextTick(cb, er);
              pna.nextTick(finishMaybe, stream, state);
              stream._writableState.errorEmitted = true;
              stream.emit("error", er);
            } else {
              cb(er);
              stream._writableState.errorEmitted = true;
              stream.emit("error", er);
              finishMaybe(stream, state);
            }
          }
          function onwriteStateUpdate(state) {
            state.writing = false;
            state.writecb = null;
            state.length -= state.writelen;
            state.writelen = 0;
          }
          function onwrite(stream, er) {
            var state = stream._writableState;
            var sync = state.sync;
            var cb = state.writecb;
            onwriteStateUpdate(state);
            if (er)
              onwriteError(stream, state, sync, er, cb);
            else {
              var finished = needFinish(state);
              if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                clearBuffer(stream, state);
              }
              if (sync) {
                asyncWrite(afterWrite, stream, state, finished, cb);
              } else {
                afterWrite(stream, state, finished, cb);
              }
            }
          }
          function afterWrite(stream, state, finished, cb) {
            if (!finished)
              onwriteDrain(stream, state);
            state.pendingcb--;
            cb();
            finishMaybe(stream, state);
          }
          function onwriteDrain(stream, state) {
            if (state.length === 0 && state.needDrain) {
              state.needDrain = false;
              stream.emit("drain");
            }
          }
          function clearBuffer(stream, state) {
            state.bufferProcessing = true;
            var entry = state.bufferedRequest;
            if (stream._writev && entry && entry.next) {
              var l = state.bufferedRequestCount;
              var buffer = new Array(l);
              var holder = state.corkedRequestsFree;
              holder.entry = entry;
              var count = 0;
              var allBuffers = true;
              while (entry) {
                buffer[count] = entry;
                if (!entry.isBuf)
                  allBuffers = false;
                entry = entry.next;
                count += 1;
              }
              buffer.allBuffers = allBuffers;
              doWrite(stream, state, true, state.length, buffer, "", holder.finish);
              state.pendingcb++;
              state.lastBufferedRequest = null;
              if (holder.next) {
                state.corkedRequestsFree = holder.next;
                holder.next = null;
              } else {
                state.corkedRequestsFree = new CorkedRequest(state);
              }
              state.bufferedRequestCount = 0;
            } else {
              while (entry) {
                var chunk = entry.chunk;
                var encoding = entry.encoding;
                var cb = entry.callback;
                var len = state.objectMode ? 1 : chunk.length;
                doWrite(stream, state, false, len, chunk, encoding, cb);
                entry = entry.next;
                state.bufferedRequestCount--;
                if (state.writing) {
                  break;
                }
              }
              if (entry === null)
                state.lastBufferedRequest = null;
            }
            state.bufferedRequest = entry;
            state.bufferProcessing = false;
          }
          Writable.prototype._write = function(chunk, encoding, cb) {
            cb(new Error("_write() is not implemented"));
          };
          Writable.prototype._writev = null;
          Writable.prototype.end = function(chunk, encoding, cb) {
            var state = this._writableState;
            if (typeof chunk === "function") {
              cb = chunk;
              chunk = null;
              encoding = null;
            } else if (typeof encoding === "function") {
              cb = encoding;
              encoding = null;
            }
            if (chunk !== null && chunk !== void 0)
              this.write(chunk, encoding);
            if (state.corked) {
              state.corked = 1;
              this.uncork();
            }
            if (!state.ending && !state.finished)
              endWritable(this, state, cb);
          };
          function needFinish(state) {
            return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
          }
          function callFinal(stream, state) {
            stream._final(function(err) {
              state.pendingcb--;
              if (err) {
                stream.emit("error", err);
              }
              state.prefinished = true;
              stream.emit("prefinish");
              finishMaybe(stream, state);
            });
          }
          function prefinish(stream, state) {
            if (!state.prefinished && !state.finalCalled) {
              if (typeof stream._final === "function") {
                state.pendingcb++;
                state.finalCalled = true;
                pna.nextTick(callFinal, stream, state);
              } else {
                state.prefinished = true;
                stream.emit("prefinish");
              }
            }
          }
          function finishMaybe(stream, state) {
            var need = needFinish(state);
            if (need) {
              prefinish(stream, state);
              if (state.pendingcb === 0) {
                state.finished = true;
                stream.emit("finish");
              }
            }
            return need;
          }
          function endWritable(stream, state, cb) {
            state.ending = true;
            finishMaybe(stream, state);
            if (cb) {
              if (state.finished)
                pna.nextTick(cb);
              else
                stream.once("finish", cb);
            }
            state.ended = true;
            stream.writable = false;
          }
          function onCorkedFinish(corkReq, state, err) {
            var entry = corkReq.entry;
            corkReq.entry = null;
            while (entry) {
              var cb = entry.callback;
              state.pendingcb--;
              cb(err);
              entry = entry.next;
            }
            if (state.corkedRequestsFree) {
              state.corkedRequestsFree.next = corkReq;
            } else {
              state.corkedRequestsFree = corkReq;
            }
          }
          Object.defineProperty(Writable.prototype, "destroyed", {
            get: function get() {
              if (this._writableState === void 0) {
                return false;
              }
              return this._writableState.destroyed;
            },
            set: function set(value) {
              if (!this._writableState) {
                return;
              }
              this._writableState.destroyed = value;
            }
          });
          Writable.prototype.destroy = destroyImpl.destroy;
          Writable.prototype._undestroy = destroyImpl.undestroy;
          Writable.prototype._destroy = function(err, cb) {
            this.end();
            cb(err);
          };
        }).call(this);
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require2("timers").setImmediate);
    }, { "./_stream_duplex": 97, "./internal/streams/destroy": 103, "./internal/streams/stream": 104, "_process": 361, "core-util-is": 108, "inherits": 256, "process-nextick-args": 360, "safe-buffer": 106, "timers": 506, "util-deprecate": 511 }], 102: [function(require2, module2, exports2) {
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var Buffer = require2("safe-buffer").Buffer;
      var util = require2("../../../../../../util/util.js");
      function copyBuffer(src, target, offset) {
        src.copy(target, offset);
      }
      module2.exports = function() {
        function BufferList() {
          _classCallCheck(this, BufferList);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        BufferList.prototype.push = function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        };
        BufferList.prototype.unshift = function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        };
        BufferList.prototype.shift = function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        };
        BufferList.prototype.clear = function clear() {
          this.head = this.tail = null;
          this.length = 0;
        };
        BufferList.prototype.join = function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) {
            ret += s + p.data;
          }
          return ret;
        };
        BufferList.prototype.concat = function concat(n) {
          if (this.length === 0)
            return Buffer.alloc(0);
          if (this.length === 1)
            return this.head.data;
          var ret = Buffer.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        };
        return BufferList;
      }();
      if (util && util.inspect && util.inspect.custom) {
        module2.exports.prototype[util.inspect.custom] = function() {
          var obj = util.inspect({
            length: this.length
          });
          return this.constructor.name + " " + obj;
        };
      }
    }, { "../../../../../../util/util.js": 514, "safe-buffer": 106 }], 103: [function(require2, module2, exports2) {
      var pna = require2("process-nextick-args");
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
            pna.nextTick(emitErrorNT, this, err);
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            pna.nextTick(emitErrorNT, _this, err2);
            if (_this._writableState) {
              _this._writableState.errorEmitted = true;
            }
          } else if (cb) {
            cb(err2);
          }
        });
        return this;
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      module2.exports = {
        destroy,
        undestroy
      };
    }, { "process-nextick-args": 360 }], 104: [function(require2, module2, exports2) {
      module2.exports = require2("events").EventEmitter;
    }, { "events": 193 }], 105: [function(require2, module2, exports2) {
      exports2 = module2.exports = require2("./lib/_stream_readable.js");
      exports2.Stream = exports2;
      exports2.Readable = exports2;
      exports2.Writable = require2("./lib/_stream_writable.js");
      exports2.Duplex = require2("./lib/_stream_duplex.js");
      exports2.Transform = require2("./lib/_stream_transform.js");
      exports2.PassThrough = require2("./lib/_stream_passthrough.js");
    }, { "./lib/_stream_duplex.js": 97, "./lib/_stream_passthrough.js": 98, "./lib/_stream_readable.js": 99, "./lib/_stream_transform.js": 100, "./lib/_stream_writable.js": 101 }], 106: [function(require2, module2, exports2) {
      var buffer = require2("buffer");
      var Buffer = buffer.Buffer;
      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }
      if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
        module2.exports = buffer;
      } else {
        copyProps(buffer, exports2);
        exports2.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer(arg, encodingOrOffset, length);
      }
      copyProps(Buffer, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer(size);
        if (fill !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer.SlowBuffer(size);
      };
    }, { "buffer": 82 }], 107: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      var isEncoding = Buffer.isEncoding || function(encoding) {
        encoding = "" + encoding;
        switch (encoding && encoding.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      function _normalizeEncoding(enc) {
        if (!enc)
          return "utf8";
        var retried;
        while (true) {
          switch (enc) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return enc;
            default:
              if (retried)
                return;
              enc = ("" + enc).toLowerCase();
              retried = true;
          }
        }
      }
      function normalizeEncoding(enc) {
        var nenc = _normalizeEncoding(enc);
        if (typeof nenc !== "string" && (Buffer.isEncoding === isEncoding || !isEncoding(enc)))
          throw new Error("Unknown encoding: " + enc);
        return nenc || enc;
      }
      exports2.StringDecoder = StringDecoder;
      function StringDecoder(encoding) {
        this.encoding = normalizeEncoding(encoding);
        var nb;
        switch (this.encoding) {
          case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
          case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
          case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
          default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
        }
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer.allocUnsafe(nb);
      }
      StringDecoder.prototype.write = function(buf) {
        if (buf.length === 0)
          return "";
        var r;
        var i;
        if (this.lastNeed) {
          r = this.fillLast(buf);
          if (r === void 0)
            return "";
          i = this.lastNeed;
          this.lastNeed = 0;
        } else {
          i = 0;
        }
        if (i < buf.length)
          return r ? r + this.text(buf, i) : this.text(buf, i);
        return r || "";
      };
      StringDecoder.prototype.end = utf8End;
      StringDecoder.prototype.text = utf8Text;
      StringDecoder.prototype.fillLast = function(buf) {
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
        this.lastNeed -= buf.length;
      };
      function utf8CheckByte(byte) {
        if (byte <= 127)
          return 0;
        else if (byte >> 5 === 6)
          return 2;
        else if (byte >> 4 === 14)
          return 3;
        else if (byte >> 3 === 30)
          return 4;
        return byte >> 6 === 2 ? -1 : -2;
      }
      function utf8CheckIncomplete(self2, buf, i) {
        var j = buf.length - 1;
        if (j < i)
          return 0;
        var nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0)
            self2.lastNeed = nb - 1;
          return nb;
        }
        if (--j < i || nb === -2)
          return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0)
            self2.lastNeed = nb - 2;
          return nb;
        }
        if (--j < i || nb === -2)
          return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) {
            if (nb === 2)
              nb = 0;
            else
              self2.lastNeed = nb - 3;
          }
          return nb;
        }
        return 0;
      }
      function utf8CheckExtraBytes(self2, buf, p) {
        if ((buf[0] & 192) !== 128) {
          self2.lastNeed = 0;
          return "\uFFFD";
        }
        if (self2.lastNeed > 1 && buf.length > 1) {
          if ((buf[1] & 192) !== 128) {
            self2.lastNeed = 1;
            return "\uFFFD";
          }
          if (self2.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 192) !== 128) {
              self2.lastNeed = 2;
              return "\uFFFD";
            }
          }
        }
      }
      function utf8FillLast(buf) {
        var p = this.lastTotal - this.lastNeed;
        var r = utf8CheckExtraBytes(this, buf);
        if (r !== void 0)
          return r;
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, p, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, p, 0, buf.length);
        this.lastNeed -= buf.length;
      }
      function utf8Text(buf, i) {
        var total = utf8CheckIncomplete(this, buf, i);
        if (!this.lastNeed)
          return buf.toString("utf8", i);
        this.lastTotal = total;
        var end = buf.length - (total - this.lastNeed);
        buf.copy(this.lastChar, 0, end);
        return buf.toString("utf8", i, end);
      }
      function utf8End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed)
          return r + "\uFFFD";
        return r;
      }
      function utf16Text(buf, i) {
        if ((buf.length - i) % 2 === 0) {
          var r = buf.toString("utf16le", i);
          if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 55296 && c <= 56319) {
              this.lastNeed = 2;
              this.lastTotal = 4;
              this.lastChar[0] = buf[buf.length - 2];
              this.lastChar[1] = buf[buf.length - 1];
              return r.slice(0, -1);
            }
          }
          return r;
        }
        this.lastNeed = 1;
        this.lastTotal = 2;
        this.lastChar[0] = buf[buf.length - 1];
        return buf.toString("utf16le", i, buf.length - 1);
      }
      function utf16End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) {
          var end = this.lastTotal - this.lastNeed;
          return r + this.lastChar.toString("utf16le", 0, end);
        }
        return r;
      }
      function base64Text(buf, i) {
        var n = (buf.length - i) % 3;
        if (n === 0)
          return buf.toString("base64", i);
        this.lastNeed = 3 - n;
        this.lastTotal = 3;
        if (n === 1) {
          this.lastChar[0] = buf[buf.length - 1];
        } else {
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
        }
        return buf.toString("base64", i, buf.length - n);
      }
      function base64End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed)
          return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
        return r;
      }
      function simpleWrite(buf) {
        return buf.toString(this.encoding);
      }
      function simpleEnd(buf) {
        return buf && buf.length ? this.write(buf) : "";
      }
    }, { "safe-buffer": 106 }], 108: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          function isArray(arg) {
            if (Array.isArray) {
              return Array.isArray(arg);
            }
            return objectToString(arg) === "[object Array]";
          }
          exports2.isArray = isArray;
          function isBoolean(arg) {
            return typeof arg === "boolean";
          }
          exports2.isBoolean = isBoolean;
          function isNull(arg) {
            return arg === null;
          }
          exports2.isNull = isNull;
          function isNullOrUndefined(arg) {
            return arg == null;
          }
          exports2.isNullOrUndefined = isNullOrUndefined;
          function isNumber(arg) {
            return typeof arg === "number";
          }
          exports2.isNumber = isNumber;
          function isString(arg) {
            return typeof arg === "string";
          }
          exports2.isString = isString;
          function isSymbol(arg) {
            return typeof arg === "symbol";
          }
          exports2.isSymbol = isSymbol;
          function isUndefined(arg) {
            return arg === void 0;
          }
          exports2.isUndefined = isUndefined;
          function isRegExp(re) {
            return objectToString(re) === "[object RegExp]";
          }
          exports2.isRegExp = isRegExp;
          function isObject(arg) {
            return typeof arg === "object" && arg !== null;
          }
          exports2.isObject = isObject;
          function isDate(d) {
            return objectToString(d) === "[object Date]";
          }
          exports2.isDate = isDate;
          function isError(e) {
            return objectToString(e) === "[object Error]" || e instanceof Error;
          }
          exports2.isError = isError;
          function isFunction(arg) {
            return typeof arg === "function";
          }
          exports2.isFunction = isFunction;
          function isPrimitive(arg) {
            return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
          }
          exports2.isPrimitive = isPrimitive;
          exports2.isBuffer = Buffer.isBuffer;
          function objectToString(o) {
            return Object.prototype.toString.call(o);
          }
        }).call(this);
      }).call(this, { "isBuffer": require2("../../is-buffer/index.js") });
    }, { "../../is-buffer/index.js": 259 }], 109: [function(require2, module2, exports2) {
      (function(process, Buffer) {
        (function() {
          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              if (enumerableOnly)
                symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
              keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              if (i % 2) {
                ownKeys(Object(source), true).forEach(function(key) {
                  _defineProperty(target, key, source[key]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys(Object(source)).forEach(function(key) {
                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
              }
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var HypercoreProtocol = require2("hypercore-protocol");
          var Nanoresource = require2("nanoresource/emitter");
          var hypercore = require2("hypercore");
          var hypercoreCrypto = require2("hypercore-crypto");
          var datEncoding = require2("dat-encoding");
          var maybe = require2("call-me-maybe");
          var RefPool = require2("refpool");
          var deriveSeed = require2("derive-key");
          var derivedStorage = require2("derived-key-storage");
          var raf = require2("random-access-file");
          var MASTER_KEY_FILENAME = "master_key";
          var NAMESPACE = "corestore";
          var NAMESPACE_SEPERATOR = ":";
          class InnerCorestore extends Nanoresource {
            constructor(storage) {
              var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              super();
              if (typeof storage === "string")
                storage = defaultStorage(storage);
              if (typeof storage !== "function")
                throw new Error("Storage should be a function or string");
              this.storage = storage;
              this.opts = opts;
              this._replicationStreams = [];
              this.cache = new RefPool({
                maxSize: opts.cacheSize || 1e3,
                close: (core) => {
                  core.close((err) => {
                    if (err)
                      this.emit("error", err);
                  });
                }
              });
              this._masterKey = opts.masterKey || null;
              this._id = hypercoreCrypto.randomBytes(8);
              this.setMaxListeners(0);
            }
            _open(cb) {
              if (this._masterKey)
                return cb();
              var keyStorage = this.storage(MASTER_KEY_FILENAME);
              keyStorage.read(0, 32, (err, key) => {
                if (err) {
                  this._masterKey = hypercoreCrypto.randomBytes(32);
                  return keyStorage.write(0, this._masterKey, (err2) => {
                    if (err2)
                      return cb(err2);
                    keyStorage.close(cb);
                  });
                }
                this._masterKey = key;
                keyStorage.close(cb);
              });
            }
            _close(cb) {
              var error = null;
              for (var {
                stream
              } of this._replicationStreams) {
                stream.destroy();
              }
              if (!this.cache.size)
                return process.nextTick(cb, null);
              var remaining = this.cache.size;
              for (var {
                value: core
              } of this.cache.entries.values()) {
                core.close((err) => {
                  if (err)
                    error = err;
                  if (!--remaining) {
                    if (error)
                      return cb(error);
                    return cb(null);
                  }
                });
              }
            }
            _checkIfExists(dkey, cb) {
              dkey = encodeKey(dkey);
              if (this.cache.has(dkey))
                return process.nextTick(cb, null, true);
              var coreStorage = this.storage([dkey.slice(0, 2), dkey.slice(2, 4), dkey, "key"].join("/"));
              coreStorage.read(0, 32, (err, key) => {
                if (err)
                  return cb(err);
                coreStorage.close((err2) => {
                  if (err2)
                    return cb(err2);
                  if (!key)
                    return cb(null, false);
                  return cb(null, true);
                });
              });
            }
            _injectIntoReplicationStreams(core) {
              for (var {
                stream,
                opts
              } of this._replicationStreams) {
                this._replicateCore(false, core, stream, _objectSpread({}, opts));
              }
            }
            _replicateCore(isInitiator, core, mainStream, opts) {
              if (!core)
                return;
              core.ready(function(err) {
                if (err)
                  return;
                core.replicate(isInitiator, _objectSpread(_objectSpread({}, opts), {}, {
                  stream: mainStream
                }));
              });
            }
            _deriveSecret(namespace, name) {
              return deriveSeed(namespace, this._masterKey, name);
            }
            _generateKeyPair(name) {
              if (typeof name === "string")
                name = Buffer.from(name);
              else if (!name)
                name = hypercoreCrypto.randomBytes(32);
              var seed = this._deriveSecret(NAMESPACE, name);
              var keyPair = hypercoreCrypto.keyPair(seed);
              var discoveryKey = hypercoreCrypto.discoveryKey(keyPair.publicKey);
              return {
                name,
                publicKey: keyPair.publicKey,
                secretKey: keyPair.secretKey,
                discoveryKey
              };
            }
            _generateKeys(coreOpts) {
              if (!coreOpts)
                coreOpts = {};
              if (typeof coreOpts === "string")
                coreOpts = Buffer.from(coreOpts, "hex");
              if (Buffer.isBuffer(coreOpts))
                coreOpts = {
                  key: coreOpts
                };
              if (coreOpts.keyPair) {
                var publicKey = coreOpts.keyPair.publicKey;
                var secretKey = coreOpts.keyPair.secretKey;
                return {
                  publicKey,
                  secretKey,
                  discoveryKey: hypercoreCrypto.discoveryKey(publicKey),
                  name: null
                };
              }
              if (coreOpts.key) {
                var _publicKey = decodeKey(coreOpts.key);
                return {
                  publicKey: _publicKey,
                  secretKey: null,
                  discoveryKey: hypercoreCrypto.discoveryKey(_publicKey),
                  name: null
                };
              }
              if (coreOpts.default || coreOpts.name) {
                if (!coreOpts.name)
                  throw new Error("If the default option is set, a name must be specified.");
                return this._generateKeyPair(coreOpts.name);
              }
              if (coreOpts.discoveryKey) {
                var discoveryKey = decodeKey(coreOpts.discoveryKey);
                return {
                  publicKey: null,
                  secretKey: null,
                  discoveryKey,
                  name: null
                };
              }
              return this._generateKeyPair(null);
            }
            isLoaded(coreOpts) {
              var generatedKeys = this._generateKeys(coreOpts);
              return this.cache.has(encodeKey(generatedKeys.discoveryKey));
            }
            isExternal(coreOpts) {
              var generatedKeys = this._generateKeys(coreOpts);
              var entry = this._cache.entry(encodeKey(generatedKeys.discoveryKey));
              if (!entry)
                return false;
              return entry.refs !== 0;
            }
            get() {
              var coreOpts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              if (!this.opened)
                throw new Error("Corestore.ready must be called before get.");
              var self2 = this;
              var generatedKeys = this._generateKeys(coreOpts);
              var {
                publicKey,
                discoveryKey,
                secretKey
              } = generatedKeys;
              var id = encodeKey(discoveryKey);
              var cached = this.cache.get(id);
              if (cached)
                return cached;
              var storageRoot = [id.slice(0, 2), id.slice(2, 4), id].join("/");
              var keyStorage = derivedStorage(createStorage, (name, cb) => {
                if (name) {
                  var res = this._generateKeyPair(name);
                  if (discoveryKey && !discoveryKey.equals(res.discoveryKey)) {
                    return cb(new Error("Stored an incorrect name."));
                  }
                  return cb(null, res);
                }
                if (secretKey)
                  return cb(null, generatedKeys);
                if (publicKey)
                  return cb(null, {
                    name: null,
                    publicKey,
                    secretKey: null
                  });
                var err = new Error("Unknown key pair.");
                err.unknownKeyPair = true;
                return cb(err);
              });
              var cacheOpts = _objectSpread({}, this.opts.cache);
              if (coreOpts.cache) {
                if (coreOpts.cache.data === false)
                  delete cacheOpts.data;
                if (coreOpts.cache.tree === false)
                  delete cacheOpts.tree;
              }
              if (cacheOpts.data)
                cacheOpts.data = cacheOpts.data.namespace();
              if (cacheOpts.tree)
                cacheOpts.tree = cacheOpts.tree.namespace();
              var core = hypercore((name) => {
                if (name === "key")
                  return keyStorage.key;
                if (name === "secret_key")
                  return keyStorage.secretKey;
                return createStorage(name);
              }, publicKey, _objectSpread(_objectSpread(_objectSpread({}, this.opts), coreOpts), {}, {
                cache: cacheOpts,
                createIfMissing: !!publicKey
              }));
              this.cache.set(id, core);
              core.ifAvailable.wait();
              var errored = false;
              core.once("error", onerror);
              core.once("ready", onready);
              core.once("close", onclose);
              return core;
              function onready() {
                if (errored)
                  return;
                self2.emit("feed", core, coreOpts);
                core.removeListener("error", onerror);
                self2._injectIntoReplicationStreams(core);
                process.nextTick(() => core.ifAvailable.continue());
              }
              function onerror(err) {
                errored = true;
                core.ifAvailable.continue();
                self2.cache.delete(id);
                if (err.unknownKeyPair)
                  ;
              }
              function onclose() {
                self2.cache.delete(id);
              }
              function createStorage(name) {
                return self2.storage(storageRoot + "/" + name);
              }
            }
            replicate(isInitiator, cores) {
              var replicationOpts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
              var self2 = this;
              var finalOpts = _objectSpread(_objectSpread({}, this.opts), replicationOpts);
              var mainStream = replicationOpts.stream || new HypercoreProtocol(isInitiator, _objectSpread({}, finalOpts));
              var closed = false;
              for (var core of cores) {
                this._replicateCore(isInitiator, core, mainStream, _objectSpread({}, finalOpts));
              }
              mainStream.on("discovery-key", ondiscoverykey);
              mainStream.on("finish", onclose);
              mainStream.on("end", onclose);
              mainStream.on("close", onclose);
              var streamState = {
                stream: mainStream,
                opts: finalOpts
              };
              this._replicationStreams.push(streamState);
              return mainStream;
              function ondiscoverykey(dkey) {
                self2._checkIfExists(dkey, (err, exists) => {
                  if (closed)
                    return;
                  if (err || !exists)
                    return mainStream.close(dkey);
                  var passiveCore = self2.get({
                    discoveryKey: dkey
                  });
                  self2._replicateCore(false, passiveCore, mainStream, _objectSpread({}, finalOpts));
                });
              }
              function onclose() {
                if (!closed) {
                  self2._replicationStreams.splice(self2._replicationStreams.indexOf(streamState), 1);
                  closed = true;
                }
              }
            }
          }
          class Corestore extends Nanoresource {
            constructor(storage) {
              var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              super();
              this.storage = storage;
              this.name = opts.name || "default";
              this.inner = opts.inner || new InnerCorestore(storage, opts);
              this.cache = this.inner.cache;
              this.store = this;
              this._parent = opts.parent;
              this._isNamespaced = !!opts.name;
              this._openedCores = /* @__PURE__ */ new Map();
              var onfeed = (feed) => this.emit("feed", feed);
              var onerror = (err) => this.emit("error", err);
              this.inner.on("feed", onfeed);
              this.inner.on("error", onerror);
              this._unlisten = () => {
                this.inner.removeListener("feed", onfeed);
                this.inner.removeListener("error", onerror);
              };
            }
            ready(cb) {
              return maybe(cb, new Promise((resolve, reject) => {
                this.open((err) => {
                  if (err)
                    return reject(err);
                  return resolve();
                });
              }));
            }
            _open(cb) {
              return this.inner.open(cb);
            }
            _close(cb) {
              this._unlisten();
              if (!this._parent)
                return this.inner.close(cb);
              for (var dkey of this._openedCores) {
                this.cache.decrement(dkey);
              }
              return process.nextTick(cb, null);
            }
            _maybeIncrement(core) {
              var id = encodeKey(core.discoveryKey);
              if (this._openedCores.has(id))
                return;
              this._openedCores.set(id, core);
              this.cache.increment(id);
            }
            get() {
              var coreOpts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              if (Buffer.isBuffer(coreOpts))
                coreOpts = {
                  key: coreOpts
                };
              var core = this.inner.get(coreOpts);
              this._maybeIncrement(core);
              return core;
            }
            default() {
              var coreOpts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              if (Buffer.isBuffer(coreOpts))
                coreOpts = {
                  key: coreOpts
                };
              return this.get(_objectSpread(_objectSpread({}, coreOpts), {}, {
                name: this.name
              }));
            }
            namespace(name) {
              if (!name)
                name = hypercoreCrypto.randomBytes(32);
              if (Buffer.isBuffer(name))
                name = name.toString("hex");
              name = this._isNamespaced ? this.name + NAMESPACE_SEPERATOR + name : name;
              return new Corestore(this.storage, {
                inner: this.inner,
                parent: this,
                name
              });
            }
            replicate(isInitiator, opts) {
              var cores = !this._parent ? allReferenced(this.cache) : this._openedCores.values();
              return this.inner.replicate(isInitiator, cores, opts);
            }
            isLoaded(coreOpts) {
              return this.inner.isLoaded(coreOpts);
            }
            isExternal(coreOpts) {
              return this.inner.isExternal(coreOpts);
            }
            list() {
              return new Map([...this._openedCores]);
            }
          }
          function* allReferenced(cache) {
            for (var entry of cache.entries.values()) {
              if (entry.refs > 0)
                yield entry.value;
              continue;
            }
          }
          function encodeKey(key) {
            return Buffer.isBuffer(key) ? datEncoding.encode(key) : key;
          }
          function decodeKey(key) {
            return typeof key === "string" ? datEncoding.decode(key) : key;
          }
          function defaultStorage(dir) {
            return function(name) {
              try {
                var lock = name.endsWith("/bitfield") ? require2("fd-lock") : null;
              } catch (err) {
              }
              return raf(name, {
                directory: dir,
                lock
              });
            };
          }
          module2.exports = Corestore;
        }).call(this);
      }).call(this, require2("_process"), require2("buffer").Buffer);
    }, { "_process": 361, "buffer": 82, "call-me-maybe": 90, "dat-encoding": 118, "derive-key": 130, "derived-key-storage": 131, "fd-lock": 199, "hypercore": 230, "hypercore-crypto": 227, "hypercore-protocol": 228, "nanoresource/emitter": 327, "random-access-file": 379, "refpool": 414 }], 110: [function(require2, module2, exports2) {
      module2.exports = function(v) {
        var c = 32;
        v &= -v;
        if (v)
          c--;
        if (v & 65535)
          c -= 16;
        if (v & 16711935)
          c -= 8;
        if (v & 252645135)
          c -= 4;
        if (v & 858993459)
          c -= 2;
        if (v & 1431655765)
          c -= 1;
        return c;
      };
    }, {}], 111: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var elliptic = require2("elliptic");
          var BN = require2("bn.js");
          module2.exports = function createECDH(curve) {
            return new ECDH(curve);
          };
          var aliases = {
            secp256k1: {
              name: "secp256k1",
              byteLength: 32
            },
            secp224r1: {
              name: "p224",
              byteLength: 28
            },
            prime256v1: {
              name: "p256",
              byteLength: 32
            },
            prime192v1: {
              name: "p192",
              byteLength: 24
            },
            ed25519: {
              name: "ed25519",
              byteLength: 32
            },
            secp384r1: {
              name: "p384",
              byteLength: 48
            },
            secp521r1: {
              name: "p521",
              byteLength: 66
            }
          };
          aliases.p224 = aliases.secp224r1;
          aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
          aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
          aliases.p384 = aliases.secp384r1;
          aliases.p521 = aliases.secp521r1;
          function ECDH(curve) {
            this.curveType = aliases[curve];
            if (!this.curveType) {
              this.curveType = {
                name: curve
              };
            }
            this.curve = new elliptic.ec(this.curveType.name);
            this.keys = void 0;
          }
          ECDH.prototype.generateKeys = function(enc, format) {
            this.keys = this.curve.genKeyPair();
            return this.getPublicKey(enc, format);
          };
          ECDH.prototype.computeSecret = function(other, inenc, enc) {
            inenc = inenc || "utf8";
            if (!Buffer.isBuffer(other)) {
              other = new Buffer(other, inenc);
            }
            var otherPub = this.curve.keyFromPublic(other).getPublic();
            var out = otherPub.mul(this.keys.getPrivate()).getX();
            return formatReturnValue(out, enc, this.curveType.byteLength);
          };
          ECDH.prototype.getPublicKey = function(enc, format) {
            var key = this.keys.getPublic(format === "compressed", true);
            if (format === "hybrid") {
              if (key[key.length - 1] % 2) {
                key[0] = 7;
              } else {
                key[0] = 6;
              }
            }
            return formatReturnValue(key, enc);
          };
          ECDH.prototype.getPrivateKey = function(enc) {
            return formatReturnValue(this.keys.getPrivate(), enc);
          };
          ECDH.prototype.setPublicKey = function(pub, enc) {
            enc = enc || "utf8";
            if (!Buffer.isBuffer(pub)) {
              pub = new Buffer(pub, enc);
            }
            this.keys._importPublic(pub);
            return this;
          };
          ECDH.prototype.setPrivateKey = function(priv, enc) {
            enc = enc || "utf8";
            if (!Buffer.isBuffer(priv)) {
              priv = new Buffer(priv, enc);
            }
            var _priv = new BN(priv);
            _priv = _priv.toString(16);
            this.keys = this.curve.genKeyPair();
            this.keys._importPrivate(_priv);
            return this;
          };
          function formatReturnValue(bn, enc, len) {
            if (!Array.isArray(bn)) {
              bn = bn.toArray();
            }
            var buf = new Buffer(bn);
            if (len && buf.length < len) {
              var zeros = new Buffer(len - buf.length);
              zeros.fill(0);
              buf = Buffer.concat([zeros, buf]);
            }
            if (!enc) {
              return buf;
            } else {
              return buf.toString(enc);
            }
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "bn.js": 112, "buffer": 82, "elliptic": 167 }], 112: [function(require2, module2, exports2) {
      arguments[4][35][0].apply(exports2, arguments);
    }, { "buffer": 53, "dup": 35 }], 113: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var MD5 = require2("md5.js");
      var RIPEMD160 = require2("ripemd160");
      var sha = require2("sha.js");
      var Base = require2("cipher-base");
      function Hash(hash) {
        Base.call(this, "digest");
        this._hash = hash;
      }
      inherits(Hash, Base);
      Hash.prototype._update = function(data) {
        this._hash.update(data);
      };
      Hash.prototype._final = function() {
        return this._hash.digest();
      };
      module2.exports = function createHash(alg) {
        alg = alg.toLowerCase();
        if (alg === "md5")
          return new MD5();
        if (alg === "rmd160" || alg === "ripemd160")
          return new RIPEMD160();
        return new Hash(sha(alg));
      };
    }, { "cipher-base": 92, "inherits": 256, "md5.js": 284, "ripemd160": 416, "sha.js": 420 }], 114: [function(require2, module2, exports2) {
      var MD5 = require2("md5.js");
      module2.exports = function(buffer) {
        return new MD5().update(buffer).digest();
      };
    }, { "md5.js": 284 }], 115: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Legacy = require2("./legacy");
      var Base = require2("cipher-base");
      var Buffer = require2("safe-buffer").Buffer;
      var md5 = require2("create-hash/md5");
      var RIPEMD160 = require2("ripemd160");
      var sha = require2("sha.js");
      var ZEROS = Buffer.alloc(128);
      function Hmac(alg, key) {
        Base.call(this, "digest");
        if (typeof key === "string") {
          key = Buffer.from(key);
        }
        var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
        this._alg = alg;
        this._key = key;
        if (key.length > blocksize) {
          var hash = alg === "rmd160" ? new RIPEMD160() : sha(alg);
          key = hash.update(key).digest();
        } else if (key.length < blocksize) {
          key = Buffer.concat([key, ZEROS], blocksize);
        }
        var ipad = this._ipad = Buffer.allocUnsafe(blocksize);
        var opad = this._opad = Buffer.allocUnsafe(blocksize);
        for (var i = 0; i < blocksize; i++) {
          ipad[i] = key[i] ^ 54;
          opad[i] = key[i] ^ 92;
        }
        this._hash = alg === "rmd160" ? new RIPEMD160() : sha(alg);
        this._hash.update(ipad);
      }
      inherits(Hmac, Base);
      Hmac.prototype._update = function(data) {
        this._hash.update(data);
      };
      Hmac.prototype._final = function() {
        var h = this._hash.digest();
        var hash = this._alg === "rmd160" ? new RIPEMD160() : sha(this._alg);
        return hash.update(this._opad).update(h).digest();
      };
      module2.exports = function createHmac(alg, key) {
        alg = alg.toLowerCase();
        if (alg === "rmd160" || alg === "ripemd160") {
          return new Hmac("rmd160", key);
        }
        if (alg === "md5") {
          return new Legacy(md5, key);
        }
        return new Hmac(alg, key);
      };
    }, { "./legacy": 116, "cipher-base": 92, "create-hash/md5": 114, "inherits": 256, "ripemd160": 416, "safe-buffer": 417, "sha.js": 420 }], 116: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Buffer = require2("safe-buffer").Buffer;
      var Base = require2("cipher-base");
      var ZEROS = Buffer.alloc(128);
      var blocksize = 64;
      function Hmac(alg, key) {
        Base.call(this, "digest");
        if (typeof key === "string") {
          key = Buffer.from(key);
        }
        this._alg = alg;
        this._key = key;
        if (key.length > blocksize) {
          key = alg(key);
        } else if (key.length < blocksize) {
          key = Buffer.concat([key, ZEROS], blocksize);
        }
        var ipad = this._ipad = Buffer.allocUnsafe(blocksize);
        var opad = this._opad = Buffer.allocUnsafe(blocksize);
        for (var i = 0; i < blocksize; i++) {
          ipad[i] = key[i] ^ 54;
          opad[i] = key[i] ^ 92;
        }
        this._hash = [ipad];
      }
      inherits(Hmac, Base);
      Hmac.prototype._update = function(data) {
        this._hash.push(data);
      };
      Hmac.prototype._final = function() {
        var h = this._alg(Buffer.concat(this._hash));
        return this._alg(Buffer.concat([this._opad, h]));
      };
      module2.exports = Hmac;
    }, { "cipher-base": 92, "inherits": 256, "safe-buffer": 417 }], 117: [function(require2, module2, exports2) {
      exports2.randomBytes = exports2.rng = exports2.pseudoRandomBytes = exports2.prng = require2("randombytes");
      exports2.createHash = exports2.Hash = require2("create-hash");
      exports2.createHmac = exports2.Hmac = require2("create-hmac");
      var algos = require2("browserify-sign/algos");
      var algoKeys = Object.keys(algos);
      var hashes = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(algoKeys);
      exports2.getHashes = function() {
        return hashes;
      };
      var p = require2("pbkdf2");
      exports2.pbkdf2 = p.pbkdf2;
      exports2.pbkdf2Sync = p.pbkdf2Sync;
      var aes = require2("browserify-cipher");
      exports2.Cipher = aes.Cipher;
      exports2.createCipher = aes.createCipher;
      exports2.Cipheriv = aes.Cipheriv;
      exports2.createCipheriv = aes.createCipheriv;
      exports2.Decipher = aes.Decipher;
      exports2.createDecipher = aes.createDecipher;
      exports2.Decipheriv = aes.Decipheriv;
      exports2.createDecipheriv = aes.createDecipheriv;
      exports2.getCiphers = aes.getCiphers;
      exports2.listCiphers = aes.listCiphers;
      var dh = require2("diffie-hellman");
      exports2.DiffieHellmanGroup = dh.DiffieHellmanGroup;
      exports2.createDiffieHellmanGroup = dh.createDiffieHellmanGroup;
      exports2.getDiffieHellman = dh.getDiffieHellman;
      exports2.createDiffieHellman = dh.createDiffieHellman;
      exports2.DiffieHellman = dh.DiffieHellman;
      var sign = require2("browserify-sign");
      exports2.createSign = sign.createSign;
      exports2.Sign = sign.Sign;
      exports2.createVerify = sign.createVerify;
      exports2.Verify = sign.Verify;
      exports2.createECDH = require2("create-ecdh");
      var publicEncrypt = require2("public-encrypt");
      exports2.publicEncrypt = publicEncrypt.publicEncrypt;
      exports2.privateEncrypt = publicEncrypt.privateEncrypt;
      exports2.publicDecrypt = publicEncrypt.publicDecrypt;
      exports2.privateDecrypt = publicEncrypt.privateDecrypt;
      var rf = require2("randomfill");
      exports2.randomFill = rf.randomFill;
      exports2.randomFillSync = rf.randomFillSync;
      exports2.createCredentials = function() {
        throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join("\n"));
      };
      exports2.constants = {
        "DH_CHECK_P_NOT_SAFE_PRIME": 2,
        "DH_CHECK_P_NOT_PRIME": 1,
        "DH_UNABLE_TO_CHECK_GENERATOR": 4,
        "DH_NOT_SUITABLE_GENERATOR": 8,
        "NPN_ENABLED": 1,
        "ALPN_ENABLED": 1,
        "RSA_PKCS1_PADDING": 1,
        "RSA_SSLV23_PADDING": 2,
        "RSA_NO_PADDING": 3,
        "RSA_PKCS1_OAEP_PADDING": 4,
        "RSA_X931_PADDING": 5,
        "RSA_PKCS1_PSS_PADDING": 6,
        "POINT_CONVERSION_COMPRESSED": 2,
        "POINT_CONVERSION_UNCOMPRESSED": 4,
        "POINT_CONVERSION_HYBRID": 6
      };
    }, { "browserify-cipher": 71, "browserify-sign": 78, "browserify-sign/algos": 75, "create-ecdh": 111, "create-hash": 113, "create-hmac": 115, "diffie-hellman": 138, "pbkdf2": 353, "public-encrypt": 369, "randombytes": 382, "randomfill": 383 }], 118: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      function encode(buf) {
        if (typeof buf === "string")
          return encode(decode(buf));
        if (!Buffer.isBuffer(buf))
          throw new Error("Not a buffer");
        if (buf.length !== 32)
          throw new Error("Invalid buffer");
        return buf.toString("hex");
      }
      function decode(str) {
        if (Buffer.isBuffer(str))
          return decode(encode(str));
        if (typeof str !== "string")
          throw new Error("Not a string");
        var match = /([a-f0-9]{64,65})/i.exec(str);
        if (!match || match[1].length !== 64)
          throw new Error("Invalid key");
        return Buffer.from(match[1], "hex");
      }
      exports2.encode = exports2.toStr = encode;
      exports2.decode = exports2.toBuf = decode;
    }, { "safe-buffer": 417 }], 119: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          exports2.formatArgs = formatArgs;
          exports2.save = save;
          exports2.load = load;
          exports2.useColors = useColors;
          exports2.storage = localstorage();
          exports2.destroy = (() => {
            var warned = false;
            return () => {
              if (!warned) {
                warned = true;
                console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
              }
            };
          })();
          exports2.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
          function useColors() {
            if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
              return true;
            }
            if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
              return false;
            }
            return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
          }
          function formatArgs(args) {
            args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
            if (!this.useColors) {
              return;
            }
            var c = "color: " + this.color;
            args.splice(1, 0, c, "color: inherit");
            var index = 0;
            var lastC = 0;
            args[0].replace(/%[a-zA-Z%]/g, (match) => {
              if (match === "%%") {
                return;
              }
              index++;
              if (match === "%c") {
                lastC = index;
              }
            });
            args.splice(lastC, 0, c);
          }
          exports2.log = console.debug || console.log || (() => {
          });
          function save(namespaces) {
            try {
              if (namespaces) {
                exports2.storage.setItem("debug", namespaces);
              } else {
                exports2.storage.removeItem("debug");
              }
            } catch (error) {
            }
          }
          function load() {
            var r;
            try {
              r = exports2.storage.getItem("debug");
            } catch (error) {
            }
            if (!r && typeof process !== "undefined" && "env" in process) {
              r = process.env.DEBUG;
            }
            return r;
          }
          function localstorage() {
            try {
              return localStorage;
            } catch (error) {
            }
          }
          module2.exports = require2("./common")(exports2);
          var {
            formatters
          } = module2.exports;
          formatters.j = function(v) {
            try {
              return JSON.stringify(v);
            } catch (error) {
              return "[UnexpectedJSONParseError]: " + error.message;
            }
          };
        }).call(this);
      }).call(this, require2("_process"));
    }, { "./common": 120, "_process": 361 }], 120: [function(require2, module2, exports2) {
      function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require2("ms");
        createDebug.destroy = destroy;
        Object.keys(env).forEach((key) => {
          createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          var hash = 0;
          for (var i = 0; i < namespace.length; i++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          var prevTime;
          var enableOverride = null;
          function debug() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            if (!debug.enabled) {
              return;
            }
            var self2 = debug;
            var curr = Number(new Date());
            var ms = curr - (prevTime || curr);
            self2.diff = ms;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            var index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              var formatter = createDebug.formatters[format];
              if (typeof formatter === "function") {
                var val = args[index];
                match = formatter.call(self2, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self2, args);
            var logFn = self2.log || createDebug.log;
            logFn.apply(self2, args);
          }
          debug.namespace = namespace;
          debug.useColors = createDebug.useColors();
          debug.color = createDebug.selectColor(namespace);
          debug.extend = extend;
          debug.destroy = createDebug.destroy;
          Object.defineProperty(debug, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
            set: (v) => {
              enableOverride = v;
            }
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug);
          }
          return debug;
        }
        function extend(namespace, delimiter) {
          var newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.names = [];
          createDebug.skips = [];
          var i;
          var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          var len = split.length;
          for (i = 0; i < len; i++) {
            if (!split[i]) {
              continue;
            }
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
        }
        function disable() {
          var namespaces = [...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)].join(",");
          createDebug.enable("");
          return namespaces;
        }
        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }
          var i;
          var len;
          for (i = 0, len = createDebug.skips.length; i < len; i++) {
            if (createDebug.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = createDebug.names.length; i < len; i++) {
            if (createDebug.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        function toNamespace(regexp) {
          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module2.exports = setup;
    }, { "ms": 305 }], 121: [function(require2, module2, exports2) {
      var AbstractIterator = require2("abstract-leveldown").AbstractIterator;
      var inherits = require2("inherits");
      function DeferredIterator(db, options) {
        AbstractIterator.call(this, db);
        this._options = options;
        this._iterator = null;
        this._operations = [];
      }
      inherits(DeferredIterator, AbstractIterator);
      DeferredIterator.prototype.setDb = function(db) {
        var it = this._iterator = db.iterator(this._options);
        this._operations.forEach(function(op) {
          it[op.method].apply(it, op.args);
        });
      };
      DeferredIterator.prototype._operation = function(method, args) {
        if (this._iterator)
          return this._iterator[method].apply(this._iterator, args);
        this._operations.push({
          method,
          args
        });
      };
      "next end".split(" ").forEach(function(m) {
        DeferredIterator.prototype["_" + m] = function() {
          this._operation(m, arguments);
        };
      });
      DeferredIterator.prototype.seek = function() {
        this._operation("seek", arguments);
      };
      module2.exports = DeferredIterator;
    }, { "abstract-leveldown": 126, "inherits": 256 }], 122: [function(require2, module2, exports2) {
      var AbstractLevelDOWN = require2("abstract-leveldown").AbstractLevelDOWN;
      var inherits = require2("inherits");
      var DeferredIterator = require2("./deferred-iterator");
      var deferrables = "put get del batch clear".split(" ");
      var optionalDeferrables = "approximateSize compactRange".split(" ");
      function DeferredLevelDOWN(db) {
        AbstractLevelDOWN.call(this, db.supports || {});
        optionalDeferrables.forEach(function(m) {
          if (typeof db[m] === "function" && !this.supports.additionalMethods[m]) {
            this.supports.additionalMethods[m] = true;
          }
        }, this);
        this._db = db;
        this._operations = [];
        closed(this);
      }
      inherits(DeferredLevelDOWN, AbstractLevelDOWN);
      DeferredLevelDOWN.prototype.type = "deferred-leveldown";
      DeferredLevelDOWN.prototype._open = function(options, callback) {
        var self2 = this;
        this._db.open(options, function(err) {
          if (err)
            return callback(err);
          self2._operations.forEach(function(op) {
            if (op.iterator) {
              op.iterator.setDb(self2._db);
            } else {
              self2._db[op.method].apply(self2._db, op.args);
            }
          });
          self2._operations = [];
          open(self2);
          callback();
        });
      };
      DeferredLevelDOWN.prototype._close = function(callback) {
        var self2 = this;
        this._db.close(function(err) {
          if (err)
            return callback(err);
          closed(self2);
          callback();
        });
      };
      function open(self2) {
        deferrables.concat("iterator").forEach(function(m) {
          self2["_" + m] = function() {
            return this._db[m].apply(this._db, arguments);
          };
        });
        Object.keys(self2.supports.additionalMethods).forEach(function(m) {
          self2[m] = function() {
            return this._db[m].apply(this._db, arguments);
          };
        });
      }
      function closed(self2) {
        deferrables.forEach(function(m) {
          self2["_" + m] = function() {
            this._operations.push({
              method: m,
              args: arguments
            });
          };
        });
        Object.keys(self2.supports.additionalMethods).forEach(function(m) {
          self2[m] = function() {
            this._operations.push({
              method: m,
              args: arguments
            });
          };
        });
        self2._iterator = function(options) {
          var it = new DeferredIterator(self2, options);
          this._operations.push({
            iterator: it
          });
          return it;
        };
      }
      DeferredLevelDOWN.prototype._serializeKey = function(key) {
        return key;
      };
      DeferredLevelDOWN.prototype._serializeValue = function(value) {
        return value;
      };
      module2.exports = DeferredLevelDOWN;
      module2.exports.DeferredIterator = DeferredIterator;
    }, { "./deferred-iterator": 121, "abstract-leveldown": 126, "inherits": 256 }], 123: [function(require2, module2, exports2) {
      arguments[4][15][0].apply(exports2, arguments);
    }, { "./next-tick": 127, "dup": 15 }], 124: [function(require2, module2, exports2) {
      arguments[4][16][0].apply(exports2, arguments);
    }, { "./next-tick": 127, "dup": 16 }], 125: [function(require2, module2, exports2) {
      arguments[4][17][0].apply(exports2, arguments);
    }, { "./abstract-chained-batch": 123, "./abstract-iterator": 124, "./next-tick": 127, "buffer": 82, "dup": 17, "level-supports": 278, "xtend": 539 }], 126: [function(require2, module2, exports2) {
      arguments[4][18][0].apply(exports2, arguments);
    }, { "./abstract-chained-batch": 123, "./abstract-iterator": 124, "./abstract-leveldown": 125, "dup": 18 }], 127: [function(require2, module2, exports2) {
      arguments[4][19][0].apply(exports2, arguments);
    }, { "dup": 19, "immediate": 250 }], 128: [function(require2, module2, exports2) {
      module2.exports = function() {
        for (var i = 0; i < arguments.length; i++) {
          if (arguments[i] !== void 0)
            return arguments[i];
        }
      };
    }, {}], 129: [function(require2, module2, exports2) {
      var randomInteger = (minimum, maximum) => Math.floor(Math.random() * (maximum - minimum + 1) + minimum);
      var createAbortError = () => {
        var error = new Error("Delay aborted");
        error.name = "AbortError";
        return error;
      };
      var createDelay = (_ref) => {
        var {
          clearTimeout: defaultClear,
          setTimeout: set,
          willResolve
        } = _ref;
        return function(ms) {
          var {
            value,
            signal
          } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (signal && signal.aborted) {
            return Promise.reject(createAbortError());
          }
          var timeoutId;
          var settle;
          var rejectFn;
          var clear = defaultClear || clearTimeout;
          var signalListener = () => {
            clear(timeoutId);
            rejectFn(createAbortError());
          };
          var cleanup = () => {
            if (signal) {
              signal.removeEventListener("abort", signalListener);
            }
          };
          var delayPromise = new Promise((resolve, reject) => {
            settle = () => {
              cleanup();
              if (willResolve) {
                resolve(value);
              } else {
                reject(value);
              }
            };
            rejectFn = reject;
            timeoutId = (set || setTimeout)(settle, ms);
          });
          if (signal) {
            signal.addEventListener("abort", signalListener, {
              once: true
            });
          }
          delayPromise.clear = () => {
            clear(timeoutId);
            timeoutId = null;
            settle();
          };
          return delayPromise;
        };
      };
      var delay = createDelay({
        willResolve: true
      });
      delay.reject = createDelay({
        willResolve: false
      });
      delay.range = (minimum, maximum, options) => delay(randomInteger(minimum, maximum), options);
      delay.createWithTimers = (_ref2) => {
        var {
          clearTimeout: clearTimeout2,
          setTimeout: setTimeout2
        } = _ref2;
        var delay2 = createDelay({
          clearTimeout: clearTimeout2,
          setTimeout: setTimeout2,
          willResolve: true
        });
        delay2.reject = createDelay({
          clearTimeout: clearTimeout2,
          setTimeout: setTimeout2,
          willResolve: false
        });
        return delay2;
      };
      module2.exports = delay;
      module2.exports.default = delay;
    }, {}], 130: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var blake2b = require2("blake2b-universal");
          module2.exports = derive;
          function derive(ns, masterKey, input, output) {
            if (!output)
              output = Buffer.alloc(32);
            blake2b.batch(output, [Buffer.from(Buffer.byteLength(ns, "ascii") + "\n" + ns, "ascii"), Buffer.isBuffer(input) ? input : Buffer.from(input)], masterKey);
            return output;
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "blake2b-universal": 45, "buffer": 82 }], 131: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var RAS = require2("random-access-storage");
          var thunky = require2("thunky");
          var varint = require2("varint");
          module2.exports = keyPair;
          function keyPair(storage, derive) {
            var keyStorage = storage("key");
            var nameStorage = storage("name");
            var secretKeyStorage = storage("secret_key");
            var load = thunky(function(cb) {
              keyStorage.read(0, 32, (err, key2) => {
                if (err)
                  return createNew();
                readName((err2, name) => {
                  if (err2)
                    return cb(err2);
                  if (name)
                    return derive(name, cb);
                  secretKeyStorage.read(0, 64, (err3, secretKey2) => {
                    if (err3)
                      return cb(null, {
                        publicKey: key2,
                        secretKey: null,
                        name: null
                      });
                    return cb(null, {
                      publicKey: key2,
                      secretKey: secretKey2,
                      name: null
                    });
                  });
                });
              });
              function readName(cb2) {
                nameStorage.stat((err, st) => {
                  if (err)
                    return cb2(null, null);
                  if (st.size < 2)
                    return cb2(null, null);
                  nameStorage.read(0, st.size, (err2, buf) => {
                    if (err2)
                      return cb2(err2, null);
                    var len = 0;
                    try {
                      len = varint.decode(buf, 0);
                    } catch (err3) {
                      return cb2(null, null);
                    }
                    var offset = varint.decode.bytes;
                    if (offset + len !== buf.length)
                      return cb2(null, null);
                    var name = buf.slice(offset);
                    return cb2(null, name);
                  });
                });
              }
              function writeName(name, cb2) {
                if (!name)
                  return cb2(null);
                var buf = Buffer.allocUnsafe(varint.encodingLength(name.length) + name.length);
                varint.encode(name.length, buf, 0);
                name.copy(buf, varint.encode.bytes);
                nameStorage.write(0, buf, cb2);
              }
              function createNew() {
                derive(null, (err, res) => {
                  if (err)
                    return cb(err);
                  keyStorage.write(0, res.publicKey, (err2) => {
                    if (err2)
                      return cb(err2);
                    if (res.name)
                      return writeName(res.name, done);
                    else if (res.secretKey)
                      return secretKeyStorage.write(0, res.secretKey, done);
                    else
                      return done(new Error("The derivation function did not provide a name or a secret key."));
                  });
                  function done(err2) {
                    if (err2)
                      return cb(err2);
                    return cb(null, res);
                  }
                });
              }
            });
            var key = new RAS({
              stat(req) {
                load((err, res) => {
                  if (err)
                    return req.callback(err);
                  req.callback(null, {
                    size: 32
                  });
                });
              },
              read(req) {
                load((err, res) => {
                  if (err)
                    return req.callback(err);
                  req.callback(null, res.publicKey);
                });
              },
              close(req) {
                keyStorage.close((err) => req.callback(err));
              }
            });
            var secretKey = new RAS({
              stat(req) {
                load((err, res) => {
                  if (err)
                    return req.callback(err);
                  if (!res.secretKey)
                    return req.callback(new Error("No secret key."));
                  req.callback(null, {
                    size: 64
                  });
                });
              },
              read(req) {
                load((err, res) => {
                  if (err)
                    return req.callback(err);
                  if (!res.secretKey)
                    return req.callback(new Error("No secret key."));
                  req.callback(null, res.secretKey);
                });
              },
              close(req) {
                nameStorage.close((err) => req.callback(err));
              }
            });
            return {
              key,
              secretKey
            };
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82, "random-access-storage": 381, "thunky": 503, "varint": 517 }], 132: [function(require2, module2, exports2) {
      exports2.utils = require2("./des/utils");
      exports2.Cipher = require2("./des/cipher");
      exports2.DES = require2("./des/des");
      exports2.CBC = require2("./des/cbc");
      exports2.EDE = require2("./des/ede");
    }, { "./des/cbc": 133, "./des/cipher": 134, "./des/des": 135, "./des/ede": 136, "./des/utils": 137 }], 133: [function(require2, module2, exports2) {
      var assert = require2("minimalistic-assert");
      var inherits = require2("inherits");
      var proto = {};
      function CBCState(iv) {
        assert.equal(iv.length, 8, "Invalid IV length");
        this.iv = new Array(8);
        for (var i = 0; i < this.iv.length; i++) {
          this.iv[i] = iv[i];
        }
      }
      function instantiate(Base) {
        function CBC(options) {
          Base.call(this, options);
          this._cbcInit();
        }
        inherits(CBC, Base);
        var keys = Object.keys(proto);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          CBC.prototype[key] = proto[key];
        }
        CBC.create = function create(options) {
          return new CBC(options);
        };
        return CBC;
      }
      exports2.instantiate = instantiate;
      proto._cbcInit = function _cbcInit() {
        var state = new CBCState(this.options.iv);
        this._cbcState = state;
      };
      proto._update = function _update(inp, inOff, out, outOff) {
        var state = this._cbcState;
        var superProto = this.constructor.super_.prototype;
        var iv = state.iv;
        if (this.type === "encrypt") {
          for (var i = 0; i < this.blockSize; i++) {
            iv[i] ^= inp[inOff + i];
          }
          superProto._update.call(this, iv, 0, out, outOff);
          for (var i = 0; i < this.blockSize; i++) {
            iv[i] = out[outOff + i];
          }
        } else {
          superProto._update.call(this, inp, inOff, out, outOff);
          for (var i = 0; i < this.blockSize; i++) {
            out[outOff + i] ^= iv[i];
          }
          for (var i = 0; i < this.blockSize; i++) {
            iv[i] = inp[inOff + i];
          }
        }
      };
    }, { "inherits": 256, "minimalistic-assert": 302 }], 134: [function(require2, module2, exports2) {
      var assert = require2("minimalistic-assert");
      function Cipher(options) {
        this.options = options;
        this.type = this.options.type;
        this.blockSize = 8;
        this._init();
        this.buffer = new Array(this.blockSize);
        this.bufferOff = 0;
      }
      module2.exports = Cipher;
      Cipher.prototype._init = function _init() {
      };
      Cipher.prototype.update = function update(data) {
        if (data.length === 0)
          return [];
        if (this.type === "decrypt")
          return this._updateDecrypt(data);
        else
          return this._updateEncrypt(data);
      };
      Cipher.prototype._buffer = function _buffer(data, off) {
        var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
        for (var i = 0; i < min; i++) {
          this.buffer[this.bufferOff + i] = data[off + i];
        }
        this.bufferOff += min;
        return min;
      };
      Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
        this._update(this.buffer, 0, out, off);
        this.bufferOff = 0;
        return this.blockSize;
      };
      Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
        var inputOff = 0;
        var outputOff = 0;
        var count = (this.bufferOff + data.length) / this.blockSize | 0;
        var out = new Array(count * this.blockSize);
        if (this.bufferOff !== 0) {
          inputOff += this._buffer(data, inputOff);
          if (this.bufferOff === this.buffer.length)
            outputOff += this._flushBuffer(out, outputOff);
        }
        var max = data.length - (data.length - inputOff) % this.blockSize;
        for (; inputOff < max; inputOff += this.blockSize) {
          this._update(data, inputOff, out, outputOff);
          outputOff += this.blockSize;
        }
        for (; inputOff < data.length; inputOff++, this.bufferOff++) {
          this.buffer[this.bufferOff] = data[inputOff];
        }
        return out;
      };
      Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
        var inputOff = 0;
        var outputOff = 0;
        var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
        var out = new Array(count * this.blockSize);
        for (; count > 0; count--) {
          inputOff += this._buffer(data, inputOff);
          outputOff += this._flushBuffer(out, outputOff);
        }
        inputOff += this._buffer(data, inputOff);
        return out;
      };
      Cipher.prototype.final = function final(buffer) {
        var first;
        if (buffer)
          first = this.update(buffer);
        var last;
        if (this.type === "encrypt")
          last = this._finalEncrypt();
        else
          last = this._finalDecrypt();
        if (first)
          return first.concat(last);
        else
          return last;
      };
      Cipher.prototype._pad = function _pad(buffer, off) {
        if (off === 0)
          return false;
        while (off < buffer.length) {
          buffer[off++] = 0;
        }
        return true;
      };
      Cipher.prototype._finalEncrypt = function _finalEncrypt() {
        if (!this._pad(this.buffer, this.bufferOff))
          return [];
        var out = new Array(this.blockSize);
        this._update(this.buffer, 0, out, 0);
        return out;
      };
      Cipher.prototype._unpad = function _unpad(buffer) {
        return buffer;
      };
      Cipher.prototype._finalDecrypt = function _finalDecrypt() {
        assert.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
        var out = new Array(this.blockSize);
        this._flushBuffer(out, 0);
        return this._unpad(out);
      };
    }, { "minimalistic-assert": 302 }], 135: [function(require2, module2, exports2) {
      var assert = require2("minimalistic-assert");
      var inherits = require2("inherits");
      var utils = require2("./utils");
      var Cipher = require2("./cipher");
      function DESState() {
        this.tmp = new Array(2);
        this.keys = null;
      }
      function DES(options) {
        Cipher.call(this, options);
        var state = new DESState();
        this._desState = state;
        this.deriveKeys(state, options.key);
      }
      inherits(DES, Cipher);
      module2.exports = DES;
      DES.create = function create(options) {
        return new DES(options);
      };
      var shiftTable = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
      DES.prototype.deriveKeys = function deriveKeys(state, key) {
        state.keys = new Array(16 * 2);
        assert.equal(key.length, this.blockSize, "Invalid key length");
        var kL = utils.readUInt32BE(key, 0);
        var kR = utils.readUInt32BE(key, 4);
        utils.pc1(kL, kR, state.tmp, 0);
        kL = state.tmp[0];
        kR = state.tmp[1];
        for (var i = 0; i < state.keys.length; i += 2) {
          var shift = shiftTable[i >>> 1];
          kL = utils.r28shl(kL, shift);
          kR = utils.r28shl(kR, shift);
          utils.pc2(kL, kR, state.keys, i);
        }
      };
      DES.prototype._update = function _update(inp, inOff, out, outOff) {
        var state = this._desState;
        var l = utils.readUInt32BE(inp, inOff);
        var r = utils.readUInt32BE(inp, inOff + 4);
        utils.ip(l, r, state.tmp, 0);
        l = state.tmp[0];
        r = state.tmp[1];
        if (this.type === "encrypt")
          this._encrypt(state, l, r, state.tmp, 0);
        else
          this._decrypt(state, l, r, state.tmp, 0);
        l = state.tmp[0];
        r = state.tmp[1];
        utils.writeUInt32BE(out, l, outOff);
        utils.writeUInt32BE(out, r, outOff + 4);
      };
      DES.prototype._pad = function _pad(buffer, off) {
        var value = buffer.length - off;
        for (var i = off; i < buffer.length; i++) {
          buffer[i] = value;
        }
        return true;
      };
      DES.prototype._unpad = function _unpad(buffer) {
        var pad = buffer[buffer.length - 1];
        for (var i = buffer.length - pad; i < buffer.length; i++) {
          assert.equal(buffer[i], pad);
        }
        return buffer.slice(0, buffer.length - pad);
      };
      DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
        var l = lStart;
        var r = rStart;
        for (var i = 0; i < state.keys.length; i += 2) {
          var keyL = state.keys[i];
          var keyR = state.keys[i + 1];
          utils.expand(r, state.tmp, 0);
          keyL ^= state.tmp[0];
          keyR ^= state.tmp[1];
          var s = utils.substitute(keyL, keyR);
          var f = utils.permute(s);
          var t = r;
          r = (l ^ f) >>> 0;
          l = t;
        }
        utils.rip(r, l, out, off);
      };
      DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
        var l = rStart;
        var r = lStart;
        for (var i = state.keys.length - 2; i >= 0; i -= 2) {
          var keyL = state.keys[i];
          var keyR = state.keys[i + 1];
          utils.expand(l, state.tmp, 0);
          keyL ^= state.tmp[0];
          keyR ^= state.tmp[1];
          var s = utils.substitute(keyL, keyR);
          var f = utils.permute(s);
          var t = l;
          l = (r ^ f) >>> 0;
          r = t;
        }
        utils.rip(l, r, out, off);
      };
    }, { "./cipher": 134, "./utils": 137, "inherits": 256, "minimalistic-assert": 302 }], 136: [function(require2, module2, exports2) {
      var assert = require2("minimalistic-assert");
      var inherits = require2("inherits");
      var Cipher = require2("./cipher");
      var DES = require2("./des");
      function EDEState(type, key) {
        assert.equal(key.length, 24, "Invalid key length");
        var k1 = key.slice(0, 8);
        var k2 = key.slice(8, 16);
        var k3 = key.slice(16, 24);
        if (type === "encrypt") {
          this.ciphers = [DES.create({
            type: "encrypt",
            key: k1
          }), DES.create({
            type: "decrypt",
            key: k2
          }), DES.create({
            type: "encrypt",
            key: k3
          })];
        } else {
          this.ciphers = [DES.create({
            type: "decrypt",
            key: k3
          }), DES.create({
            type: "encrypt",
            key: k2
          }), DES.create({
            type: "decrypt",
            key: k1
          })];
        }
      }
      function EDE(options) {
        Cipher.call(this, options);
        var state = new EDEState(this.type, this.options.key);
        this._edeState = state;
      }
      inherits(EDE, Cipher);
      module2.exports = EDE;
      EDE.create = function create(options) {
        return new EDE(options);
      };
      EDE.prototype._update = function _update(inp, inOff, out, outOff) {
        var state = this._edeState;
        state.ciphers[0]._update(inp, inOff, out, outOff);
        state.ciphers[1]._update(out, outOff, out, outOff);
        state.ciphers[2]._update(out, outOff, out, outOff);
      };
      EDE.prototype._pad = DES.prototype._pad;
      EDE.prototype._unpad = DES.prototype._unpad;
    }, { "./cipher": 134, "./des": 135, "inherits": 256, "minimalistic-assert": 302 }], 137: [function(require2, module2, exports2) {
      exports2.readUInt32BE = function readUInt32BE(bytes, off) {
        var res = bytes[0 + off] << 24 | bytes[1 + off] << 16 | bytes[2 + off] << 8 | bytes[3 + off];
        return res >>> 0;
      };
      exports2.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
        bytes[0 + off] = value >>> 24;
        bytes[1 + off] = value >>> 16 & 255;
        bytes[2 + off] = value >>> 8 & 255;
        bytes[3 + off] = value & 255;
      };
      exports2.ip = function ip(inL, inR, out, off) {
        var outL = 0;
        var outR = 0;
        for (var i = 6; i >= 0; i -= 2) {
          for (var j = 0; j <= 24; j += 8) {
            outL <<= 1;
            outL |= inR >>> j + i & 1;
          }
          for (var j = 0; j <= 24; j += 8) {
            outL <<= 1;
            outL |= inL >>> j + i & 1;
          }
        }
        for (var i = 6; i >= 0; i -= 2) {
          for (var j = 1; j <= 25; j += 8) {
            outR <<= 1;
            outR |= inR >>> j + i & 1;
          }
          for (var j = 1; j <= 25; j += 8) {
            outR <<= 1;
            outR |= inL >>> j + i & 1;
          }
        }
        out[off + 0] = outL >>> 0;
        out[off + 1] = outR >>> 0;
      };
      exports2.rip = function rip(inL, inR, out, off) {
        var outL = 0;
        var outR = 0;
        for (var i = 0; i < 4; i++) {
          for (var j = 24; j >= 0; j -= 8) {
            outL <<= 1;
            outL |= inR >>> j + i & 1;
            outL <<= 1;
            outL |= inL >>> j + i & 1;
          }
        }
        for (var i = 4; i < 8; i++) {
          for (var j = 24; j >= 0; j -= 8) {
            outR <<= 1;
            outR |= inR >>> j + i & 1;
            outR <<= 1;
            outR |= inL >>> j + i & 1;
          }
        }
        out[off + 0] = outL >>> 0;
        out[off + 1] = outR >>> 0;
      };
      exports2.pc1 = function pc1(inL, inR, out, off) {
        var outL = 0;
        var outR = 0;
        for (var i = 7; i >= 5; i--) {
          for (var j = 0; j <= 24; j += 8) {
            outL <<= 1;
            outL |= inR >> j + i & 1;
          }
          for (var j = 0; j <= 24; j += 8) {
            outL <<= 1;
            outL |= inL >> j + i & 1;
          }
        }
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inR >> j + i & 1;
        }
        for (var i = 1; i <= 3; i++) {
          for (var j = 0; j <= 24; j += 8) {
            outR <<= 1;
            outR |= inR >> j + i & 1;
          }
          for (var j = 0; j <= 24; j += 8) {
            outR <<= 1;
            outR |= inL >> j + i & 1;
          }
        }
        for (var j = 0; j <= 24; j += 8) {
          outR <<= 1;
          outR |= inL >> j + i & 1;
        }
        out[off + 0] = outL >>> 0;
        out[off + 1] = outR >>> 0;
      };
      exports2.r28shl = function r28shl(num, shift) {
        return num << shift & 268435455 | num >>> 28 - shift;
      };
      var pc2table = [
        14,
        11,
        17,
        4,
        27,
        23,
        25,
        0,
        13,
        22,
        7,
        18,
        5,
        9,
        16,
        24,
        2,
        20,
        12,
        21,
        1,
        8,
        15,
        26,
        15,
        4,
        25,
        19,
        9,
        1,
        26,
        16,
        5,
        11,
        23,
        8,
        12,
        7,
        17,
        0,
        22,
        3,
        10,
        14,
        6,
        20,
        27,
        24
      ];
      exports2.pc2 = function pc2(inL, inR, out, off) {
        var outL = 0;
        var outR = 0;
        var len = pc2table.length >>> 1;
        for (var i = 0; i < len; i++) {
          outL <<= 1;
          outL |= inL >>> pc2table[i] & 1;
        }
        for (var i = len; i < pc2table.length; i++) {
          outR <<= 1;
          outR |= inR >>> pc2table[i] & 1;
        }
        out[off + 0] = outL >>> 0;
        out[off + 1] = outR >>> 0;
      };
      exports2.expand = function expand(r, out, off) {
        var outL = 0;
        var outR = 0;
        outL = (r & 1) << 5 | r >>> 27;
        for (var i = 23; i >= 15; i -= 4) {
          outL <<= 6;
          outL |= r >>> i & 63;
        }
        for (var i = 11; i >= 3; i -= 4) {
          outR |= r >>> i & 63;
          outR <<= 6;
        }
        outR |= (r & 31) << 1 | r >>> 31;
        out[off + 0] = outL >>> 0;
        out[off + 1] = outR >>> 0;
      };
      var sTable = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
      exports2.substitute = function substitute(inL, inR) {
        var out = 0;
        for (var i = 0; i < 4; i++) {
          var b = inL >>> 18 - i * 6 & 63;
          var sb = sTable[i * 64 + b];
          out <<= 4;
          out |= sb;
        }
        for (var i = 0; i < 4; i++) {
          var b = inR >>> 18 - i * 6 & 63;
          var sb = sTable[4 * 64 + i * 64 + b];
          out <<= 4;
          out |= sb;
        }
        return out >>> 0;
      };
      var permuteTable = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
      exports2.permute = function permute(num) {
        var out = 0;
        for (var i = 0; i < permuteTable.length; i++) {
          out <<= 1;
          out |= num >>> permuteTable[i] & 1;
        }
        return out >>> 0;
      };
      exports2.padSplit = function padSplit(num, size, group) {
        var str = num.toString(2);
        while (str.length < size) {
          str = "0" + str;
        }
        var out = [];
        for (var i = 0; i < size; i += group) {
          out.push(str.slice(i, i + group));
        }
        return out.join(" ");
      };
    }, {}], 138: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var generatePrime = require2("./lib/generatePrime");
          var primes = require2("./lib/primes.json");
          var DH = require2("./lib/dh");
          function getDiffieHellman(mod) {
            var prime = new Buffer(primes[mod].prime, "hex");
            var gen = new Buffer(primes[mod].gen, "hex");
            return new DH(prime, gen);
          }
          var ENCODINGS = {
            "binary": true,
            "hex": true,
            "base64": true
          };
          function createDiffieHellman(prime, enc, generator, genc) {
            if (Buffer.isBuffer(enc) || ENCODINGS[enc] === void 0) {
              return createDiffieHellman(prime, "binary", enc, generator);
            }
            enc = enc || "binary";
            genc = genc || "binary";
            generator = generator || new Buffer([2]);
            if (!Buffer.isBuffer(generator)) {
              generator = new Buffer(generator, genc);
            }
            if (typeof prime === "number") {
              return new DH(generatePrime(prime, generator), generator, true);
            }
            if (!Buffer.isBuffer(prime)) {
              prime = new Buffer(prime, enc);
            }
            return new DH(prime, generator, true);
          }
          exports2.DiffieHellmanGroup = exports2.createDiffieHellmanGroup = exports2.getDiffieHellman = getDiffieHellman;
          exports2.createDiffieHellman = exports2.DiffieHellman = createDiffieHellman;
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "./lib/dh": 139, "./lib/generatePrime": 140, "./lib/primes.json": 141, "buffer": 82 }], 139: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var BN = require2("bn.js");
          var MillerRabin = require2("miller-rabin");
          var millerRabin = new MillerRabin();
          var TWENTYFOUR = new BN(24);
          var ELEVEN = new BN(11);
          var TEN = new BN(10);
          var THREE = new BN(3);
          var SEVEN = new BN(7);
          var primes = require2("./generatePrime");
          var randomBytes = require2("randombytes");
          module2.exports = DH;
          function setPublicKey(pub, enc) {
            enc = enc || "utf8";
            if (!Buffer.isBuffer(pub)) {
              pub = new Buffer(pub, enc);
            }
            this._pub = new BN(pub);
            return this;
          }
          function setPrivateKey(priv, enc) {
            enc = enc || "utf8";
            if (!Buffer.isBuffer(priv)) {
              priv = new Buffer(priv, enc);
            }
            this._priv = new BN(priv);
            return this;
          }
          var primeCache = {};
          function checkPrime(prime, generator) {
            var gen = generator.toString("hex");
            var hex = [gen, prime.toString(16)].join("_");
            if (hex in primeCache) {
              return primeCache[hex];
            }
            var error = 0;
            if (prime.isEven() || !primes.simpleSieve || !primes.fermatTest(prime) || !millerRabin.test(prime)) {
              error += 1;
              if (gen === "02" || gen === "05") {
                error += 8;
              } else {
                error += 4;
              }
              primeCache[hex] = error;
              return error;
            }
            if (!millerRabin.test(prime.shrn(1))) {
              error += 2;
            }
            var rem;
            switch (gen) {
              case "02":
                if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
                  error += 8;
                }
                break;
              case "05":
                rem = prime.mod(TEN);
                if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
                  error += 8;
                }
                break;
              default:
                error += 4;
            }
            primeCache[hex] = error;
            return error;
          }
          function DH(prime, generator, malleable) {
            this.setGenerator(generator);
            this.__prime = new BN(prime);
            this._prime = BN.mont(this.__prime);
            this._primeLen = prime.length;
            this._pub = void 0;
            this._priv = void 0;
            this._primeCode = void 0;
            if (malleable) {
              this.setPublicKey = setPublicKey;
              this.setPrivateKey = setPrivateKey;
            } else {
              this._primeCode = 8;
            }
          }
          Object.defineProperty(DH.prototype, "verifyError", {
            enumerable: true,
            get: function get() {
              if (typeof this._primeCode !== "number") {
                this._primeCode = checkPrime(this.__prime, this.__gen);
              }
              return this._primeCode;
            }
          });
          DH.prototype.generateKeys = function() {
            if (!this._priv) {
              this._priv = new BN(randomBytes(this._primeLen));
            }
            this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
            return this.getPublicKey();
          };
          DH.prototype.computeSecret = function(other) {
            other = new BN(other);
            other = other.toRed(this._prime);
            var secret = other.redPow(this._priv).fromRed();
            var out = new Buffer(secret.toArray());
            var prime = this.getPrime();
            if (out.length < prime.length) {
              var front = new Buffer(prime.length - out.length);
              front.fill(0);
              out = Buffer.concat([front, out]);
            }
            return out;
          };
          DH.prototype.getPublicKey = function getPublicKey(enc) {
            return formatReturnValue(this._pub, enc);
          };
          DH.prototype.getPrivateKey = function getPrivateKey(enc) {
            return formatReturnValue(this._priv, enc);
          };
          DH.prototype.getPrime = function(enc) {
            return formatReturnValue(this.__prime, enc);
          };
          DH.prototype.getGenerator = function(enc) {
            return formatReturnValue(this._gen, enc);
          };
          DH.prototype.setGenerator = function(gen, enc) {
            enc = enc || "utf8";
            if (!Buffer.isBuffer(gen)) {
              gen = new Buffer(gen, enc);
            }
            this.__gen = gen;
            this._gen = new BN(gen);
            return this;
          };
          function formatReturnValue(bn, enc) {
            var buf = new Buffer(bn.toArray());
            if (!enc) {
              return buf;
            } else {
              return buf.toString(enc);
            }
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "./generatePrime": 140, "bn.js": 142, "buffer": 82, "miller-rabin": 300, "randombytes": 382 }], 140: [function(require2, module2, exports2) {
      var randomBytes = require2("randombytes");
      module2.exports = findPrime;
      findPrime.simpleSieve = simpleSieve;
      findPrime.fermatTest = fermatTest;
      var BN = require2("bn.js");
      var TWENTYFOUR = new BN(24);
      var MillerRabin = require2("miller-rabin");
      var millerRabin = new MillerRabin();
      var ONE = new BN(1);
      var TWO = new BN(2);
      var FIVE = new BN(5);
      new BN(16);
      new BN(8);
      var TEN = new BN(10);
      var THREE = new BN(3);
      new BN(7);
      var ELEVEN = new BN(11);
      var FOUR = new BN(4);
      new BN(12);
      var primes = null;
      function _getPrimes() {
        if (primes !== null)
          return primes;
        var limit = 1048576;
        var res = [];
        res[0] = 2;
        for (var i = 1, k = 3; k < limit; k += 2) {
          var sqrt = Math.ceil(Math.sqrt(k));
          for (var j = 0; j < i && res[j] <= sqrt; j++) {
            if (k % res[j] === 0)
              break;
          }
          if (i !== j && res[j] <= sqrt)
            continue;
          res[i++] = k;
        }
        primes = res;
        return res;
      }
      function simpleSieve(p) {
        var primes2 = _getPrimes();
        for (var i = 0; i < primes2.length; i++) {
          if (p.modn(primes2[i]) === 0) {
            if (p.cmpn(primes2[i]) === 0) {
              return true;
            } else {
              return false;
            }
          }
        }
        return true;
      }
      function fermatTest(p) {
        var red = BN.mont(p);
        return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
      }
      function findPrime(bits, gen) {
        if (bits < 16) {
          if (gen === 2 || gen === 5) {
            return new BN([140, 123]);
          } else {
            return new BN([140, 39]);
          }
        }
        gen = new BN(gen);
        var num, n2;
        while (true) {
          num = new BN(randomBytes(Math.ceil(bits / 8)));
          while (num.bitLength() > bits) {
            num.ishrn(1);
          }
          if (num.isEven()) {
            num.iadd(ONE);
          }
          if (!num.testn(1)) {
            num.iadd(TWO);
          }
          if (!gen.cmp(TWO)) {
            while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
              num.iadd(FOUR);
            }
          } else if (!gen.cmp(FIVE)) {
            while (num.mod(TEN).cmp(THREE)) {
              num.iadd(FOUR);
            }
          }
          n2 = num.shrn(1);
          if (simpleSieve(n2) && simpleSieve(num) && fermatTest(n2) && fermatTest(num) && millerRabin.test(n2) && millerRabin.test(num)) {
            return num;
          }
        }
      }
    }, { "bn.js": 142, "miller-rabin": 300, "randombytes": 382 }], 141: [function(require2, module2, exports2) {
      module2.exports = {
        "modp1": {
          "gen": "02",
          "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
        },
        "modp2": {
          "gen": "02",
          "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
        },
        "modp5": {
          "gen": "02",
          "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
        },
        "modp14": {
          "gen": "02",
          "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
        },
        "modp15": {
          "gen": "02",
          "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
        },
        "modp16": {
          "gen": "02",
          "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
        },
        "modp17": {
          "gen": "02",
          "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
        },
        "modp18": {
          "gen": "02",
          "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
        }
      };
    }, {}], 142: [function(require2, module2, exports2) {
      arguments[4][35][0].apply(exports2, arguments);
    }, { "buffer": 53, "dup": 35 }], 143: [function(require2, module2, exports2) {
      (function(process, Buffer) {
        (function() {
          var stream = require2("readable-stream");
          var eos = require2("end-of-stream");
          var inherits = require2("inherits");
          var shift = require2("stream-shift");
          var SIGNAL_FLUSH = Buffer.from && Buffer.from !== Uint8Array.from ? Buffer.from([0]) : new Buffer([0]);
          var onuncork = function onuncork2(self2, fn) {
            if (self2._corked)
              self2.once("uncork", fn);
            else
              fn();
          };
          var autoDestroy = function autoDestroy2(self2, err) {
            if (self2._autoDestroy)
              self2.destroy(err);
          };
          var destroyer = function destroyer2(self2, end2) {
            return function(err) {
              if (err)
                autoDestroy(self2, err.message === "premature close" ? null : err);
              else if (end2 && !self2._ended)
                self2.end();
            };
          };
          var end = function end2(ws, fn) {
            if (!ws)
              return fn();
            if (ws._writableState && ws._writableState.finished)
              return fn();
            if (ws._writableState)
              return ws.end(fn);
            ws.end();
            fn();
          };
          var toStreams2 = function toStreams22(rs) {
            return new stream.Readable({
              objectMode: true,
              highWaterMark: 16
            }).wrap(rs);
          };
          var Duplexify = function Duplexify2(writable, readable, opts) {
            if (!(this instanceof Duplexify2))
              return new Duplexify2(writable, readable, opts);
            stream.Duplex.call(this, opts);
            this._writable = null;
            this._readable = null;
            this._readable2 = null;
            this._autoDestroy = !opts || opts.autoDestroy !== false;
            this._forwardDestroy = !opts || opts.destroy !== false;
            this._forwardEnd = !opts || opts.end !== false;
            this._corked = 1;
            this._ondrain = null;
            this._drained = false;
            this._forwarding = false;
            this._unwrite = null;
            this._unread = null;
            this._ended = false;
            this.destroyed = false;
            if (writable)
              this.setWritable(writable);
            if (readable)
              this.setReadable(readable);
          };
          inherits(Duplexify, stream.Duplex);
          Duplexify.obj = function(writable, readable, opts) {
            if (!opts)
              opts = {};
            opts.objectMode = true;
            opts.highWaterMark = 16;
            return new Duplexify(writable, readable, opts);
          };
          Duplexify.prototype.cork = function() {
            if (++this._corked === 1)
              this.emit("cork");
          };
          Duplexify.prototype.uncork = function() {
            if (this._corked && --this._corked === 0)
              this.emit("uncork");
          };
          Duplexify.prototype.setWritable = function(writable) {
            if (this._unwrite)
              this._unwrite();
            if (this.destroyed) {
              if (writable && writable.destroy)
                writable.destroy();
              return;
            }
            if (writable === null || writable === false) {
              this.end();
              return;
            }
            var self2 = this;
            var unend = eos(writable, {
              writable: true,
              readable: false
            }, destroyer(this, this._forwardEnd));
            var ondrain = function ondrain2() {
              var ondrain3 = self2._ondrain;
              self2._ondrain = null;
              if (ondrain3)
                ondrain3();
            };
            var clear = function clear2() {
              self2._writable.removeListener("drain", ondrain);
              unend();
            };
            if (this._unwrite)
              process.nextTick(ondrain);
            this._writable = writable;
            this._writable.on("drain", ondrain);
            this._unwrite = clear;
            this.uncork();
          };
          Duplexify.prototype.setReadable = function(readable) {
            if (this._unread)
              this._unread();
            if (this.destroyed) {
              if (readable && readable.destroy)
                readable.destroy();
              return;
            }
            if (readable === null || readable === false) {
              this.push(null);
              this.resume();
              return;
            }
            var self2 = this;
            var unend = eos(readable, {
              writable: false,
              readable: true
            }, destroyer(this));
            var onreadable = function onreadable2() {
              self2._forward();
            };
            var onend = function onend2() {
              self2.push(null);
            };
            var clear = function clear2() {
              self2._readable2.removeListener("readable", onreadable);
              self2._readable2.removeListener("end", onend);
              unend();
            };
            this._drained = true;
            this._readable = readable;
            this._readable2 = readable._readableState ? readable : toStreams2(readable);
            this._readable2.on("readable", onreadable);
            this._readable2.on("end", onend);
            this._unread = clear;
            this._forward();
          };
          Duplexify.prototype._read = function() {
            this._drained = true;
            this._forward();
          };
          Duplexify.prototype._forward = function() {
            if (this._forwarding || !this._readable2 || !this._drained)
              return;
            this._forwarding = true;
            var data;
            while (this._drained && (data = shift(this._readable2)) !== null) {
              if (this.destroyed)
                continue;
              this._drained = this.push(data);
            }
            this._forwarding = false;
          };
          Duplexify.prototype.destroy = function(err) {
            if (this.destroyed)
              return;
            this.destroyed = true;
            var self2 = this;
            process.nextTick(function() {
              self2._destroy(err);
            });
          };
          Duplexify.prototype._destroy = function(err) {
            if (err) {
              var ondrain = this._ondrain;
              this._ondrain = null;
              if (ondrain)
                ondrain(err);
              else
                this.emit("error", err);
            }
            if (this._forwardDestroy) {
              if (this._readable && this._readable.destroy)
                this._readable.destroy();
              if (this._writable && this._writable.destroy)
                this._writable.destroy();
            }
            this.emit("close");
          };
          Duplexify.prototype._write = function(data, enc, cb) {
            if (this.destroyed)
              return cb();
            if (this._corked)
              return onuncork(this, this._write.bind(this, data, enc, cb));
            if (data === SIGNAL_FLUSH)
              return this._finish(cb);
            if (!this._writable)
              return cb();
            if (this._writable.write(data) === false)
              this._ondrain = cb;
            else
              cb();
          };
          Duplexify.prototype._finish = function(cb) {
            var self2 = this;
            this.emit("preend");
            onuncork(this, function() {
              end(self2._forwardEnd && self2._writable, function() {
                if (self2._writableState.prefinished === false)
                  self2._writableState.prefinished = true;
                self2.emit("prefinish");
                onuncork(self2, cb);
              });
            });
          };
          Duplexify.prototype.end = function(data, enc, cb) {
            if (typeof data === "function")
              return this.end(null, null, data);
            if (typeof enc === "function")
              return this.end(data, null, enc);
            this._ended = true;
            if (data)
              this.write(data);
            if (!this._writableState.ending)
              this.write(SIGNAL_FLUSH);
            return stream.Writable.prototype.end.call(this, cb);
          };
          module2.exports = Duplexify;
        }).call(this);
      }).call(this, require2("_process"), require2("buffer").Buffer);
    }, { "_process": 361, "buffer": 82, "end-of-stream": 187, "inherits": 256, "readable-stream": 152, "stream-shift": 497 }], 144: [function(require2, module2, exports2) {
      arguments[4][97][0].apply(exports2, arguments);
    }, { "./_stream_readable": 146, "./_stream_writable": 148, "core-util-is": 108, "dup": 97, "inherits": 256, "process-nextick-args": 360 }], 145: [function(require2, module2, exports2) {
      arguments[4][98][0].apply(exports2, arguments);
    }, { "./_stream_transform": 147, "core-util-is": 108, "dup": 98, "inherits": 256 }], 146: [function(require2, module2, exports2) {
      arguments[4][99][0].apply(exports2, arguments);
    }, { "../../../../util/util.js": 514, "./_stream_duplex": 144, "./internal/streams/BufferList": 149, "./internal/streams/destroy": 150, "./internal/streams/stream": 151, "_process": 361, "core-util-is": 108, "dup": 99, "events": 193, "inherits": 256, "isarray": 263, "process-nextick-args": 360, "safe-buffer": 153, "string_decoder/": 154 }], 147: [function(require2, module2, exports2) {
      arguments[4][100][0].apply(exports2, arguments);
    }, { "./_stream_duplex": 144, "core-util-is": 108, "dup": 100, "inherits": 256 }], 148: [function(require2, module2, exports2) {
      arguments[4][101][0].apply(exports2, arguments);
    }, { "./_stream_duplex": 144, "./internal/streams/destroy": 150, "./internal/streams/stream": 151, "_process": 361, "core-util-is": 108, "dup": 101, "inherits": 256, "process-nextick-args": 360, "safe-buffer": 153, "timers": 506, "util-deprecate": 511 }], 149: [function(require2, module2, exports2) {
      arguments[4][102][0].apply(exports2, arguments);
    }, { "../../../../../../util/util.js": 514, "dup": 102, "safe-buffer": 153 }], 150: [function(require2, module2, exports2) {
      arguments[4][103][0].apply(exports2, arguments);
    }, { "dup": 103, "process-nextick-args": 360 }], 151: [function(require2, module2, exports2) {
      arguments[4][104][0].apply(exports2, arguments);
    }, { "dup": 104, "events": 193 }], 152: [function(require2, module2, exports2) {
      arguments[4][105][0].apply(exports2, arguments);
    }, { "./lib/_stream_duplex.js": 144, "./lib/_stream_passthrough.js": 145, "./lib/_stream_readable.js": 146, "./lib/_stream_transform.js": 147, "./lib/_stream_writable.js": 148, "dup": 105 }], 153: [function(require2, module2, exports2) {
      arguments[4][106][0].apply(exports2, arguments);
    }, { "buffer": 82, "dup": 106 }], 154: [function(require2, module2, exports2) {
      arguments[4][107][0].apply(exports2, arguments);
    }, { "dup": 107, "safe-buffer": 153 }], 155: [function(require2, module2, exports2) {
      var Duplex = require2("readable-stream").Duplex;
      var kCallback = Symbol("Callback");
      var kOtherSide = Symbol("Other");
      class DuplexSocket extends Duplex {
        constructor(options) {
          super(options);
          this[kCallback] = null;
          this[kOtherSide] = null;
        }
        _read() {
          var callback = this[kCallback];
          if (callback) {
            this[kCallback] = null;
            callback();
          }
        }
        _write(chunk, encoding, callback) {
          this[kOtherSide][kCallback] = callback;
          this[kOtherSide].push(chunk);
        }
        _final(callback) {
          this[kOtherSide].on("end", callback);
          this[kOtherSide].push(null);
        }
      }
      class DuplexPair {
        constructor(options) {
          this.socket1 = new DuplexSocket(options);
          this.socket2 = new DuplexSocket(options);
          this.socket1[kOtherSide] = this.socket2;
          this.socket2[kOtherSide] = this.socket1;
        }
      }
      module2.exports = DuplexPair;
    }, { "readable-stream": 164 }], 156: [function(require2, module2, exports2) {
      arguments[4][97][0].apply(exports2, arguments);
    }, { "./_stream_readable": 158, "./_stream_writable": 160, "core-util-is": 108, "dup": 97, "inherits": 256, "process-nextick-args": 360 }], 157: [function(require2, module2, exports2) {
      arguments[4][98][0].apply(exports2, arguments);
    }, { "./_stream_transform": 159, "core-util-is": 108, "dup": 98, "inherits": 256 }], 158: [function(require2, module2, exports2) {
      arguments[4][99][0].apply(exports2, arguments);
    }, { "../../../../util/util.js": 514, "./_stream_duplex": 156, "./internal/streams/BufferList": 161, "./internal/streams/destroy": 162, "./internal/streams/stream": 163, "_process": 361, "core-util-is": 108, "dup": 99, "events": 193, "inherits": 256, "isarray": 263, "process-nextick-args": 360, "safe-buffer": 165, "string_decoder/": 166 }], 159: [function(require2, module2, exports2) {
      arguments[4][100][0].apply(exports2, arguments);
    }, { "./_stream_duplex": 156, "core-util-is": 108, "dup": 100, "inherits": 256 }], 160: [function(require2, module2, exports2) {
      arguments[4][101][0].apply(exports2, arguments);
    }, { "./_stream_duplex": 156, "./internal/streams/destroy": 162, "./internal/streams/stream": 163, "_process": 361, "core-util-is": 108, "dup": 101, "inherits": 256, "process-nextick-args": 360, "safe-buffer": 165, "timers": 506, "util-deprecate": 511 }], 161: [function(require2, module2, exports2) {
      arguments[4][102][0].apply(exports2, arguments);
    }, { "../../../../../../util/util.js": 514, "dup": 102, "safe-buffer": 165 }], 162: [function(require2, module2, exports2) {
      arguments[4][103][0].apply(exports2, arguments);
    }, { "dup": 103, "process-nextick-args": 360 }], 163: [function(require2, module2, exports2) {
      arguments[4][104][0].apply(exports2, arguments);
    }, { "dup": 104, "events": 193 }], 164: [function(require2, module2, exports2) {
      arguments[4][105][0].apply(exports2, arguments);
    }, { "./lib/_stream_duplex.js": 156, "./lib/_stream_passthrough.js": 157, "./lib/_stream_readable.js": 158, "./lib/_stream_transform.js": 159, "./lib/_stream_writable.js": 160, "dup": 105 }], 165: [function(require2, module2, exports2) {
      arguments[4][106][0].apply(exports2, arguments);
    }, { "buffer": 82, "dup": 106 }], 166: [function(require2, module2, exports2) {
      arguments[4][107][0].apply(exports2, arguments);
    }, { "dup": 107, "safe-buffer": 165 }], 167: [function(require2, module2, exports2) {
      var elliptic = exports2;
      elliptic.version = require2("../package.json").version;
      elliptic.utils = require2("./elliptic/utils");
      elliptic.rand = require2("brorand");
      elliptic.curve = require2("./elliptic/curve");
      elliptic.curves = require2("./elliptic/curves");
      elliptic.ec = require2("./elliptic/ec");
      elliptic.eddsa = require2("./elliptic/eddsa");
    }, { "../package.json": 183, "./elliptic/curve": 170, "./elliptic/curves": 173, "./elliptic/ec": 174, "./elliptic/eddsa": 177, "./elliptic/utils": 181, "brorand": 52 }], 168: [function(require2, module2, exports2) {
      var BN = require2("bn.js");
      var utils = require2("../utils");
      var getNAF = utils.getNAF;
      var getJSF = utils.getJSF;
      var assert = utils.assert;
      function BaseCurve(type, conf) {
        this.type = type;
        this.p = new BN(conf.p, 16);
        this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
        this.zero = new BN(0).toRed(this.red);
        this.one = new BN(1).toRed(this.red);
        this.two = new BN(2).toRed(this.red);
        this.n = conf.n && new BN(conf.n, 16);
        this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
        this._wnafT1 = new Array(4);
        this._wnafT2 = new Array(4);
        this._wnafT3 = new Array(4);
        this._wnafT4 = new Array(4);
        this._bitLength = this.n ? this.n.bitLength() : 0;
        var adjustCount = this.n && this.p.div(this.n);
        if (!adjustCount || adjustCount.cmpn(100) > 0) {
          this.redN = null;
        } else {
          this._maxwellTrick = true;
          this.redN = this.n.toRed(this.red);
        }
      }
      module2.exports = BaseCurve;
      BaseCurve.prototype.point = function point() {
        throw new Error("Not implemented");
      };
      BaseCurve.prototype.validate = function validate() {
        throw new Error("Not implemented");
      };
      BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
        assert(p.precomputed);
        var doubles = p._getDoubles();
        var naf = getNAF(k, 1, this._bitLength);
        var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
        I /= 3;
        var repr = [];
        var j;
        var nafW;
        for (j = 0; j < naf.length; j += doubles.step) {
          nafW = 0;
          for (var l = j + doubles.step - 1; l >= j; l--) {
            nafW = (nafW << 1) + naf[l];
          }
          repr.push(nafW);
        }
        var a = this.jpoint(null, null, null);
        var b = this.jpoint(null, null, null);
        for (var i = I; i > 0; i--) {
          for (j = 0; j < repr.length; j++) {
            nafW = repr[j];
            if (nafW === i)
              b = b.mixedAdd(doubles.points[j]);
            else if (nafW === -i)
              b = b.mixedAdd(doubles.points[j].neg());
          }
          a = a.add(b);
        }
        return a.toP();
      };
      BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
        var w = 4;
        var nafPoints = p._getNAFPoints(w);
        w = nafPoints.wnd;
        var wnd = nafPoints.points;
        var naf = getNAF(k, w, this._bitLength);
        var acc = this.jpoint(null, null, null);
        for (var i = naf.length - 1; i >= 0; i--) {
          for (var l = 0; i >= 0 && naf[i] === 0; i--) {
            l++;
          }
          if (i >= 0)
            l++;
          acc = acc.dblp(l);
          if (i < 0)
            break;
          var z = naf[i];
          assert(z !== 0);
          if (p.type === "affine") {
            if (z > 0)
              acc = acc.mixedAdd(wnd[z - 1 >> 1]);
            else
              acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
          } else {
            if (z > 0)
              acc = acc.add(wnd[z - 1 >> 1]);
            else
              acc = acc.add(wnd[-z - 1 >> 1].neg());
          }
        }
        return p.type === "affine" ? acc.toP() : acc;
      };
      BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
        var wndWidth = this._wnafT1;
        var wnd = this._wnafT2;
        var naf = this._wnafT3;
        var max = 0;
        var i;
        var j;
        var p;
        for (i = 0; i < len; i++) {
          p = points[i];
          var nafPoints = p._getNAFPoints(defW);
          wndWidth[i] = nafPoints.wnd;
          wnd[i] = nafPoints.points;
        }
        for (i = len - 1; i >= 1; i -= 2) {
          var a = i - 1;
          var b = i;
          if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
            naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
            naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
            max = Math.max(naf[a].length, max);
            max = Math.max(naf[b].length, max);
            continue;
          }
          var comb = [
            points[a],
            null,
            null,
            points[b]
          ];
          if (points[a].y.cmp(points[b].y) === 0) {
            comb[1] = points[a].add(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
          } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].add(points[b].neg());
          } else {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
          }
          var index = [
            -3,
            -1,
            -5,
            -7,
            0,
            7,
            5,
            1,
            3
          ];
          var jsf = getJSF(coeffs[a], coeffs[b]);
          max = Math.max(jsf[0].length, max);
          naf[a] = new Array(max);
          naf[b] = new Array(max);
          for (j = 0; j < max; j++) {
            var ja = jsf[0][j] | 0;
            var jb = jsf[1][j] | 0;
            naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
            naf[b][j] = 0;
            wnd[a] = comb;
          }
        }
        var acc = this.jpoint(null, null, null);
        var tmp = this._wnafT4;
        for (i = max; i >= 0; i--) {
          var k = 0;
          while (i >= 0) {
            var zero = true;
            for (j = 0; j < len; j++) {
              tmp[j] = naf[j][i] | 0;
              if (tmp[j] !== 0)
                zero = false;
            }
            if (!zero)
              break;
            k++;
            i--;
          }
          if (i >= 0)
            k++;
          acc = acc.dblp(k);
          if (i < 0)
            break;
          for (j = 0; j < len; j++) {
            var z = tmp[j];
            if (z === 0)
              continue;
            else if (z > 0)
              p = wnd[j][z - 1 >> 1];
            else if (z < 0)
              p = wnd[j][-z - 1 >> 1].neg();
            if (p.type === "affine")
              acc = acc.mixedAdd(p);
            else
              acc = acc.add(p);
          }
        }
        for (i = 0; i < len; i++) {
          wnd[i] = null;
        }
        if (jacobianResult)
          return acc;
        else
          return acc.toP();
      };
      function BasePoint(curve, type) {
        this.curve = curve;
        this.type = type;
        this.precomputed = null;
      }
      BaseCurve.BasePoint = BasePoint;
      BasePoint.prototype.eq = function eq() {
        throw new Error("Not implemented");
      };
      BasePoint.prototype.validate = function validate() {
        return this.curve.validate(this);
      };
      BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
        bytes = utils.toArray(bytes, enc);
        var len = this.p.byteLength();
        if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
          if (bytes[0] === 6)
            assert(bytes[bytes.length - 1] % 2 === 0);
          else if (bytes[0] === 7)
            assert(bytes[bytes.length - 1] % 2 === 1);
          var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
          return res;
        } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
          return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
        }
        throw new Error("Unknown point format");
      };
      BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
        return this.encode(enc, true);
      };
      BasePoint.prototype._encode = function _encode(compact) {
        var len = this.curve.p.byteLength();
        var x = this.getX().toArray("be", len);
        if (compact)
          return [this.getY().isEven() ? 2 : 3].concat(x);
        return [4].concat(x, this.getY().toArray("be", len));
      };
      BasePoint.prototype.encode = function encode(enc, compact) {
        return utils.encode(this._encode(compact), enc);
      };
      BasePoint.prototype.precompute = function precompute(power) {
        if (this.precomputed)
          return this;
        var precomputed = {
          doubles: null,
          naf: null,
          beta: null
        };
        precomputed.naf = this._getNAFPoints(8);
        precomputed.doubles = this._getDoubles(4, power);
        precomputed.beta = this._getBeta();
        this.precomputed = precomputed;
        return this;
      };
      BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
        if (!this.precomputed)
          return false;
        var doubles = this.precomputed.doubles;
        if (!doubles)
          return false;
        return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
      };
      BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
        if (this.precomputed && this.precomputed.doubles)
          return this.precomputed.doubles;
        var doubles = [this];
        var acc = this;
        for (var i = 0; i < power; i += step) {
          for (var j = 0; j < step; j++) {
            acc = acc.dbl();
          }
          doubles.push(acc);
        }
        return {
          step,
          points: doubles
        };
      };
      BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
        if (this.precomputed && this.precomputed.naf)
          return this.precomputed.naf;
        var res = [this];
        var max = (1 << wnd) - 1;
        var dbl = max === 1 ? null : this.dbl();
        for (var i = 1; i < max; i++) {
          res[i] = res[i - 1].add(dbl);
        }
        return {
          wnd,
          points: res
        };
      };
      BasePoint.prototype._getBeta = function _getBeta() {
        return null;
      };
      BasePoint.prototype.dblp = function dblp(k) {
        var r = this;
        for (var i = 0; i < k; i++) {
          r = r.dbl();
        }
        return r;
      };
    }, { "../utils": 181, "bn.js": 182 }], 169: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var BN = require2("bn.js");
      var inherits = require2("inherits");
      var Base = require2("./base");
      var assert = utils.assert;
      function EdwardsCurve(conf) {
        this.twisted = (conf.a | 0) !== 1;
        this.mOneA = this.twisted && (conf.a | 0) === -1;
        this.extended = this.mOneA;
        Base.call(this, "edwards", conf);
        this.a = new BN(conf.a, 16).umod(this.red.m);
        this.a = this.a.toRed(this.red);
        this.c = new BN(conf.c, 16).toRed(this.red);
        this.c2 = this.c.redSqr();
        this.d = new BN(conf.d, 16).toRed(this.red);
        this.dd = this.d.redAdd(this.d);
        assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
        this.oneC = (conf.c | 0) === 1;
      }
      inherits(EdwardsCurve, Base);
      module2.exports = EdwardsCurve;
      EdwardsCurve.prototype._mulA = function _mulA(num) {
        if (this.mOneA)
          return num.redNeg();
        else
          return this.a.redMul(num);
      };
      EdwardsCurve.prototype._mulC = function _mulC(num) {
        if (this.oneC)
          return num;
        else
          return this.c.redMul(num);
      };
      EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
        return this.point(x, y, z, t);
      };
      EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
        x = new BN(x, 16);
        if (!x.red)
          x = x.toRed(this.red);
        var x2 = x.redSqr();
        var rhs = this.c2.redSub(this.a.redMul(x2));
        var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
        var y2 = rhs.redMul(lhs.redInvm());
        var y = y2.redSqrt();
        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd)
          y = y.redNeg();
        return this.point(x, y);
      };
      EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
        y = new BN(y, 16);
        if (!y.red)
          y = y.toRed(this.red);
        var y2 = y.redSqr();
        var lhs = y2.redSub(this.c2);
        var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
        var x2 = lhs.redMul(rhs.redInvm());
        if (x2.cmp(this.zero) === 0) {
          if (odd)
            throw new Error("invalid point");
          else
            return this.point(this.zero, y);
        }
        var x = x2.redSqrt();
        if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        if (x.fromRed().isOdd() !== odd)
          x = x.redNeg();
        return this.point(x, y);
      };
      EdwardsCurve.prototype.validate = function validate(point) {
        if (point.isInfinity())
          return true;
        point.normalize();
        var x2 = point.x.redSqr();
        var y2 = point.y.redSqr();
        var lhs = x2.redMul(this.a).redAdd(y2);
        var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
        return lhs.cmp(rhs) === 0;
      };
      function Point(curve, x, y, z, t) {
        Base.BasePoint.call(this, curve, "projective");
        if (x === null && y === null && z === null) {
          this.x = this.curve.zero;
          this.y = this.curve.one;
          this.z = this.curve.one;
          this.t = this.curve.zero;
          this.zOne = true;
        } else {
          this.x = new BN(x, 16);
          this.y = new BN(y, 16);
          this.z = z ? new BN(z, 16) : this.curve.one;
          this.t = t && new BN(t, 16);
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.y.red)
            this.y = this.y.toRed(this.curve.red);
          if (!this.z.red)
            this.z = this.z.toRed(this.curve.red);
          if (this.t && !this.t.red)
            this.t = this.t.toRed(this.curve.red);
          this.zOne = this.z === this.curve.one;
          if (this.curve.extended && !this.t) {
            this.t = this.x.redMul(this.y);
            if (!this.zOne)
              this.t = this.t.redMul(this.z.redInvm());
          }
        }
      }
      inherits(Point, Base.BasePoint);
      EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
      };
      EdwardsCurve.prototype.point = function point(x, y, z, t) {
        return new Point(this, x, y, z, t);
      };
      Point.fromJSON = function fromJSON(curve, obj) {
        return new Point(curve, obj[0], obj[1], obj[2]);
      };
      Point.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
      };
      Point.prototype._extDbl = function _extDbl() {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c = this.z.redSqr();
        c = c.redIAdd(c);
        var d = this.curve._mulA(a);
        var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
        var g = d.redAdd(b);
        var f = g.redSub(c);
        var h = d.redSub(b);
        var nx = e.redMul(f);
        var ny = g.redMul(h);
        var nt = e.redMul(h);
        var nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
      };
      Point.prototype._projDbl = function _projDbl() {
        var b = this.x.redAdd(this.y).redSqr();
        var c = this.x.redSqr();
        var d = this.y.redSqr();
        var nx;
        var ny;
        var nz;
        var e;
        var h;
        var j;
        if (this.curve.twisted) {
          e = this.curve._mulA(c);
          var f = e.redAdd(d);
          if (this.zOne) {
            nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
            ny = f.redMul(e.redSub(d));
            nz = f.redSqr().redSub(f).redSub(f);
          } else {
            h = this.z.redSqr();
            j = f.redSub(h).redISub(h);
            nx = b.redSub(c).redISub(d).redMul(j);
            ny = f.redMul(e.redSub(d));
            nz = f.redMul(j);
          }
        } else {
          e = c.redAdd(d);
          h = this.curve._mulC(this.z).redSqr();
          j = e.redSub(h).redSub(h);
          nx = this.curve._mulC(b.redISub(e)).redMul(j);
          ny = this.curve._mulC(e).redMul(c.redISub(d));
          nz = e.redMul(j);
        }
        return this.curve.point(nx, ny, nz);
      };
      Point.prototype.dbl = function dbl() {
        if (this.isInfinity())
          return this;
        if (this.curve.extended)
          return this._extDbl();
        else
          return this._projDbl();
      };
      Point.prototype._extAdd = function _extAdd(p) {
        var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
        var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
        var c = this.t.redMul(this.curve.dd).redMul(p.t);
        var d = this.z.redMul(p.z.redAdd(p.z));
        var e = b.redSub(a);
        var f = d.redSub(c);
        var g = d.redAdd(c);
        var h = b.redAdd(a);
        var nx = e.redMul(f);
        var ny = g.redMul(h);
        var nt = e.redMul(h);
        var nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
      };
      Point.prototype._projAdd = function _projAdd(p) {
        var a = this.z.redMul(p.z);
        var b = a.redSqr();
        var c = this.x.redMul(p.x);
        var d = this.y.redMul(p.y);
        var e = this.curve.d.redMul(c).redMul(d);
        var f = b.redSub(e);
        var g = b.redAdd(e);
        var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
        var nx = a.redMul(f).redMul(tmp);
        var ny;
        var nz;
        if (this.curve.twisted) {
          ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
          nz = f.redMul(g);
        } else {
          ny = a.redMul(g).redMul(d.redSub(c));
          nz = this.curve._mulC(f).redMul(g);
        }
        return this.curve.point(nx, ny, nz);
      };
      Point.prototype.add = function add(p) {
        if (this.isInfinity())
          return p;
        if (p.isInfinity())
          return this;
        if (this.curve.extended)
          return this._extAdd(p);
        else
          return this._projAdd(p);
      };
      Point.prototype.mul = function mul(k) {
        if (this._hasDoubles(k))
          return this.curve._fixedNafMul(this, k);
        else
          return this.curve._wnafMul(this, k);
      };
      Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
      };
      Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
      };
      Point.prototype.normalize = function normalize() {
        if (this.zOne)
          return this;
        var zi = this.z.redInvm();
        this.x = this.x.redMul(zi);
        this.y = this.y.redMul(zi);
        if (this.t)
          this.t = this.t.redMul(zi);
        this.z = this.curve.one;
        this.zOne = true;
        return this;
      };
      Point.prototype.neg = function neg() {
        return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
      };
      Point.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
      };
      Point.prototype.getY = function getY() {
        this.normalize();
        return this.y.fromRed();
      };
      Point.prototype.eq = function eq(other) {
        return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
      };
      Point.prototype.eqXToP = function eqXToP(x) {
        var rx = x.toRed(this.curve.red).redMul(this.z);
        if (this.x.cmp(rx) === 0)
          return true;
        var xc = x.clone();
        var t = this.curve.redN.redMul(this.z);
        for (; ; ) {
          xc.iadd(this.curve.n);
          if (xc.cmp(this.curve.p) >= 0)
            return false;
          rx.redIAdd(t);
          if (this.x.cmp(rx) === 0)
            return true;
        }
      };
      Point.prototype.toP = Point.prototype.normalize;
      Point.prototype.mixedAdd = Point.prototype.add;
    }, { "../utils": 181, "./base": 168, "bn.js": 182, "inherits": 256 }], 170: [function(require2, module2, exports2) {
      var curve = exports2;
      curve.base = require2("./base");
      curve.short = require2("./short");
      curve.mont = require2("./mont");
      curve.edwards = require2("./edwards");
    }, { "./base": 168, "./edwards": 169, "./mont": 171, "./short": 172 }], 171: [function(require2, module2, exports2) {
      var BN = require2("bn.js");
      var inherits = require2("inherits");
      var Base = require2("./base");
      var utils = require2("../utils");
      function MontCurve(conf) {
        Base.call(this, "mont", conf);
        this.a = new BN(conf.a, 16).toRed(this.red);
        this.b = new BN(conf.b, 16).toRed(this.red);
        this.i4 = new BN(4).toRed(this.red).redInvm();
        this.two = new BN(2).toRed(this.red);
        this.a24 = this.i4.redMul(this.a.redAdd(this.two));
      }
      inherits(MontCurve, Base);
      module2.exports = MontCurve;
      MontCurve.prototype.validate = function validate(point) {
        var x = point.normalize().x;
        var x2 = x.redSqr();
        var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
        var y = rhs.redSqrt();
        return y.redSqr().cmp(rhs) === 0;
      };
      function Point(curve, x, z) {
        Base.BasePoint.call(this, curve, "projective");
        if (x === null && z === null) {
          this.x = this.curve.one;
          this.z = this.curve.zero;
        } else {
          this.x = new BN(x, 16);
          this.z = new BN(z, 16);
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.z.red)
            this.z = this.z.toRed(this.curve.red);
        }
      }
      inherits(Point, Base.BasePoint);
      MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
        return this.point(utils.toArray(bytes, enc), 1);
      };
      MontCurve.prototype.point = function point(x, z) {
        return new Point(this, x, z);
      };
      MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
      };
      Point.prototype.precompute = function precompute() {
      };
      Point.prototype._encode = function _encode() {
        return this.getX().toArray("be", this.curve.p.byteLength());
      };
      Point.fromJSON = function fromJSON(curve, obj) {
        return new Point(curve, obj[0], obj[1] || curve.one);
      };
      Point.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
      };
      Point.prototype.dbl = function dbl() {
        var a = this.x.redAdd(this.z);
        var aa = a.redSqr();
        var b = this.x.redSub(this.z);
        var bb = b.redSqr();
        var c = aa.redSub(bb);
        var nx = aa.redMul(bb);
        var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
        return this.curve.point(nx, nz);
      };
      Point.prototype.add = function add() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.diffAdd = function diffAdd(p, diff) {
        var a = this.x.redAdd(this.z);
        var b = this.x.redSub(this.z);
        var c = p.x.redAdd(p.z);
        var d = p.x.redSub(p.z);
        var da = d.redMul(a);
        var cb = c.redMul(b);
        var nx = diff.z.redMul(da.redAdd(cb).redSqr());
        var nz = diff.x.redMul(da.redISub(cb).redSqr());
        return this.curve.point(nx, nz);
      };
      Point.prototype.mul = function mul(k) {
        var t = k.clone();
        var a = this;
        var b = this.curve.point(null, null);
        var c = this;
        for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1)) {
          bits.push(t.andln(1));
        }
        for (var i = bits.length - 1; i >= 0; i--) {
          if (bits[i] === 0) {
            a = a.diffAdd(b, c);
            b = b.dbl();
          } else {
            b = a.diffAdd(b, c);
            a = a.dbl();
          }
        }
        return b;
      };
      Point.prototype.mulAdd = function mulAdd() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.jumlAdd = function jumlAdd() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.eq = function eq(other) {
        return this.getX().cmp(other.getX()) === 0;
      };
      Point.prototype.normalize = function normalize() {
        this.x = this.x.redMul(this.z.redInvm());
        this.z = this.curve.one;
        return this;
      };
      Point.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
      };
    }, { "../utils": 181, "./base": 168, "bn.js": 182, "inherits": 256 }], 172: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var BN = require2("bn.js");
      var inherits = require2("inherits");
      var Base = require2("./base");
      var assert = utils.assert;
      function ShortCurve(conf) {
        Base.call(this, "short", conf);
        this.a = new BN(conf.a, 16).toRed(this.red);
        this.b = new BN(conf.b, 16).toRed(this.red);
        this.tinv = this.two.redInvm();
        this.zeroA = this.a.fromRed().cmpn(0) === 0;
        this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
        this.endo = this._getEndomorphism(conf);
        this._endoWnafT1 = new Array(4);
        this._endoWnafT2 = new Array(4);
      }
      inherits(ShortCurve, Base);
      module2.exports = ShortCurve;
      ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
        if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
          return;
        var beta;
        var lambda;
        if (conf.beta) {
          beta = new BN(conf.beta, 16).toRed(this.red);
        } else {
          var betas = this._getEndoRoots(this.p);
          beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
          beta = beta.toRed(this.red);
        }
        if (conf.lambda) {
          lambda = new BN(conf.lambda, 16);
        } else {
          var lambdas = this._getEndoRoots(this.n);
          if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
            lambda = lambdas[0];
          } else {
            lambda = lambdas[1];
            assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
          }
        }
        var basis;
        if (conf.basis) {
          basis = conf.basis.map(function(vec) {
            return {
              a: new BN(vec.a, 16),
              b: new BN(vec.b, 16)
            };
          });
        } else {
          basis = this._getEndoBasis(lambda);
        }
        return {
          beta,
          lambda,
          basis
        };
      };
      ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
        var red = num === this.p ? this.red : BN.mont(num);
        var tinv = new BN(2).toRed(red).redInvm();
        var ntinv = tinv.redNeg();
        var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
        var l1 = ntinv.redAdd(s).fromRed();
        var l2 = ntinv.redSub(s).fromRed();
        return [l1, l2];
      };
      ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
        var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
        var u = lambda;
        var v = this.n.clone();
        var x1 = new BN(1);
        var y1 = new BN(0);
        var x2 = new BN(0);
        var y2 = new BN(1);
        var a0;
        var b0;
        var a1;
        var b1;
        var a2;
        var b2;
        var prevR;
        var i = 0;
        var r;
        var x;
        while (u.cmpn(0) !== 0) {
          var q = v.div(u);
          r = v.sub(q.mul(u));
          x = x2.sub(q.mul(x1));
          var y = y2.sub(q.mul(y1));
          if (!a1 && r.cmp(aprxSqrt) < 0) {
            a0 = prevR.neg();
            b0 = x1;
            a1 = r.neg();
            b1 = x;
          } else if (a1 && ++i === 2) {
            break;
          }
          prevR = r;
          v = u;
          u = r;
          x2 = x1;
          x1 = x;
          y2 = y1;
          y1 = y;
        }
        a2 = r.neg();
        b2 = x;
        var len1 = a1.sqr().add(b1.sqr());
        var len2 = a2.sqr().add(b2.sqr());
        if (len2.cmp(len1) >= 0) {
          a2 = a0;
          b2 = b0;
        }
        if (a1.negative) {
          a1 = a1.neg();
          b1 = b1.neg();
        }
        if (a2.negative) {
          a2 = a2.neg();
          b2 = b2.neg();
        }
        return [{
          a: a1,
          b: b1
        }, {
          a: a2,
          b: b2
        }];
      };
      ShortCurve.prototype._endoSplit = function _endoSplit(k) {
        var basis = this.endo.basis;
        var v1 = basis[0];
        var v2 = basis[1];
        var c1 = v2.b.mul(k).divRound(this.n);
        var c2 = v1.b.neg().mul(k).divRound(this.n);
        var p1 = c1.mul(v1.a);
        var p2 = c2.mul(v2.a);
        var q1 = c1.mul(v1.b);
        var q2 = c2.mul(v2.b);
        var k1 = k.sub(p1).sub(p2);
        var k2 = q1.add(q2).neg();
        return {
          k1,
          k2
        };
      };
      ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
        x = new BN(x, 16);
        if (!x.red)
          x = x.toRed(this.red);
        var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
        var y = y2.redSqrt();
        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd)
          y = y.redNeg();
        return this.point(x, y);
      };
      ShortCurve.prototype.validate = function validate(point) {
        if (point.inf)
          return true;
        var x = point.x;
        var y = point.y;
        var ax = this.a.redMul(x);
        var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
        return y.redSqr().redISub(rhs).cmpn(0) === 0;
      };
      ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
        var npoints = this._endoWnafT1;
        var ncoeffs = this._endoWnafT2;
        for (var i = 0; i < points.length; i++) {
          var split = this._endoSplit(coeffs[i]);
          var p = points[i];
          var beta = p._getBeta();
          if (split.k1.negative) {
            split.k1.ineg();
            p = p.neg(true);
          }
          if (split.k2.negative) {
            split.k2.ineg();
            beta = beta.neg(true);
          }
          npoints[i * 2] = p;
          npoints[i * 2 + 1] = beta;
          ncoeffs[i * 2] = split.k1;
          ncoeffs[i * 2 + 1] = split.k2;
        }
        var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
        for (var j = 0; j < i * 2; j++) {
          npoints[j] = null;
          ncoeffs[j] = null;
        }
        return res;
      };
      function Point(curve, x, y, isRed) {
        Base.BasePoint.call(this, curve, "affine");
        if (x === null && y === null) {
          this.x = null;
          this.y = null;
          this.inf = true;
        } else {
          this.x = new BN(x, 16);
          this.y = new BN(y, 16);
          if (isRed) {
            this.x.forceRed(this.curve.red);
            this.y.forceRed(this.curve.red);
          }
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.y.red)
            this.y = this.y.toRed(this.curve.red);
          this.inf = false;
        }
      }
      inherits(Point, Base.BasePoint);
      ShortCurve.prototype.point = function point(x, y, isRed) {
        return new Point(this, x, y, isRed);
      };
      ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
        return Point.fromJSON(this, obj, red);
      };
      Point.prototype._getBeta = function _getBeta() {
        if (!this.curve.endo)
          return;
        var pre = this.precomputed;
        if (pre && pre.beta)
          return pre.beta;
        var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (pre) {
          var curve = this.curve;
          var endoMul = function endoMul2(p) {
            return curve.point(p.x.redMul(curve.endo.beta), p.y);
          };
          pre.beta = beta;
          beta.precomputed = {
            beta: null,
            naf: pre.naf && {
              wnd: pre.naf.wnd,
              points: pre.naf.points.map(endoMul)
            },
            doubles: pre.doubles && {
              step: pre.doubles.step,
              points: pre.doubles.points.map(endoMul)
            }
          };
        }
        return beta;
      };
      Point.prototype.toJSON = function toJSON() {
        if (!this.precomputed)
          return [this.x, this.y];
        return [this.x, this.y, this.precomputed && {
          doubles: this.precomputed.doubles && {
            step: this.precomputed.doubles.step,
            points: this.precomputed.doubles.points.slice(1)
          },
          naf: this.precomputed.naf && {
            wnd: this.precomputed.naf.wnd,
            points: this.precomputed.naf.points.slice(1)
          }
        }];
      };
      Point.fromJSON = function fromJSON(curve, obj, red) {
        if (typeof obj === "string")
          obj = JSON.parse(obj);
        var res = curve.point(obj[0], obj[1], red);
        if (!obj[2])
          return res;
        function obj2point(obj2) {
          return curve.point(obj2[0], obj2[1], red);
        }
        var pre = obj[2];
        res.precomputed = {
          beta: null,
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: [res].concat(pre.doubles.points.map(obj2point))
          },
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: [res].concat(pre.naf.points.map(obj2point))
          }
        };
        return res;
      };
      Point.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.inf;
      };
      Point.prototype.add = function add(p) {
        if (this.inf)
          return p;
        if (p.inf)
          return this;
        if (this.eq(p))
          return this.dbl();
        if (this.neg().eq(p))
          return this.curve.point(null, null);
        if (this.x.cmp(p.x) === 0)
          return this.curve.point(null, null);
        var c = this.y.redSub(p.y);
        if (c.cmpn(0) !== 0)
          c = c.redMul(this.x.redSub(p.x).redInvm());
        var nx = c.redSqr().redISub(this.x).redISub(p.x);
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      };
      Point.prototype.dbl = function dbl() {
        if (this.inf)
          return this;
        var ys1 = this.y.redAdd(this.y);
        if (ys1.cmpn(0) === 0)
          return this.curve.point(null, null);
        var a = this.curve.a;
        var x2 = this.x.redSqr();
        var dyinv = ys1.redInvm();
        var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
        var nx = c.redSqr().redISub(this.x.redAdd(this.x));
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      };
      Point.prototype.getX = function getX() {
        return this.x.fromRed();
      };
      Point.prototype.getY = function getY() {
        return this.y.fromRed();
      };
      Point.prototype.mul = function mul(k) {
        k = new BN(k, 16);
        if (this.isInfinity())
          return this;
        else if (this._hasDoubles(k))
          return this.curve._fixedNafMul(this, k);
        else if (this.curve.endo)
          return this.curve._endoWnafMulAdd([this], [k]);
        else
          return this.curve._wnafMul(this, k);
      };
      Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
        var points = [this, p2];
        var coeffs = [k1, k2];
        if (this.curve.endo)
          return this.curve._endoWnafMulAdd(points, coeffs);
        else
          return this.curve._wnafMulAdd(1, points, coeffs, 2);
      };
      Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
        var points = [this, p2];
        var coeffs = [k1, k2];
        if (this.curve.endo)
          return this.curve._endoWnafMulAdd(points, coeffs, true);
        else
          return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
      };
      Point.prototype.eq = function eq(p) {
        return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
      };
      Point.prototype.neg = function neg(_precompute) {
        if (this.inf)
          return this;
        var res = this.curve.point(this.x, this.y.redNeg());
        if (_precompute && this.precomputed) {
          var pre = this.precomputed;
          var negate = function negate2(p) {
            return p.neg();
          };
          res.precomputed = {
            naf: pre.naf && {
              wnd: pre.naf.wnd,
              points: pre.naf.points.map(negate)
            },
            doubles: pre.doubles && {
              step: pre.doubles.step,
              points: pre.doubles.points.map(negate)
            }
          };
        }
        return res;
      };
      Point.prototype.toJ = function toJ() {
        if (this.inf)
          return this.curve.jpoint(null, null, null);
        var res = this.curve.jpoint(this.x, this.y, this.curve.one);
        return res;
      };
      function JPoint(curve, x, y, z) {
        Base.BasePoint.call(this, curve, "jacobian");
        if (x === null && y === null && z === null) {
          this.x = this.curve.one;
          this.y = this.curve.one;
          this.z = new BN(0);
        } else {
          this.x = new BN(x, 16);
          this.y = new BN(y, 16);
          this.z = new BN(z, 16);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
      }
      inherits(JPoint, Base.BasePoint);
      ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
        return new JPoint(this, x, y, z);
      };
      JPoint.prototype.toP = function toP() {
        if (this.isInfinity())
          return this.curve.point(null, null);
        var zinv = this.z.redInvm();
        var zinv2 = zinv.redSqr();
        var ax = this.x.redMul(zinv2);
        var ay = this.y.redMul(zinv2).redMul(zinv);
        return this.curve.point(ax, ay);
      };
      JPoint.prototype.neg = function neg() {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
      };
      JPoint.prototype.add = function add(p) {
        if (this.isInfinity())
          return p;
        if (p.isInfinity())
          return this;
        var pz2 = p.z.redSqr();
        var z2 = this.z.redSqr();
        var u1 = this.x.redMul(pz2);
        var u2 = p.x.redMul(z2);
        var s1 = this.y.redMul(pz2.redMul(p.z));
        var s2 = p.y.redMul(z2.redMul(this.z));
        var h = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h.cmpn(0) === 0) {
          if (r.cmpn(0) !== 0)
            return this.curve.jpoint(null, null, null);
          else
            return this.dbl();
        }
        var h2 = h.redSqr();
        var h3 = h2.redMul(h);
        var v = u1.redMul(h2);
        var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
        var nz = this.z.redMul(p.z).redMul(h);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.mixedAdd = function mixedAdd(p) {
        if (this.isInfinity())
          return p.toJ();
        if (p.isInfinity())
          return this;
        var z2 = this.z.redSqr();
        var u1 = this.x;
        var u2 = p.x.redMul(z2);
        var s1 = this.y;
        var s2 = p.y.redMul(z2).redMul(this.z);
        var h = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h.cmpn(0) === 0) {
          if (r.cmpn(0) !== 0)
            return this.curve.jpoint(null, null, null);
          else
            return this.dbl();
        }
        var h2 = h.redSqr();
        var h3 = h2.redMul(h);
        var v = u1.redMul(h2);
        var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
        var nz = this.z.redMul(h);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.dblp = function dblp(pow) {
        if (pow === 0)
          return this;
        if (this.isInfinity())
          return this;
        if (!pow)
          return this.dbl();
        var i;
        if (this.curve.zeroA || this.curve.threeA) {
          var r = this;
          for (i = 0; i < pow; i++) {
            r = r.dbl();
          }
          return r;
        }
        var a = this.curve.a;
        var tinv = this.curve.tinv;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jyd = jy.redAdd(jy);
        for (i = 0; i < pow; i++) {
          var jx2 = jx.redSqr();
          var jyd2 = jyd.redSqr();
          var jyd4 = jyd2.redSqr();
          var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
          var t1 = jx.redMul(jyd2);
          var nx = c.redSqr().redISub(t1.redAdd(t1));
          var t2 = t1.redISub(nx);
          var dny = c.redMul(t2);
          dny = dny.redIAdd(dny).redISub(jyd4);
          var nz = jyd.redMul(jz);
          if (i + 1 < pow)
            jz4 = jz4.redMul(jyd4);
          jx = nx;
          jz = nz;
          jyd = dny;
        }
        return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
      };
      JPoint.prototype.dbl = function dbl() {
        if (this.isInfinity())
          return this;
        if (this.curve.zeroA)
          return this._zeroDbl();
        else if (this.curve.threeA)
          return this._threeDbl();
        else
          return this._dbl();
      };
      JPoint.prototype._zeroDbl = function _zeroDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
          var xx = this.x.redSqr();
          var yy = this.y.redSqr();
          var yyyy = yy.redSqr();
          var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
          s = s.redIAdd(s);
          var m = xx.redAdd(xx).redIAdd(xx);
          var t = m.redSqr().redISub(s).redISub(s);
          var yyyy8 = yyyy.redIAdd(yyyy);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          nx = t;
          ny = m.redMul(s.redISub(t)).redISub(yyyy8);
          nz = this.y.redAdd(this.y);
        } else {
          var a = this.x.redSqr();
          var b = this.y.redSqr();
          var c = b.redSqr();
          var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
          d = d.redIAdd(d);
          var e = a.redAdd(a).redIAdd(a);
          var f = e.redSqr();
          var c8 = c.redIAdd(c);
          c8 = c8.redIAdd(c8);
          c8 = c8.redIAdd(c8);
          nx = f.redISub(d).redISub(d);
          ny = e.redMul(d.redISub(nx)).redISub(c8);
          nz = this.y.redMul(this.z);
          nz = nz.redIAdd(nz);
        }
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype._threeDbl = function _threeDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
          var xx = this.x.redSqr();
          var yy = this.y.redSqr();
          var yyyy = yy.redSqr();
          var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
          s = s.redIAdd(s);
          var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
          var t = m.redSqr().redISub(s).redISub(s);
          nx = t;
          var yyyy8 = yyyy.redIAdd(yyyy);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          ny = m.redMul(s.redISub(t)).redISub(yyyy8);
          nz = this.y.redAdd(this.y);
        } else {
          var delta = this.z.redSqr();
          var gamma = this.y.redSqr();
          var beta = this.x.redMul(gamma);
          var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
          alpha = alpha.redAdd(alpha).redIAdd(alpha);
          var beta4 = beta.redIAdd(beta);
          beta4 = beta4.redIAdd(beta4);
          var beta8 = beta4.redAdd(beta4);
          nx = alpha.redSqr().redISub(beta8);
          nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
          var ggamma8 = gamma.redSqr();
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
        }
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype._dbl = function _dbl() {
        var a = this.curve.a;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jx2 = jx.redSqr();
        var jy2 = jy.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var jxd4 = jx.redAdd(jx);
        jxd4 = jxd4.redIAdd(jxd4);
        var t1 = jxd4.redMul(jy2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var jyd8 = jy2.redSqr();
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        var ny = c.redMul(t2).redISub(jyd8);
        var nz = jy.redAdd(jy).redMul(jz);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.trpl = function trpl() {
        if (!this.curve.zeroA)
          return this.dbl().add(this);
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var zz = this.z.redSqr();
        var yyyy = yy.redSqr();
        var m = xx.redAdd(xx).redIAdd(xx);
        var mm = m.redSqr();
        var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        e = e.redIAdd(e);
        e = e.redAdd(e).redIAdd(e);
        e = e.redISub(mm);
        var ee = e.redSqr();
        var t = yyyy.redIAdd(yyyy);
        t = t.redIAdd(t);
        t = t.redIAdd(t);
        t = t.redIAdd(t);
        var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
        var yyu4 = yy.redMul(u);
        yyu4 = yyu4.redIAdd(yyu4);
        yyu4 = yyu4.redIAdd(yyu4);
        var nx = this.x.redMul(ee).redISub(yyu4);
        nx = nx.redIAdd(nx);
        nx = nx.redIAdd(nx);
        var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.mul = function mul(k, kbase) {
        k = new BN(k, kbase);
        return this.curve._wnafMul(this, k);
      };
      JPoint.prototype.eq = function eq(p) {
        if (p.type === "affine")
          return this.eq(p.toJ());
        if (this === p)
          return true;
        var z2 = this.z.redSqr();
        var pz2 = p.z.redSqr();
        if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
          return false;
        var z3 = z2.redMul(this.z);
        var pz3 = pz2.redMul(p.z);
        return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
      };
      JPoint.prototype.eqXToP = function eqXToP(x) {
        var zs = this.z.redSqr();
        var rx = x.toRed(this.curve.red).redMul(zs);
        if (this.x.cmp(rx) === 0)
          return true;
        var xc = x.clone();
        var t = this.curve.redN.redMul(zs);
        for (; ; ) {
          xc.iadd(this.curve.n);
          if (xc.cmp(this.curve.p) >= 0)
            return false;
          rx.redIAdd(t);
          if (this.x.cmp(rx) === 0)
            return true;
        }
      };
      JPoint.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC JPoint Infinity>";
        return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
      };
      JPoint.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
      };
    }, { "../utils": 181, "./base": 168, "bn.js": 182, "inherits": 256 }], 173: [function(require2, module2, exports2) {
      var curves = exports2;
      var hash = require2("hash.js");
      var curve = require2("./curve");
      var utils = require2("./utils");
      var assert = utils.assert;
      function PresetCurve(options) {
        if (options.type === "short")
          this.curve = new curve.short(options);
        else if (options.type === "edwards")
          this.curve = new curve.edwards(options);
        else
          this.curve = new curve.mont(options);
        this.g = this.curve.g;
        this.n = this.curve.n;
        this.hash = options.hash;
        assert(this.g.validate(), "Invalid curve");
        assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
      }
      curves.PresetCurve = PresetCurve;
      function defineCurve(name, options) {
        Object.defineProperty(curves, name, {
          configurable: true,
          enumerable: true,
          get: function get() {
            var curve2 = new PresetCurve(options);
            Object.defineProperty(curves, name, {
              configurable: true,
              enumerable: true,
              value: curve2
            });
            return curve2;
          }
        });
      }
      defineCurve("p192", {
        type: "short",
        prime: "p192",
        p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
        b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
        n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
        hash: hash.sha256,
        gRed: false,
        g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
      });
      defineCurve("p224", {
        type: "short",
        prime: "p224",
        p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
        b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
        n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
        hash: hash.sha256,
        gRed: false,
        g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
      });
      defineCurve("p256", {
        type: "short",
        prime: null,
        p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
        a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
        b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
        n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
        hash: hash.sha256,
        gRed: false,
        g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
      });
      defineCurve("p384", {
        type: "short",
        prime: null,
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
        a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
        b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
        n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
        hash: hash.sha384,
        gRed: false,
        g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
      });
      defineCurve("p521", {
        type: "short",
        prime: null,
        p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
        a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
        b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
        n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
        hash: hash.sha512,
        gRed: false,
        g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
      });
      defineCurve("curve25519", {
        type: "mont",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "76d06",
        b: "1",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: hash.sha256,
        gRed: false,
        g: ["9"]
      });
      defineCurve("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: hash.sha256,
        gRed: false,
        g: [
          "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
          "6666666666666666666666666666666666666666666666666666666666666658"
        ]
      });
      var pre;
      try {
        pre = require2("./precomputed/secp256k1");
      } catch (e) {
        pre = void 0;
      }
      defineCurve("secp256k1", {
        type: "short",
        prime: "k256",
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
        a: "0",
        b: "7",
        n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
        h: "1",
        hash: hash.sha256,
        beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
        basis: [{
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        }, {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }],
        gRed: false,
        g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", pre]
      });
    }, { "./curve": 170, "./precomputed/secp256k1": 180, "./utils": 181, "hash.js": 211 }], 174: [function(require2, module2, exports2) {
      var BN = require2("bn.js");
      var HmacDRBG = require2("hmac-drbg");
      var utils = require2("../utils");
      var curves = require2("../curves");
      var rand = require2("brorand");
      var assert = utils.assert;
      var KeyPair = require2("./key");
      var Signature = require2("./signature");
      function EC(options) {
        if (!(this instanceof EC))
          return new EC(options);
        if (typeof options === "string") {
          assert(Object.prototype.hasOwnProperty.call(curves, options), "Unknown curve " + options);
          options = curves[options];
        }
        if (options instanceof curves.PresetCurve)
          options = {
            curve: options
          };
        this.curve = options.curve.curve;
        this.n = this.curve.n;
        this.nh = this.n.ushrn(1);
        this.g = this.curve.g;
        this.g = options.curve.g;
        this.g.precompute(options.curve.n.bitLength() + 1);
        this.hash = options.hash || options.curve.hash;
      }
      module2.exports = EC;
      EC.prototype.keyPair = function keyPair(options) {
        return new KeyPair(this, options);
      };
      EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
        return KeyPair.fromPrivate(this, priv, enc);
      };
      EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
        return KeyPair.fromPublic(this, pub, enc);
      };
      EC.prototype.genKeyPair = function genKeyPair(options) {
        if (!options)
          options = {};
        var drbg = new HmacDRBG({
          hash: this.hash,
          pers: options.pers,
          persEnc: options.persEnc || "utf8",
          entropy: options.entropy || rand(this.hash.hmacStrength),
          entropyEnc: options.entropy && options.entropyEnc || "utf8",
          nonce: this.n.toArray()
        });
        var bytes = this.n.byteLength();
        var ns2 = this.n.sub(new BN(2));
        for (; ; ) {
          var priv = new BN(drbg.generate(bytes));
          if (priv.cmp(ns2) > 0)
            continue;
          priv.iaddn(1);
          return this.keyFromPrivate(priv);
        }
      };
      EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
        var delta = msg.byteLength() * 8 - this.n.bitLength();
        if (delta > 0)
          msg = msg.ushrn(delta);
        if (!truncOnly && msg.cmp(this.n) >= 0)
          return msg.sub(this.n);
        else
          return msg;
      };
      EC.prototype.sign = function sign(msg, key, enc, options) {
        if (typeof enc === "object") {
          options = enc;
          enc = null;
        }
        if (!options)
          options = {};
        key = this.keyFromPrivate(key, enc);
        msg = this._truncateToN(new BN(msg, 16));
        var bytes = this.n.byteLength();
        var bkey = key.getPrivate().toArray("be", bytes);
        var nonce = msg.toArray("be", bytes);
        var drbg = new HmacDRBG({
          hash: this.hash,
          entropy: bkey,
          nonce,
          pers: options.pers,
          persEnc: options.persEnc || "utf8"
        });
        var ns1 = this.n.sub(new BN(1));
        for (var iter = 0; ; iter++) {
          var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
          k = this._truncateToN(k, true);
          if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
            continue;
          var kp = this.g.mul(k);
          if (kp.isInfinity())
            continue;
          var kpX = kp.getX();
          var r = kpX.umod(this.n);
          if (r.cmpn(0) === 0)
            continue;
          var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
          s = s.umod(this.n);
          if (s.cmpn(0) === 0)
            continue;
          var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
          if (options.canonical && s.cmp(this.nh) > 0) {
            s = this.n.sub(s);
            recoveryParam ^= 1;
          }
          return new Signature({
            r,
            s,
            recoveryParam
          });
        }
      };
      EC.prototype.verify = function verify(msg, signature, key, enc) {
        msg = this._truncateToN(new BN(msg, 16));
        key = this.keyFromPublic(key, enc);
        signature = new Signature(signature, "hex");
        var r = signature.r;
        var s = signature.s;
        if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
          return false;
        if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
          return false;
        var sinv = s.invm(this.n);
        var u1 = sinv.mul(msg).umod(this.n);
        var u2 = sinv.mul(r).umod(this.n);
        var p;
        if (!this.curve._maxwellTrick) {
          p = this.g.mulAdd(u1, key.getPublic(), u2);
          if (p.isInfinity())
            return false;
          return p.getX().umod(this.n).cmp(r) === 0;
        }
        p = this.g.jmulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.eqXToP(r);
      };
      EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
        assert((3 & j) === j, "The recovery param is more than two bits");
        signature = new Signature(signature, enc);
        var n = this.n;
        var e = new BN(msg);
        var r = signature.r;
        var s = signature.s;
        var isYOdd = j & 1;
        var isSecondKey = j >> 1;
        if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
          throw new Error("Unable to find sencond key candinate");
        if (isSecondKey)
          r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
        else
          r = this.curve.pointFromX(r, isYOdd);
        var rInv = signature.r.invm(n);
        var s1 = n.sub(e).mul(rInv).umod(n);
        var s2 = s.mul(rInv).umod(n);
        return this.g.mulAdd(s1, r, s2);
      };
      EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
        signature = new Signature(signature, enc);
        if (signature.recoveryParam !== null)
          return signature.recoveryParam;
        for (var i = 0; i < 4; i++) {
          var Qprime;
          try {
            Qprime = this.recoverPubKey(e, signature, i);
          } catch (e2) {
            continue;
          }
          if (Qprime.eq(Q))
            return i;
        }
        throw new Error("Unable to find valid recovery factor");
      };
    }, { "../curves": 173, "../utils": 181, "./key": 175, "./signature": 176, "bn.js": 182, "brorand": 52, "hmac-drbg": 225 }], 175: [function(require2, module2, exports2) {
      var BN = require2("bn.js");
      var utils = require2("../utils");
      var assert = utils.assert;
      function KeyPair(ec, options) {
        this.ec = ec;
        this.priv = null;
        this.pub = null;
        if (options.priv)
          this._importPrivate(options.priv, options.privEnc);
        if (options.pub)
          this._importPublic(options.pub, options.pubEnc);
      }
      module2.exports = KeyPair;
      KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
        if (pub instanceof KeyPair)
          return pub;
        return new KeyPair(ec, {
          pub,
          pubEnc: enc
        });
      };
      KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
        if (priv instanceof KeyPair)
          return priv;
        return new KeyPair(ec, {
          priv,
          privEnc: enc
        });
      };
      KeyPair.prototype.validate = function validate() {
        var pub = this.getPublic();
        if (pub.isInfinity())
          return {
            result: false,
            reason: "Invalid public key"
          };
        if (!pub.validate())
          return {
            result: false,
            reason: "Public key is not a point"
          };
        if (!pub.mul(this.ec.curve.n).isInfinity())
          return {
            result: false,
            reason: "Public key * N != O"
          };
        return {
          result: true,
          reason: null
        };
      };
      KeyPair.prototype.getPublic = function getPublic(compact, enc) {
        if (typeof compact === "string") {
          enc = compact;
          compact = null;
        }
        if (!this.pub)
          this.pub = this.ec.g.mul(this.priv);
        if (!enc)
          return this.pub;
        return this.pub.encode(enc, compact);
      };
      KeyPair.prototype.getPrivate = function getPrivate(enc) {
        if (enc === "hex")
          return this.priv.toString(16, 2);
        else
          return this.priv;
      };
      KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
        this.priv = new BN(key, enc || 16);
        this.priv = this.priv.umod(this.ec.curve.n);
      };
      KeyPair.prototype._importPublic = function _importPublic(key, enc) {
        if (key.x || key.y) {
          if (this.ec.curve.type === "mont") {
            assert(key.x, "Need x coordinate");
          } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
            assert(key.x && key.y, "Need both x and y coordinate");
          }
          this.pub = this.ec.curve.point(key.x, key.y);
          return;
        }
        this.pub = this.ec.curve.decodePoint(key, enc);
      };
      KeyPair.prototype.derive = function derive(pub) {
        if (!pub.validate()) {
          assert(pub.validate(), "public point not validated");
        }
        return pub.mul(this.priv).getX();
      };
      KeyPair.prototype.sign = function sign(msg, enc, options) {
        return this.ec.sign(msg, this, enc, options);
      };
      KeyPair.prototype.verify = function verify(msg, signature) {
        return this.ec.verify(msg, signature, this);
      };
      KeyPair.prototype.inspect = function inspect() {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
      };
    }, { "../utils": 181, "bn.js": 182 }], 176: [function(require2, module2, exports2) {
      var BN = require2("bn.js");
      var utils = require2("../utils");
      var assert = utils.assert;
      function Signature(options, enc) {
        if (options instanceof Signature)
          return options;
        if (this._importDER(options, enc))
          return;
        assert(options.r && options.s, "Signature without r or s");
        this.r = new BN(options.r, 16);
        this.s = new BN(options.s, 16);
        if (options.recoveryParam === void 0)
          this.recoveryParam = null;
        else
          this.recoveryParam = options.recoveryParam;
      }
      module2.exports = Signature;
      function Position() {
        this.place = 0;
      }
      function getLength(buf, p) {
        var initial = buf[p.place++];
        if (!(initial & 128)) {
          return initial;
        }
        var octetLen = initial & 15;
        if (octetLen === 0 || octetLen > 4) {
          return false;
        }
        var val = 0;
        for (var i = 0, off = p.place; i < octetLen; i++, off++) {
          val <<= 8;
          val |= buf[off];
          val >>>= 0;
        }
        if (val <= 127) {
          return false;
        }
        p.place = off;
        return val;
      }
      function rmPadding(buf) {
        var i = 0;
        var len = buf.length - 1;
        while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
          i++;
        }
        if (i === 0) {
          return buf;
        }
        return buf.slice(i);
      }
      Signature.prototype._importDER = function _importDER(data, enc) {
        data = utils.toArray(data, enc);
        var p = new Position();
        if (data[p.place++] !== 48) {
          return false;
        }
        var len = getLength(data, p);
        if (len === false) {
          return false;
        }
        if (len + p.place !== data.length) {
          return false;
        }
        if (data[p.place++] !== 2) {
          return false;
        }
        var rlen = getLength(data, p);
        if (rlen === false) {
          return false;
        }
        var r = data.slice(p.place, rlen + p.place);
        p.place += rlen;
        if (data[p.place++] !== 2) {
          return false;
        }
        var slen = getLength(data, p);
        if (slen === false) {
          return false;
        }
        if (data.length !== slen + p.place) {
          return false;
        }
        var s = data.slice(p.place, slen + p.place);
        if (r[0] === 0) {
          if (r[1] & 128) {
            r = r.slice(1);
          } else {
            return false;
          }
        }
        if (s[0] === 0) {
          if (s[1] & 128) {
            s = s.slice(1);
          } else {
            return false;
          }
        }
        this.r = new BN(r);
        this.s = new BN(s);
        this.recoveryParam = null;
        return true;
      };
      function constructLength(arr, len) {
        if (len < 128) {
          arr.push(len);
          return;
        }
        var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
        arr.push(octets | 128);
        while (--octets) {
          arr.push(len >>> (octets << 3) & 255);
        }
        arr.push(len);
      }
      Signature.prototype.toDER = function toDER(enc) {
        var r = this.r.toArray();
        var s = this.s.toArray();
        if (r[0] & 128)
          r = [0].concat(r);
        if (s[0] & 128)
          s = [0].concat(s);
        r = rmPadding(r);
        s = rmPadding(s);
        while (!s[0] && !(s[1] & 128)) {
          s = s.slice(1);
        }
        var arr = [2];
        constructLength(arr, r.length);
        arr = arr.concat(r);
        arr.push(2);
        constructLength(arr, s.length);
        var backHalf = arr.concat(s);
        var res = [48];
        constructLength(res, backHalf.length);
        res = res.concat(backHalf);
        return utils.encode(res, enc);
      };
    }, { "../utils": 181, "bn.js": 182 }], 177: [function(require2, module2, exports2) {
      var hash = require2("hash.js");
      var curves = require2("../curves");
      var utils = require2("../utils");
      var assert = utils.assert;
      var parseBytes = utils.parseBytes;
      var KeyPair = require2("./key");
      var Signature = require2("./signature");
      function EDDSA(curve) {
        assert(curve === "ed25519", "only tested with ed25519 so far");
        if (!(this instanceof EDDSA))
          return new EDDSA(curve);
        curve = curves[curve].curve;
        this.curve = curve;
        this.g = curve.g;
        this.g.precompute(curve.n.bitLength() + 1);
        this.pointClass = curve.point().constructor;
        this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
        this.hash = hash.sha512;
      }
      module2.exports = EDDSA;
      EDDSA.prototype.sign = function sign(message, secret) {
        message = parseBytes(message);
        var key = this.keyFromSecret(secret);
        var r = this.hashInt(key.messagePrefix(), message);
        var R = this.g.mul(r);
        var Rencoded = this.encodePoint(R);
        var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
        var S = r.add(s_).umod(this.curve.n);
        return this.makeSignature({
          R,
          S,
          Rencoded
        });
      };
      EDDSA.prototype.verify = function verify(message, sig, pub) {
        message = parseBytes(message);
        sig = this.makeSignature(sig);
        var key = this.keyFromPublic(pub);
        var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
        var SG = this.g.mul(sig.S());
        var RplusAh = sig.R().add(key.pub().mul(h));
        return RplusAh.eq(SG);
      };
      EDDSA.prototype.hashInt = function hashInt() {
        var hash2 = this.hash();
        for (var i = 0; i < arguments.length; i++) {
          hash2.update(arguments[i]);
        }
        return utils.intFromLE(hash2.digest()).umod(this.curve.n);
      };
      EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
        return KeyPair.fromPublic(this, pub);
      };
      EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
        return KeyPair.fromSecret(this, secret);
      };
      EDDSA.prototype.makeSignature = function makeSignature(sig) {
        if (sig instanceof Signature)
          return sig;
        return new Signature(this, sig);
      };
      EDDSA.prototype.encodePoint = function encodePoint(point) {
        var enc = point.getY().toArray("le", this.encodingLength);
        enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
        return enc;
      };
      EDDSA.prototype.decodePoint = function decodePoint(bytes) {
        bytes = utils.parseBytes(bytes);
        var lastIx = bytes.length - 1;
        var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
        var xIsOdd = (bytes[lastIx] & 128) !== 0;
        var y = utils.intFromLE(normed);
        return this.curve.pointFromY(y, xIsOdd);
      };
      EDDSA.prototype.encodeInt = function encodeInt(num) {
        return num.toArray("le", this.encodingLength);
      };
      EDDSA.prototype.decodeInt = function decodeInt(bytes) {
        return utils.intFromLE(bytes);
      };
      EDDSA.prototype.isPoint = function isPoint(val) {
        return val instanceof this.pointClass;
      };
    }, { "../curves": 173, "../utils": 181, "./key": 178, "./signature": 179, "hash.js": 211 }], 178: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var assert = utils.assert;
      var parseBytes = utils.parseBytes;
      var cachedProperty = utils.cachedProperty;
      function KeyPair(eddsa, params) {
        this.eddsa = eddsa;
        this._secret = parseBytes(params.secret);
        if (eddsa.isPoint(params.pub))
          this._pub = params.pub;
        else
          this._pubBytes = parseBytes(params.pub);
      }
      KeyPair.fromPublic = function fromPublic(eddsa, pub) {
        if (pub instanceof KeyPair)
          return pub;
        return new KeyPair(eddsa, {
          pub
        });
      };
      KeyPair.fromSecret = function fromSecret(eddsa, secret) {
        if (secret instanceof KeyPair)
          return secret;
        return new KeyPair(eddsa, {
          secret
        });
      };
      KeyPair.prototype.secret = function secret() {
        return this._secret;
      };
      cachedProperty(KeyPair, "pubBytes", function pubBytes() {
        return this.eddsa.encodePoint(this.pub());
      });
      cachedProperty(KeyPair, "pub", function pub() {
        if (this._pubBytes)
          return this.eddsa.decodePoint(this._pubBytes);
        return this.eddsa.g.mul(this.priv());
      });
      cachedProperty(KeyPair, "privBytes", function privBytes() {
        var eddsa = this.eddsa;
        var hash = this.hash();
        var lastIx = eddsa.encodingLength - 1;
        var a = hash.slice(0, eddsa.encodingLength);
        a[0] &= 248;
        a[lastIx] &= 127;
        a[lastIx] |= 64;
        return a;
      });
      cachedProperty(KeyPair, "priv", function priv() {
        return this.eddsa.decodeInt(this.privBytes());
      });
      cachedProperty(KeyPair, "hash", function hash() {
        return this.eddsa.hash().update(this.secret()).digest();
      });
      cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
        return this.hash().slice(this.eddsa.encodingLength);
      });
      KeyPair.prototype.sign = function sign(message) {
        assert(this._secret, "KeyPair can only verify");
        return this.eddsa.sign(message, this);
      };
      KeyPair.prototype.verify = function verify(message, sig) {
        return this.eddsa.verify(message, sig, this);
      };
      KeyPair.prototype.getSecret = function getSecret(enc) {
        assert(this._secret, "KeyPair is public only");
        return utils.encode(this.secret(), enc);
      };
      KeyPair.prototype.getPublic = function getPublic(enc) {
        return utils.encode(this.pubBytes(), enc);
      };
      module2.exports = KeyPair;
    }, { "../utils": 181 }], 179: [function(require2, module2, exports2) {
      var BN = require2("bn.js");
      var utils = require2("../utils");
      var assert = utils.assert;
      var cachedProperty = utils.cachedProperty;
      var parseBytes = utils.parseBytes;
      function Signature(eddsa, sig) {
        this.eddsa = eddsa;
        if (typeof sig !== "object")
          sig = parseBytes(sig);
        if (Array.isArray(sig)) {
          sig = {
            R: sig.slice(0, eddsa.encodingLength),
            S: sig.slice(eddsa.encodingLength)
          };
        }
        assert(sig.R && sig.S, "Signature without R or S");
        if (eddsa.isPoint(sig.R))
          this._R = sig.R;
        if (sig.S instanceof BN)
          this._S = sig.S;
        this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
        this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
      }
      cachedProperty(Signature, "S", function S() {
        return this.eddsa.decodeInt(this.Sencoded());
      });
      cachedProperty(Signature, "R", function R() {
        return this.eddsa.decodePoint(this.Rencoded());
      });
      cachedProperty(Signature, "Rencoded", function Rencoded() {
        return this.eddsa.encodePoint(this.R());
      });
      cachedProperty(Signature, "Sencoded", function Sencoded() {
        return this.eddsa.encodeInt(this.S());
      });
      Signature.prototype.toBytes = function toBytes() {
        return this.Rencoded().concat(this.Sencoded());
      };
      Signature.prototype.toHex = function toHex() {
        return utils.encode(this.toBytes(), "hex").toUpperCase();
      };
      module2.exports = Signature;
    }, { "../utils": 181, "bn.js": 182 }], 180: [function(require2, module2, exports2) {
      module2.exports = {
        doubles: {
          step: 4,
          points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]]
        },
        naf: {
          wnd: 7,
          points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]]
        }
      };
    }, {}], 181: [function(require2, module2, exports2) {
      var utils = exports2;
      var BN = require2("bn.js");
      var minAssert = require2("minimalistic-assert");
      var minUtils = require2("minimalistic-crypto-utils");
      utils.assert = minAssert;
      utils.toArray = minUtils.toArray;
      utils.zero2 = minUtils.zero2;
      utils.toHex = minUtils.toHex;
      utils.encode = minUtils.encode;
      function getNAF(num, w, bits) {
        var naf = new Array(Math.max(num.bitLength(), bits) + 1);
        naf.fill(0);
        var ws = 1 << w + 1;
        var k = num.clone();
        for (var i = 0; i < naf.length; i++) {
          var z;
          var mod = k.andln(ws - 1);
          if (k.isOdd()) {
            if (mod > (ws >> 1) - 1)
              z = (ws >> 1) - mod;
            else
              z = mod;
            k.isubn(z);
          } else {
            z = 0;
          }
          naf[i] = z;
          k.iushrn(1);
        }
        return naf;
      }
      utils.getNAF = getNAF;
      function getJSF(k1, k2) {
        var jsf = [[], []];
        k1 = k1.clone();
        k2 = k2.clone();
        var d1 = 0;
        var d2 = 0;
        var m8;
        while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
          var m14 = k1.andln(3) + d1 & 3;
          var m24 = k2.andln(3) + d2 & 3;
          if (m14 === 3)
            m14 = -1;
          if (m24 === 3)
            m24 = -1;
          var u1;
          if ((m14 & 1) === 0) {
            u1 = 0;
          } else {
            m8 = k1.andln(7) + d1 & 7;
            if ((m8 === 3 || m8 === 5) && m24 === 2)
              u1 = -m14;
            else
              u1 = m14;
          }
          jsf[0].push(u1);
          var u2;
          if ((m24 & 1) === 0) {
            u2 = 0;
          } else {
            m8 = k2.andln(7) + d2 & 7;
            if ((m8 === 3 || m8 === 5) && m14 === 2)
              u2 = -m24;
            else
              u2 = m24;
          }
          jsf[1].push(u2);
          if (2 * d1 === u1 + 1)
            d1 = 1 - d1;
          if (2 * d2 === u2 + 1)
            d2 = 1 - d2;
          k1.iushrn(1);
          k2.iushrn(1);
        }
        return jsf;
      }
      utils.getJSF = getJSF;
      function cachedProperty(obj, name, computer) {
        var key = "_" + name;
        obj.prototype[name] = function cachedProperty2() {
          return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
        };
      }
      utils.cachedProperty = cachedProperty;
      function parseBytes(bytes) {
        return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
      }
      utils.parseBytes = parseBytes;
      function intFromLE(bytes) {
        return new BN(bytes, "hex", "le");
      }
      utils.intFromLE = intFromLE;
    }, { "bn.js": 182, "minimalistic-assert": 302, "minimalistic-crypto-utils": 303 }], 182: [function(require2, module2, exports2) {
      (function(module3, exports3) {
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function TempCtor2() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN(number, base, endian) {
          if (BN.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
          }
        }
        if (typeof module3 === "object") {
          module3.exports = BN;
        } else {
          exports3.BN = BN;
        }
        BN.BN = BN;
        BN.wordSize = 26;
        var Buffer;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer = window.Buffer;
          } else {
            Buffer = require2("buffer").Buffer;
          }
        } catch (e) {
        }
        BN.isBN = function isBN(num) {
          if (num instanceof BN) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
        };
        BN.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN.prototype._init = function init(number, base, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert(base === (base | 0) && base >= 2 && base <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number.length) {
            if (base === 16) {
              this._parseHex(number, start, endian);
            } else {
              this._parseBase(number, base, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base, endian);
              }
            }
          }
        };
        BN.prototype._initNumber = function _initNumber(number, base, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [number & 67108863, number / 67108864 & 67108863];
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            this.words = [number & 67108863, number / 67108864 & 67108863, 1];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN.prototype._initArray = function _initArray(number, base, endian) {
          assert(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          if (endian === "be") {
            for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
              w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number.length; i += 3) {
              w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this.strip();
        };
        function parseHex4Bits(string, index) {
          var c = string.charCodeAt(index);
          if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            return c - 48 & 15;
          }
        }
        function parseHexByte(string, lowerBound, index) {
          var r = parseHex4Bits(string, index);
          if (index - 1 >= lowerBound) {
            r |= parseHex4Bits(string, index - 1) << 4;
          }
          return r;
        }
        BN.prototype._parseHex = function _parseHex(number, start, endian) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var off = 0;
          var j = 0;
          var w;
          if (endian === "be") {
            for (i = number.length - 1; i >= start; i -= 2) {
              w = parseHexByte(number, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number.length - start;
            for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
              w = parseHexByte(number, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this.strip();
        };
        function parseBase(str, start, end, mul) {
          var r = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              r += c - 49 + 10;
            } else if (c >= 17) {
              r += c - 17 + 10;
            } else {
              r += c;
            }
          }
          return r;
        }
        BN.prototype._parseBase = function _parseBase(number, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for (i = 0; i < mod; i++) {
              pow *= base;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this.strip();
        };
        BN.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        BN.prototype.clone = function clone() {
          var r = new BN(null);
          this.copy(r);
          return r;
        };
        BN.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        BN.prototype.inspect = function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"];
        var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
        var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        BN.prototype.toString = function toString(base, padding) {
          base = base || 10;
          padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off | carry) & 16777215).toString(16);
              carry = w >>> 24 - off & 16777215;
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
              off += 2;
              if (off >= 26) {
                off -= 26;
                i--;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modn(groupBase).toString(base);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN.prototype.toJSON = function toJSON() {
          return this.toString(16);
        };
        BN.prototype.toBuffer = function toBuffer(endian, length) {
          assert(typeof Buffer !== "undefined");
          return this.toArrayLike(Buffer, endian, length);
        };
        BN.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert(byteLength <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          this.strip();
          var littleEndian = endian === "le";
          var res = new ArrayType(reqLength);
          var b, i;
          var q = this.clone();
          if (!littleEndian) {
            for (i = 0; i < reqLength - byteLength; i++) {
              res[i] = 0;
            }
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[reqLength - i - 1] = b;
            }
          } else {
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[i] = b;
            }
            for (; i < reqLength; i++) {
              res[i] = 0;
            }
          }
          return res;
        };
        if (Math.clz32) {
          BN.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN.prototype._countBits = function _countBits(w) {
            var t = w;
            var r = 0;
            if (t >= 4096) {
              r += 13;
              t >>>= 13;
            }
            if (t >= 64) {
              r += 7;
              t >>>= 7;
            }
            if (t >= 8) {
              r += 4;
              t >>>= 4;
            }
            if (t >= 2) {
              r += 2;
              t >>>= 2;
            }
            return r + t;
          };
        }
        BN.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0)
            return 26;
          var t = w;
          var r = 0;
          if ((t & 8191) === 0) {
            r += 13;
            t >>>= 13;
          }
          if ((t & 127) === 0) {
            r += 7;
            t >>>= 7;
          }
          if ((t & 15) === 0) {
            r += 4;
            t >>>= 4;
          }
          if ((t & 3) === 0) {
            r += 2;
            t >>>= 2;
          }
          if ((t & 1) === 0) {
            r++;
          }
          return r;
        };
        BN.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
          }
          return w;
        }
        BN.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26)
              break;
          }
          return r;
        };
        BN.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this.strip();
        };
        BN.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this.strip();
        };
        BN.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this.strip();
        };
        BN.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this.strip();
        };
        BN.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this.strip();
        };
        BN.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this.strip();
        };
        BN.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self2.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self2.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM();
          return fftm.mulp(self2, num, out);
        }
        BN.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y) {
          this.x = x;
          this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N);
          var l = BN.prototype._countBits(N) - 1;
          for (var i = 0; i < N; i++) {
            t[i] = this.revBin(i, l, N);
          }
          return t;
        };
        FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1)
            return x;
          var rb = 0;
          for (var i = 0; i < l; i++) {
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i = 0; i < N; i++) {
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1; s < N; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1;
          var odd = N & 1;
          var i = 0;
          for (N = N / 2 | 0; N; N = N >>> 1) {
            i++;
          }
          return 1 << i + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1)
            return;
          for (var i = 0; i < N / 2; i++) {
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i = 0; i < N / 2; i++) {
            var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 67108863;
            if (w < 67108864) {
              carry = 0;
            } else {
              carry = w / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
          var carry = 0;
          for (var i = 0; i < len; i++) {
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i = 2 * len; i < N; ++i) {
            rws[i] = 0;
          }
          assert(carry === 0);
          assert((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i = 0; i < N; i++) {
            ph[i] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length);
          var rbt = this.makeRBT(N);
          var _ = this.stub(N);
          var rws = new Array(N);
          var rwst = new Array(N);
          var iwst = new Array(N);
          var nrws = new Array(N);
          var nrwst = new Array(N);
          var niwst = new Array(N);
          var rmws = out.words;
          rmws.length = N;
          this.convert13b(x.words, x.length, rws, N);
          this.convert13b(y.words, y.length, nrws, N);
          this.transform(rws, _, rwst, iwst, N, rbt);
          this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i = 0; i < N; i++) {
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
          }
          this.conjugate(rwst, iwst, N);
          this.transform(rwst, iwst, rmws, _, N, rbt);
          this.conjugate(rmws, _, N);
          this.normalize13b(rmws, N);
          out.negative = x.negative ^ y.negative;
          out.length = x.length + y.length;
          return out.strip();
        };
        BN.prototype.mul = function mul(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN.prototype.mulf = function mulf(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN.prototype.imuln = function imuln(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0)
            return new BN(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0)
              break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this.strip();
        };
        BN.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0)
            ;
          else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this.strip();
        };
        BN.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s)
            return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this.strip();
        };
        BN.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this.strip();
        };
        BN.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry === 0)
            return this.strip();
          assert(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this.strip();
        };
        BN.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q.strip();
          }
          a.strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN(0),
              mod: new BN(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN(this.modn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN.prototype.modn = function modn(num) {
          assert(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return acc;
        };
        BN.prototype.idivn = function idivn(num) {
          assert(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w / num | 0;
            carry = w % num;
          }
          return this.strip();
        };
        BN.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN.prototype.egcd = function egcd(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN(1);
          var B = new BN(0);
          var C = new BN(0);
          var D = new BN(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) {
            }
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) {
            }
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y.iushln(g)
          };
        };
        BN.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN(1);
          var x2 = new BN(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) {
            }
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) {
            }
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b;
              b = t;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this.strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN.red = function red(num) {
          return new Red(num);
        };
        BN.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name, p) {
          this.name = name;
          this.p = new BN(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output.words[i] = input.words[i];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives");
          assert(a.red && a.red === b.red, "red works only with red numbers");
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          return a.umod(this.m)._forceRed(this);
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert(!q.isZero());
          var one = new BN(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t = this.pow(a, q);
          var m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t = a.imul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN(0)._forceRed(this);
          var t = a.mul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module2 === "undefined" || module2, void 0);
    }, { "buffer": 53 }], 183: [function(require2, module2, exports2) {
      module2.exports = {
        "name": "elliptic",
        "version": "6.5.4",
        "description": "EC cryptography",
        "main": "lib/elliptic.js",
        "files": [
          "lib"
        ],
        "scripts": {
          "lint": "eslint lib test",
          "lint:fix": "npm run lint -- --fix",
          "unit": "istanbul test _mocha --reporter=spec test/index.js",
          "test": "npm run lint && npm run unit",
          "version": "grunt dist && git add dist/"
        },
        "repository": {
          "type": "git",
          "url": "git@github.com:indutny/elliptic"
        },
        "keywords": [
          "EC",
          "Elliptic",
          "curve",
          "Cryptography"
        ],
        "author": "Fedor Indutny <fedor@indutny.com>",
        "license": "MIT",
        "bugs": {
          "url": "https://github.com/indutny/elliptic/issues"
        },
        "homepage": "https://github.com/indutny/elliptic",
        "devDependencies": {
          "brfs": "^2.0.2",
          "coveralls": "^3.1.0",
          "eslint": "^7.6.0",
          "grunt": "^1.2.1",
          "grunt-browserify": "^5.3.0",
          "grunt-cli": "^1.3.2",
          "grunt-contrib-connect": "^3.0.0",
          "grunt-contrib-copy": "^1.0.0",
          "grunt-contrib-uglify": "^5.0.0",
          "grunt-mocha-istanbul": "^5.0.2",
          "grunt-saucelabs": "^9.0.1",
          "istanbul": "^0.4.5",
          "mocha": "^8.0.1"
        },
        "dependencies": {
          "bn.js": "^4.11.9",
          "brorand": "^1.1.0",
          "hash.js": "^1.0.0",
          "hmac-drbg": "^1.0.1",
          "inherits": "^2.0.4",
          "minimalistic-assert": "^1.0.1",
          "minimalistic-crypto-utils": "^1.0.1"
        }
      };
    }, {}], 184: [function(require2, module2, exports2) {
      function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator(fn) {
        return function() {
          var self2 = this, args = arguments;
          return new Promise(function(resolve, reject) {
            var gen = fn.apply(self2, args);
            function _next(value) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(void 0);
          });
        };
      }
      var anyMap = /* @__PURE__ */ new WeakMap();
      var eventsMap = /* @__PURE__ */ new WeakMap();
      var producersMap = /* @__PURE__ */ new WeakMap();
      var anyProducer = Symbol("anyProducer");
      var resolvedPromise = Promise.resolve();
      var listenerAdded = Symbol("listenerAdded");
      var listenerRemoved = Symbol("listenerRemoved");
      function assertEventName(eventName) {
        if (typeof eventName !== "string" && typeof eventName !== "symbol") {
          throw new TypeError("eventName must be a string or a symbol");
        }
      }
      function assertListener(listener) {
        if (typeof listener !== "function") {
          throw new TypeError("listener must be a function");
        }
      }
      function getListeners(instance, eventName) {
        var events = eventsMap.get(instance);
        if (!events.has(eventName)) {
          events.set(eventName, /* @__PURE__ */ new Set());
        }
        return events.get(eventName);
      }
      function getEventProducers(instance, eventName) {
        var key = typeof eventName === "string" ? eventName : anyProducer;
        var producers = producersMap.get(instance);
        if (!producers.has(key)) {
          producers.set(key, /* @__PURE__ */ new Set());
        }
        return producers.get(key);
      }
      function enqueueProducers(instance, eventName, eventData) {
        var producers = producersMap.get(instance);
        if (producers.has(eventName)) {
          for (var producer of producers.get(eventName)) {
            producer.enqueue(eventData);
          }
        }
        if (producers.has(anyProducer)) {
          var item = Promise.all([eventName, eventData]);
          for (var _producer of producers.get(anyProducer)) {
            _producer.enqueue(item);
          }
        }
      }
      function iterator(instance, eventName) {
        var isFinished = false;
        var flush = () => {
        };
        var queue = [];
        var producer = {
          enqueue(item) {
            queue.push(item);
            flush();
          },
          finish() {
            isFinished = true;
            flush();
          }
        };
        getEventProducers(instance, eventName).add(producer);
        return {
          next() {
            var _this = this;
            return _asyncToGenerator(function* () {
              if (!queue) {
                return {
                  done: true
                };
              }
              if (queue.length === 0) {
                if (isFinished) {
                  queue = void 0;
                  return _this.next();
                }
                yield new Promise((resolve) => {
                  flush = resolve;
                });
                return _this.next();
              }
              return {
                done: false,
                value: yield queue.shift()
              };
            })();
          },
          return(value) {
            var _arguments = arguments;
            return _asyncToGenerator(function* () {
              queue = void 0;
              getEventProducers(instance, eventName).delete(producer);
              flush();
              return _arguments.length > 0 ? {
                done: true,
                value: yield value
              } : {
                done: true
              };
            })();
          },
          [Symbol.asyncIterator]() {
            return this;
          }
        };
      }
      function defaultMethodNamesOrAssert(methodNames) {
        if (methodNames === void 0) {
          return allEmitteryMethods;
        }
        if (!Array.isArray(methodNames)) {
          throw new TypeError("`methodNames` must be an array of strings");
        }
        for (var methodName of methodNames) {
          if (!allEmitteryMethods.includes(methodName)) {
            if (typeof methodName !== "string") {
              throw new TypeError("`methodNames` element must be a string");
            }
            throw new Error("".concat(methodName, " is not Emittery method"));
          }
        }
        return methodNames;
      }
      var isListenerSymbol = (symbol) => symbol === listenerAdded || symbol === listenerRemoved;
      class Emittery {
        static mixin(emitteryPropertyName, methodNames) {
          methodNames = defaultMethodNamesOrAssert(methodNames);
          return (target) => {
            if (typeof target !== "function") {
              throw new TypeError("`target` must be function");
            }
            for (var methodName of methodNames) {
              if (target.prototype[methodName] !== void 0) {
                throw new Error("The property `".concat(methodName, "` already exists on `target`"));
              }
            }
            function getEmitteryProperty() {
              Object.defineProperty(this, emitteryPropertyName, {
                enumerable: false,
                value: new Emittery()
              });
              return this[emitteryPropertyName];
            }
            Object.defineProperty(target.prototype, emitteryPropertyName, {
              enumerable: false,
              get: getEmitteryProperty
            });
            var emitteryMethodCaller = (methodName2) => function() {
              return this[emitteryPropertyName][methodName2](...arguments);
            };
            for (var _methodName of methodNames) {
              Object.defineProperty(target.prototype, _methodName, {
                enumerable: false,
                value: emitteryMethodCaller(_methodName)
              });
            }
            return target;
          };
        }
        constructor() {
          anyMap.set(this, /* @__PURE__ */ new Set());
          eventsMap.set(this, /* @__PURE__ */ new Map());
          producersMap.set(this, /* @__PURE__ */ new Map());
        }
        on(eventName, listener) {
          assertEventName(eventName);
          assertListener(listener);
          getListeners(this, eventName).add(listener);
          if (!isListenerSymbol(eventName)) {
            this.emit(listenerAdded, {
              eventName,
              listener
            });
          }
          return this.off.bind(this, eventName, listener);
        }
        off(eventName, listener) {
          assertEventName(eventName);
          assertListener(listener);
          if (!isListenerSymbol(eventName)) {
            this.emit(listenerRemoved, {
              eventName,
              listener
            });
          }
          getListeners(this, eventName).delete(listener);
        }
        once(eventName) {
          return new Promise((resolve) => {
            assertEventName(eventName);
            var off = this.on(eventName, (data) => {
              off();
              resolve(data);
            });
          });
        }
        events(eventName) {
          assertEventName(eventName);
          return iterator(this, eventName);
        }
        emit(eventName, eventData) {
          var _this2 = this;
          return _asyncToGenerator(function* () {
            assertEventName(eventName);
            enqueueProducers(_this2, eventName, eventData);
            var listeners = getListeners(_this2, eventName);
            var anyListeners = anyMap.get(_this2);
            var staticListeners = [...listeners];
            var staticAnyListeners = isListenerSymbol(eventName) ? [] : [...anyListeners];
            yield resolvedPromise;
            return Promise.all([...staticListeners.map(/* @__PURE__ */ function() {
              var _ref = _asyncToGenerator(function* (listener) {
                if (listeners.has(listener)) {
                  return listener(eventData);
                }
              });
              return function(_x) {
                return _ref.apply(this, arguments);
              };
            }()), ...staticAnyListeners.map(/* @__PURE__ */ function() {
              var _ref2 = _asyncToGenerator(function* (listener) {
                if (anyListeners.has(listener)) {
                  return listener(eventName, eventData);
                }
              });
              return function(_x2) {
                return _ref2.apply(this, arguments);
              };
            }())]);
          })();
        }
        emitSerial(eventName, eventData) {
          var _this3 = this;
          return _asyncToGenerator(function* () {
            assertEventName(eventName);
            var listeners = getListeners(_this3, eventName);
            var anyListeners = anyMap.get(_this3);
            var staticListeners = [...listeners];
            var staticAnyListeners = [...anyListeners];
            yield resolvedPromise;
            for (var listener of staticListeners) {
              if (listeners.has(listener)) {
                yield listener(eventData);
              }
            }
            for (var _listener of staticAnyListeners) {
              if (anyListeners.has(_listener)) {
                yield _listener(eventName, eventData);
              }
            }
          })();
        }
        onAny(listener) {
          assertListener(listener);
          anyMap.get(this).add(listener);
          this.emit(listenerAdded, {
            listener
          });
          return this.offAny.bind(this, listener);
        }
        anyEvent() {
          return iterator(this);
        }
        offAny(listener) {
          assertListener(listener);
          this.emit(listenerRemoved, {
            listener
          });
          anyMap.get(this).delete(listener);
        }
        clearListeners(eventName) {
          if (typeof eventName === "string") {
            getListeners(this, eventName).clear();
            var producers = getEventProducers(this, eventName);
            for (var producer of producers) {
              producer.finish();
            }
            producers.clear();
          } else {
            anyMap.get(this).clear();
            for (var listeners of eventsMap.get(this).values()) {
              listeners.clear();
            }
            for (var _producers of producersMap.get(this).values()) {
              for (var _producer2 of _producers) {
                _producer2.finish();
              }
              _producers.clear();
            }
          }
        }
        listenerCount(eventName) {
          if (typeof eventName === "string") {
            return anyMap.get(this).size + getListeners(this, eventName).size + getEventProducers(this, eventName).size + getEventProducers(this).size;
          }
          if (typeof eventName !== "undefined") {
            assertEventName(eventName);
          }
          var count = anyMap.get(this).size;
          for (var value of eventsMap.get(this).values()) {
            count += value.size;
          }
          for (var _value of producersMap.get(this).values()) {
            count += _value.size;
          }
          return count;
        }
        bindMethods(target, methodNames) {
          if (typeof target !== "object" || target === null) {
            throw new TypeError("`target` must be an object");
          }
          methodNames = defaultMethodNamesOrAssert(methodNames);
          for (var methodName of methodNames) {
            if (target[methodName] !== void 0) {
              throw new Error("The property `".concat(methodName, "` already exists on `target`"));
            }
            Object.defineProperty(target, methodName, {
              enumerable: false,
              value: this[methodName].bind(this)
            });
          }
        }
      }
      var allEmitteryMethods = Object.getOwnPropertyNames(Emittery.prototype).filter((v) => v !== "constructor");
      Emittery.Typed = class extends Emittery {
      };
      Object.defineProperty(Emittery.Typed, "Typed", {
        enumerable: false,
        value: void 0
      });
      Object.defineProperty(Emittery, "listenerAdded", {
        value: listenerAdded,
        writable: false,
        enumerable: true,
        configurable: false
      });
      Object.defineProperty(Emittery, "listenerRemoved", {
        value: listenerRemoved,
        writable: false,
        enumerable: true,
        configurable: false
      });
      module2.exports = Emittery;
    }, {}], 185: [function(require2, module2, exports2) {
      var AbstractLevelDOWN = require2("abstract-leveldown").AbstractLevelDOWN;
      var AbstractChainedBatch = require2("abstract-leveldown").AbstractChainedBatch;
      var AbstractIterator = require2("abstract-leveldown").AbstractIterator;
      var inherits = require2("inherits");
      var Codec = require2("level-codec");
      var EncodingError = require2("level-errors").EncodingError;
      var rangeMethods = ["approximateSize", "compactRange"];
      module2.exports = DB.default = DB;
      function DB(db, opts) {
        if (!(this instanceof DB))
          return new DB(db, opts);
        var manifest = db.supports || {};
        var additionalMethods = manifest.additionalMethods || {};
        AbstractLevelDOWN.call(this, manifest);
        this.supports.encodings = true;
        this.supports.additionalMethods = {};
        rangeMethods.forEach(function(m) {
          var fallback = typeof db[m] === "function";
          if (additionalMethods[m] || fallback) {
            this.supports.additionalMethods[m] = true;
            this[m] = function(start, end, opts2, cb) {
              start = this.codec.encodeKey(start, opts2);
              end = this.codec.encodeKey(end, opts2);
              return this.db[m](start, end, opts2, cb);
            };
          }
        }, this);
        opts = opts || {};
        if (typeof opts.keyEncoding === "undefined")
          opts.keyEncoding = "utf8";
        if (typeof opts.valueEncoding === "undefined")
          opts.valueEncoding = "utf8";
        this.db = db;
        this.codec = new Codec(opts);
      }
      inherits(DB, AbstractLevelDOWN);
      DB.prototype.type = "encoding-down";
      DB.prototype._serializeKey = DB.prototype._serializeValue = function(datum) {
        return datum;
      };
      DB.prototype._open = function(opts, cb) {
        this.db.open(opts, cb);
      };
      DB.prototype._close = function(cb) {
        this.db.close(cb);
      };
      DB.prototype._put = function(key, value, opts, cb) {
        key = this.codec.encodeKey(key, opts);
        value = this.codec.encodeValue(value, opts);
        this.db.put(key, value, opts, cb);
      };
      DB.prototype._get = function(key, opts, cb) {
        var self2 = this;
        key = this.codec.encodeKey(key, opts);
        opts.asBuffer = this.codec.valueAsBuffer(opts);
        this.db.get(key, opts, function(err, value) {
          if (err)
            return cb(err);
          try {
            value = self2.codec.decodeValue(value, opts);
          } catch (err2) {
            return cb(new EncodingError(err2));
          }
          cb(null, value);
        });
      };
      DB.prototype._del = function(key, opts, cb) {
        key = this.codec.encodeKey(key, opts);
        this.db.del(key, opts, cb);
      };
      DB.prototype._chainedBatch = function() {
        return new Batch(this);
      };
      DB.prototype._batch = function(ops, opts, cb) {
        ops = this.codec.encodeBatch(ops, opts);
        this.db.batch(ops, opts, cb);
      };
      DB.prototype._iterator = function(opts) {
        opts.keyAsBuffer = this.codec.keyAsBuffer(opts);
        opts.valueAsBuffer = this.codec.valueAsBuffer(opts);
        return new Iterator(this, opts);
      };
      DB.prototype._clear = function(opts, callback) {
        opts = this.codec.encodeLtgt(opts);
        this.db.clear(opts, callback);
      };
      function Iterator(db, opts) {
        AbstractIterator.call(this, db);
        this.codec = db.codec;
        this.keys = opts.keys;
        this.values = opts.values;
        this.opts = this.codec.encodeLtgt(opts);
        this.it = db.db.iterator(this.opts);
      }
      inherits(Iterator, AbstractIterator);
      Iterator.prototype._next = function(cb) {
        var self2 = this;
        this.it.next(function(err, key, value) {
          if (err)
            return cb(err);
          try {
            if (self2.keys && typeof key !== "undefined") {
              key = self2.codec.decodeKey(key, self2.opts);
            } else {
              key = void 0;
            }
            if (self2.values && typeof value !== "undefined") {
              value = self2.codec.decodeValue(value, self2.opts);
            } else {
              value = void 0;
            }
          } catch (err2) {
            return cb(new EncodingError(err2));
          }
          cb(null, key, value);
        });
      };
      Iterator.prototype._seek = function(key) {
        key = this.codec.encodeKey(key, this.opts);
        this.it.seek(key);
      };
      Iterator.prototype._end = function(cb) {
        this.it.end(cb);
      };
      function Batch(db, codec) {
        AbstractChainedBatch.call(this, db);
        this.codec = db.codec;
        this.batch = db.db.batch();
      }
      inherits(Batch, AbstractChainedBatch);
      Batch.prototype._put = function(key, value) {
        key = this.codec.encodeKey(key);
        value = this.codec.encodeValue(value);
        this.batch.put(key, value);
      };
      Batch.prototype._del = function(key) {
        key = this.codec.encodeKey(key);
        this.batch.del(key);
      };
      Batch.prototype._clear = function() {
        this.batch.clear();
      };
      Batch.prototype._write = function(opts, cb) {
        this.batch.write(opts, cb);
      };
    }, { "abstract-leveldown": 18, "inherits": 256, "level-codec": 271, "level-errors": 273 }], 186: [function(require2, module2, exports2) {
      var eos = require2("end-of-stream");
      module2.exports = function eosp(stream) {
        var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return new Promise((resolve, reject) => {
          function cb(err) {
            if (err)
              reject(err);
            else
              resolve();
          }
          eos(stream, opts, cb);
        });
      };
    }, { "end-of-stream": 187 }], 187: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          var once = require2("once");
          var noop = function noop2() {
          };
          var isRequest = function isRequest2(stream) {
            return stream.setHeader && typeof stream.abort === "function";
          };
          var isChildProcess = function isChildProcess2(stream) {
            return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
          };
          var eos = function eos2(stream, opts, callback) {
            if (typeof opts === "function")
              return eos2(stream, null, opts);
            if (!opts)
              opts = {};
            callback = once(callback || noop);
            var ws = stream._writableState;
            var rs = stream._readableState;
            var readable = opts.readable || opts.readable !== false && stream.readable;
            var writable = opts.writable || opts.writable !== false && stream.writable;
            var cancelled = false;
            var onlegacyfinish = function onlegacyfinish2() {
              if (!stream.writable)
                onfinish();
            };
            var onfinish = function onfinish2() {
              writable = false;
              if (!readable)
                callback.call(stream);
            };
            var onend = function onend2() {
              readable = false;
              if (!writable)
                callback.call(stream);
            };
            var onexit = function onexit2(exitCode) {
              callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
            };
            var onerror = function onerror2(err) {
              callback.call(stream, err);
            };
            var onclose = function onclose2() {
              process.nextTick(onclosenexttick);
            };
            var onclosenexttick = function onclosenexttick2() {
              if (cancelled)
                return;
              if (readable && !(rs && rs.ended && !rs.destroyed))
                return callback.call(stream, new Error("premature close"));
              if (writable && !(ws && ws.ended && !ws.destroyed))
                return callback.call(stream, new Error("premature close"));
            };
            var onrequest = function onrequest2() {
              stream.req.on("finish", onfinish);
            };
            if (isRequest(stream)) {
              stream.on("complete", onfinish);
              stream.on("abort", onclose);
              if (stream.req)
                onrequest();
              else
                stream.on("request", onrequest);
            } else if (writable && !ws) {
              stream.on("end", onlegacyfinish);
              stream.on("close", onlegacyfinish);
            }
            if (isChildProcess(stream))
              stream.on("exit", onexit);
            stream.on("end", onend);
            stream.on("finish", onfinish);
            if (opts.error !== false)
              stream.on("error", onerror);
            stream.on("close", onclose);
            return function() {
              cancelled = true;
              stream.removeListener("complete", onfinish);
              stream.removeListener("abort", onclose);
              stream.removeListener("request", onrequest);
              if (stream.req)
                stream.req.removeListener("finish", onfinish);
              stream.removeListener("end", onlegacyfinish);
              stream.removeListener("close", onlegacyfinish);
              stream.removeListener("finish", onfinish);
              stream.removeListener("exit", onexit);
              stream.removeListener("end", onend);
              stream.removeListener("error", onerror);
              stream.removeListener("close", onclose);
            };
          };
          module2.exports = eos;
        }).call(this);
      }).call(this, require2("_process"));
    }, { "_process": 361, "once": 339 }], 188: [function(require2, module2, exports2) {
      function assign(obj, props) {
        for (var key in props) {
          Object.defineProperty(obj, key, {
            value: props[key],
            enumerable: true,
            configurable: true
          });
        }
        return obj;
      }
      function createError(err, code, props) {
        if (!err || typeof err === "string") {
          throw new TypeError("Please pass an Error to err-code");
        }
        if (!props) {
          props = {};
        }
        if (typeof code === "object") {
          props = code;
          code = void 0;
        }
        if (code != null) {
          props.code = code;
        }
        try {
          return assign(err, props);
        } catch (_) {
          props.message = err.message;
          props.stack = err.stack;
          var ErrClass = function ErrClass2() {
          };
          ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
          return assign(new ErrClass(), props);
        }
      }
      module2.exports = createError;
    }, {}], 189: [function(require2, module2, exports2) {
      var prr = require2("prr");
      function init(type, message, cause) {
        if (!!message && typeof message != "string") {
          message = message.message || message.name;
        }
        prr(this, {
          type,
          name: type,
          cause: typeof message != "string" ? message : cause,
          message
        }, "ewr");
      }
      function CustomError(message, cause) {
        Error.call(this);
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, this.constructor);
        init.call(this, "CustomError", message, cause);
      }
      CustomError.prototype = new Error();
      function createError(errno, type, proto) {
        var err = function err2(message, cause) {
          init.call(this, type, message, cause);
          if (type == "FilesystemError") {
            this.code = this.cause.code;
            this.path = this.cause.path;
            this.errno = this.cause.errno;
            this.message = (errno.errno[this.cause.errno] ? errno.errno[this.cause.errno].description : this.cause.message) + (this.cause.path ? " [" + this.cause.path + "]" : "");
          }
          Error.call(this);
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, err2);
        };
        err.prototype = !!proto ? new proto() : new CustomError();
        return err;
      }
      module2.exports = function(errno) {
        var ce = function ce2(type, proto) {
          return createError(errno, type, proto);
        };
        return {
          CustomError,
          FilesystemError: ce("FilesystemError"),
          createError: ce
        };
      };
    }, { "prr": 368 }], 190: [function(require2, module2, exports2) {
      var all = module2.exports.all = [{
        errno: -2,
        code: "ENOENT",
        description: "no such file or directory"
      }, {
        errno: -1,
        code: "UNKNOWN",
        description: "unknown error"
      }, {
        errno: 0,
        code: "OK",
        description: "success"
      }, {
        errno: 1,
        code: "EOF",
        description: "end of file"
      }, {
        errno: 2,
        code: "EADDRINFO",
        description: "getaddrinfo error"
      }, {
        errno: 3,
        code: "EACCES",
        description: "permission denied"
      }, {
        errno: 4,
        code: "EAGAIN",
        description: "resource temporarily unavailable"
      }, {
        errno: 5,
        code: "EADDRINUSE",
        description: "address already in use"
      }, {
        errno: 6,
        code: "EADDRNOTAVAIL",
        description: "address not available"
      }, {
        errno: 7,
        code: "EAFNOSUPPORT",
        description: "address family not supported"
      }, {
        errno: 8,
        code: "EALREADY",
        description: "connection already in progress"
      }, {
        errno: 9,
        code: "EBADF",
        description: "bad file descriptor"
      }, {
        errno: 10,
        code: "EBUSY",
        description: "resource busy or locked"
      }, {
        errno: 11,
        code: "ECONNABORTED",
        description: "software caused connection abort"
      }, {
        errno: 12,
        code: "ECONNREFUSED",
        description: "connection refused"
      }, {
        errno: 13,
        code: "ECONNRESET",
        description: "connection reset by peer"
      }, {
        errno: 14,
        code: "EDESTADDRREQ",
        description: "destination address required"
      }, {
        errno: 15,
        code: "EFAULT",
        description: "bad address in system call argument"
      }, {
        errno: 16,
        code: "EHOSTUNREACH",
        description: "host is unreachable"
      }, {
        errno: 17,
        code: "EINTR",
        description: "interrupted system call"
      }, {
        errno: 18,
        code: "EINVAL",
        description: "invalid argument"
      }, {
        errno: 19,
        code: "EISCONN",
        description: "socket is already connected"
      }, {
        errno: 20,
        code: "EMFILE",
        description: "too many open files"
      }, {
        errno: 21,
        code: "EMSGSIZE",
        description: "message too long"
      }, {
        errno: 22,
        code: "ENETDOWN",
        description: "network is down"
      }, {
        errno: 23,
        code: "ENETUNREACH",
        description: "network is unreachable"
      }, {
        errno: 24,
        code: "ENFILE",
        description: "file table overflow"
      }, {
        errno: 25,
        code: "ENOBUFS",
        description: "no buffer space available"
      }, {
        errno: 26,
        code: "ENOMEM",
        description: "not enough memory"
      }, {
        errno: 27,
        code: "ENOTDIR",
        description: "not a directory"
      }, {
        errno: 28,
        code: "EISDIR",
        description: "illegal operation on a directory"
      }, {
        errno: 29,
        code: "ENONET",
        description: "machine is not on the network"
      }, {
        errno: 31,
        code: "ENOTCONN",
        description: "socket is not connected"
      }, {
        errno: 32,
        code: "ENOTSOCK",
        description: "socket operation on non-socket"
      }, {
        errno: 33,
        code: "ENOTSUP",
        description: "operation not supported on socket"
      }, {
        errno: 34,
        code: "ENOENT",
        description: "no such file or directory"
      }, {
        errno: 35,
        code: "ENOSYS",
        description: "function not implemented"
      }, {
        errno: 36,
        code: "EPIPE",
        description: "broken pipe"
      }, {
        errno: 37,
        code: "EPROTO",
        description: "protocol error"
      }, {
        errno: 38,
        code: "EPROTONOSUPPORT",
        description: "protocol not supported"
      }, {
        errno: 39,
        code: "EPROTOTYPE",
        description: "protocol wrong type for socket"
      }, {
        errno: 40,
        code: "ETIMEDOUT",
        description: "connection timed out"
      }, {
        errno: 41,
        code: "ECHARSET",
        description: "invalid Unicode character"
      }, {
        errno: 42,
        code: "EAIFAMNOSUPPORT",
        description: "address family for hostname not supported"
      }, {
        errno: 44,
        code: "EAISERVICE",
        description: "servname not supported for ai_socktype"
      }, {
        errno: 45,
        code: "EAISOCKTYPE",
        description: "ai_socktype not supported"
      }, {
        errno: 46,
        code: "ESHUTDOWN",
        description: "cannot send after transport endpoint shutdown"
      }, {
        errno: 47,
        code: "EEXIST",
        description: "file already exists"
      }, {
        errno: 48,
        code: "ESRCH",
        description: "no such process"
      }, {
        errno: 49,
        code: "ENAMETOOLONG",
        description: "name too long"
      }, {
        errno: 50,
        code: "EPERM",
        description: "operation not permitted"
      }, {
        errno: 51,
        code: "ELOOP",
        description: "too many symbolic links encountered"
      }, {
        errno: 52,
        code: "EXDEV",
        description: "cross-device link not permitted"
      }, {
        errno: 53,
        code: "ENOTEMPTY",
        description: "directory not empty"
      }, {
        errno: 54,
        code: "ENOSPC",
        description: "no space left on device"
      }, {
        errno: 55,
        code: "EIO",
        description: "i/o error"
      }, {
        errno: 56,
        code: "EROFS",
        description: "read-only file system"
      }, {
        errno: 57,
        code: "ENODEV",
        description: "no such device"
      }, {
        errno: 58,
        code: "ESPIPE",
        description: "invalid seek"
      }, {
        errno: 59,
        code: "ECANCELED",
        description: "operation canceled"
      }];
      module2.exports.errno = {};
      module2.exports.code = {};
      all.forEach(function(error) {
        module2.exports.errno[error.errno] = error;
        module2.exports.code[error.code] = error;
      });
      module2.exports.custom = require2("./custom")(module2.exports);
      module2.exports.create = module2.exports.custom.createError;
    }, { "./custom": 189 }], 191: [function(require2, module2, exports2) {
      var GetIntrinsic = require2("get-intrinsic");
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      if ($gOPD) {
        try {
          $gOPD([], "length");
        } catch (e) {
          $gOPD = null;
        }
      }
      module2.exports = $gOPD;
    }, { "get-intrinsic": 206 }], 192: [function(require2, module2, exports2) {
      var has = Object.prototype.hasOwnProperty, prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__)
          prefix = false;
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
          emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
          emitter._events[evt].push(listener);
        else
          emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Events();
        else
          delete emitter._events[evt];
      }
      function EventEmitter() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0)
          return names;
        for (name in events = this._events) {
          if (has.call(events, name))
            names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
          ee[i] = handlers[i].fn;
        }
        return ee;
      };
      EventEmitter.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners)
          return 0;
        if (listeners.fn)
          return 1;
        return listeners.length;
      };
      EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once)
            this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j;
          for (i = 0; i < length; i++) {
            if (listeners[i].once)
              this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;
              default:
                if (!args)
                  for (j = 1, args = new Array(len - 1); j < len; j++) {
                    args[j - 1] = arguments[j];
                  }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter.prototype.on = function on(event, fn, context) {
        return addListener(this, event, fn, context, false);
      };
      EventEmitter.prototype.once = function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
      };
      EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events = [], length = listeners.length; i < length; i++) {
            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
              events.push(listeners[i]);
            }
          }
          if (events.length)
            this._events[evt] = events.length === 1 ? events[0] : events;
          else
            clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.addListener = EventEmitter.prototype.on;
      EventEmitter.prefixed = prefix;
      EventEmitter.EventEmitter = EventEmitter;
      if ("undefined" !== typeof module2) {
        module2.exports = EventEmitter;
      }
    }, {}], 193: [function(require2, module2, exports2) {
      var objectCreate = Object.create || objectCreatePolyfill;
      var objectKeys = Object.keys || objectKeysPolyfill;
      var bind = Function.prototype.bind || functionBindPolyfill;
      function EventEmitter() {
        if (!this._events || !Object.prototype.hasOwnProperty.call(this, "_events")) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      }
      module2.exports = EventEmitter;
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._maxListeners = void 0;
      var defaultMaxListeners = 10;
      var hasDefineProperty;
      try {
        var o = {};
        if (Object.defineProperty)
          Object.defineProperty(o, "x", {
            value: 0
          });
        hasDefineProperty = o.x === 0;
      } catch (err) {
        hasDefineProperty = false;
      }
      if (hasDefineProperty) {
        Object.defineProperty(EventEmitter, "defaultMaxListeners", {
          enumerable: true,
          get: function get() {
            return defaultMaxListeners;
          },
          set: function set(arg) {
            if (typeof arg !== "number" || arg < 0 || arg !== arg)
              throw new TypeError('"defaultMaxListeners" must be a positive number');
            defaultMaxListeners = arg;
          }
        });
      } else {
        EventEmitter.defaultMaxListeners = defaultMaxListeners;
      }
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || isNaN(n))
          throw new TypeError('"n" argument must be a positive number');
        this._maxListeners = n;
        return this;
      };
      function $getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return $getMaxListeners(this);
      };
      function emitNone(handler, isFn, self2) {
        if (isFn)
          handler.call(self2);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i) {
            listeners[i].call(self2);
          }
        }
      }
      function emitOne(handler, isFn, self2, arg1) {
        if (isFn)
          handler.call(self2, arg1);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i) {
            listeners[i].call(self2, arg1);
          }
        }
      }
      function emitTwo(handler, isFn, self2, arg1, arg2) {
        if (isFn)
          handler.call(self2, arg1, arg2);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i) {
            listeners[i].call(self2, arg1, arg2);
          }
        }
      }
      function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
        if (isFn)
          handler.call(self2, arg1, arg2, arg3);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i) {
            listeners[i].call(self2, arg1, arg2, arg3);
          }
        }
      }
      function emitMany(handler, isFn, self2, args) {
        if (isFn)
          handler.apply(self2, args);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i) {
            listeners[i].apply(self2, args);
          }
        }
      }
      EventEmitter.prototype.emit = function emit(type) {
        var er, handler, len, args, i, events;
        var doError = type === "error";
        events = this._events;
        if (events)
          doError = doError && events.error == null;
        else if (!doError)
          return false;
        if (doError) {
          if (arguments.length > 1)
            er = arguments[1];
          if (er instanceof Error) {
            throw er;
          } else {
            var err = new Error('Unhandled "error" event. (' + er + ")");
            err.context = er;
            throw err;
          }
        }
        handler = events[type];
        if (!handler)
          return false;
        var isFn = typeof handler === "function";
        len = arguments.length;
        switch (len) {
          case 1:
            emitNone(handler, isFn, this);
            break;
          case 2:
            emitOne(handler, isFn, this, arguments[1]);
            break;
          case 3:
            emitTwo(handler, isFn, this, arguments[1], arguments[2]);
            break;
          case 4:
            emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
            break;
          default:
            args = new Array(len - 1);
            for (i = 1; i < len; i++) {
              args[i - 1] = arguments[i];
            }
            emitMany(handler, isFn, this, args);
        }
        return true;
      };
      function _addListener(target, type, listener, prepend) {
        var m;
        var events;
        var existing;
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        events = target._events;
        if (!events) {
          events = target._events = objectCreate(null);
          target._eventsCount = 0;
        } else {
          if (events.newListener) {
            target.emit("newListener", type, listener.listener ? listener.listener : listener);
            events = target._events;
          }
          existing = events[type];
        }
        if (!existing) {
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type] = prepend ? [listener, existing] : [existing, listener];
          } else {
            if (prepend) {
              existing.unshift(listener);
            } else {
              existing.push(listener);
            }
          }
          if (!existing.warned) {
            m = $getMaxListeners(target);
            if (m && m > 0 && existing.length > m) {
              existing.warned = true;
              var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + ' "' + String(type) + '" listeners added. Use emitter.setMaxListeners() to increase limit.');
              w.name = "MaxListenersExceededWarning";
              w.emitter = target;
              w.type = type;
              w.count = existing.length;
              if (typeof console === "object" && console.warn) {
                console.warn("%s: %s", w.name, w.message);
              }
            }
          }
        }
        return target;
      }
      EventEmitter.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          switch (arguments.length) {
            case 0:
              return this.listener.call(this.target);
            case 1:
              return this.listener.call(this.target, arguments[0]);
            case 2:
              return this.listener.call(this.target, arguments[0], arguments[1]);
            case 3:
              return this.listener.call(this.target, arguments[0], arguments[1], arguments[2]);
            default:
              var args = new Array(arguments.length);
              for (var i = 0; i < args.length; ++i) {
                args[i] = arguments[i];
              }
              this.listener.apply(this.target, args);
          }
        }
      }
      function _onceWrap(target, type, listener) {
        var state = {
          fired: false,
          wrapFn: void 0,
          target,
          type,
          listener
        };
        var wrapped = bind.call(onceWrapper, state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter.prototype.once = function once(type, listener) {
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i, originalListener;
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        events = this._events;
        if (!events)
          return this;
        list = events[type];
        if (!list)
          return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit("removeListener", type, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0)
            return this;
          if (position === 0)
            list.shift();
          else
            spliceOne(list, position);
          if (list.length === 1)
            events[type] = list[0];
          if (events.removeListener)
            this.emit("removeListener", type, originalListener || listener);
        }
        return this;
      };
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i;
        events = this._events;
        if (!events)
          return this;
        if (!events.removeListener) {
          if (arguments.length === 0) {
            this._events = objectCreate(null);
            this._eventsCount = 0;
          } else if (events[type]) {
            if (--this._eventsCount === 0)
              this._events = objectCreate(null);
            else
              delete events[type];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys = objectKeys(events);
          var key;
          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === "removeListener")
              continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = objectCreate(null);
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type];
        if (typeof listeners === "function") {
          this.removeListener(type, listeners);
        } else if (listeners) {
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }
        return this;
      };
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (!events)
          return [];
        var evlistener = events[type];
        if (!evlistener)
          return [];
        if (typeof evlistener === "function")
          return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };
      EventEmitter.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };
      EventEmitter.listenerCount = function(emitter, type) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      function listenerCount(type) {
        var events = this._events;
        if (events) {
          var evlistener = events[type];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
      };
      function spliceOne(list, index) {
        for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
          list[i] = list[k];
        }
        list.pop();
      }
      function arrayClone(arr, n) {
        var copy = new Array(n);
        for (var i = 0; i < n; ++i) {
          copy[i] = arr[i];
        }
        return copy;
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }
        return ret;
      }
      function objectCreatePolyfill(proto) {
        var F = function F2() {
        };
        F.prototype = proto;
        return new F();
      }
      function objectKeysPolyfill(obj) {
        for (var k in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, k))
            ;
        }
        return k;
      }
      function functionBindPolyfill(context) {
        var fn = this;
        return function() {
          return fn.apply(context, arguments);
        };
      }
    }, {}], 194: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      var MD5 = require2("md5.js");
      function EVP_BytesToKey(password, salt, keyBits, ivLen) {
        if (!Buffer.isBuffer(password))
          password = Buffer.from(password, "binary");
        if (salt) {
          if (!Buffer.isBuffer(salt))
            salt = Buffer.from(salt, "binary");
          if (salt.length !== 8)
            throw new RangeError("salt should be Buffer with 8 byte length");
        }
        var keyLen = keyBits / 8;
        var key = Buffer.alloc(keyLen);
        var iv = Buffer.alloc(ivLen || 0);
        var tmp = Buffer.alloc(0);
        while (keyLen > 0 || ivLen > 0) {
          var hash = new MD5();
          hash.update(tmp);
          hash.update(password);
          if (salt)
            hash.update(salt);
          tmp = hash.digest();
          var used = 0;
          if (keyLen > 0) {
            var keyStart = key.length - keyLen;
            used = Math.min(keyLen, tmp.length);
            tmp.copy(key, keyStart, 0, used);
            keyLen -= used;
          }
          if (used < tmp.length && ivLen > 0) {
            var ivStart = iv.length - ivLen;
            var length = Math.min(ivLen, tmp.length - used);
            tmp.copy(iv, ivStart, used, used + length);
            ivLen -= length;
          }
        }
        tmp.fill(0);
        return {
          key,
          iv
        };
      }
      module2.exports = EVP_BytesToKey;
    }, { "md5.js": 284, "safe-buffer": 417 }], 195: [function(require2, module2, exports2) {
      var ctz = require2("count-trailing-zeros");
      module2.exports = () => new Bitfield();
      class Page {
        constructor(level) {
          var buf = new Uint8Array(level ? 8456 : 4360);
          var b = buf.byteOffset;
          this.buffer = buf;
          this.bits = level ? null : new Uint32Array(buf.buffer, b, 1024);
          this.children = level ? new Array(32768) : null;
          this.level = level;
          this.allOne = level ? [new Uint32Array(buf.buffer, b, 1024), new Uint32Array(buf.buffer, b + 4096, 32), new Uint32Array(buf.buffer, b + 4224, 1)] : [this.bits, new Uint32Array(buf.buffer, b + 4096, 32), new Uint32Array(buf.buffer, b + 4224, 1)];
          this.oneOne = level ? [new Uint32Array(buf.buffer, b + 4228, 1024), new Uint32Array(buf.buffer, b + 8324, 32), new Uint32Array(buf.buffer, b + 8452, 1)] : [this.bits, new Uint32Array(buf.buffer, b + 4228, 32), new Uint32Array(buf.buffer, b + 4356, 1)];
        }
      }
      var ZEROS = [new Page(0), new Page(1), new Page(2), new Page(3)];
      var MASK = new Uint32Array(32);
      var MASK_INCL = new Uint32Array(32);
      for (var i = 0; i < 32; i++) {
        MASK[i] = Math.pow(2, 31 - i) - 1;
        MASK_INCL[i] = Math.pow(2, 32 - i) - 1;
      }
      var LITTLE_ENDIAN = new Uint8Array(MASK.buffer, MASK.byteOffset, 1)[0] === 255;
      class Bitfield {
        constructor() {
          this.length = 32768;
          this.littleEndian = LITTLE_ENDIAN;
          this._path = new Uint16Array(5);
          this._offsets = new Uint16Array(this._path.buffer, this._path.byteOffset + 2, 4);
          this._parents = new Array(4).fill(null);
          this._page = new Page(0);
          this._allocs = 1;
        }
        last() {
          var page = this._page;
          var b = 0;
          while (true) {
            for (var i2 = 2; i2 >= 0; i2--) {
              var c = ctz(page.oneOne[i2][b]);
              if (c === 32)
                return -1;
              b = (b << 5) + (31 - c);
            }
            this._path[page.level] = b;
            if (!page.level)
              return defactor(this._path);
            page = page.children[b];
            b = 0;
          }
        }
        set(index, bit) {
          var page = this._getPage(index, bit);
          if (!page)
            return false;
          var i2 = this._path[0];
          var r = i2 & 31;
          var b = i2 >>> 5;
          var prev = page.bits[b];
          page.bits[b] = bit ? prev | 2147483648 >>> r : prev & ~(2147483648 >>> r);
          var upd = page.bits[b];
          if (upd === prev)
            return false;
          this._updateAllOne(page, b, upd);
          this._updateOneOne(page, b, upd);
          return true;
        }
        get(index) {
          var page = this._getPage(index, false);
          if (!page)
            return false;
          var i2 = this._path[0];
          var r = i2 & 31;
          return (page.bits[i2 >>> 5] & 2147483648 >>> r) !== 0;
        }
        iterator() {
          return new Iterator(this);
        }
        fill(val, start, end) {
          if (!start)
            start = 0;
          if (val === true)
            return this._fillBit(true, start, end === 0 ? end : end || this.length);
          if (val === false)
            return this._fillBit(false, start, end === 0 ? end : end || this.length);
          this._fillBuffer(val, start, end === 0 ? end : end || start + 8 * val.length);
        }
        grow() {
          if (this._page.level === 3)
            throw new Error("Cannot grow beyond " + this.length);
          var page = this._page;
          this._page = new Page(page.level + 1);
          this._page.children[0] = page;
          if (this._page.level === 3)
            this.length = Number.MAX_SAFE_INTEGER;
          else
            this.length *= 32768;
        }
        _fillBuffer(buf, start, end) {
          if (start & 7 || end & 7)
            throw new Error("Offsets must be a multiple of 8");
          start /= 8;
          while (end > this.length) {
            this.grow();
          }
          end /= 8;
          var offset = start;
          var page = this._getPage(8 * start, true);
          while (start < end) {
            var delta = end - start < 4096 ? end - start : 4096;
            var s = start - offset;
            start += this._setPageBuffer(page, buf.subarray(s, s + delta), start & 1023);
            if (start !== end)
              page = this._nextPage(page, 8 * start);
          }
        }
        _fillBit(bit, start, end) {
          var page = this._getPage(start, bit);
          while (start < end) {
            var delta = end - start < 32768 ? end - start : 32768;
            start += this._setPageBits(page, bit, start & 32767, delta);
            if (start !== end)
              page = this._nextPage(page, start);
          }
        }
        _nextPage(page, start) {
          var i2 = ++this._offsets[page.level];
          return i2 === 32768 ? this._getPage(start, true) : this._parents[page.level].children[i2] || this._addPage(this._parents[page.level], i2);
        }
        _setPageBuffer(page, buf, start) {
          new Uint8Array(page.bits.buffer, page.bits.byteOffset, page.bits.length * 4).set(buf, start);
          start >>>= 2;
          this._update(page, start, start + (buf.length >>> 2) + (buf.length & 3 ? 1 : 0));
          return buf.length;
        }
        _setPageBits(page, bit, start, end) {
          var s = start >>> 5;
          var e = end >>> 5;
          var sm = 4294967295 >>> (start & 31);
          var em = ~(4294967295 >>> (end & 31));
          if (s === e) {
            page.bits[s] = bit ? page.bits[s] | sm & em : page.bits[s] & ~(sm & em);
            this._update(page, s, s + 1);
            return end - start;
          }
          page.bits[s] = bit ? page.bits[s] | sm : page.bits[s] & ~sm;
          if (e - s > 2)
            page.bits.fill(bit ? 4294967295 : 0, s + 1, e - 1);
          if (e === 1024) {
            page.bits[e - 1] = bit ? 4294967295 : 0;
            this._update(page, s, e);
            return end - start;
          }
          page.bits[e] = bit ? page.bits[e] | em : page.bits[e] & ~em;
          this._update(page, s, e + 1);
          return end - start;
        }
        _update(page, start, end) {
          for (; start < end; start++) {
            var upd = page.bits[start];
            this._updateAllOne(page, start, upd);
            this._updateOneOne(page, start, upd);
          }
        }
        _updateAllOne(page, b, upd) {
          var i2 = 1;
          do {
            for (; i2 < 3; i2++) {
              var buf = page.allOne[i2];
              var r = b & 31;
              var prev = buf[b >>>= 5];
              buf[b] = upd === 4294967295 ? prev | 2147483648 >>> r : prev & ~(2147483648 >>> r);
              upd = buf[b];
              if (upd === prev)
                return;
            }
            b += this._offsets[page.level];
            page = this._parents[page.level];
            i2 = 0;
          } while (page);
        }
        _updateOneOne(page, b, upd) {
          var i2 = 1;
          do {
            for (; i2 < 3; i2++) {
              var buf = page.oneOne[i2];
              var r = b & 31;
              var prev = buf[b >>>= 5];
              buf[b] = upd !== 0 ? prev | 2147483648 >>> r : prev & ~(2147483648 >>> r);
              upd = buf[b];
              if (upd === prev)
                return;
            }
            b += this._offsets[page.level];
            page = this._parents[page.level];
            i2 = 0;
            if (upd === 0 && page) {
              page.children[this._offsets[page.level - 1]] = void 0;
            }
          } while (page);
        }
        _getPage(index, createIfMissing) {
          factor(index, this._path);
          while (index >= this.length) {
            if (!createIfMissing)
              return null;
            this.grow();
          }
          var page = this._page;
          for (var i2 = page.level; i2 > 0 && page; i2--) {
            var p = this._path[i2];
            this._parents[i2 - 1] = page;
            page = page.children[p] || (createIfMissing ? this._addPage(page, p) : null);
          }
          return page;
        }
        _addPage(page, i2) {
          this._allocs++;
          page = page.children[i2] = new Page(page.level - 1);
          return page;
        }
      }
      class Iterator {
        constructor(bitfield) {
          this._bitfield = bitfield;
          this._path = new Uint16Array(5);
          this._offsets = new Uint16Array(this._path.buffer, this._path.byteOffset + 2, 4);
          this._parents = new Array(4).fill(null);
          this._page = null;
          this._allocs = bitfield._allocs;
          this.seek(0);
        }
        seek(index) {
          this._allocs = this._bitfield._allocs;
          if (index >= this._bitfield.length) {
            this._page = null;
            return this;
          }
          factor(index, this._path);
          this._page = this._bitfield._page;
          for (var i2 = this._page.level; i2 > 0; i2--) {
            this._parents[i2 - 1] = this._page;
            this._page = this._page.children[this._path[i2]] || ZEROS[i2 - 1];
          }
          return this;
        }
        next(bit) {
          return bit ? this.nextTrue() : this.nextFalse();
        }
        nextFalse() {
          if (this._allocs !== this._bitfield._allocs) {
            this.seek(defactor(this._path));
          }
          var page = this._page;
          var b = this._path[0];
          var mask = MASK_INCL;
          while (page) {
            for (var i2 = 0; i2 < 3; i2++) {
              var r = b & 31;
              var clz = Math.clz32(~page.allOne[i2][b >>>= 5] & mask[r]);
              if (clz !== 32)
                return this._downLeftFalse(page, i2, b, clz);
              mask = MASK;
            }
            b = this._offsets[page.level];
            page = this._parents[page.level];
          }
          return -1;
        }
        _downLeftFalse(page, i2, b, clz) {
          while (true) {
            while (i2) {
              b = (b << 5) + clz;
              clz = Math.clz32(~page.allOne[--i2][b]);
            }
            b = (b << 5) + clz;
            if (!page.level)
              break;
            this._parents[page.level - 1] = page;
            this._path[page.level] = b;
            page = page.children[b];
            i2 = 3;
            clz = b = 0;
          }
          this._page = page;
          this._path[0] = b;
          return this._inc();
        }
        nextTrue() {
          var page = this._page;
          var b = this._path[0];
          var mask = MASK_INCL;
          while (page) {
            for (var i2 = 0; i2 < 3; i2++) {
              var r = b & 31;
              var clz = Math.clz32(page.oneOne[i2][b >>>= 5] & mask[r]);
              if (clz !== 32)
                return this._downLeftTrue(page, i2, b, clz);
              mask = MASK;
            }
            b = this._offsets[page.level];
            page = this._parents[page.level];
          }
          return -1;
        }
        _downLeftTrue(page, i2, b, clz) {
          while (true) {
            while (i2) {
              b = (b << 5) + clz;
              clz = Math.clz32(page.oneOne[--i2][b]);
            }
            b = (b << 5) + clz;
            if (!page.level)
              break;
            this._parents[page.level - 1] = page;
            this._path[page.level] = b;
            page = page.children[b];
            i2 = 3;
            clz = b = 0;
          }
          this._page = page;
          this._path[0] = b;
          return this._inc();
        }
        _inc() {
          var n = defactor(this._path);
          if (this._path[0] < 32767)
            this._path[0]++;
          else
            this.seek(n + 1);
          return n;
        }
      }
      function defactor(out) {
        return ((out[3] * 32768 + out[2]) * 32768 + out[1]) * 32768 + out[0];
      }
      function factor(n, out) {
        n = (n - (out[0] = n & 32767)) / 32768;
        n = (n - (out[1] = n & 32767)) / 32768;
        out[3] = (n - (out[2] = n & 32767)) / 32768 & 32767;
      }
    }, { "count-trailing-zeros": 110 }], 196: [function(require2, module2, exports2) {
      module2.exports = class FixedFIFO {
        constructor(hwm) {
          if (!(hwm > 0) || (hwm - 1 & hwm) !== 0)
            throw new Error("Max size for a FixedFIFO should be a power of two");
          this.buffer = new Array(hwm);
          this.mask = hwm - 1;
          this.top = 0;
          this.btm = 0;
          this.next = null;
        }
        push(data) {
          if (this.buffer[this.top] !== void 0)
            return false;
          this.buffer[this.top] = data;
          this.top = this.top + 1 & this.mask;
          return true;
        }
        shift() {
          var last = this.buffer[this.btm];
          if (last === void 0)
            return void 0;
          this.buffer[this.btm] = void 0;
          this.btm = this.btm + 1 & this.mask;
          return last;
        }
        isEmpty() {
          return this.buffer[this.btm] === void 0;
        }
      };
    }, {}], 197: [function(require2, module2, exports2) {
      var FixedFIFO = require2("./fixed-size");
      module2.exports = class FastFIFO {
        constructor(hwm) {
          this.hwm = hwm || 16;
          this.head = new FixedFIFO(this.hwm);
          this.tail = this.head;
        }
        push(val) {
          if (!this.head.push(val)) {
            var prev = this.head;
            this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
            this.head.push(val);
          }
        }
        shift() {
          var val = this.tail.shift();
          if (val === void 0 && this.tail.next) {
            var next = this.tail.next;
            this.tail.next = null;
            this.tail = next;
            return this.tail.shift();
          }
          return val;
        }
        isEmpty() {
          return this.head.isEmpty();
        }
      };
    }, { "./fixed-size": 196 }], 198: [function(require2, module2, exports2) {
      var reusify = require2("reusify");
      function fastqueue(context, worker, concurrency) {
        if (typeof context === "function") {
          concurrency = worker;
          worker = context;
          context = null;
        }
        var cache = reusify(Task);
        var queueHead = null;
        var queueTail = null;
        var _running = 0;
        var errorHandler = null;
        var self2 = {
          push,
          drain: noop,
          saturated: noop,
          pause,
          paused: false,
          concurrency,
          running,
          resume,
          idle,
          length,
          getQueue,
          unshift,
          empty: noop,
          kill,
          killAndDrain,
          error
        };
        return self2;
        function running() {
          return _running;
        }
        function pause() {
          self2.paused = true;
        }
        function length() {
          var current = queueHead;
          var counter = 0;
          while (current) {
            current = current.next;
            counter++;
          }
          return counter;
        }
        function getQueue() {
          var current = queueHead;
          var tasks = [];
          while (current) {
            tasks.push(current.value);
            current = current.next;
          }
          return tasks;
        }
        function resume() {
          if (!self2.paused)
            return;
          self2.paused = false;
          for (var i = 0; i < self2.concurrency; i++) {
            _running++;
            release();
          }
        }
        function idle() {
          return _running === 0 && self2.length() === 0;
        }
        function push(value, done) {
          var current = cache.get();
          current.context = context;
          current.release = release;
          current.value = value;
          current.callback = done || noop;
          current.errorHandler = errorHandler;
          if (_running === self2.concurrency || self2.paused) {
            if (queueTail) {
              queueTail.next = current;
              queueTail = current;
            } else {
              queueHead = current;
              queueTail = current;
              self2.saturated();
            }
          } else {
            _running++;
            worker.call(context, current.value, current.worked);
          }
        }
        function unshift(value, done) {
          var current = cache.get();
          current.context = context;
          current.release = release;
          current.value = value;
          current.callback = done || noop;
          if (_running === self2.concurrency || self2.paused) {
            if (queueHead) {
              current.next = queueHead;
              queueHead = current;
            } else {
              queueHead = current;
              queueTail = current;
              self2.saturated();
            }
          } else {
            _running++;
            worker.call(context, current.value, current.worked);
          }
        }
        function release(holder) {
          if (holder) {
            cache.release(holder);
          }
          var next = queueHead;
          if (next) {
            if (!self2.paused) {
              if (queueTail === queueHead) {
                queueTail = null;
              }
              queueHead = next.next;
              next.next = null;
              worker.call(context, next.value, next.worked);
              if (queueTail === null) {
                self2.empty();
              }
            } else {
              _running--;
            }
          } else if (--_running === 0) {
            self2.drain();
          }
        }
        function kill() {
          queueHead = null;
          queueTail = null;
          self2.drain = noop;
        }
        function killAndDrain() {
          queueHead = null;
          queueTail = null;
          self2.drain();
          self2.drain = noop;
        }
        function error(handler) {
          errorHandler = handler;
        }
      }
      function noop() {
      }
      function Task() {
        this.value = null;
        this.callback = noop;
        this.next = null;
        this.release = noop;
        this.context = null;
        this.errorHandler = null;
        var self2 = this;
        this.worked = function worked(err, result) {
          var callback = self2.callback;
          var errorHandler = self2.errorHandler;
          var val = self2.value;
          self2.value = null;
          self2.callback = noop;
          if (self2.errorHandler) {
            errorHandler(err, val);
          }
          callback.call(self2.context, err, result);
          self2.release(self2);
        };
      }
      module2.exports = fastqueue;
    }, { "reusify": 415 }], 199: [function(require2, module2, exports2) {
      (function(__dirname) {
        (function() {
          var binding = require2("node-gyp-build")(__dirname);
          lock.unlock = unlock;
          module2.exports = lock;
          function lock(fd) {
            return !!binding.fd_lock(fd);
          }
          function unlock(fd) {
            return !!binding.fd_unlock(fd);
          }
        }).call(this);
      }).call(this, "/node_modules/fd-lock");
    }, { "node-gyp-build": 330 }], 200: [function(require2, module2, exports2) {
      exports2.fullRoots = function(index, result) {
        if (index & 1)
          throw new Error("You can only look up roots for depth(0) blocks");
        if (!result)
          result = [];
        index /= 2;
        var offset = 0;
        var factor = 1;
        while (true) {
          if (!index)
            return result;
          while (factor * 2 <= index) {
            factor *= 2;
          }
          result.push(offset + factor - 1);
          offset = offset + 2 * factor;
          index -= factor;
          factor = 1;
        }
      };
      exports2.depth = function(index) {
        var depth = 0;
        index += 1;
        while (!(index & 1)) {
          depth++;
          index = rightShift(index);
        }
        return depth;
      };
      exports2.sibling = function(index, depth) {
        if (!depth)
          depth = exports2.depth(index);
        var offset = exports2.offset(index, depth);
        return exports2.index(depth, offset & 1 ? offset - 1 : offset + 1);
      };
      exports2.parent = function(index, depth) {
        if (!depth)
          depth = exports2.depth(index);
        var offset = exports2.offset(index, depth);
        return exports2.index(depth + 1, rightShift(offset));
      };
      exports2.leftChild = function(index, depth) {
        if (!(index & 1))
          return -1;
        if (!depth)
          depth = exports2.depth(index);
        return exports2.index(depth - 1, exports2.offset(index, depth) * 2);
      };
      exports2.rightChild = function(index, depth) {
        if (!(index & 1))
          return -1;
        if (!depth)
          depth = exports2.depth(index);
        return exports2.index(depth - 1, 1 + exports2.offset(index, depth) * 2);
      };
      exports2.children = function(index, depth) {
        if (!(index & 1))
          return null;
        if (!depth)
          depth = exports2.depth(index);
        var offset = exports2.offset(index, depth) * 2;
        return [exports2.index(depth - 1, offset), exports2.index(depth - 1, offset + 1)];
      };
      exports2.leftSpan = function(index, depth) {
        if (!(index & 1))
          return index;
        if (!depth)
          depth = exports2.depth(index);
        return exports2.offset(index, depth) * twoPow(depth + 1);
      };
      exports2.rightSpan = function(index, depth) {
        if (!(index & 1))
          return index;
        if (!depth)
          depth = exports2.depth(index);
        return (exports2.offset(index, depth) + 1) * twoPow(depth + 1) - 2;
      };
      exports2.count = function(index, depth) {
        if (!(index & 1))
          return 1;
        if (!depth)
          depth = exports2.depth(index);
        return twoPow(depth + 1) - 1;
      };
      exports2.spans = function(index, depth) {
        if (!(index & 1))
          return [index, index];
        if (!depth)
          depth = exports2.depth(index);
        var offset = exports2.offset(index, depth);
        var width = twoPow(depth + 1);
        return [offset * width, (offset + 1) * width - 2];
      };
      exports2.index = function(depth, offset) {
        return (1 + 2 * offset) * twoPow(depth) - 1;
      };
      exports2.offset = function(index, depth) {
        if (!(index & 1))
          return index / 2;
        if (!depth)
          depth = exports2.depth(index);
        return ((index + 1) / twoPow(depth) - 1) / 2;
      };
      exports2.iterator = function(index) {
        var ite = new Iterator();
        ite.seek(index || 0);
        return ite;
      };
      function twoPow(n) {
        return n < 31 ? 1 << n : (1 << 30) * (1 << n - 30);
      }
      function rightShift(n) {
        return (n - (n & 1)) / 2;
      }
      function Iterator() {
        this.index = 0;
        this.offset = 0;
        this.factor = 0;
      }
      Iterator.prototype.seek = function(index) {
        this.index = index;
        if (this.index & 1) {
          this.offset = exports2.offset(index);
          this.factor = twoPow(exports2.depth(index) + 1);
        } else {
          this.offset = index / 2;
          this.factor = 2;
        }
      };
      Iterator.prototype.isLeft = function() {
        return (this.offset & 1) === 0;
      };
      Iterator.prototype.isRight = function() {
        return (this.offset & 1) === 1;
      };
      Iterator.prototype.contains = function(index) {
        return index > this.index ? index < this.index + this.factor / 2 : index < this.index ? index > this.index - this.factor / 2 : true;
      };
      Iterator.prototype.prev = function() {
        if (!this.offset)
          return this.index;
        this.offset--;
        this.index -= this.factor;
        return this.index;
      };
      Iterator.prototype.next = function() {
        this.offset++;
        this.index += this.factor;
        return this.index;
      };
      Iterator.prototype.sibling = function() {
        return this.isLeft() ? this.next() : this.prev();
      };
      Iterator.prototype.parent = function() {
        if (this.offset & 1) {
          this.index -= this.factor / 2;
          this.offset = (this.offset - 1) / 2;
        } else {
          this.index += this.factor / 2;
          this.offset /= 2;
        }
        this.factor *= 2;
        return this.index;
      };
      Iterator.prototype.leftSpan = function() {
        this.index = this.index - this.factor / 2 + 1;
        this.offset = this.index / 2;
        this.factor = 2;
        return this.index;
      };
      Iterator.prototype.rightSpan = function() {
        this.index = this.index + this.factor / 2 - 1;
        this.offset = this.index / 2;
        this.factor = 2;
        return this.index;
      };
      Iterator.prototype.leftChild = function() {
        if (this.factor === 2)
          return this.index;
        this.factor /= 2;
        this.index -= this.factor / 2;
        this.offset *= 2;
        return this.index;
      };
      Iterator.prototype.rightChild = function() {
        if (this.factor === 2)
          return this.index;
        this.factor /= 2;
        this.index += this.factor / 2;
        this.offset = 2 * this.offset + 1;
        return this.index;
      };
      Iterator.prototype.nextTree = function() {
        this.index = this.index + this.factor / 2 + 1;
        this.offset = this.index / 2;
        this.factor = 2;
        return this.index;
      };
      Iterator.prototype.prevTree = function() {
        if (!this.offset) {
          this.index = 0;
          this.factor = 2;
        } else {
          this.index = this.index - this.factor / 2 - 1;
          this.offset = this.index / 2;
          this.factor = 2;
        }
        return this.index;
      };
      Iterator.prototype.fullRoot = function(index) {
        if (index <= this.index || (this.index & 1) > 0)
          return false;
        while (index > this.index + this.factor + this.factor / 2) {
          this.index += this.factor / 2;
          this.factor *= 2;
          this.offset /= 2;
        }
        return true;
      };
    }, {}], 201: [function(require2, module2, exports2) {
      var hasOwn = Object.prototype.hasOwnProperty;
      var toString = Object.prototype.toString;
      module2.exports = function forEach(obj, fn, ctx) {
        if (toString.call(fn) !== "[object Function]") {
          throw new TypeError("iterator must be a function");
        }
        var l = obj.length;
        if (l === +l) {
          for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
          }
        } else {
          for (var k in obj) {
            if (hasOwn.call(obj, k)) {
              fn.call(ctx, obj[k], k, obj);
            }
          }
        }
      };
    }, {}], 202: [function(require2, module2, exports2) {
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var slice = Array.prototype.slice;
      var toStr = Object.prototype.toString;
      var funcType = "[object Function]";
      module2.exports = function bind(that) {
        var target = this;
        if (typeof target !== "function" || toStr.call(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice.call(arguments, 1);
        var bound;
        var binder = function binder2() {
          if (this instanceof bound) {
            var result = target.apply(this, args.concat(slice.call(arguments)));
            if (Object(result) === result) {
              return result;
            }
            return this;
          } else {
            return target.apply(that, args.concat(slice.call(arguments)));
          }
        };
        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
          boundArgs.push("$" + i);
        }
        bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
          var Empty = function Empty2() {
          };
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }
        return bound;
      };
    }, {}], 203: [function(require2, module2, exports2) {
      var implementation = require2("./implementation");
      module2.exports = Function.prototype.bind || implementation;
    }, { "./implementation": 202 }], 204: [function(require2, module2, exports2) {
      module2.exports = createRBTree;
      var RED = 0;
      var BLACK = 1;
      function RBNode(color, key, value, left, right, count) {
        this._color = color;
        this.key = key;
        this.value = value;
        this.left = left;
        this.right = right;
        this._count = count;
      }
      function cloneNode(node) {
        return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count);
      }
      function repaint(color, node) {
        return new RBNode(color, node.key, node.value, node.left, node.right, node._count);
      }
      function recount(node) {
        node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0);
      }
      function RedBlackTree(compare, root) {
        this._compare = compare;
        this.root = root;
      }
      var proto = RedBlackTree.prototype;
      Object.defineProperty(proto, "keys", {
        get: function get() {
          var result = [];
          this.forEach(function(k, v) {
            result.push(k);
          });
          return result;
        }
      });
      Object.defineProperty(proto, "values", {
        get: function get() {
          var result = [];
          this.forEach(function(k, v) {
            result.push(v);
          });
          return result;
        }
      });
      Object.defineProperty(proto, "length", {
        get: function get() {
          if (this.root) {
            return this.root._count;
          }
          return 0;
        }
      });
      proto.insert = function(key, value) {
        var cmp = this._compare;
        var n = this.root;
        var n_stack = [];
        var d_stack = [];
        while (n) {
          var d = cmp(key, n.key);
          n_stack.push(n);
          d_stack.push(d);
          if (d <= 0) {
            n = n.left;
          } else {
            n = n.right;
          }
        }
        n_stack.push(new RBNode(RED, key, value, null, null, 1));
        for (var s = n_stack.length - 2; s >= 0; --s) {
          var n = n_stack[s];
          if (d_stack[s] <= 0) {
            n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s + 1], n.right, n._count + 1);
          } else {
            n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s + 1], n._count + 1);
          }
        }
        for (var s = n_stack.length - 1; s > 1; --s) {
          var p = n_stack[s - 1];
          var n = n_stack[s];
          if (p._color === BLACK || n._color === BLACK) {
            break;
          }
          var pp = n_stack[s - 2];
          if (pp.left === p) {
            if (p.left === n) {
              var y = pp.right;
              if (y && y._color === RED) {
                p._color = BLACK;
                pp.right = repaint(BLACK, y);
                pp._color = RED;
                s -= 1;
              } else {
                pp._color = RED;
                pp.left = p.right;
                p._color = BLACK;
                p.right = pp;
                n_stack[s - 2] = p;
                n_stack[s - 1] = n;
                recount(pp);
                recount(p);
                if (s >= 3) {
                  var ppp = n_stack[s - 3];
                  if (ppp.left === pp) {
                    ppp.left = p;
                  } else {
                    ppp.right = p;
                  }
                }
                break;
              }
            } else {
              var y = pp.right;
              if (y && y._color === RED) {
                p._color = BLACK;
                pp.right = repaint(BLACK, y);
                pp._color = RED;
                s -= 1;
              } else {
                p.right = n.left;
                pp._color = RED;
                pp.left = n.right;
                n._color = BLACK;
                n.left = p;
                n.right = pp;
                n_stack[s - 2] = n;
                n_stack[s - 1] = p;
                recount(pp);
                recount(p);
                recount(n);
                if (s >= 3) {
                  var ppp = n_stack[s - 3];
                  if (ppp.left === pp) {
                    ppp.left = n;
                  } else {
                    ppp.right = n;
                  }
                }
                break;
              }
            }
          } else {
            if (p.right === n) {
              var y = pp.left;
              if (y && y._color === RED) {
                p._color = BLACK;
                pp.left = repaint(BLACK, y);
                pp._color = RED;
                s -= 1;
              } else {
                pp._color = RED;
                pp.right = p.left;
                p._color = BLACK;
                p.left = pp;
                n_stack[s - 2] = p;
                n_stack[s - 1] = n;
                recount(pp);
                recount(p);
                if (s >= 3) {
                  var ppp = n_stack[s - 3];
                  if (ppp.right === pp) {
                    ppp.right = p;
                  } else {
                    ppp.left = p;
                  }
                }
                break;
              }
            } else {
              var y = pp.left;
              if (y && y._color === RED) {
                p._color = BLACK;
                pp.left = repaint(BLACK, y);
                pp._color = RED;
                s -= 1;
              } else {
                p.left = n.right;
                pp._color = RED;
                pp.right = n.left;
                n._color = BLACK;
                n.right = p;
                n.left = pp;
                n_stack[s - 2] = n;
                n_stack[s - 1] = p;
                recount(pp);
                recount(p);
                recount(n);
                if (s >= 3) {
                  var ppp = n_stack[s - 3];
                  if (ppp.right === pp) {
                    ppp.right = n;
                  } else {
                    ppp.left = n;
                  }
                }
                break;
              }
            }
          }
        }
        n_stack[0]._color = BLACK;
        return new RedBlackTree(cmp, n_stack[0]);
      };
      function doVisitFull(visit, node) {
        if (node.left) {
          var v = doVisitFull(visit, node.left);
          if (v) {
            return v;
          }
        }
        var v = visit(node.key, node.value);
        if (v) {
          return v;
        }
        if (node.right) {
          return doVisitFull(visit, node.right);
        }
      }
      function doVisitHalf(lo, compare, visit, node) {
        var l = compare(lo, node.key);
        if (l <= 0) {
          if (node.left) {
            var v = doVisitHalf(lo, compare, visit, node.left);
            if (v) {
              return v;
            }
          }
          var v = visit(node.key, node.value);
          if (v) {
            return v;
          }
        }
        if (node.right) {
          return doVisitHalf(lo, compare, visit, node.right);
        }
      }
      function doVisit(lo, hi, compare, visit, node) {
        var l = compare(lo, node.key);
        var h = compare(hi, node.key);
        var v;
        if (l <= 0) {
          if (node.left) {
            v = doVisit(lo, hi, compare, visit, node.left);
            if (v) {
              return v;
            }
          }
          if (h > 0) {
            v = visit(node.key, node.value);
            if (v) {
              return v;
            }
          }
        }
        if (h > 0 && node.right) {
          return doVisit(lo, hi, compare, visit, node.right);
        }
      }
      proto.forEach = function rbTreeForEach(visit, lo, hi) {
        if (!this.root) {
          return;
        }
        switch (arguments.length) {
          case 1:
            return doVisitFull(visit, this.root);
          case 2:
            return doVisitHalf(lo, this._compare, visit, this.root);
          case 3:
            if (this._compare(lo, hi) >= 0) {
              return;
            }
            return doVisit(lo, hi, this._compare, visit, this.root);
        }
      };
      Object.defineProperty(proto, "begin", {
        get: function get() {
          var stack = [];
          var n = this.root;
          while (n) {
            stack.push(n);
            n = n.left;
          }
          return new RedBlackTreeIterator(this, stack);
        }
      });
      Object.defineProperty(proto, "end", {
        get: function get() {
          var stack = [];
          var n = this.root;
          while (n) {
            stack.push(n);
            n = n.right;
          }
          return new RedBlackTreeIterator(this, stack);
        }
      });
      proto.at = function(idx) {
        if (idx < 0) {
          return new RedBlackTreeIterator(this, []);
        }
        var n = this.root;
        var stack = [];
        while (true) {
          stack.push(n);
          if (n.left) {
            if (idx < n.left._count) {
              n = n.left;
              continue;
            }
            idx -= n.left._count;
          }
          if (!idx) {
            return new RedBlackTreeIterator(this, stack);
          }
          idx -= 1;
          if (n.right) {
            if (idx >= n.right._count) {
              break;
            }
            n = n.right;
          } else {
            break;
          }
        }
        return new RedBlackTreeIterator(this, []);
      };
      proto.ge = function(key) {
        var cmp = this._compare;
        var n = this.root;
        var stack = [];
        var last_ptr = 0;
        while (n) {
          var d = cmp(key, n.key);
          stack.push(n);
          if (d <= 0) {
            last_ptr = stack.length;
          }
          if (d <= 0) {
            n = n.left;
          } else {
            n = n.right;
          }
        }
        stack.length = last_ptr;
        return new RedBlackTreeIterator(this, stack);
      };
      proto.gt = function(key) {
        var cmp = this._compare;
        var n = this.root;
        var stack = [];
        var last_ptr = 0;
        while (n) {
          var d = cmp(key, n.key);
          stack.push(n);
          if (d < 0) {
            last_ptr = stack.length;
          }
          if (d < 0) {
            n = n.left;
          } else {
            n = n.right;
          }
        }
        stack.length = last_ptr;
        return new RedBlackTreeIterator(this, stack);
      };
      proto.lt = function(key) {
        var cmp = this._compare;
        var n = this.root;
        var stack = [];
        var last_ptr = 0;
        while (n) {
          var d = cmp(key, n.key);
          stack.push(n);
          if (d > 0) {
            last_ptr = stack.length;
          }
          if (d <= 0) {
            n = n.left;
          } else {
            n = n.right;
          }
        }
        stack.length = last_ptr;
        return new RedBlackTreeIterator(this, stack);
      };
      proto.le = function(key) {
        var cmp = this._compare;
        var n = this.root;
        var stack = [];
        var last_ptr = 0;
        while (n) {
          var d = cmp(key, n.key);
          stack.push(n);
          if (d >= 0) {
            last_ptr = stack.length;
          }
          if (d < 0) {
            n = n.left;
          } else {
            n = n.right;
          }
        }
        stack.length = last_ptr;
        return new RedBlackTreeIterator(this, stack);
      };
      proto.find = function(key) {
        var cmp = this._compare;
        var n = this.root;
        var stack = [];
        while (n) {
          var d = cmp(key, n.key);
          stack.push(n);
          if (d === 0) {
            return new RedBlackTreeIterator(this, stack);
          }
          if (d <= 0) {
            n = n.left;
          } else {
            n = n.right;
          }
        }
        return new RedBlackTreeIterator(this, []);
      };
      proto.remove = function(key) {
        var iter = this.find(key);
        if (iter) {
          return iter.remove();
        }
        return this;
      };
      proto.get = function(key) {
        var cmp = this._compare;
        var n = this.root;
        while (n) {
          var d = cmp(key, n.key);
          if (d === 0) {
            return n.value;
          }
          if (d <= 0) {
            n = n.left;
          } else {
            n = n.right;
          }
        }
        return;
      };
      function RedBlackTreeIterator(tree, stack) {
        this.tree = tree;
        this._stack = stack;
      }
      var iproto = RedBlackTreeIterator.prototype;
      Object.defineProperty(iproto, "valid", {
        get: function get() {
          return this._stack.length > 0;
        }
      });
      Object.defineProperty(iproto, "node", {
        get: function get() {
          if (this._stack.length > 0) {
            return this._stack[this._stack.length - 1];
          }
          return null;
        },
        enumerable: true
      });
      iproto.clone = function() {
        return new RedBlackTreeIterator(this.tree, this._stack.slice());
      };
      function swapNode(n, v) {
        n.key = v.key;
        n.value = v.value;
        n.left = v.left;
        n.right = v.right;
        n._color = v._color;
        n._count = v._count;
      }
      function fixDoubleBlack(stack) {
        var n, p, s, z;
        for (var i = stack.length - 1; i >= 0; --i) {
          n = stack[i];
          if (i === 0) {
            n._color = BLACK;
            return;
          }
          p = stack[i - 1];
          if (p.left === n) {
            s = p.right;
            if (s.right && s.right._color === RED) {
              s = p.right = cloneNode(s);
              z = s.right = cloneNode(s.right);
              p.right = s.left;
              s.left = p;
              s.right = z;
              s._color = p._color;
              n._color = BLACK;
              p._color = BLACK;
              z._color = BLACK;
              recount(p);
              recount(s);
              if (i > 1) {
                var pp = stack[i - 2];
                if (pp.left === p) {
                  pp.left = s;
                } else {
                  pp.right = s;
                }
              }
              stack[i - 1] = s;
              return;
            } else if (s.left && s.left._color === RED) {
              s = p.right = cloneNode(s);
              z = s.left = cloneNode(s.left);
              p.right = z.left;
              s.left = z.right;
              z.left = p;
              z.right = s;
              z._color = p._color;
              p._color = BLACK;
              s._color = BLACK;
              n._color = BLACK;
              recount(p);
              recount(s);
              recount(z);
              if (i > 1) {
                var pp = stack[i - 2];
                if (pp.left === p) {
                  pp.left = z;
                } else {
                  pp.right = z;
                }
              }
              stack[i - 1] = z;
              return;
            }
            if (s._color === BLACK) {
              if (p._color === RED) {
                p._color = BLACK;
                p.right = repaint(RED, s);
                return;
              } else {
                p.right = repaint(RED, s);
                continue;
              }
            } else {
              s = cloneNode(s);
              p.right = s.left;
              s.left = p;
              s._color = p._color;
              p._color = RED;
              recount(p);
              recount(s);
              if (i > 1) {
                var pp = stack[i - 2];
                if (pp.left === p) {
                  pp.left = s;
                } else {
                  pp.right = s;
                }
              }
              stack[i - 1] = s;
              stack[i] = p;
              if (i + 1 < stack.length) {
                stack[i + 1] = n;
              } else {
                stack.push(n);
              }
              i = i + 2;
            }
          } else {
            s = p.left;
            if (s.left && s.left._color === RED) {
              s = p.left = cloneNode(s);
              z = s.left = cloneNode(s.left);
              p.left = s.right;
              s.right = p;
              s.left = z;
              s._color = p._color;
              n._color = BLACK;
              p._color = BLACK;
              z._color = BLACK;
              recount(p);
              recount(s);
              if (i > 1) {
                var pp = stack[i - 2];
                if (pp.right === p) {
                  pp.right = s;
                } else {
                  pp.left = s;
                }
              }
              stack[i - 1] = s;
              return;
            } else if (s.right && s.right._color === RED) {
              s = p.left = cloneNode(s);
              z = s.right = cloneNode(s.right);
              p.left = z.right;
              s.right = z.left;
              z.right = p;
              z.left = s;
              z._color = p._color;
              p._color = BLACK;
              s._color = BLACK;
              n._color = BLACK;
              recount(p);
              recount(s);
              recount(z);
              if (i > 1) {
                var pp = stack[i - 2];
                if (pp.right === p) {
                  pp.right = z;
                } else {
                  pp.left = z;
                }
              }
              stack[i - 1] = z;
              return;
            }
            if (s._color === BLACK) {
              if (p._color === RED) {
                p._color = BLACK;
                p.left = repaint(RED, s);
                return;
              } else {
                p.left = repaint(RED, s);
                continue;
              }
            } else {
              s = cloneNode(s);
              p.left = s.right;
              s.right = p;
              s._color = p._color;
              p._color = RED;
              recount(p);
              recount(s);
              if (i > 1) {
                var pp = stack[i - 2];
                if (pp.right === p) {
                  pp.right = s;
                } else {
                  pp.left = s;
                }
              }
              stack[i - 1] = s;
              stack[i] = p;
              if (i + 1 < stack.length) {
                stack[i + 1] = n;
              } else {
                stack.push(n);
              }
              i = i + 2;
            }
          }
        }
      }
      iproto.remove = function() {
        var stack = this._stack;
        if (stack.length === 0) {
          return this.tree;
        }
        var cstack = new Array(stack.length);
        var n = stack[stack.length - 1];
        cstack[cstack.length - 1] = new RBNode(n._color, n.key, n.value, n.left, n.right, n._count);
        for (var i = stack.length - 2; i >= 0; --i) {
          var n = stack[i];
          if (n.left === stack[i + 1]) {
            cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count);
          } else {
            cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
          }
        }
        n = cstack[cstack.length - 1];
        if (n.left && n.right) {
          var split = cstack.length;
          n = n.left;
          while (n.right) {
            cstack.push(n);
            n = n.right;
          }
          var v = cstack[split - 1];
          cstack.push(new RBNode(n._color, v.key, v.value, n.left, n.right, n._count));
          cstack[split - 1].key = n.key;
          cstack[split - 1].value = n.value;
          for (var i = cstack.length - 2; i >= split; --i) {
            n = cstack[i];
            cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
          }
          cstack[split - 1].left = cstack[split];
        }
        n = cstack[cstack.length - 1];
        if (n._color === RED) {
          var p = cstack[cstack.length - 2];
          if (p.left === n) {
            p.left = null;
          } else if (p.right === n) {
            p.right = null;
          }
          cstack.pop();
          for (var i = 0; i < cstack.length; ++i) {
            cstack[i]._count--;
          }
          return new RedBlackTree(this.tree._compare, cstack[0]);
        } else {
          if (n.left || n.right) {
            if (n.left) {
              swapNode(n, n.left);
            } else if (n.right) {
              swapNode(n, n.right);
            }
            n._color = BLACK;
            for (var i = 0; i < cstack.length - 1; ++i) {
              cstack[i]._count--;
            }
            return new RedBlackTree(this.tree._compare, cstack[0]);
          } else if (cstack.length === 1) {
            return new RedBlackTree(this.tree._compare, null);
          } else {
            for (var i = 0; i < cstack.length; ++i) {
              cstack[i]._count--;
            }
            var parent = cstack[cstack.length - 2];
            fixDoubleBlack(cstack);
            if (parent.left === n) {
              parent.left = null;
            } else {
              parent.right = null;
            }
          }
        }
        return new RedBlackTree(this.tree._compare, cstack[0]);
      };
      Object.defineProperty(iproto, "key", {
        get: function get() {
          if (this._stack.length > 0) {
            return this._stack[this._stack.length - 1].key;
          }
          return;
        },
        enumerable: true
      });
      Object.defineProperty(iproto, "value", {
        get: function get() {
          if (this._stack.length > 0) {
            return this._stack[this._stack.length - 1].value;
          }
          return;
        },
        enumerable: true
      });
      Object.defineProperty(iproto, "index", {
        get: function get() {
          var idx = 0;
          var stack = this._stack;
          if (stack.length === 0) {
            var r = this.tree.root;
            if (r) {
              return r._count;
            }
            return 0;
          } else if (stack[stack.length - 1].left) {
            idx = stack[stack.length - 1].left._count;
          }
          for (var s = stack.length - 2; s >= 0; --s) {
            if (stack[s + 1] === stack[s].right) {
              ++idx;
              if (stack[s].left) {
                idx += stack[s].left._count;
              }
            }
          }
          return idx;
        },
        enumerable: true
      });
      iproto.next = function() {
        var stack = this._stack;
        if (stack.length === 0) {
          return;
        }
        var n = stack[stack.length - 1];
        if (n.right) {
          n = n.right;
          while (n) {
            stack.push(n);
            n = n.left;
          }
        } else {
          stack.pop();
          while (stack.length > 0 && stack[stack.length - 1].right === n) {
            n = stack[stack.length - 1];
            stack.pop();
          }
        }
      };
      Object.defineProperty(iproto, "hasNext", {
        get: function get() {
          var stack = this._stack;
          if (stack.length === 0) {
            return false;
          }
          if (stack[stack.length - 1].right) {
            return true;
          }
          for (var s = stack.length - 1; s > 0; --s) {
            if (stack[s - 1].left === stack[s]) {
              return true;
            }
          }
          return false;
        }
      });
      iproto.update = function(value) {
        var stack = this._stack;
        if (stack.length === 0) {
          throw new Error("Can't update empty node!");
        }
        var cstack = new Array(stack.length);
        var n = stack[stack.length - 1];
        cstack[cstack.length - 1] = new RBNode(n._color, n.key, value, n.left, n.right, n._count);
        for (var i = stack.length - 2; i >= 0; --i) {
          n = stack[i];
          if (n.left === stack[i + 1]) {
            cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count);
          } else {
            cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
          }
        }
        return new RedBlackTree(this.tree._compare, cstack[0]);
      };
      iproto.prev = function() {
        var stack = this._stack;
        if (stack.length === 0) {
          return;
        }
        var n = stack[stack.length - 1];
        if (n.left) {
          n = n.left;
          while (n) {
            stack.push(n);
            n = n.right;
          }
        } else {
          stack.pop();
          while (stack.length > 0 && stack[stack.length - 1].left === n) {
            n = stack[stack.length - 1];
            stack.pop();
          }
        }
      };
      Object.defineProperty(iproto, "hasPrev", {
        get: function get() {
          var stack = this._stack;
          if (stack.length === 0) {
            return false;
          }
          if (stack[stack.length - 1].left) {
            return true;
          }
          for (var s = stack.length - 1; s > 0; --s) {
            if (stack[s - 1].right === stack[s]) {
              return true;
            }
          }
          return false;
        }
      });
      function defaultCompare(a, b) {
        if (a < b) {
          return -1;
        }
        if (a > b) {
          return 1;
        }
        return 0;
      }
      function createRBTree(compare) {
        return new RedBlackTree(compare || defaultCompare, null);
      }
    }, {}], 205: [function(require2, module2, exports2) {
      module2.exports = function getBrowserRTC() {
        if (typeof globalThis === "undefined")
          return null;
        var wrtc = {
          RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection,
          RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,
          RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate
        };
        if (!wrtc.RTCPeerConnection)
          return null;
        return wrtc;
      };
    }, {}], 206: [function(require2, module2, exports2) {
      var undefined$1;
      var $SyntaxError = SyntaxError;
      var $Function = Function;
      var $TypeError = TypeError;
      var getEvalledConstructor = function getEvalledConstructor2(expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e) {
        }
      };
      var $gOPD = Object.getOwnPropertyDescriptor;
      if ($gOPD) {
        try {
          $gOPD({}, "");
        } catch (e) {
          $gOPD = null;
        }
      }
      var throwTypeError = function throwTypeError2() {
        throw new $TypeError();
      };
      var ThrowTypeError = $gOPD ? function() {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD(arguments, "callee").get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() : throwTypeError;
      var hasSymbols = require2("has-symbols")();
      var getProto = Object.getPrototypeOf || function(x) {
        return x.__proto__;
      };
      var needsEval = {};
      var TypedArray = typeof Uint8Array === "undefined" ? undefined$1 : getProto(Uint8Array);
      var INTRINSICS = {
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined$1,
        "%AsyncFromSyncIteratorPrototype%": undefined$1,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%eval%": eval,
        "%EvalError%": EvalError,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
        "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
        "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
        "%RangeError%": RangeError,
        "%ReferenceError%": ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined$1,
        "%Symbol%": hasSymbols ? Symbol : undefined$1,
        "%SyntaxError%": $SyntaxError,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
        "%URIError%": URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
      };
      var doEval = function doEval2(name) {
        var value;
        if (name === "%AsyncFunction%") {
          value = getEvalledConstructor("async function () {}");
        } else if (name === "%GeneratorFunction%") {
          value = getEvalledConstructor("function* () {}");
        } else if (name === "%AsyncGeneratorFunction%") {
          value = getEvalledConstructor("async function* () {}");
        } else if (name === "%AsyncGenerator%") {
          var fn = doEval2("%AsyncGeneratorFunction%");
          if (fn) {
            value = fn.prototype;
          }
        } else if (name === "%AsyncIteratorPrototype%") {
          var gen = doEval2("%AsyncGenerator%");
          if (gen) {
            value = getProto(gen.prototype);
          }
        }
        INTRINSICS[name] = value;
        return value;
      };
      var LEGACY_ALIASES = {
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      };
      var bind = require2("function-bind");
      var hasOwn = require2("has");
      var $concat = bind.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
      var $replace = bind.call(Function.call, String.prototype.replace);
      var $strSlice = bind.call(Function.call, String.prototype.slice);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath2(string) {
        var first = $strSlice(string, 0, 1);
        var last = $strSlice(string, -1);
        if (first === "%" && last !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
        } else if (last === "%" && first !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace(string, rePropName, function(match, number, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = "%" + alias[0] + "%";
        }
        if (hasOwn(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === "undefined" && !allowMissing) {
            throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
          }
          return {
            alias,
            name: intrinsicName,
            value
          };
        }
        throw new $SyntaxError("intrinsic " + name + " does not exist!");
      };
      module2.exports = function GetIntrinsic(name, allowMissing) {
        if (typeof name !== "string" || name.length === 0) {
          throw new $TypeError("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new $TypeError('"allowMissing" argument must be a boolean');
        }
        var parts = stringToPath(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat([0, 1], alias));
        }
        for (var i = 1, isOwn = true; i < parts.length; i += 1) {
          var part = parts[i];
          var first = $strSlice(part, 0, 1);
          var last = $strSlice(part, -1);
          if ((first === '"' || first === "'" || first === "`" || last === '"' || last === "'" || last === "`") && first !== last) {
            throw new $SyntaxError("property names with quotes must have matching quotes");
          }
          if (part === "constructor" || !isOwn) {
            skipFurtherCaching = true;
          }
          intrinsicBaseName += "." + part;
          intrinsicRealName = "%" + intrinsicBaseName + "%";
          if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
              }
              return void 0;
            }
            if ($gOPD && i + 1 >= parts.length) {
              var desc = $gOPD(value, part);
              isOwn = !!desc;
              if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn(value, part);
              value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };
    }, { "function-bind": 203, "has": 209, "has-symbols": 207 }], 207: [function(require2, module2, exports2) {
      var origSymbol = typeof Symbol !== "undefined" && Symbol;
      var hasSymbolSham = require2("./shams");
      module2.exports = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }
        return hasSymbolSham();
      };
    }, { "./shams": 208 }], 208: [function(require2, module2, exports2) {
      module2.exports = function hasSymbols() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
    }, {}], 209: [function(require2, module2, exports2) {
      var bind = require2("function-bind");
      module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
    }, { "function-bind": 203 }], 210: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      var Transform = require2("readable-stream").Transform;
      var inherits = require2("inherits");
      function throwIfNotStringOrBuffer(val, prefix) {
        if (!Buffer.isBuffer(val) && typeof val !== "string") {
          throw new TypeError(prefix + " must be a string or a buffer");
        }
      }
      function HashBase(blockSize) {
        Transform.call(this);
        this._block = Buffer.allocUnsafe(blockSize);
        this._blockSize = blockSize;
        this._blockOffset = 0;
        this._length = [0, 0, 0, 0];
        this._finalized = false;
      }
      inherits(HashBase, Transform);
      HashBase.prototype._transform = function(chunk, encoding, callback) {
        var error = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error = err;
        }
        callback(error);
      };
      HashBase.prototype._flush = function(callback) {
        var error = null;
        try {
          this.push(this.digest());
        } catch (err) {
          error = err;
        }
        callback(error);
      };
      HashBase.prototype.update = function(data, encoding) {
        throwIfNotStringOrBuffer(data, "Data");
        if (this._finalized)
          throw new Error("Digest already called");
        if (!Buffer.isBuffer(data))
          data = Buffer.from(data, encoding);
        var block = this._block;
        var offset = 0;
        while (this._blockOffset + data.length - offset >= this._blockSize) {
          for (var i = this._blockOffset; i < this._blockSize; ) {
            block[i++] = data[offset++];
          }
          this._update();
          this._blockOffset = 0;
        }
        while (offset < data.length) {
          block[this._blockOffset++] = data[offset++];
        }
        for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
          this._length[j] += carry;
          carry = this._length[j] / 4294967296 | 0;
          if (carry > 0)
            this._length[j] -= 4294967296 * carry;
        }
        return this;
      };
      HashBase.prototype._update = function() {
        throw new Error("_update is not implemented");
      };
      HashBase.prototype.digest = function(encoding) {
        if (this._finalized)
          throw new Error("Digest already called");
        this._finalized = true;
        var digest = this._digest();
        if (encoding !== void 0)
          digest = digest.toString(encoding);
        this._block.fill(0);
        this._blockOffset = 0;
        for (var i = 0; i < 4; ++i) {
          this._length[i] = 0;
        }
        return digest;
      };
      HashBase.prototype._digest = function() {
        throw new Error("_digest is not implemented");
      };
      module2.exports = HashBase;
    }, { "inherits": 256, "readable-stream": 412, "safe-buffer": 417 }], 211: [function(require2, module2, exports2) {
      var hash = exports2;
      hash.utils = require2("./hash/utils");
      hash.common = require2("./hash/common");
      hash.sha = require2("./hash/sha");
      hash.ripemd = require2("./hash/ripemd");
      hash.hmac = require2("./hash/hmac");
      hash.sha1 = hash.sha.sha1;
      hash.sha256 = hash.sha.sha256;
      hash.sha224 = hash.sha.sha224;
      hash.sha384 = hash.sha.sha384;
      hash.sha512 = hash.sha.sha512;
      hash.ripemd160 = hash.ripemd.ripemd160;
    }, { "./hash/common": 212, "./hash/hmac": 213, "./hash/ripemd": 214, "./hash/sha": 215, "./hash/utils": 222 }], 212: [function(require2, module2, exports2) {
      var utils = require2("./utils");
      var assert = require2("minimalistic-assert");
      function BlockHash() {
        this.pending = null;
        this.pendingTotal = 0;
        this.blockSize = this.constructor.blockSize;
        this.outSize = this.constructor.outSize;
        this.hmacStrength = this.constructor.hmacStrength;
        this.padLength = this.constructor.padLength / 8;
        this.endian = "big";
        this._delta8 = this.blockSize / 8;
        this._delta32 = this.blockSize / 32;
      }
      exports2.BlockHash = BlockHash;
      BlockHash.prototype.update = function update(msg, enc) {
        msg = utils.toArray(msg, enc);
        if (!this.pending)
          this.pending = msg;
        else
          this.pending = this.pending.concat(msg);
        this.pendingTotal += msg.length;
        if (this.pending.length >= this._delta8) {
          msg = this.pending;
          var r = msg.length % this._delta8;
          this.pending = msg.slice(msg.length - r, msg.length);
          if (this.pending.length === 0)
            this.pending = null;
          msg = utils.join32(msg, 0, msg.length - r, this.endian);
          for (var i = 0; i < msg.length; i += this._delta32) {
            this._update(msg, i, i + this._delta32);
          }
        }
        return this;
      };
      BlockHash.prototype.digest = function digest(enc) {
        this.update(this._pad());
        assert(this.pending === null);
        return this._digest(enc);
      };
      BlockHash.prototype._pad = function pad() {
        var len = this.pendingTotal;
        var bytes = this._delta8;
        var k = bytes - (len + this.padLength) % bytes;
        var res = new Array(k + this.padLength);
        res[0] = 128;
        for (var i = 1; i < k; i++) {
          res[i] = 0;
        }
        len <<= 3;
        if (this.endian === "big") {
          for (var t = 8; t < this.padLength; t++) {
            res[i++] = 0;
          }
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = len >>> 24 & 255;
          res[i++] = len >>> 16 & 255;
          res[i++] = len >>> 8 & 255;
          res[i++] = len & 255;
        } else {
          res[i++] = len & 255;
          res[i++] = len >>> 8 & 255;
          res[i++] = len >>> 16 & 255;
          res[i++] = len >>> 24 & 255;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          for (t = 8; t < this.padLength; t++) {
            res[i++] = 0;
          }
        }
        return res;
      };
    }, { "./utils": 222, "minimalistic-assert": 302 }], 213: [function(require2, module2, exports2) {
      var utils = require2("./utils");
      var assert = require2("minimalistic-assert");
      function Hmac(hash, key, enc) {
        if (!(this instanceof Hmac))
          return new Hmac(hash, key, enc);
        this.Hash = hash;
        this.blockSize = hash.blockSize / 8;
        this.outSize = hash.outSize / 8;
        this.inner = null;
        this.outer = null;
        this._init(utils.toArray(key, enc));
      }
      module2.exports = Hmac;
      Hmac.prototype._init = function init(key) {
        if (key.length > this.blockSize)
          key = new this.Hash().update(key).digest();
        assert(key.length <= this.blockSize);
        for (var i = key.length; i < this.blockSize; i++) {
          key.push(0);
        }
        for (i = 0; i < key.length; i++) {
          key[i] ^= 54;
        }
        this.inner = new this.Hash().update(key);
        for (i = 0; i < key.length; i++) {
          key[i] ^= 106;
        }
        this.outer = new this.Hash().update(key);
      };
      Hmac.prototype.update = function update(msg, enc) {
        this.inner.update(msg, enc);
        return this;
      };
      Hmac.prototype.digest = function digest(enc) {
        this.outer.update(this.inner.digest());
        return this.outer.digest(enc);
      };
    }, { "./utils": 222, "minimalistic-assert": 302 }], 214: [function(require2, module2, exports2) {
      var utils = require2("./utils");
      var common = require2("./common");
      var rotl32 = utils.rotl32;
      var sum32 = utils.sum32;
      var sum32_3 = utils.sum32_3;
      var sum32_4 = utils.sum32_4;
      var BlockHash = common.BlockHash;
      function RIPEMD160() {
        if (!(this instanceof RIPEMD160))
          return new RIPEMD160();
        BlockHash.call(this);
        this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        this.endian = "little";
      }
      utils.inherits(RIPEMD160, BlockHash);
      exports2.ripemd160 = RIPEMD160;
      RIPEMD160.blockSize = 512;
      RIPEMD160.outSize = 160;
      RIPEMD160.hmacStrength = 192;
      RIPEMD160.padLength = 64;
      RIPEMD160.prototype._update = function update(msg, start) {
        var A = this.h[0];
        var B = this.h[1];
        var C = this.h[2];
        var D = this.h[3];
        var E = this.h[4];
        var Ah = A;
        var Bh = B;
        var Ch = C;
        var Dh = D;
        var Eh = E;
        for (var j = 0; j < 80; j++) {
          var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
          A = E;
          E = D;
          D = rotl32(C, 10);
          C = B;
          B = T;
          T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
          Ah = Eh;
          Eh = Dh;
          Dh = rotl32(Ch, 10);
          Ch = Bh;
          Bh = T;
        }
        T = sum32_3(this.h[1], C, Dh);
        this.h[1] = sum32_3(this.h[2], D, Eh);
        this.h[2] = sum32_3(this.h[3], E, Ah);
        this.h[3] = sum32_3(this.h[4], A, Bh);
        this.h[4] = sum32_3(this.h[0], B, Ch);
        this.h[0] = T;
      };
      RIPEMD160.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "little");
        else
          return utils.split32(this.h, "little");
      };
      function f(j, x, y, z) {
        if (j <= 15)
          return x ^ y ^ z;
        else if (j <= 31)
          return x & y | ~x & z;
        else if (j <= 47)
          return (x | ~y) ^ z;
        else if (j <= 63)
          return x & z | y & ~z;
        else
          return x ^ (y | ~z);
      }
      function K(j) {
        if (j <= 15)
          return 0;
        else if (j <= 31)
          return 1518500249;
        else if (j <= 47)
          return 1859775393;
        else if (j <= 63)
          return 2400959708;
        else
          return 2840853838;
      }
      function Kh(j) {
        if (j <= 15)
          return 1352829926;
        else if (j <= 31)
          return 1548603684;
        else if (j <= 47)
          return 1836072691;
        else if (j <= 63)
          return 2053994217;
        else
          return 0;
      }
      var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
      var rh = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
      var s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
      var sh = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
    }, { "./common": 212, "./utils": 222 }], 215: [function(require2, module2, exports2) {
      exports2.sha1 = require2("./sha/1");
      exports2.sha224 = require2("./sha/224");
      exports2.sha256 = require2("./sha/256");
      exports2.sha384 = require2("./sha/384");
      exports2.sha512 = require2("./sha/512");
    }, { "./sha/1": 216, "./sha/224": 217, "./sha/256": 218, "./sha/384": 219, "./sha/512": 220 }], 216: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var common = require2("../common");
      var shaCommon = require2("./common");
      var rotl32 = utils.rotl32;
      var sum32 = utils.sum32;
      var sum32_5 = utils.sum32_5;
      var ft_1 = shaCommon.ft_1;
      var BlockHash = common.BlockHash;
      var sha1_K = [1518500249, 1859775393, 2400959708, 3395469782];
      function SHA1() {
        if (!(this instanceof SHA1))
          return new SHA1();
        BlockHash.call(this);
        this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        this.W = new Array(80);
      }
      utils.inherits(SHA1, BlockHash);
      module2.exports = SHA1;
      SHA1.blockSize = 512;
      SHA1.outSize = 160;
      SHA1.hmacStrength = 80;
      SHA1.padLength = 64;
      SHA1.prototype._update = function _update(msg, start) {
        var W = this.W;
        for (var i = 0; i < 16; i++) {
          W[i] = msg[start + i];
        }
        for (; i < W.length; i++) {
          W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
        }
        var a = this.h[0];
        var b = this.h[1];
        var c = this.h[2];
        var d = this.h[3];
        var e = this.h[4];
        for (i = 0; i < W.length; i++) {
          var s = ~~(i / 20);
          var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
          e = d;
          d = c;
          c = rotl32(b, 30);
          b = a;
          a = t;
        }
        this.h[0] = sum32(this.h[0], a);
        this.h[1] = sum32(this.h[1], b);
        this.h[2] = sum32(this.h[2], c);
        this.h[3] = sum32(this.h[3], d);
        this.h[4] = sum32(this.h[4], e);
      };
      SHA1.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
    }, { "../common": 212, "../utils": 222, "./common": 221 }], 217: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var SHA256 = require2("./256");
      function SHA224() {
        if (!(this instanceof SHA224))
          return new SHA224();
        SHA256.call(this);
        this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
      }
      utils.inherits(SHA224, SHA256);
      module2.exports = SHA224;
      SHA224.blockSize = 512;
      SHA224.outSize = 224;
      SHA224.hmacStrength = 192;
      SHA224.padLength = 64;
      SHA224.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h.slice(0, 7), "big");
        else
          return utils.split32(this.h.slice(0, 7), "big");
      };
    }, { "../utils": 222, "./256": 218 }], 218: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var common = require2("../common");
      var shaCommon = require2("./common");
      var assert = require2("minimalistic-assert");
      var sum32 = utils.sum32;
      var sum32_4 = utils.sum32_4;
      var sum32_5 = utils.sum32_5;
      var ch32 = shaCommon.ch32;
      var maj32 = shaCommon.maj32;
      var s0_256 = shaCommon.s0_256;
      var s1_256 = shaCommon.s1_256;
      var g0_256 = shaCommon.g0_256;
      var g1_256 = shaCommon.g1_256;
      var BlockHash = common.BlockHash;
      var sha256_K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
      function SHA256() {
        if (!(this instanceof SHA256))
          return new SHA256();
        BlockHash.call(this);
        this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225];
        this.k = sha256_K;
        this.W = new Array(64);
      }
      utils.inherits(SHA256, BlockHash);
      module2.exports = SHA256;
      SHA256.blockSize = 512;
      SHA256.outSize = 256;
      SHA256.hmacStrength = 192;
      SHA256.padLength = 64;
      SHA256.prototype._update = function _update(msg, start) {
        var W = this.W;
        for (var i = 0; i < 16; i++) {
          W[i] = msg[start + i];
        }
        for (; i < W.length; i++) {
          W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
        }
        var a = this.h[0];
        var b = this.h[1];
        var c = this.h[2];
        var d = this.h[3];
        var e = this.h[4];
        var f = this.h[5];
        var g = this.h[6];
        var h = this.h[7];
        assert(this.k.length === W.length);
        for (i = 0; i < W.length; i++) {
          var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
          var T2 = sum32(s0_256(a), maj32(a, b, c));
          h = g;
          g = f;
          f = e;
          e = sum32(d, T1);
          d = c;
          c = b;
          b = a;
          a = sum32(T1, T2);
        }
        this.h[0] = sum32(this.h[0], a);
        this.h[1] = sum32(this.h[1], b);
        this.h[2] = sum32(this.h[2], c);
        this.h[3] = sum32(this.h[3], d);
        this.h[4] = sum32(this.h[4], e);
        this.h[5] = sum32(this.h[5], f);
        this.h[6] = sum32(this.h[6], g);
        this.h[7] = sum32(this.h[7], h);
      };
      SHA256.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
    }, { "../common": 212, "../utils": 222, "./common": 221, "minimalistic-assert": 302 }], 219: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var SHA512 = require2("./512");
      function SHA384() {
        if (!(this instanceof SHA384))
          return new SHA384();
        SHA512.call(this);
        this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
      }
      utils.inherits(SHA384, SHA512);
      module2.exports = SHA384;
      SHA384.blockSize = 1024;
      SHA384.outSize = 384;
      SHA384.hmacStrength = 192;
      SHA384.padLength = 128;
      SHA384.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h.slice(0, 12), "big");
        else
          return utils.split32(this.h.slice(0, 12), "big");
      };
    }, { "../utils": 222, "./512": 220 }], 220: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var common = require2("../common");
      var assert = require2("minimalistic-assert");
      var rotr64_hi = utils.rotr64_hi;
      var rotr64_lo = utils.rotr64_lo;
      var shr64_hi = utils.shr64_hi;
      var shr64_lo = utils.shr64_lo;
      var sum64 = utils.sum64;
      var sum64_hi = utils.sum64_hi;
      var sum64_lo = utils.sum64_lo;
      var sum64_4_hi = utils.sum64_4_hi;
      var sum64_4_lo = utils.sum64_4_lo;
      var sum64_5_hi = utils.sum64_5_hi;
      var sum64_5_lo = utils.sum64_5_lo;
      var BlockHash = common.BlockHash;
      var sha512_K = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
      function SHA512() {
        if (!(this instanceof SHA512))
          return new SHA512();
        BlockHash.call(this);
        this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209];
        this.k = sha512_K;
        this.W = new Array(160);
      }
      utils.inherits(SHA512, BlockHash);
      module2.exports = SHA512;
      SHA512.blockSize = 1024;
      SHA512.outSize = 512;
      SHA512.hmacStrength = 192;
      SHA512.padLength = 128;
      SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
        var W = this.W;
        for (var i = 0; i < 32; i++) {
          W[i] = msg[start + i];
        }
        for (; i < W.length; i += 2) {
          var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
          var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
          var c1_hi = W[i - 14];
          var c1_lo = W[i - 13];
          var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
          var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
          var c3_hi = W[i - 32];
          var c3_lo = W[i - 31];
          W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
          W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
        }
      };
      SHA512.prototype._update = function _update(msg, start) {
        this._prepareBlock(msg, start);
        var W = this.W;
        var ah = this.h[0];
        var al = this.h[1];
        var bh = this.h[2];
        var bl = this.h[3];
        var ch = this.h[4];
        var cl = this.h[5];
        var dh = this.h[6];
        var dl = this.h[7];
        var eh = this.h[8];
        var el = this.h[9];
        var fh = this.h[10];
        var fl = this.h[11];
        var gh = this.h[12];
        var gl = this.h[13];
        var hh = this.h[14];
        var hl = this.h[15];
        assert(this.k.length === W.length);
        for (var i = 0; i < W.length; i += 2) {
          var c0_hi = hh;
          var c0_lo = hl;
          var c1_hi = s1_512_hi(eh, el);
          var c1_lo = s1_512_lo(eh, el);
          var c2_hi = ch64_hi(eh, el, fh, fl, gh);
          var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
          var c3_hi = this.k[i];
          var c3_lo = this.k[i + 1];
          var c4_hi = W[i];
          var c4_lo = W[i + 1];
          var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
          var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
          c0_hi = s0_512_hi(ah, al);
          c0_lo = s0_512_lo(ah, al);
          c1_hi = maj64_hi(ah, al, bh, bl, ch);
          c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
          var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
          var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
          hh = gh;
          hl = gl;
          gh = fh;
          gl = fl;
          fh = eh;
          fl = el;
          eh = sum64_hi(dh, dl, T1_hi, T1_lo);
          el = sum64_lo(dl, dl, T1_hi, T1_lo);
          dh = ch;
          dl = cl;
          ch = bh;
          cl = bl;
          bh = ah;
          bl = al;
          ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
          al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
        }
        sum64(this.h, 0, ah, al);
        sum64(this.h, 2, bh, bl);
        sum64(this.h, 4, ch, cl);
        sum64(this.h, 6, dh, dl);
        sum64(this.h, 8, eh, el);
        sum64(this.h, 10, fh, fl);
        sum64(this.h, 12, gh, gl);
        sum64(this.h, 14, hh, hl);
      };
      SHA512.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
      function ch64_hi(xh, xl, yh, yl, zh) {
        var r = xh & yh ^ ~xh & zh;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function ch64_lo(xh, xl, yh, yl, zh, zl) {
        var r = xl & yl ^ ~xl & zl;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function maj64_hi(xh, xl, yh, yl, zh) {
        var r = xh & yh ^ xh & zh ^ yh & zh;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function maj64_lo(xh, xl, yh, yl, zh, zl) {
        var r = xl & yl ^ xl & zl ^ yl & zl;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 28);
        var c1_hi = rotr64_hi(xl, xh, 2);
        var c2_hi = rotr64_hi(xl, xh, 7);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 28);
        var c1_lo = rotr64_lo(xl, xh, 2);
        var c2_lo = rotr64_lo(xl, xh, 7);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 14);
        var c1_hi = rotr64_hi(xh, xl, 18);
        var c2_hi = rotr64_hi(xl, xh, 9);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 14);
        var c1_lo = rotr64_lo(xh, xl, 18);
        var c2_lo = rotr64_lo(xl, xh, 9);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 1);
        var c1_hi = rotr64_hi(xh, xl, 8);
        var c2_hi = shr64_hi(xh, xl, 7);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 1);
        var c1_lo = rotr64_lo(xh, xl, 8);
        var c2_lo = shr64_lo(xh, xl, 7);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 19);
        var c1_hi = rotr64_hi(xl, xh, 29);
        var c2_hi = shr64_hi(xh, xl, 6);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 19);
        var c1_lo = rotr64_lo(xl, xh, 29);
        var c2_lo = shr64_lo(xh, xl, 6);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
    }, { "../common": 212, "../utils": 222, "minimalistic-assert": 302 }], 221: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var rotr32 = utils.rotr32;
      function ft_1(s, x, y, z) {
        if (s === 0)
          return ch32(x, y, z);
        if (s === 1 || s === 3)
          return p32(x, y, z);
        if (s === 2)
          return maj32(x, y, z);
      }
      exports2.ft_1 = ft_1;
      function ch32(x, y, z) {
        return x & y ^ ~x & z;
      }
      exports2.ch32 = ch32;
      function maj32(x, y, z) {
        return x & y ^ x & z ^ y & z;
      }
      exports2.maj32 = maj32;
      function p32(x, y, z) {
        return x ^ y ^ z;
      }
      exports2.p32 = p32;
      function s0_256(x) {
        return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
      }
      exports2.s0_256 = s0_256;
      function s1_256(x) {
        return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
      }
      exports2.s1_256 = s1_256;
      function g0_256(x) {
        return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
      }
      exports2.g0_256 = g0_256;
      function g1_256(x) {
        return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
      }
      exports2.g1_256 = g1_256;
    }, { "../utils": 222 }], 222: [function(require2, module2, exports2) {
      var assert = require2("minimalistic-assert");
      var inherits = require2("inherits");
      exports2.inherits = inherits;
      function isSurrogatePair(msg, i) {
        if ((msg.charCodeAt(i) & 64512) !== 55296) {
          return false;
        }
        if (i < 0 || i + 1 >= msg.length) {
          return false;
        }
        return (msg.charCodeAt(i + 1) & 64512) === 56320;
      }
      function toArray(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg === "string") {
          if (!enc) {
            var p = 0;
            for (var i = 0; i < msg.length; i++) {
              var c = msg.charCodeAt(i);
              if (c < 128) {
                res[p++] = c;
              } else if (c < 2048) {
                res[p++] = c >> 6 | 192;
                res[p++] = c & 63 | 128;
              } else if (isSurrogatePair(msg, i)) {
                c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
                res[p++] = c >> 18 | 240;
                res[p++] = c >> 12 & 63 | 128;
                res[p++] = c >> 6 & 63 | 128;
                res[p++] = c & 63 | 128;
              } else {
                res[p++] = c >> 12 | 224;
                res[p++] = c >> 6 & 63 | 128;
                res[p++] = c & 63 | 128;
              }
            }
          } else if (enc === "hex") {
            msg = msg.replace(/[^a-z0-9]+/ig, "");
            if (msg.length % 2 !== 0)
              msg = "0" + msg;
            for (i = 0; i < msg.length; i += 2) {
              res.push(parseInt(msg[i] + msg[i + 1], 16));
            }
          }
        } else {
          for (i = 0; i < msg.length; i++) {
            res[i] = msg[i] | 0;
          }
        }
        return res;
      }
      exports2.toArray = toArray;
      function toHex(msg) {
        var res = "";
        for (var i = 0; i < msg.length; i++) {
          res += zero2(msg[i].toString(16));
        }
        return res;
      }
      exports2.toHex = toHex;
      function htonl(w) {
        var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
        return res >>> 0;
      }
      exports2.htonl = htonl;
      function toHex32(msg, endian) {
        var res = "";
        for (var i = 0; i < msg.length; i++) {
          var w = msg[i];
          if (endian === "little")
            w = htonl(w);
          res += zero8(w.toString(16));
        }
        return res;
      }
      exports2.toHex32 = toHex32;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      exports2.zero2 = zero2;
      function zero8(word) {
        if (word.length === 7)
          return "0" + word;
        else if (word.length === 6)
          return "00" + word;
        else if (word.length === 5)
          return "000" + word;
        else if (word.length === 4)
          return "0000" + word;
        else if (word.length === 3)
          return "00000" + word;
        else if (word.length === 2)
          return "000000" + word;
        else if (word.length === 1)
          return "0000000" + word;
        else
          return word;
      }
      exports2.zero8 = zero8;
      function join32(msg, start, end, endian) {
        var len = end - start;
        assert(len % 4 === 0);
        var res = new Array(len / 4);
        for (var i = 0, k = start; i < res.length; i++, k += 4) {
          var w;
          if (endian === "big")
            w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
          else
            w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
          res[i] = w >>> 0;
        }
        return res;
      }
      exports2.join32 = join32;
      function split32(msg, endian) {
        var res = new Array(msg.length * 4);
        for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
          var m = msg[i];
          if (endian === "big") {
            res[k] = m >>> 24;
            res[k + 1] = m >>> 16 & 255;
            res[k + 2] = m >>> 8 & 255;
            res[k + 3] = m & 255;
          } else {
            res[k + 3] = m >>> 24;
            res[k + 2] = m >>> 16 & 255;
            res[k + 1] = m >>> 8 & 255;
            res[k] = m & 255;
          }
        }
        return res;
      }
      exports2.split32 = split32;
      function rotr32(w, b) {
        return w >>> b | w << 32 - b;
      }
      exports2.rotr32 = rotr32;
      function rotl32(w, b) {
        return w << b | w >>> 32 - b;
      }
      exports2.rotl32 = rotl32;
      function sum32(a, b) {
        return a + b >>> 0;
      }
      exports2.sum32 = sum32;
      function sum32_3(a, b, c) {
        return a + b + c >>> 0;
      }
      exports2.sum32_3 = sum32_3;
      function sum32_4(a, b, c, d) {
        return a + b + c + d >>> 0;
      }
      exports2.sum32_4 = sum32_4;
      function sum32_5(a, b, c, d, e) {
        return a + b + c + d + e >>> 0;
      }
      exports2.sum32_5 = sum32_5;
      function sum64(buf, pos, ah, al) {
        var bh = buf[pos];
        var bl = buf[pos + 1];
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        buf[pos] = hi >>> 0;
        buf[pos + 1] = lo;
      }
      exports2.sum64 = sum64;
      function sum64_hi(ah, al, bh, bl) {
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        return hi >>> 0;
      }
      exports2.sum64_hi = sum64_hi;
      function sum64_lo(ah, al, bh, bl) {
        var lo = al + bl;
        return lo >>> 0;
      }
      exports2.sum64_lo = sum64_lo;
      function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        var hi = ah + bh + ch + dh + carry;
        return hi >>> 0;
      }
      exports2.sum64_4_hi = sum64_4_hi;
      function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
        var lo = al + bl + cl + dl;
        return lo >>> 0;
      }
      exports2.sum64_4_lo = sum64_4_lo;
      function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        lo = lo + el >>> 0;
        carry += lo < el ? 1 : 0;
        var hi = ah + bh + ch + dh + eh + carry;
        return hi >>> 0;
      }
      exports2.sum64_5_hi = sum64_5_hi;
      function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var lo = al + bl + cl + dl + el;
        return lo >>> 0;
      }
      exports2.sum64_5_lo = sum64_5_lo;
      function rotr64_hi(ah, al, num) {
        var r = al << 32 - num | ah >>> num;
        return r >>> 0;
      }
      exports2.rotr64_hi = rotr64_hi;
      function rotr64_lo(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
      }
      exports2.rotr64_lo = rotr64_lo;
      function shr64_hi(ah, al, num) {
        return ah >>> num;
      }
      exports2.shr64_hi = shr64_hi;
      function shr64_lo(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
      }
      exports2.shr64_lo = shr64_lo;
    }, { "inherits": 256, "minimalistic-assert": 302 }], 223: [function(require2, module2, exports2) {
      var {
        sodium_malloc,
        sodium_memzero
      } = require2("sodium-universal/memory");
      var {
        crypto_generichash,
        crypto_generichash_batch
      } = require2("sodium-universal/crypto_generichash");
      var assert = require2("nanoassert");
      var HASHLEN = 64;
      var BLOCKLEN = 128;
      var scratch = sodium_malloc(BLOCKLEN * 3);
      var HMACKey = scratch.subarray(BLOCKLEN * 0, BLOCKLEN * 1);
      var OuterKeyPad = scratch.subarray(BLOCKLEN * 1, BLOCKLEN * 2);
      var InnerKeyPad = scratch.subarray(BLOCKLEN * 2, BLOCKLEN * 3);
      module2.exports = function hmac(out, data, key) {
        assert(out.byteLength === HASHLEN);
        assert(key.byteLength != null);
        assert(Array.isArray(data) ? data.every((d) => d.byteLength != null) : data.byteLength != null);
        if (key.byteLength > BLOCKLEN) {
          crypto_generichash(HMACKey.subarray(0, HASHLEN), key);
          sodium_memzero(HMACKey.subarray(HASHLEN));
        } else {
          HMACKey.set(key);
          sodium_memzero(HMACKey.subarray(key.byteLength));
        }
        for (var i = 0; i < HMACKey.byteLength; i++) {
          OuterKeyPad[i] = 92 ^ HMACKey[i];
          InnerKeyPad[i] = 54 ^ HMACKey[i];
        }
        sodium_memzero(HMACKey);
        crypto_generichash_batch(out, [InnerKeyPad].concat(data));
        sodium_memzero(InnerKeyPad);
        crypto_generichash_batch(out, [OuterKeyPad].concat(out));
        sodium_memzero(OuterKeyPad);
      };
      module2.exports.BYTES = HASHLEN;
      module2.exports.KEYBYTES = BLOCKLEN;
    }, { "nanoassert": 224, "sodium-universal/crypto_generichash": 460, "sodium-universal/memory": 477 }], 224: [function(require2, module2, exports2) {
      arguments[4][48][0].apply(exports2, arguments);
    }, { "dup": 48 }], 225: [function(require2, module2, exports2) {
      var hash = require2("hash.js");
      var utils = require2("minimalistic-crypto-utils");
      var assert = require2("minimalistic-assert");
      function HmacDRBG(options) {
        if (!(this instanceof HmacDRBG))
          return new HmacDRBG(options);
        this.hash = options.hash;
        this.predResist = !!options.predResist;
        this.outLen = this.hash.outSize;
        this.minEntropy = options.minEntropy || this.hash.hmacStrength;
        this._reseed = null;
        this.reseedInterval = null;
        this.K = null;
        this.V = null;
        var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
        var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
        var pers = utils.toArray(options.pers, options.persEnc || "hex");
        assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
        this._init(entropy, nonce, pers);
      }
      module2.exports = HmacDRBG;
      HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
        var seed = entropy.concat(nonce).concat(pers);
        this.K = new Array(this.outLen / 8);
        this.V = new Array(this.outLen / 8);
        for (var i = 0; i < this.V.length; i++) {
          this.K[i] = 0;
          this.V[i] = 1;
        }
        this._update(seed);
        this._reseed = 1;
        this.reseedInterval = 281474976710656;
      };
      HmacDRBG.prototype._hmac = function hmac() {
        return new hash.hmac(this.hash, this.K);
      };
      HmacDRBG.prototype._update = function update(seed) {
        var kmac = this._hmac().update(this.V).update([0]);
        if (seed)
          kmac = kmac.update(seed);
        this.K = kmac.digest();
        this.V = this._hmac().update(this.V).digest();
        if (!seed)
          return;
        this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
        this.V = this._hmac().update(this.V).digest();
      };
      HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
        if (typeof entropyEnc !== "string") {
          addEnc = add;
          add = entropyEnc;
          entropyEnc = null;
        }
        entropy = utils.toArray(entropy, entropyEnc);
        add = utils.toArray(add, addEnc);
        assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
        this._update(entropy.concat(add || []));
        this._reseed = 1;
      };
      HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
        if (this._reseed > this.reseedInterval)
          throw new Error("Reseed is required");
        if (typeof enc !== "string") {
          addEnc = add;
          add = enc;
          enc = null;
        }
        if (add) {
          add = utils.toArray(add, addEnc || "hex");
          this._update(add);
        }
        var temp = [];
        while (temp.length < len) {
          this.V = this._hmac().update(this.V).digest();
          temp = temp.concat(this.V);
        }
        var res = temp.slice(0, len);
        this._update(add);
        this._reseed++;
        return utils.encode(res, enc);
      };
    }, { "hash.js": 211, "minimalistic-assert": 302, "minimalistic-crypto-utils": 303 }], 226: [function(require2, module2, exports2) {
      var DEFAULT_MAX_BYTE_SIZE = 1024 * 1024 * 16;
      class NamespacedCache {
        constructor(parent, name) {
          this.name = name;
          this.parent = parent;
        }
        get _info() {
          return this.parent._info;
        }
        set(key, value) {
          return this.parent._set(this.name, key, value);
        }
        del(key) {
          return this.parent._del(this.name, key);
        }
        get(key) {
          return this.parent._get(this.name, key);
        }
      }
      module2.exports = class HypercoreCache {
        constructor() {
          var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          this.maxByteSize = opts.maxByteSize || DEFAULT_MAX_BYTE_SIZE;
          this.onEvict = opts.onEvict;
          this.estimateSize = opts.estimateSize || defaultSize;
          this._nextNamespace = 0;
          this.defaultCache = new NamespacedCache(this, this._nextNamespace++);
          this._stale = null;
          this._fresh = /* @__PURE__ */ new Map();
          this._freshByteSize = 0;
          this._staleByteSize = 0;
        }
        get _info() {
          return {
            freshByteSize: this._freshByteSize,
            staleByteSize: this._staleByteSize,
            staleEntries: this._stale ? this._stale.size : 0,
            freshEntries: this._fresh.size,
            byteSize: this.byteSize
          };
        }
        _prefix(namespace, key) {
          return namespace + ":" + key;
        }
        _gc() {
          if (this.onEvict && this._staleByteSize > 0)
            this.onEvict(this._stale);
          this._stale = this._fresh;
          this._fresh = /* @__PURE__ */ new Map();
          this._staleByteSize = this._freshByteSize;
          this._freshByteSize = 0;
        }
        _get(namespace, key, prefixedKey) {
          if (!prefixedKey)
            prefixedKey = this._prefix(namespace, key);
          return this._fresh.get(prefixedKey) || this._stale && this._stale.get(prefixedKey);
        }
        _set(namespace, key, value) {
          var valueSize = this.estimateSize(value);
          var prefixedKey = this._prefix(namespace, key);
          if (this._freshByteSize + valueSize > this.maxByteSize) {
            this._gc();
          }
          this._fresh.set(prefixedKey, value);
          this._freshByteSize += valueSize;
        }
        _del(namespace, key) {
          var prefixedKey = this._prefix(namespace, key);
          var val = this._stale && this._stale.get(prefixedKey);
          if (val) {
            this._stale.delete(prefixedKey);
            this._staleByteSize -= this.estimateSize(val);
          }
          val = this._fresh.get(prefixedKey);
          if (val) {
            this._fresh.delete(prefixedKey);
            this._freshByteSize -= this.estimateSize(val);
          }
        }
        get byteSize() {
          return this._freshByteSize + this._staleByteSize;
        }
        namespace() {
          var cache = new NamespacedCache(this, this._nextNamespace++);
          return cache;
        }
        set(key, value) {
          return this.defaultCache.set(key, value);
        }
        del(key) {
          return this.defaultCache.del(key);
        }
        get(key) {
          return this.defaultCache.get(key);
        }
      };
      function defaultSize() {
        return 1024;
      }
    }, {}], 227: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var sodium = require2("sodium-universal");
          var uint64be = require2("uint64be");
          var LEAF_TYPE = Buffer.from([0]);
          var PARENT_TYPE = Buffer.from([1]);
          var ROOT_TYPE = Buffer.from([2]);
          var CAP_TYPE = Buffer.from([3]);
          var HYPERCORE = Buffer.from("hypercore");
          var HYPERCORE_CAP = Buffer.from("hypercore capability");
          exports2.writerCapability = function(key, secretKey, split) {
            if (!split)
              return null;
            var out = Buffer.allocUnsafe(32);
            sodium.crypto_generichash_batch(out, [CAP_TYPE, HYPERCORE_CAP, split.tx.slice(0, 32), key], split.rx.slice(0, 32));
            return exports2.sign(out, secretKey);
          };
          exports2.verifyRemoteWriterCapability = function(key, cap, split) {
            if (!split)
              return null;
            var out = Buffer.allocUnsafe(32);
            sodium.crypto_generichash_batch(out, [CAP_TYPE, HYPERCORE_CAP, split.rx.slice(0, 32), key], split.tx.slice(0, 32));
            return exports2.verify(out, cap, key);
          };
          exports2.capability = function(key, split) {
            if (!split)
              return null;
            var out = Buffer.allocUnsafe(32);
            sodium.crypto_generichash_batch(out, [HYPERCORE_CAP, split.tx.slice(0, 32), key], split.rx.slice(0, 32));
            return out;
          };
          exports2.remoteCapability = function(key, split) {
            if (!split)
              return null;
            var out = Buffer.allocUnsafe(32);
            sodium.crypto_generichash_batch(out, [HYPERCORE_CAP, split.rx.slice(0, 32), key], split.tx.slice(0, 32));
            return out;
          };
          exports2.keyPair = function(seed) {
            var publicKey = Buffer.allocUnsafe(sodium.crypto_sign_PUBLICKEYBYTES);
            var secretKey = Buffer.allocUnsafe(sodium.crypto_sign_SECRETKEYBYTES);
            if (seed)
              sodium.crypto_sign_seed_keypair(publicKey, secretKey, seed);
            else
              sodium.crypto_sign_keypair(publicKey, secretKey);
            return {
              publicKey,
              secretKey
            };
          };
          exports2.sign = function(message, secretKey) {
            var signature = Buffer.allocUnsafe(sodium.crypto_sign_BYTES);
            sodium.crypto_sign_detached(signature, message, secretKey);
            return signature;
          };
          exports2.verify = function(message, signature, publicKey) {
            return sodium.crypto_sign_verify_detached(signature, message, publicKey);
          };
          exports2.data = function(data) {
            var out = Buffer.allocUnsafe(32);
            sodium.crypto_generichash_batch(out, [LEAF_TYPE, encodeUInt64(data.length), data]);
            return out;
          };
          exports2.leaf = function(leaf) {
            return exports2.data(leaf.data);
          };
          exports2.parent = function(a, b) {
            if (a.index > b.index) {
              var tmp = a;
              a = b;
              b = tmp;
            }
            var out = Buffer.allocUnsafe(32);
            sodium.crypto_generichash_batch(out, [PARENT_TYPE, encodeUInt64(a.size + b.size), a.hash, b.hash]);
            return out;
          };
          exports2.tree = function(roots, out) {
            var buffers = new Array(3 * roots.length + 1);
            var j = 0;
            buffers[j++] = ROOT_TYPE;
            for (var i = 0; i < roots.length; i++) {
              var r = roots[i];
              buffers[j++] = r.hash;
              buffers[j++] = encodeUInt64(r.index);
              buffers[j++] = encodeUInt64(r.size);
            }
            if (!out)
              out = Buffer.allocUnsafe(32);
            sodium.crypto_generichash_batch(out, buffers);
            return out;
          };
          exports2.signable = function(roots, length) {
            var out = Buffer.allocUnsafe(40);
            if (Buffer.isBuffer(roots))
              roots.copy(out);
            else
              exports2.tree(roots, out.slice(0, 32));
            uint64be.encode(length, out.slice(32));
            return out;
          };
          exports2.randomBytes = function(n) {
            var buf = Buffer.allocUnsafe(n);
            sodium.randombytes_buf(buf);
            return buf;
          };
          exports2.discoveryKey = function(publicKey) {
            var digest = Buffer.allocUnsafe(32);
            sodium.crypto_generichash(digest, HYPERCORE, publicKey);
            return digest;
          };
          if (sodium.sodium_free) {
            exports2.free = function(secureBuf) {
              if (secureBuf.secure)
                sodium.sodium_free(secureBuf);
            };
          } else {
            exports2.free = function() {
            };
          }
          function encodeUInt64(n) {
            return uint64be.encode(n, Buffer.allocUnsafe(8));
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82, "sodium-universal": 474, "uint64be": 508 }], 228: [function(require2, module2, exports2) {
      var SHP = require2("simple-hypercore-protocol");
      var crypto = require2("hypercore-crypto");
      var timeout = require2("timeout-refresh");
      var inspect = require2("inspect-custom-symbol");
      var Nanoguard = require2("nanoguard");
      var pretty = require2("pretty-hash");
      var Message = require2("abstract-extension");
      var {
        Duplex
      } = require2("streamx");
      var debug = require2("debug")("hypercore-protocol");
      class StreamExtension extends Message {
        send(message) {
          var stream = this.local.handlers;
          if (stream._changes !== this.local.changes) {
            stream._changes = this.local.changes;
            stream.state.options(0, {
              extensions: this.local.names()
            });
          }
          return stream.state.extension(0, this.id, this.encode(message));
        }
      }
      class Channelizer {
        constructor(stream, _ref) {
          var {
            encrypted,
            noise,
            keyPair
          } = _ref;
          this.stream = stream;
          this.created = /* @__PURE__ */ new Map();
          this.local = [null];
          this.remote = [null];
          this.noise = !(noise === false && encrypted === false);
          this.encrypted = encrypted !== false;
          this.keyPair = keyPair;
        }
        allocLocal() {
          var id = this.local.indexOf(null);
          if (id > 0)
            return id;
          this.local.push(null);
          return this.local.length - 1;
        }
        attachLocal(ch) {
          var id = this.allocLocal();
          this.local[id] = ch;
          ch.localId = id;
        }
        attachRemote(ch, id) {
          if (this.remote.length === id)
            this.remote.push(null);
          this.remote[id] = ch;
          ch.remoteId = id;
        }
        detachChannel(ch) {
          if (ch.localId > -1 && this.local[ch.localId] === ch) {
            this.local[ch.localId] = null;
            ch.localId = -1;
            if (ch.handlers && ch.handlers.onclose)
              ch.handlers.onclose();
          }
          if (ch.remoteId > -1 && this.remote[ch.remoteId] === ch) {
            this.remote[ch.remoteId] = null;
          }
          var hex = ch.discoveryKey.toString("hex");
          if (this.created.get(hex) === ch)
            this.created.delete(hex);
        }
        getChannel(dk) {
          return this.created.get(dk.toString("hex"));
        }
        createChannel(dk) {
          var hex = dk.toString("hex");
          var old = this.created.get(hex);
          if (old)
            return old;
          var fresh = new Channel(this.stream.state, this.stream, dk);
          this.created.set(hex, fresh);
          return fresh;
        }
        onauthenticate(key, done) {
          if (this.stream.handlers && this.stream.handlers.onauthenticate)
            this.stream.handlers.onauthenticate(key, done);
          else
            done(null);
        }
        onhandshake() {
          debug("recv handshake");
          if (this.stream.handlers && this.stream.handlers.onhandshake)
            this.stream.handlers.onhandshake();
          this.stream.emit("handshake");
        }
        onopen(channelId, message) {
          debug("recv open", channelId, message);
          var ch = this.createChannel(message.discoveryKey);
          ch.remoteCapability = message.capability;
          this.attachRemote(ch, channelId);
          if (ch.localId === -1) {
            if (this.stream.handlers.ondiscoverykey)
              this.stream.handlers.ondiscoverykey(ch.discoveryKey);
            this.stream.emit("discovery-key", ch.discoveryKey);
          } else {
            if (this.noise && !ch.remoteVerified) {
              this.stream.destroy(new Error("Invalid remote channel capability"));
              return;
            }
            this.stream.emit("duplex-channel", ch);
          }
          if (ch.handlers && ch.handlers.onopen)
            ch.handlers.onopen();
          if (this.stream.handlers.onremoteopen)
            this.stream.handlers.onremoteopen(ch.discoveryKey);
          this.stream.emit("remote-open", ch.discoveryKey);
        }
        onoptions(channelId, message) {
          debug("recv options", channelId, message);
          var ch = this.remote[channelId];
          if (ch && ch.handlers && ch.handlers.onoptions)
            ch.handlers.onoptions(message);
          else if (channelId === 0 && !ch)
            this.stream._updateExtensions(message.extensions);
        }
        onstatus(channelId, message) {
          debug("recv status", channelId, message);
          var ch = this.remote[channelId];
          if (ch && ch.handlers && ch.handlers.onstatus)
            ch.handlers.onstatus(message);
        }
        onhave(channelId, message) {
          debug("recv have", channelId, message);
          var ch = this.remote[channelId];
          if (ch && ch.handlers && ch.handlers.onhave)
            ch.handlers.onhave(message);
        }
        onunhave(channelId, message) {
          debug("recv unhave", channelId, message);
          var ch = this.remote[channelId];
          if (ch && ch.handlers && ch.handlers.onunhave)
            ch.handlers.onunhave(message);
        }
        onwant(channelId, message) {
          debug("recv want", channelId, message);
          var ch = this.remote[channelId];
          if (ch && ch.handlers && ch.handlers.onwant)
            ch.handlers.onwant(message);
        }
        onunwant(channelId, message) {
          debug("recv unwant", channelId, message);
          var ch = this.remote[channelId];
          if (ch && ch.handlers && ch.handlers.onunwant)
            ch.handlers.onunwant(message);
        }
        onrequest(channelId, message) {
          debug("recv request", channelId, message);
          var ch = this.remote[channelId];
          if (ch && ch.handlers && ch.handlers.onrequest)
            ch.handlers.onrequest(message);
        }
        oncancel(channelId, message) {
          debug("recv cancel", channelId, message);
          var ch = this.remote[channelId];
          if (ch && ch.handlers && ch.handlers.oncancel)
            ch.handlers.oncancel(message);
        }
        ondata(channelId, message) {
          debug("recv data", channelId, message);
          var ch = this.remote[channelId];
          if (ch && ch.handlers && ch.handlers.ondata)
            ch.handlers.ondata(message);
        }
        onextension(channelId, id, buf) {
          debug("recv extension", channelId, id);
          var ch = this.remote[channelId];
          if (ch && ch.handlers && ch.handlers.onextension)
            ch.handlers.onextension(id, buf);
          else if (channelId === 0 && !ch)
            this.stream.remoteExtensions.onmessage(id, buf);
        }
        onclose(channelId, message) {
          debug("recv close", channelId, message);
          var ch = channelId < this.remote.length ? this.remote[channelId] : null;
          if (ch) {
            this.remote[channelId] = null;
          } else if (message.discoveryKey) {
            ch = this.getChannel(message.discoveryKey);
          }
          if (!ch)
            return;
          if (ch.localId > -1 && this.local[ch.localId] === ch) {
            this.local[ch.localId] = null;
            ch.state.close(ch.localId, {});
            ch.localId = -1;
            if (ch.handlers && ch.handlers.onclose)
              ch.handlers.onclose();
          }
          if (this.stream.handlers && this.stream.handlers.onchannelclose) {
            this.stream.handlers.onchannelclose(ch.discoveryKey, ch.key);
          }
          var hex = ch.discoveryKey.toString("hex");
          if (this.created.get(hex) === ch)
            this.created.delete(hex);
          this.stream._prefinalize();
        }
        onmissing(bytes) {
          if (this.stream._utp === null)
            return;
          this.stream._utp.setContentSize(bytes);
        }
        send(data) {
          if (this.stream.keepAlive !== null)
            this.stream.keepAlive.refresh();
          this.stream.bytesSent += data.length;
          return this.stream.push(data);
        }
        destroy(err) {
          this.stream.destroy(err);
          this.local = [];
          this.remote = [];
          for (var ch of this.created.values()) {
            var closed = ch.localId === -1;
            ch.localId = ch.remoteId = -1;
            if (!closed && ch.handlers && ch.handlers.onclose)
              ch.handlers.onclose();
            if (this.stream.handlers && this.stream.handlers.onchannelclose) {
              this.stream.handlers.onchannelclose(ch.discoveryKey, ch.key);
            }
          }
          this.created.clear();
        }
      }
      class Channel {
        constructor(state, stream, dk) {
          this.key = null;
          this.discoveryKey = dk;
          this.localId = -1;
          this.remoteId = -1;
          this.remoteCapability = null;
          this.handlers = null;
          this.state = state;
          this.stream = stream;
        }
        get opened() {
          return this.localId > -1;
        }
        get closed() {
          return this.localId === -1;
        }
        get remoteOpened() {
          return this.remoteId > -1;
        }
        get remoteVerified() {
          return this.localId > -1 && this.remoteId > -1 && !!this.remoteCapability && this.remoteCapability.equals(this.state.remoteCapability(this.key));
        }
        options(message) {
          debug("send options", message);
          return this.state.options(this.localId, message);
        }
        status(message) {
          debug("send status", message);
          return this.state.status(this.localId, message);
        }
        have(message) {
          debug("send have", message);
          return this.state.have(this.localId, message);
        }
        unhave(message) {
          debug("send unhave", message);
          return this.state.unhave(this.localId, message);
        }
        want(message) {
          debug("send want", message);
          return this.state.want(this.localId, message);
        }
        unwant(message) {
          debug("send unwant", message);
          return this.state.unwant(this.localId, message);
        }
        request(message) {
          debug("send request", message);
          return this.state.request(this.localId, message);
        }
        cancel(message) {
          debug("send cancel", message);
          return this.state.cancel(this.localId, message);
        }
        data(message) {
          debug("send data", message);
          return this.state.data(this.localId, message);
        }
        extension(id, buf) {
          debug("send extension", id);
          return this.state.extension(this.localId, id, buf);
        }
        close() {
          debug("send close");
          if (this.closed)
            return;
          var localId = this.localId;
          this.stream.channelizer.detachChannel(this);
          this.state.close(localId, {});
          this.stream._prefinalize();
        }
        destroy(err) {
          this.stream.destroy(err);
        }
      }
      module2.exports = class ProtocolStream extends Duplex {
        constructor(initiator) {
          var handlers = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          super();
          if (typeof initiator !== "boolean")
            throw new Error("Must specify initiator boolean in replication stream");
          this.initiator = initiator;
          this.handlers = handlers;
          this.channelizer = new Channelizer(this, {
            encrypted: handlers.encrypted,
            noise: handlers.noise,
            keyPair: handlers.keyPair
          });
          this.state = new SHP(initiator, this.channelizer);
          this.live = !!handlers.live;
          this.timeout = null;
          this.keepAlive = null;
          this.prefinalize = new Nanoguard();
          this.bytesSent = 0;
          this.bytesReceived = 0;
          this.extensions = StreamExtension.createLocal(this);
          this.remoteExtensions = this.extensions.remote();
          this._utp = null;
          this._changes = 0;
          this.once("finish", this.push.bind(this, null));
          this.on("pipe", this._onpipe);
          if (handlers.timeout !== false && handlers.timeout !== 0) {
            var _timeout = handlers.timeout || 2e4;
            this.setTimeout(_timeout, () => this.destroy(new Error("ETIMEDOUT")));
            this.setKeepAlive(Math.ceil(_timeout / 2));
          }
        }
        registerExtension(name, handlers) {
          return this.extensions.add(name, handlers);
        }
        [inspect](depth, opts) {
          var indent = "";
          if (typeof opts.indentationLvl === "number") {
            while (indent.length < opts.indentationLvl) {
              indent += " ";
            }
          }
          return "HypercoreProtocolStream(\n" + indent + "  publicKey: " + opts.stylize(this.publicKey && pretty(this.publicKey), "string") + "\n" + indent + "  remotePublicKey: " + opts.stylize(this.remotePublicKey && pretty(this.remotePublicKey), "string") + "\n" + indent + "  remoteAddress: " + opts.stylize(this.remoteAddress, "string") + "\n" + indent + "  remoteType: " + opts.stylize(this.remoteType, "string") + "\n" + indent + "  live: " + opts.stylize(this.live, "boolean") + "\n" + indent + "  initiator: " + opts.stylize(this.initiator, "boolean") + "\n" + indent + "  channelCount: " + opts.stylize(this.channelCount, "number") + "\n" + indent + "  destroyed: " + opts.stylize(this.destroyed, "boolean") + "\n" + indent + "  prefinalized: " + opts.stylize(!this.prefinalize.waiting, "boolean") + "\n" + indent + "  bytesSent: " + opts.stylize(this.bytesSent, "number") + "\n" + indent + "  bytesReceived: " + opts.stylize(this.bytesReceived, "number") + "\n" + indent + ")";
        }
        static isProtocolStream(s) {
          return !!(s && typeof s.initiator === "boolean" && typeof s.pipe === "function" && s.state);
        }
        static keyPair(seed) {
          return SHP.keyPair(seed);
        }
        get remoteAddress() {
          var to = this._readableState.pipeTo;
          if (!to)
            return null;
          if (ProtocolStream.isProtocolStream(to))
            return null;
          return to.remoteAddress;
        }
        get remoteType() {
          var to = this._readableState.pipeTo;
          if (!to)
            return null;
          if (to._utp)
            return "utp";
          if (to.remoteAddress)
            return "tcp";
          return "unknown";
        }
        get publicKey() {
          return this.state.publicKey;
        }
        get remotePublicKey() {
          return this.state.remotePublicKey;
        }
        _onpipe(dest) {
          if (typeof dest.setContentSize === "function")
            this._utp = dest;
        }
        _write(data, cb) {
          if (this.timeout !== null)
            this.timeout.refresh();
          this.bytesReceived += data.length;
          this.state.recv(data);
          cb(null);
        }
        _destroy(cb) {
          this._predestroy();
          this.channelizer.destroy();
          this.state.destroy();
          cb(null);
        }
        _predestroy() {
          if (this.timeout !== null) {
            this.timeout.destroy();
            this.timeout = null;
          }
          if (this.keepAlive !== null) {
            this.keepAlive.destroy();
            this.keepAlive = null;
          }
          this.prefinalize.destroy();
        }
        _prefinalize() {
          this.emit("prefinalize");
          this.prefinalize.ready(() => {
            if (this.destroyed)
              return;
            if (this.channelCount)
              return;
            if (this.live)
              return;
            this.finalize();
          });
        }
        _updateExtensions(names) {
          this.remoteExtensions.update(names);
          if (this.handlers.onextensions)
            this.handlers.onextensions(names);
          this.emit("extensions", names);
        }
        remoteOpened(key) {
          var ch = this.channelizer.getChannel(crypto.discoveryKey(key));
          return !!(ch && ch.remoteId > -1);
        }
        remoteVerified(key) {
          var ch = this.channelizer.getChannel(crypto.discoveryKey(key));
          return !!ch && !!ch.remoteCapability && ch.remoteCapability.equals(this.state.remoteCapability(key));
        }
        opened(key) {
          var ch = this.channelizer.getChannel(crypto.discoveryKey(key));
          return !!(ch && ch.localId > -1);
        }
        ping() {
          return this.state.ping();
        }
        setKeepAlive(ms) {
          if (this.keepAlive)
            this.keepAlive.destroy();
          if (!ms) {
            this.keepAlive = null;
            return;
          }
          this.keepAlive = timeout(ms, ping, this);
          function ping() {
            this.ping();
            this.keepAlive = timeout(ms, ping, this);
          }
        }
        setTimeout(ms, ontimeout) {
          if (this.timeout)
            this.timeout.destroy();
          if (!ms) {
            this.timeout = null;
            return;
          }
          this.timeout = timeout(ms, this.emit.bind(this, "timeout"));
          if (ontimeout)
            this.once("timeout", ontimeout);
        }
        get channelCount() {
          return this.channelizer.created.size;
        }
        get channels() {
          return this.channelizer.created.values();
        }
        open(key, handlers) {
          var discoveryKey = crypto.discoveryKey(key);
          var ch = this.channelizer.createChannel(discoveryKey);
          if (ch.key === null) {
            ch.key = key;
            this.channelizer.attachLocal(ch);
            this.state.open(ch.localId, {
              key,
              discoveryKey
            });
          }
          if (handlers)
            ch.handlers = handlers;
          if (ch.remoteId > -1)
            this.emit("duplex-channel", ch);
          return ch;
        }
        close(discoveryKey) {
          var ch = this.channelizer.getChannel(discoveryKey);
          if (ch && ch.localId > -1) {
            ch.close();
            return;
          }
          this.state.close(this.channelizer.allocLocal(), {
            discoveryKey
          });
        }
        finalize() {
          this.push(null);
        }
      };
    }, { "abstract-extension": 14, "debug": 119, "hypercore-crypto": 227, "inspect-custom-symbol": 257, "nanoguard": 311, "pretty-hash": 359, "simple-hypercore-protocol": 437, "streamx": 498, "timeout-refresh": 505 }], 229: [function(require2, module2, exports2) {
      var {
        Writable,
        Readable
      } = require2("streamx");
      class WriteStream extends Writable {
        constructor(feed, opts) {
          super();
          this.feed = feed;
          this.maxBlockSize = opts && opts.maxBlockSize || 0;
        }
        _writev(batch, cb) {
          this.feed.append(this.maxBlockSize ? this._ensureMaxSize(batch) : batch, cb);
        }
        _ensureMaxSize(batch) {
          for (var i = 0; i < batch.length; i++) {
            var blk = batch[i];
            if (blk.length > this.maxBlockSize) {
              var chunked = [];
              while (blk.length > this.maxBlockSize) {
                chunked.push(blk.slice(0, this.maxBlockSize));
                blk = blk.slice(this.maxBlockSize);
              }
              if (blk.length)
                chunked.push(blk);
              batch.splice(i, 1, ...chunked);
              i += chunked.length - 1;
            }
          }
          return batch;
        }
      }
      class ReadStream extends Readable {
        constructor(feed) {
          var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          super();
          this.feed = feed;
          this.start = opts.start || 0;
          this.end = typeof opts.end === "number" ? opts.end : -1;
          this.live = !!opts.live;
          this.snapshot = opts.snapshot !== false;
          this.tail = !!opts.tail;
          this.index = this.start;
          this.options = {
            wait: opts.wait !== false,
            ifAvailable: !!opts.ifAvailable,
            valueEncoding: opts.valueEncoding
          };
        }
        _open(cb) {
          this.feed.ready((err) => {
            if (err)
              return cb(err);
            if (this.end === -1) {
              if (this.live)
                this.end = Infinity;
              else if (this.snapshot)
                this.end = this.feed.length;
              if (this.start > this.end)
                this.push(null);
            }
            if (this.tail)
              this.start = this.feed.length;
            this.index = this.start;
            cb(null);
          });
        }
        _read(cb) {
          if (this.index === this.end || this.end === -1 && this.index >= this.feed.length) {
            this.push(null);
            return cb(null);
          }
          this.feed.get(this.index++, this.options, (err, block) => {
            if (err)
              return cb(err);
            this.push(block);
            cb(null);
          });
        }
      }
      module2.exports = {
        WriteStream,
        ReadStream
      };
    }, { "streamx": 498 }], 230: [function(require2, module2, exports2) {
      (function(process, Buffer) {
        (function() {
          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              if (enumerableOnly)
                symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
              keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              if (i % 2) {
                ownKeys(Object(source), true).forEach(function(key) {
                  _defineProperty(target, key, source[key]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys(Object(source)).forEach(function(key) {
                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
              }
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var low = require2("last-one-wins");
          var remove = require2("unordered-array-remove");
          var set = require2("unordered-set");
          var MerkleGenerator = require2("merkle-tree-stream/generator");
          var flat = require2("flat-tree");
          var codecs = require2("codecs");
          var batcher = require2("atomic-batcher");
          var inherits = require2("inherits");
          var raf = require2("random-access-file");
          var bitfield = require2("./lib/bitfield");
          var sparseBitfield = require2("sparse-bitfield");
          var treeIndex = require2("./lib/tree-index");
          var storage = require2("./lib/storage");
          var crypto = require2("hypercore-crypto");
          var inspect = require2("inspect-custom-symbol");
          var pretty = require2("pretty-hash");
          var Nanoguard = require2("nanoguard");
          var safeBufferEquals = require2("./lib/safe-buffer-equals");
          var replicate = require2("./lib/replicate");
          var Protocol = require2("hypercore-protocol");
          var Message = require2("abstract-extension");
          var Nanoresource = require2("nanoresource/emitter");
          var {
            WriteStream,
            ReadStream
          } = require2("hypercore-streams");
          class Extension extends Message {
            broadcast(message) {
              var feed = this.local.handlers;
              var buf = this.encoding.encode(message);
              for (var peer of feed.peers) {
                peer.extension(this.id, buf);
              }
            }
            send(message, peer) {
              peer.extension(this.id, this.encode(message));
            }
          }
          var defaultCrypto = {
            sign(data, sk, cb) {
              return cb(null, crypto.sign(data, sk));
            },
            verify(sig, data, pk, cb) {
              return cb(null, crypto.verify(sig, data, pk));
            }
          };
          module2.exports = Feed;
          function Feed(createStorage, key, opts) {
            if (!(this instanceof Feed))
              return new Feed(createStorage, key, opts);
            Nanoresource.call(this);
            if (typeof createStorage === "string")
              createStorage = defaultStorage(createStorage);
            if (typeof createStorage !== "function")
              throw new Error("Storage should be a function or string");
            if (typeof key === "string")
              key = Buffer.from(key, "hex");
            if (!Buffer.isBuffer(key) && !opts) {
              opts = key;
              key = null;
            }
            if (!opts)
              opts = {};
            var self2 = this;
            var secretKey = opts.secretKey || null;
            if (typeof secretKey === "string")
              secretKey = Buffer.from(secretKey, "hex");
            this.noiseKeyPair = opts.noiseKeyPair || Protocol.keyPair();
            this.live = opts.live !== false;
            this.sparse = !!opts.sparse;
            this.length = 0;
            this.byteLength = 0;
            this.maxRequests = opts.maxRequests || 16;
            this.key = key || opts.key || null;
            this.discoveryKey = this.key && crypto.discoveryKey(this.key);
            this.secretKey = secretKey;
            this.bitfield = null;
            this.tree = null;
            this.writable = !!opts.writable;
            this.readable = true;
            this.downloading = opts.downloading !== false;
            this.uploading = opts.uploading !== false;
            this.allowPush = !!opts.allowPush;
            this.peers = [];
            this.ifAvailable = new Nanoguard();
            this.extensions = Extension.createLocal(this);
            this.crypto = opts.crypto || defaultCrypto;
            this._onwrite = opts.onwrite || null;
            this._expectedLength = -1;
            this._indexing = !!opts.indexing;
            this._createIfMissing = opts.createIfMissing !== false;
            this._overwrite = !!opts.overwrite;
            this._storeSecretKey = opts.storeSecretKey !== false;
            this._alwaysIfAvailable = !!opts.ifAvailable;
            this._merkle = null;
            this._storage = storage(createStorage, opts);
            this._batch = batcher(this._onwrite ? workHook : work);
            this.timeouts = opts.timeouts || {
              get(cb) {
                cb(null);
              },
              update(cb) {
                cb(null);
              }
            };
            this._seq = 0;
            this._waiting = [];
            this._selections = [];
            this._reserved = sparseBitfield();
            this._synced = null;
            this._downloadingSet = typeof opts.downloading === "boolean";
            this._stats = typeof opts.stats !== "undefined" && !opts.stats ? null : {
              downloadedBlocks: 0,
              downloadedBytes: 0,
              uploadedBlocks: 0,
              uploadedBytes: 0
            };
            this._codec = toCodec(opts.valueEncoding);
            this._sync = low(sync);
            if (!this.sparse)
              this.download({
                start: 0,
                end: -1
              });
            if (this.sparse && opts.eagerUpdate) {
              this.update(function loop(err) {
                if (err)
                  self2.emit("update-error", err);
                self2.update(loop);
              });
            }
            this.open(onerror);
            function onerror(err) {
              if (err)
                self2.emit("error", err);
            }
            function workHook(values, cb) {
              if (!self2._merkle)
                return self2._reloadMerkleStateBeforeAppend(workHook, values, cb);
              self2._appendHook(values, cb);
            }
            function work(values, cb) {
              if (!self2._merkle)
                return self2._reloadMerkleStateBeforeAppend(work, values, cb);
              self2._append(values, cb);
            }
            function sync(_, cb) {
              self2._syncBitfield(cb);
            }
          }
          inherits(Feed, Nanoresource);
          Feed.discoveryKey = crypto.discoveryKey;
          Feed.prototype[inspect] = function(depth, opts) {
            var indent = "";
            if (typeof opts.indentationLvl === "number") {
              while (indent.length < opts.indentationLvl) {
                indent += " ";
              }
            }
            return "Hypercore(\n" + indent + "  key: " + opts.stylize(this.key && pretty(this.key), "string") + "\n" + indent + "  discoveryKey: " + opts.stylize(this.discoveryKey && pretty(this.discoveryKey), "string") + "\n" + indent + "  opened: " + opts.stylize(this.opened, "boolean") + "\n" + indent + "  sparse: " + opts.stylize(this.sparse, "boolean") + "\n" + indent + "  writable: " + opts.stylize(this.writable, "boolean") + "\n" + indent + "  length: " + opts.stylize(this.length, "number") + "\n" + indent + "  byteLength: " + opts.stylize(this.byteLength, "number") + "\n" + indent + "  peers: " + opts.stylize(this.peers.length, "number") + "\n" + indent + ")";
          };
          Object.defineProperty(Feed.prototype, "remoteLength", {
            enumerable: true,
            get: function get() {
              var len = 0;
              for (var i = 0; i < this.peers.length; i++) {
                var remoteLength = this.peers[i].remoteLength;
                if (remoteLength > len)
                  len = remoteLength;
              }
              return len;
            }
          });
          Object.defineProperty(Feed.prototype, "stats", {
            enumerable: true,
            get: function get() {
              if (!this._stats)
                return null;
              var peerStats = [];
              for (var i = 0; i < this.peers.length; i++) {
                var peer = this.peers[i];
                peerStats[i] = peer.stats;
              }
              return {
                peers: peerStats,
                totals: this._stats
              };
            }
          });
          Feed.prototype.replicate = function(initiator, opts) {
            if ((!this._selections.length || this._selections[0].end !== -1) && !this.sparse && !(opts && opts.live)) {
              this.download({
                start: 0,
                end: -1
              });
            }
            if (isOptions(initiator) && !opts) {
              opts = initiator;
              initiator = opts.initiator;
            }
            opts = opts || {};
            opts.stats = !!this._stats;
            opts.noise = !(opts.noise === false && opts.encrypted === false);
            var stream = replicate(this, initiator, opts);
            this.emit("replicating", stream);
            return stream;
          };
          Feed.prototype.registerExtension = function(name, handlers) {
            return this.extensions.add(name, handlers);
          };
          Feed.prototype.onextensionupdate = function() {
            for (var peer of this.peers) {
              peer._updateOptions();
            }
          };
          Feed.prototype.setDownloading = function(downloading) {
            if (this.downloading === downloading && this._downloadingSet)
              return;
            this.downloading = downloading;
            this._downloadingSet = true;
            this.ready((err) => {
              if (err)
                return;
              for (var peer of this.peers) {
                peer.setDownloading(this.downloading);
              }
            });
          };
          Feed.prototype.setUploading = function(uploading) {
            if (uploading === this.uploading)
              return;
            this.uploading = uploading;
            this.ready((err) => {
              if (err)
                return;
              for (var peer of this.peers) {
                peer.setUploading(this.uploading);
              }
            });
          };
          Feed.prototype.ready = Feed.prototype.open;
          Feed.prototype.update = function(opts, cb) {
            if (typeof opts === "function")
              return this.update(-1, opts);
            if (typeof opts === "number")
              opts = {
                minLength: opts
              };
            if (!opts)
              opts = {};
            if (!cb)
              cb = noop;
            var self2 = this;
            var len = typeof opts.minLength === "number" ? opts.minLength : -1;
            this.ready(function(err) {
              if (err)
                return cb(err);
              if (len === -1)
                len = self2.length + 1;
              if (self2.length >= len)
                return cb(null);
              if (self2.writable)
                cb = self2._writeStateReloader(cb);
              var w = {
                hash: opts.hash !== false,
                bytes: 0,
                index: len - 1,
                options: opts,
                update: true,
                callback: cb
              };
              self2._waiting.push(w);
              if (typeof opts.ifAvailable === "boolean" ? opts.ifAvailable : self2._alwaysIfAvailable)
                self2._ifAvailable(w, len);
              self2._updatePeers();
            });
          };
          Feed.prototype.setExpectedLength = function(len) {
            this._expectedLength = len;
            this.ready((err) => {
              if (err)
                return;
              this.ifAvailable.ready(() => {
                this._expectedLength = -1;
              });
              if (this._expectedLength === -1 || this._expectedLength > this.length)
                return;
              for (var w of this._waiting) {
                if (w.update && w.ifAvailable)
                  w.callback(new Error("Expected length is less than current length"));
              }
            });
          };
          Feed.prototype.truncate = function(newLength, cb) {
            if (!cb)
              cb = noop;
            var self2 = this;
            this.ready(function(err) {
              if (err)
                return cb(err);
              self2._roots(newLength, function(err2, roots) {
                if (err2)
                  return cb(err2);
                var oldLength = self2.length;
                if (oldLength <= newLength)
                  return cb(null);
                var byteLength = 0;
                for (var {
                  size
                } of roots) {
                  byteLength += size;
                }
                for (var i = oldLength; i < newLength; i++) {
                  self2.data.set(i, false);
                }
                self2.byteLength = byteLength;
                self2.length = newLength;
                self2.tree.truncate(2 * newLength);
                self2._merkle = new MerkleGenerator(crypto, roots);
                self2._sync(null, function(err3) {
                  if (err3)
                    return cb(err3);
                  self2._storage.deleteSignatures(newLength, oldLength, cb);
                });
              });
            });
          };
          Feed.prototype._ifAvailable = function(w, minLength) {
            var cb = w.callback;
            var called = false;
            var self2 = this;
            w.callback = done;
            w.ifAvailable = true;
            if (this._expectedLength > -1 && this._expectedLength <= this.length) {
              return process.nextTick(w.callback, new Error("Expected length is less than current length"));
            }
            this.timeouts.update(function() {
              if (self2.closed)
                return done(new Error("Closed"));
              process.nextTick(readyNT, self2.ifAvailable, function() {
                if (self2.closed)
                  return done(new Error("Closed"));
                if (self2.length >= minLength || self2.remoteLength >= minLength)
                  return;
                done(new Error("No update available from peers"));
              });
            });
            function done(err) {
              if (called)
                return;
              called = true;
              var i = self2._waiting.indexOf(w);
              if (i > -1)
                remove(self2._waiting, i);
              cb(err);
            }
          };
          Feed.prototype._ifAvailableGet = function(w) {
            var cb = w.callback;
            var called = false;
            var self2 = this;
            w.callback = done;
            self2.timeouts.get(function() {
              if (self2.closed)
                return done(new Error("Closed"));
              process.nextTick(readyNT, self2.ifAvailable, function() {
                if (self2.closed)
                  return done(new Error("Closed"));
                for (var i = 0; i < self2.peers.length; i++) {
                  var peer = self2.peers[i];
                  if (peer.remoteBitfield.get(w.index))
                    return;
                }
                done(new Error("Block not available from peers"));
              });
            });
            function done(err, data) {
              if (called)
                return;
              called = true;
              var i = self2._waiting.indexOf(w);
              if (i > -1)
                remove(self2._waiting, i);
              cb(err, data);
            }
          };
          Feed.prototype._writeStateReloader = function(cb) {
            var self2 = this;
            return function(err) {
              if (err)
                return cb(err);
              self2._reloadMerkleState(cb);
            };
          };
          Feed.prototype._reloadMerkleState = function(cb) {
            var self2 = this;
            this._roots(self2.length, function(err, roots) {
              if (err)
                return cb(err);
              self2._merkle = new MerkleGenerator(crypto, roots);
              cb(null);
            });
          };
          Feed.prototype._reloadMerkleStateBeforeAppend = function(work, values, cb) {
            this._reloadMerkleState(function(err) {
              if (err)
                return cb(err);
              work(values, cb);
            });
          };
          Feed.prototype._open = function(cb) {
            var self2 = this;
            var generatedKey = false;
            var retryOpen = true;
            this._storage.openKey(function(_, key) {
              if (key && !self2._overwrite && !self2.key)
                self2.key = key;
              if (!self2.key && self2.live) {
                var keyPair = crypto.keyPair();
                self2.secretKey = keyPair.secretKey;
                self2.key = keyPair.publicKey;
                generatedKey = true;
              }
              self2.discoveryKey = self2.key && crypto.discoveryKey(self2.key);
              self2._storage.open({
                key: self2.key,
                discoveryKey: self2.discoveryKey
              }, onopen);
            });
            function onopen(err, state) {
              if (err)
                return cb(err);
              if (!state.key && state.bitfield.length) {
                self2._overwrite = true;
              }
              if (self2._overwrite) {
                state.bitfield = [];
                state.key = state.secretKey = null;
              }
              self2.bitfield = bitfield(state.bitfieldPageSize, state.bitfield);
              self2.tree = treeIndex(self2.bitfield.tree);
              self2.length = self2.tree.blocks();
              self2._seq = self2.length;
              if (state.key && self2.key && Buffer.compare(state.key, self2.key) !== 0) {
                return self2._forceClose(cb, new Error("Another hypercore is stored here"));
              }
              if (state.key)
                self2.key = state.key;
              if (state.secretKey)
                self2.secretKey = state.secretKey;
              if (!self2.length)
                return onsignature(null, null);
              self2._storage.getSignature(self2.length - 1, onsignature);
              function onsignature(_, sig) {
                if (self2.length)
                  self2.live = !!sig;
                if ((generatedKey || !self2.key) && !self2._createIfMissing) {
                  return self2._forceClose(cb, new Error("No hypercore is stored here"));
                }
                if (!self2.key && self2.live) {
                  var keyPair = crypto.keyPair();
                  self2.secretKey = keyPair.secretKey;
                  self2.key = keyPair.publicKey;
                }
                var writable = !!self2.secretKey || self2.key === null;
                if (!writable && self2.writable)
                  return self2._forceClose(cb, new Error("Feed is not writable"));
                self2.writable = writable;
                if (!self2._downloadingSet)
                  self2.downloading = !writable;
                self2.discoveryKey = self2.key && crypto.discoveryKey(self2.key);
                if (self2._storeSecretKey && !self2.secretKey) {
                  self2._storeSecretKey = false;
                }
                var shouldWriteKey = generatedKey || !safeBufferEquals(self2.key, state.key);
                var shouldWriteSecretKey = self2._storeSecretKey && (generatedKey || !safeBufferEquals(self2.secretKey, state.secretKey));
                var missing = 1 + (shouldWriteKey ? 1 : 0) + (shouldWriteSecretKey ? 1 : 0) + (self2._overwrite ? 1 : 0);
                var error = null;
                if (shouldWriteKey)
                  self2._storage.key.write(0, self2.key, done);
                if (shouldWriteSecretKey)
                  self2._storage.secretKey.write(0, self2.secretKey, done);
                if (self2._overwrite) {
                  self2._storage.bitfield.del(32, Infinity, done);
                }
                done(null);
                function done(err2) {
                  if (err2)
                    error = err2;
                  if (--missing)
                    return;
                  if (error)
                    return self2._forceClose(cb, error);
                  self2._roots(self2.length, onroots);
                }
                function onroots(err2, roots) {
                  if (err2 && retryOpen) {
                    retryOpen = false;
                    self2.length--;
                    self2._storage.getSignature(self2.length - 1, onsignature);
                    return;
                  }
                  if (err2)
                    return self2._forceClose(cb, err2);
                  self2._merkle = new MerkleGenerator(crypto, roots);
                  self2.byteLength = roots.reduce(addSize, 0);
                  self2.emit("ready");
                  cb(null);
                }
              }
            }
          };
          Feed.prototype.download = function(range, cb) {
            if (typeof range === "function")
              return this.download(null, range);
            if (typeof range === "number")
              range = {
                start: range,
                end: range + 1
              };
            if (Array.isArray(range))
              range = {
                blocks: range
              };
            if (!range)
              range = {};
            if (!cb)
              cb = noop;
            if (!this.readable)
              return cb(new Error("Feed is closed"));
            if (range.blocks && typeof range.start !== "number") {
              var min = -1;
              var max = 0;
              for (var i = 0; i < range.blocks.length; i++) {
                var blk = range.blocks[i];
                if (min === -1 || blk < min)
                  min = blk;
                if (blk >= max)
                  max = blk + 1;
              }
              range.start = min === -1 ? 0 : min;
              range.end = max;
            }
            var sel = {
              _index: this._selections.length,
              hash: !!range.hash,
              iterator: null,
              start: range.start || 0,
              end: range.end || -1,
              want: 0,
              linear: !!range.linear,
              blocks: range.blocks || null,
              blocksDownloaded: 0,
              requested: 0,
              callback: cb
            };
            sel.want = toWantRange(sel.start);
            this._selections.push(sel);
            this._updatePeers();
            return sel;
          };
          Feed.prototype.undownload = function(range) {
            if (typeof range === "number")
              range = {
                start: range,
                end: range + 1
              };
            if (!range)
              range = {};
            if (range.callback && range._index > -1) {
              set.remove(this._selections, range);
              process.nextTick(range.callback, createError("ECANCELED", -11, "Download was cancelled"));
              return;
            }
            var start = range.start || 0;
            var end = range.end || -1;
            var hash = !!range.hash;
            var linear = !!range.linear;
            for (var i = 0; i < this._selections.length; i++) {
              var s = this._selections[i];
              if (s.start === start && s.end === end && s.hash === hash && s.linear === linear) {
                set.remove(this._selections, s);
                process.nextTick(range.callback, createError("ECANCELED", -11, "Download was cancelled"));
                return;
              }
            }
          };
          Feed.prototype.digest = function(index) {
            return this.tree.digest(2 * index);
          };
          Feed.prototype.proof = function(index, opts, cb) {
            if (typeof opts === "function")
              return this.proof(index, null, opts);
            if (!this.opened)
              return this._readyAndProof(index, opts, cb);
            if (!opts)
              opts = {};
            var proof = this.tree.proof(2 * index, opts);
            if (!proof)
              return cb(new Error("No proof available for this index"));
            var needsSig = this.live && !!proof.verifiedBy;
            var pending = proof.nodes.length + (needsSig ? 1 : 0);
            var error = null;
            var signature = null;
            var nodes = new Array(proof.nodes.length);
            if (!pending)
              return cb(null, {
                nodes,
                signature: null
              });
            for (var i = 0; i < proof.nodes.length; i++) {
              this._storage.getNode(proof.nodes[i], onnode);
            }
            if (needsSig) {
              this._storage.getSignature(proof.verifiedBy / 2 - 1, onsignature);
            }
            function onsignature(err, sig) {
              if (sig)
                signature = sig;
              onnode(err, null);
            }
            function onnode(err, node) {
              if (err)
                error = err;
              if (node) {
                nodes[proof.nodes.indexOf(node.index)] = node;
              }
              if (--pending)
                return;
              if (error)
                return cb(error);
              cb(null, {
                nodes,
                signature
              });
            }
          };
          Feed.prototype._readyAndProof = function(index, opts, cb) {
            var self2 = this;
            this.ready(function(err) {
              if (err)
                return cb(err);
              self2.proof(index, opts, cb);
            });
          };
          Feed.prototype.put = function(index, data, proof, cb) {
            if (!this.opened)
              return this._readyAndPut(index, data, proof, cb);
            this._putBuffer(index, data === null ? null : this._codec.encode(data), proof, null, cb);
          };
          Feed.prototype.cancel = function(start, end) {
            if (typeof start !== "symbol") {
              if (!end)
                end = start + 1;
              for (var i = this._selections.length - 1; i >= 0; i--) {
                var sel = this._selections[i];
                if (start <= sel.start && sel.end <= end) {
                  this.undownload(sel);
                }
              }
            }
            if (this.opened)
              this._cancel(start, end);
            else
              this._readyAndCancel(start, end);
          };
          Feed.prototype._cancel = function(start, end) {
            var i = 0;
            if (typeof start === "symbol") {
              for (i = this._waiting.length - 1; i >= 0; i--) {
                var _w = this._waiting[i];
                if (_w.options.cancel === start) {
                  remove(this._waiting, i);
                  this._reserved.set(_w.index, false);
                  if (_w.callback)
                    process.nextTick(_w.callback, new Error("Request cancelled"));
                  this._updatePeers();
                  return;
                }
              }
              return;
            }
            for (i = start; i < end; i++) {
              this._reserved.set(i, false);
            }
            for (i = this._waiting.length - 1; i >= 0; i--) {
              var w = this._waiting[i];
              if (start <= w.start && w.end <= end || start <= w.index && w.index < end) {
                remove(this._waiting, i);
                if (w.callback)
                  process.nextTick(w.callback, new Error("Request cancelled"));
              }
            }
          };
          Feed.prototype.clear = function(start, end, opts, cb) {
            if (typeof end === "function")
              return this.clear(start, start + 1, null, end);
            if (typeof opts === "function")
              return this.clear(start, end, null, opts);
            if (!opts)
              opts = {};
            if (!end)
              end = start + 1;
            if (!cb)
              cb = noop;
            var self2 = this;
            var byteOffset = start === 0 ? 0 : typeof opts.byteOffset === "number" ? opts.byteOffset : -1;
            var byteLength = typeof opts.byteLength === "number" ? opts.byteLength : -1;
            this.ready(function(err) {
              if (err)
                return cb(err);
              var modified = false;
              for (var i = start; i < end; i++) {
                if (self2.bitfield.set(i, false))
                  modified = true;
              }
              if (!modified)
                return process.nextTick(cb);
              self2._unannounce({
                start,
                length: end - start
              });
              if (opts.delete === false || self2._indexing)
                return sync();
              if (byteOffset > -1)
                return onstartbytes(null, byteOffset);
              self2._storage.dataOffset(start, [], onstartbytes);
              function sync() {
                self2.emit("clear", start, end);
                self2._sync(null, cb);
              }
              function onstartbytes(err2, offset) {
                if (err2)
                  return cb(err2);
                byteOffset = offset;
                if (byteLength > -1)
                  return onendbytes(null, byteLength + byteOffset);
                if (end === self2.length)
                  return onendbytes(null, self2.byteLength);
                self2._storage.dataOffset(end, [], onendbytes);
              }
              function onendbytes(err2, end2) {
                if (err2)
                  return cb(err2);
                if (!self2._storage.data.del)
                  return sync();
                self2._storage.data.del(byteOffset, end2 - byteOffset, sync);
              }
            });
          };
          Feed.prototype.signature = function(index, cb) {
            if (typeof index === "function")
              return this.signature(this.length - 1, index);
            if (index < 0 || index >= this.length)
              return cb(new Error("No signature available for this index"));
            this._storage.nextSignature(index, cb);
          };
          Feed.prototype.verify = function(index, signature, cb) {
            var self2 = this;
            this.rootHashes(index, function(err, roots) {
              if (err)
                return cb(err);
              var checksum = crypto.signable(roots, index + 1);
              verifyCompat(self2, checksum, signature, function(err2, valid) {
                if (err2)
                  return cb(err2);
                if (!valid)
                  return cb(new Error("Signature verification failed"));
                return cb(null, true);
              });
            });
          };
          Feed.prototype.rootHashes = function(index, cb) {
            this._getRootsToVerify(index * 2 + 2, {}, [], cb);
          };
          Feed.prototype.seek = function(bytes, opts, cb) {
            if (typeof opts === "function")
              return this.seek(bytes, null, opts);
            if (!opts)
              opts = {};
            if (!this.opened)
              return this._readyAndSeek(bytes, opts, cb);
            var self2 = this;
            if (bytes === this.byteLength)
              return process.nextTick(cb, null, this.length, 0);
            this._seek(bytes, function(err, index, offset) {
              if (!err && isBlock(index))
                return done(index / 2, offset);
              if (opts.wait === false)
                return cb(err || new Error("Unable to seek to this offset"));
              var start = opts.start || 0;
              var end = opts.end || -1;
              if (!err) {
                var left = flat.leftSpan(index) / 2;
                var right = flat.rightSpan(index) / 2 + 1;
                if (left > start)
                  start = left;
                if (right < end || end === -1)
                  end = right;
              }
              if (end > -1 && end <= start)
                return cb(new Error("Unable to seek to this offset"));
              var w = {
                hash: opts.hash !== false,
                bytes,
                index: -1,
                ifAvailable: opts && typeof opts.ifAvailable === "boolean" ? opts.ifAvailable : self2._alwaysIfAvailable,
                start,
                end,
                want: toWantRange(start),
                requested: 0,
                callback: cb || noop
              };
              self2._waiting.push(w);
              self2._updatePeers();
              if (w.ifAvailable)
                self2._ifAvailableSeek(w);
            });
            function done(index, offset) {
              for (var i = 0; i < self2.peers.length; i++) {
                self2.peers[i].haveBytes(bytes);
              }
              cb(null, index, offset);
            }
          };
          Feed.prototype._ifAvailableSeek = function(w) {
            var self2 = this;
            var cb = w.callback;
            self2.timeouts.get(function() {
              if (self2.closed)
                return done(new Error("Closed"));
              process.nextTick(readyNT, self2.ifAvailable, function() {
                if (self2.closed)
                  return done(new Error("Closed"));
                var available = false;
                for (var peer of self2.peers) {
                  var ite = peer._iterator;
                  var i = ite.seek(w.start).next(true);
                  while (self2.tree.get(i * 2) && i > -1) {
                    i = ite.next(true);
                  }
                  if (i > -1 && (w.end === -1 || i < w.end)) {
                    available = true;
                    break;
                  }
                }
                if (!available)
                  done(new Error("Seek not available from peers"));
              });
            });
            function done(err) {
              var i = self2._waiting.indexOf(w);
              if (i > -1) {
                remove(self2._waiting, i);
                w.callback = noop;
                cb(err);
              }
            }
          };
          Feed.prototype._seek = function(offset, cb) {
            if (offset === 0)
              return cb(null, 0, 0);
            var self2 = this;
            var roots = flat.fullRoots(this.length * 2);
            var nearestRoot = 0;
            loop(null, null);
            function onroot(top) {
              if (isBlock(top))
                return cb(null, nearestRoot, offset);
              var left = flat.leftChild(top);
              while (!self2.tree.get(left)) {
                if (isBlock(left))
                  return cb(null, nearestRoot, offset);
                left = flat.leftChild(left);
              }
              self2._storage.getNode(left, onleftchild);
            }
            function onleftchild(err, node) {
              if (err)
                return cb(err);
              if (node.size > offset) {
                nearestRoot = node.index;
                onroot(node.index);
              } else {
                offset -= node.size;
                if (flat.parent(node.index) === nearestRoot) {
                  nearestRoot = flat.sibling(node.index);
                  onroot(nearestRoot);
                } else {
                  onroot(flat.sibling(node.index));
                }
              }
            }
            function loop(err, node) {
              if (err)
                return cb(err);
              if (node) {
                if (node.size > offset) {
                  nearestRoot = node.index;
                  return onroot(node.index);
                }
                offset -= node.size;
              }
              if (!roots.length)
                return cb(new Error("Out of bounds"));
              self2._storage.getNode(roots.shift(), loop);
            }
          };
          Feed.prototype._readyAndSeek = function(bytes, opts, cb) {
            var self2 = this;
            this.ready(function(err) {
              if (err)
                return cb(err);
              self2.seek(bytes, opts, cb);
            });
          };
          Feed.prototype._getBuffer = function(index, cb) {
            this._storage.getData(index, cb);
          };
          Feed.prototype._putBuffer = function(index, data, proof, from, cb) {
            var self2 = this;
            var trusted = -1;
            var missing = [];
            var next = 2 * index;
            var i = data ? 0 : 1;
            while (true) {
              if (this.tree.get(next)) {
                trusted = next;
                break;
              }
              var sib = flat.sibling(next);
              next = flat.parent(next);
              if (i < proof.nodes.length && proof.nodes[i].index === sib) {
                i++;
                continue;
              }
              if (!this.tree.get(sib))
                break;
              missing.push(sib);
            }
            if (trusted === -1 && this.tree.get(next))
              trusted = next;
            var error = null;
            var trustedNode = null;
            var missingNodes = new Array(missing.length);
            var pending = missing.length + (trusted > -1 ? 1 : 0);
            for (i = 0; i < missing.length; i++) {
              this._storage.getNode(missing[i], onmissing);
            }
            if (trusted > -1)
              this._storage.getNode(trusted, ontrusted);
            if (!missing.length && trusted === -1)
              onmissingloaded(null);
            function ontrusted(err, node) {
              if (err)
                error = err;
              if (node)
                trustedNode = node;
              if (!--pending)
                onmissingloaded(error);
            }
            function onmissing(err, node) {
              if (err)
                error = err;
              if (node)
                missingNodes[missing.indexOf(node.index)] = node;
              if (!--pending)
                onmissingloaded(error);
            }
            function onmissingloaded(err) {
              if (err)
                return cb(err);
              self2._verifyAndWrite(index, data, proof, missingNodes, trustedNode, from, cb);
            }
          };
          Feed.prototype._readyAndPut = function(index, data, proof, cb) {
            var self2 = this;
            this.ready(function(err) {
              if (err)
                return cb(err);
              self2.put(index, data, proof, cb);
            });
          };
          Feed.prototype._write = function(index, data, nodes, sig, from, cb) {
            if (!this._onwrite)
              return this._writeAfterHook(index, data, nodes, sig, from, cb);
            this._onwrite(index, data, from, writeHookDone(this, index, data, nodes, sig, from, cb));
          };
          function writeHookDone(self2, index, data, nodes, sig, from, cb) {
            return function(err) {
              if (err)
                return cb(err);
              self2._writeAfterHook(index, data, nodes, sig, from, cb);
            };
          }
          Feed.prototype._writeAfterHook = function(index, data, nodes, sig, from, cb) {
            var self2 = this;
            var pending = nodes.length + 1 + (sig ? 1 : 0);
            var error = null;
            for (var i = 0; i < nodes.length; i++) {
              this._storage.putNode(nodes[i].index, nodes[i], ondone);
            }
            if (data)
              this._storage.putData(index, data, nodes, ondone);
            else
              ondone();
            if (sig)
              this._storage.putSignature(sig.index, sig.signature, ondone);
            function ondone(err) {
              if (err)
                error = err;
              if (--pending)
                return;
              if (error)
                return cb(error);
              self2._writeDone(index, data, nodes, from, cb);
            }
          };
          Feed.prototype._writeDone = function(index, data, nodes, from, cb) {
            for (var i = 0; i < nodes.length; i++) {
              this.tree.set(nodes[i].index);
            }
            this.tree.set(2 * index);
            if (data) {
              if (this.bitfield.set(index, true)) {
                if (this._stats) {
                  this._stats.downloadedBlocks += 1;
                  this._stats.downloadedBytes += data.length;
                }
                this.emit("download", index, data, from);
              }
              if (this.peers.length)
                this._announce({
                  start: index
                }, from);
              if (!this.writable) {
                if (!this._synced)
                  this._synced = this.bitfield.iterator(0, this.length);
                if (this._synced.next() === -1) {
                  this._synced.range(0, this.length);
                  this._synced.seek(0);
                  if (this._synced.next() === -1) {
                    this.emit("sync");
                  }
                }
              }
            }
            this._sync(null, cb);
          };
          Feed.prototype._verifyAndWrite = function(index, data, proof, localNodes, trustedNode, from, cb) {
            var visited = [];
            var remoteNodes = proof.nodes;
            var top = data ? new storage.Node(2 * index, crypto.data(data), data.length) : remoteNodes.shift();
            if (verifyNode(trustedNode, top)) {
              this._write(index, data, visited, null, from, cb);
              return;
            }
            while (true) {
              var node = null;
              var next = flat.sibling(top.index);
              if (remoteNodes.length && remoteNodes[0].index === next) {
                node = remoteNodes.shift();
                visited.push(node);
              } else if (localNodes.length && localNodes[0].index === next) {
                node = localNodes.shift();
              } else {
                this._verifyRootsAndWrite(index, data, top, proof, visited, from, cb);
                return;
              }
              visited.push(top);
              top = new storage.Node(flat.parent(top.index), crypto.parent(top, node), top.size + node.size);
              if (verifyNode(trustedNode, top)) {
                this._write(index, data, visited, null, from, cb);
                return;
              }
            }
          };
          Feed.prototype._verifyRootsAndWrite = function(index, data, top, proof, nodes, from, cb) {
            var remoteNodes = proof.nodes;
            var lastNode = remoteNodes.length ? remoteNodes[remoteNodes.length - 1].index : top.index;
            var verifiedBy = Math.max(flat.rightSpan(top.index), flat.rightSpan(lastNode)) + 2;
            var length = verifiedBy / 2;
            var self2 = this;
            this._getRootsToVerify(verifiedBy, top, remoteNodes, function(err, roots, extraNodes) {
              if (err)
                return cb(err);
              var checksum = crypto.signable(roots, length);
              var signature = null;
              if (self2.length && self2.live && !proof.signature) {
                return cb(new Error("Remote did not include a signature"));
              }
              if (proof.signature) {
                verifyCompat(self2, checksum, proof.signature, function(err2, valid) {
                  if (err2)
                    return cb(err2);
                  if (!valid)
                    return cb(new Error("Remote signature could not be verified"));
                  signature = {
                    index: verifiedBy / 2 - 1,
                    signature: proof.signature
                  };
                  write();
                });
              } else {
                if (Buffer.compare(checksum.slice(0, 32), self2.key) !== 0) {
                  return cb(new Error("Remote checksum failed"));
                }
                write();
              }
              function write() {
                self2.live = !!signature;
                if (length > self2.length) {
                  if (self2.writable)
                    self2._merkle = null;
                  self2.length = length;
                  self2._seq = length;
                  self2.byteLength = roots.reduce(addSize, 0);
                  if (self2._synced)
                    self2._synced.seek(0, self2.length);
                  self2.emit("append");
                }
                self2._write(index, data, nodes.concat(extraNodes), signature, from, cb);
              }
            });
          };
          Feed.prototype._getRootsToVerify = function(verifiedBy, top, remoteNodes, cb) {
            var indexes = flat.fullRoots(verifiedBy);
            var roots = new Array(indexes.length);
            var nodes = [];
            var error = null;
            var pending = roots.length;
            for (var i = 0; i < indexes.length; i++) {
              if (indexes[i] === top.index) {
                nodes.push(top);
                onnode(null, top);
              } else if (remoteNodes.length && indexes[i] === remoteNodes[0].index) {
                nodes.push(remoteNodes[0]);
                onnode(null, remoteNodes.shift());
              } else if (this.tree.get(indexes[i])) {
                this._storage.getNode(indexes[i], onnode);
              } else {
                onnode(new Error("Missing tree roots needed for verify"));
              }
            }
            function onnode(err, node) {
              if (err)
                error = err;
              if (node)
                roots[indexes.indexOf(node.index)] = node;
              if (!--pending)
                done(error);
            }
            function done(err) {
              if (err)
                return cb(err);
              cb(null, roots, nodes);
            }
          };
          Feed.prototype._announce = function(message, from) {
            for (var i = 0; i < this.peers.length; i++) {
              var peer = this.peers[i];
              if (peer !== from)
                peer.have(message);
            }
          };
          Feed.prototype._unannounce = function(message) {
            for (var i = 0; i < this.peers.length; i++) {
              this.peers[i].unhave(message);
            }
          };
          Feed.prototype.downloaded = function(start, end, cb) {
            var count = this.bitfield.total(start, end);
            if (cb)
              process.nextTick(cb, null, count);
            return count;
          };
          Feed.prototype.has = function(start, end, cb) {
            if (typeof end === "function")
              return this.has(start, void 0, end);
            if (end === void 0) {
              var _res = this.bitfield.get(start);
              if (cb)
                process.nextTick(cb, null, _res);
              return _res;
            }
            var total = end - start;
            var res = total === this.bitfield.total(start, end);
            if (cb)
              process.nextTick(cb, null, res);
            return res;
          };
          Feed.prototype.head = function(opts, cb) {
            if (typeof opts === "function")
              return this.head({}, opts);
            var self2 = this;
            this.ready(function(err) {
              if (err)
                return cb(err);
              if (opts && opts.update)
                self2.update(opts, onupdate);
              else
                process.nextTick(onupdate);
            });
            function onupdate() {
              if (self2.length === 0)
                cb(new Error("feed is empty"));
              else
                self2.get(self2.length - 1, opts, cb);
            }
          };
          Feed.prototype.get = function(index, opts, cb) {
            if (typeof opts === "function")
              return this.get(index, null, opts);
            opts = _objectSpread({}, opts);
            if (!opts.cancel)
              opts.cancel = Symbol("hypercore-get");
            if (!this.opened)
              return this._readyAndGet(index, opts, cb);
            if (!this.readable) {
              process.nextTick(cb, new Error("Feed is closed"));
              return opts.cancel;
            }
            if (opts.timeout)
              cb = timeoutCallback(cb, opts.timeout);
            if (!this.bitfield.get(index)) {
              if (opts && opts.wait === false)
                return process.nextTick(cb, new Error("Block not downloaded"));
              var w = {
                bytes: 0,
                hash: false,
                index,
                options: opts,
                requested: 0,
                callback: cb
              };
              this._waiting.push(w);
              if (opts && typeof opts.ifAvailable === "boolean" ? opts.ifAvailable : this._alwaysIfAvailable)
                this._ifAvailableGet(w);
              this._updatePeers();
              if (opts.onwait) {
                var onwait = opts.onwait;
                opts.onwait = null;
                onwait(index);
              }
              return opts.cancel;
            }
            if (opts && opts.valueEncoding)
              cb = wrapCodec(toCodec(opts.valueEncoding), cb);
            else if (this._codec !== codecs.binary)
              cb = wrapCodec(this._codec, cb);
            this._getBuffer(index, cb);
            return opts.cancel;
          };
          Feed.prototype._readyAndGet = function(index, opts, cb) {
            var self2 = this;
            this.ready(function(err) {
              if (err)
                return cb(err);
              self2.get(index, opts, cb);
            });
            return opts.cancel;
          };
          Feed.prototype.getBatch = function(start, end, opts, cb) {
            if (typeof opts === "function")
              return this.getBatch(start, end, null, opts);
            if (!this.opened)
              return this._readyAndGetBatch(start, end, opts, cb);
            var self2 = this;
            var wait = !opts || opts.wait !== false;
            if (this.has(start, end))
              return this._getBatch(start, end, opts, cb);
            if (!wait)
              return process.nextTick(cb, new Error("Block not downloaded"));
            if (opts && opts.timeout)
              cb = timeoutCallback(cb, opts.timeout);
            this.download({
              start,
              end
            }, function(err) {
              if (err)
                return cb(err);
              self2._getBatch(start, end, opts, cb);
            });
          };
          Feed.prototype._getBatch = function(start, end, opts, cb) {
            var enc = opts && opts.valueEncoding;
            var codec = enc ? toCodec(enc) : this._codec;
            this._storage.getDataBatch(start, end - start, onbatch);
            function onbatch(err, buffers) {
              if (err)
                return cb(err);
              var batch = new Array(buffers.length);
              for (var i = 0; i < buffers.length; i++) {
                try {
                  batch[i] = codec ? codec.decode(buffers[i]) : buffers[i];
                } catch (err2) {
                  return cb(err2);
                }
              }
              cb(null, batch);
            }
          };
          Feed.prototype._readyAndGetBatch = function(start, end, opts, cb) {
            var self2 = this;
            this.ready(function(err) {
              if (err)
                return cb(err);
              self2.getBatch(start, end, opts, cb);
            });
          };
          Feed.prototype._updatePeers = function() {
            for (var i = 0; i < this.peers.length; i++) {
              this.peers[i].update();
            }
          };
          Feed.prototype.createWriteStream = function(opts) {
            return new WriteStream(this, opts);
          };
          Feed.prototype.createReadStream = function(opts) {
            return new ReadStream(this, opts);
          };
          Feed.prototype.finalize = function(cb) {
            if (!this.key) {
              this.key = crypto.tree(this._merkle.roots);
              this.discoveryKey = crypto.discoveryKey(this.key);
            }
            this._storage.key.write(0, this.key, cb);
          };
          Feed.prototype.append = function(batch, cb) {
            if (!cb)
              cb = noop;
            var self2 = this;
            var list = Array.isArray(batch) ? batch : [batch];
            this._batch(list, onappend);
            function onappend(err) {
              if (err)
                return cb(err);
              var seq = self2._seq;
              self2._seq += list.length;
              cb(null, seq);
            }
          };
          Feed.prototype.flush = function(cb) {
            this.append([], cb);
          };
          Feed.prototype.destroyStorage = function(cb) {
            var self2 = this;
            this.close(function(err) {
              if (err)
                cb(err);
              else
                self2._storage.destroy(cb);
            });
          };
          Feed.prototype._close = function(cb) {
            var self2 = this;
            for (var peer of this.peers) {
              if (!peer._destroyed)
                peer._close();
            }
            this._forceClose(onclose, null);
            function onclose(err) {
              if (!err)
                self2.emit("close");
              cb(err);
            }
          };
          Feed.prototype._forceClose = function(cb, error) {
            var self2 = this;
            this.writable = false;
            this.readable = false;
            this._storage.close(function(err) {
              if (!err)
                err = error;
              self2._destroy(err || new Error("Feed is closed"));
              cb(err);
            });
          };
          Feed.prototype._destroy = function(err) {
            this.ifAvailable.destroy();
            while (this._waiting.length) {
              this._waiting.pop().callback(err);
            }
            while (this._selections.length) {
              this._selections.pop().callback(err);
            }
          };
          Feed.prototype._appendHook = function(batch, cb) {
            var self2 = this;
            var missing = batch.length;
            var error = null;
            if (!missing)
              return this._append(batch, cb);
            for (var i = 0; i < batch.length; i++) {
              this._onwrite(i + this.length, batch[i], null, done);
            }
            function done(err) {
              if (err)
                error = err;
              if (--missing)
                return;
              if (error)
                return cb(error);
              self2._append(batch, cb);
            }
          };
          Feed.prototype._append = function(batch, cb) {
            if (!this.opened)
              return this._readyAndAppend(batch, cb);
            if (!this.writable)
              return cb(new Error("This feed is not writable. Did you create it?"));
            var self2 = this;
            var pending = 1;
            var offset = 0;
            var error = null;
            var nodeBatch = new Array(batch.length ? batch.length * 2 - 1 : 0);
            var nodeOffset = this.length * 2;
            var dataBatch = new Array(batch.length);
            if (!pending)
              return cb();
            for (var i = 0; i < batch.length; i++) {
              var data = this._codec.encode(batch[i]);
              var nodes = this._merkle.next(data);
              if (data.length > 8388608)
                return cb(new Error("Individual blocks has be less than 8MB"));
              offset += data.length;
              dataBatch[i] = data;
              for (var j = 0; j < nodes.length; j++) {
                var node = nodes[j];
                if (node.index >= nodeOffset && node.index - nodeOffset < nodeBatch.length) {
                  nodeBatch[node.index - nodeOffset] = node;
                } else {
                  pending++;
                  this._storage.putNode(node.index, node, done);
                }
              }
            }
            if (this.live && batch.length) {
              pending++;
              this.crypto.sign(crypto.signable(this._merkle.roots, self2.length + batch.length), this.secretKey, function(err, sig) {
                if (err)
                  return done(err);
                self2._storage.putSignature(self2.length + batch.length - 1, sig, done);
              });
            }
            if (!this._indexing) {
              pending++;
              if (dataBatch.length === 1)
                this._storage.data.write(this.byteLength, dataBatch[0], done);
              else
                this._storage.data.write(this.byteLength, Buffer.concat(dataBatch), done);
            }
            this._storage.putNodeBatch(nodeOffset, nodeBatch, done);
            function done(err) {
              if (err)
                error = err;
              if (--pending)
                return;
              if (error)
                return cb(error);
              var start = self2.length;
              self2.byteLength += offset;
              for (var i2 = 0; i2 < batch.length; i2++) {
                self2.bitfield.set(self2.length, true);
                self2.tree.set(2 * self2.length++);
              }
              self2.emit("append");
              var message = self2.length - start > 1 ? {
                start,
                length: self2.length - start
              } : {
                start
              };
              if (self2.peers.length)
                self2._announce(message);
              self2._sync(null, cb);
            }
          };
          Feed.prototype._readyAndAppend = function(batch, cb) {
            var self2 = this;
            this.ready(function(err) {
              if (err)
                return cb(err);
              self2._append(batch, cb);
            });
          };
          Feed.prototype._readyAndCancel = function(start, end) {
            var self2 = this;
            this.ready(function() {
              self2._cancel(start, end);
            });
          };
          Feed.prototype._pollWaiting = function() {
            var len = this._waiting.length;
            for (var i = 0; i < len; i++) {
              var next = this._waiting[i];
              if (!next.bytes && !this.bitfield.get(next.index) && (!next.hash || !this.tree.get(next.index * 2))) {
                continue;
              }
              remove(this._waiting, i--);
              len--;
              if (next.bytes)
                this.seek(next.bytes, next, next.callback);
              else if (next.update)
                this.update(next.index + 1, next.callback);
              else
                this.get(next.index, next.options, next.callback);
            }
          };
          Feed.prototype._syncBitfield = function(cb) {
            var missing = this.bitfield.pages.updates.length;
            var next = null;
            var error = null;
            if (!missing) {
              this._pollWaiting();
              return cb(null);
            }
            while ((next = this.bitfield.pages.lastUpdate()) !== null) {
              this._storage.putBitfield(next.offset, next.buffer, ondone);
            }
            this._pollWaiting();
            function ondone(err) {
              if (err)
                error = err;
              if (--missing)
                return;
              cb(error);
            }
          };
          Feed.prototype._roots = function(index, cb) {
            var roots = flat.fullRoots(2 * index);
            var result = new Array(roots.length);
            var pending = roots.length;
            var error = null;
            if (!pending)
              return cb(null, result);
            for (var i = 0; i < roots.length; i++) {
              this._storage.getNode(roots[i], onnode);
            }
            function onnode(err, node) {
              if (err)
                error = err;
              if (node)
                result[roots.indexOf(node.index)] = node;
              if (--pending)
                return;
              if (error)
                return cb(error);
              cb(null, result);
            }
          };
          Feed.prototype.audit = function(cb) {
            if (!cb)
              cb = noop;
            var self2 = this;
            var report = {
              valid: 0,
              invalid: 0
            };
            this.ready(function(err) {
              if (err)
                return cb(err);
              var block = 0;
              var max = self2.length;
              next();
              function onnode(err2, node) {
                if (err2)
                  return ondata(null, null);
                self2._storage.getData(block, ondata);
                function ondata(_, data) {
                  var verified = data && crypto.data(data).equals(node.hash);
                  if (verified)
                    report.valid++;
                  else
                    report.invalid++;
                  self2.bitfield.set(block, verified);
                  block++;
                  next();
                }
              }
              function next() {
                while (block < max && !self2.bitfield.get(block)) {
                  block++;
                }
                if (block >= max)
                  return done();
                self2._storage.getNode(2 * block, onnode);
              }
              function done() {
                self2._sync(null, function(err2) {
                  if (err2)
                    return cb(err2);
                  cb(null, report);
                });
              }
            });
          };
          Feed.prototype.extension = function(name, message) {
            var peers = this.peers;
            for (var i = 0; i < peers.length; i++) {
              peers[i].extension(name, message);
            }
          };
          function noop() {
          }
          function verifyNode(trusted, node) {
            return trusted && trusted.index === node.index && Buffer.compare(trusted.hash, node.hash) === 0;
          }
          function addSize(size, node) {
            return size + node.size;
          }
          function isBlock(index) {
            return (index & 1) === 0;
          }
          function defaultStorage(dir) {
            return function(name) {
              try {
                var lock = name === "bitfield" ? require2("fd-lock") : null;
              } catch (err) {
              }
              return raf(name, {
                directory: dir,
                lock
              });
            };
          }
          function toCodec(enc) {
            return codecs(enc === "json" ? "ndjson" : enc);
          }
          function wrapCodec(enc, cb) {
            return function(err, buf) {
              if (err)
                return cb(err);
              try {
                buf = enc.decode(buf);
              } catch (err2) {
                return cb(err2);
              }
              cb(null, buf);
            };
          }
          function timeoutCallback(cb, timeout) {
            var failed = false;
            var id = setTimeout(ontimeout, timeout);
            return done;
            function ontimeout() {
              failed = true;
              var err = new Error("ETIMEDOUT");
              err.code = "ETIMEDOUT";
              cb(err);
            }
            function done(err, val) {
              if (failed)
                return;
              clearTimeout(id);
              cb(err, val);
            }
          }
          function toWantRange(i) {
            return Math.floor(i / 1024 / 1024) * 1024 * 1024;
          }
          function createError(code, errno, msg) {
            var err = new Error(msg);
            err.code = code;
            err.errno = errno;
            return err;
          }
          function isOptions(initiator) {
            return !Protocol.isProtocolStream(initiator) && typeof initiator === "object" && !!initiator && typeof initiator.initiator === "boolean";
          }
          function readyNT(ifAvailable, fn) {
            ifAvailable.ready(fn);
          }
          function verifyCompat(self2, checksum, signature, cb) {
            self2.crypto.verify(checksum, signature, self2.key, function(err, valid) {
              if (err || valid)
                return cb(err, valid);
              self2.crypto.verify(checksum.slice(0, 32), signature, self2.key, cb);
            });
          }
        }).call(this);
      }).call(this, require2("_process"), require2("buffer").Buffer);
    }, { "./lib/bitfield": 231, "./lib/replicate": 233, "./lib/safe-buffer-equals": 234, "./lib/storage": 235, "./lib/tree-index": 236, "_process": 361, "abstract-extension": 14, "atomic-batcher": 37, "buffer": 82, "codecs": 94, "fd-lock": 53, "flat-tree": 200, "hypercore-crypto": 227, "hypercore-protocol": 228, "hypercore-streams": 229, "inherits": 256, "inspect-custom-symbol": 257, "last-one-wins": 267, "merkle-tree-stream/generator": 299, "nanoguard": 311, "nanoresource/emitter": 327, "pretty-hash": 359, "random-access-file": 379, "sparse-bitfield": 479, "unordered-array-remove": 509, "unordered-set": 510 }], 231: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var flat = require2("flat-tree");
          var rle = require2("bitfield-rle");
          var pager = require2("memory-pager");
          var bitfield = require2("sparse-bitfield");
          var INDEX_UPDATE_MASK = [63, 207, 243, 252];
          var INDEX_ITERATE_MASK = [0, 192, 240, 252];
          var DATA_ITERATE_MASK = [128, 192, 224, 240, 248, 252, 254, 255];
          var DATA_UPDATE_MASK = [127, 191, 223, 239, 247, 251, 253, 254];
          var MAP_PARENT_RIGHT = new Array(256);
          var MAP_PARENT_LEFT = new Array(256);
          var NEXT_DATA_0_BIT = new Array(256);
          var NEXT_INDEX_0_BIT = new Array(256);
          var TOTAL_1_BITS = new Array(256);
          for (var i = 0; i < 256; i++) {
            var a = (i & 15 << 4) >> 4;
            var b = i & 15;
            var nibble = [0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4];
            MAP_PARENT_RIGHT[i] = (a === 15 ? 3 : a === 0 ? 0 : 1) << 2 | (b === 15 ? 3 : b === 0 ? 0 : 1);
            MAP_PARENT_LEFT[i] = MAP_PARENT_RIGHT[i] << 4;
            NEXT_DATA_0_BIT[i] = i === 255 ? -1 : 8 - Math.ceil(Math.log(256 - i) / Math.log(2));
            NEXT_INDEX_0_BIT[i] = i === 255 ? -1 : Math.floor(NEXT_DATA_0_BIT[i] / 2);
            TOTAL_1_BITS[i] = nibble[i >> 4] + nibble[i & 15];
          }
          module2.exports = Bitfield;
          function Bitfield(pageSize, pages) {
            if (!(this instanceof Bitfield))
              return new Bitfield(pageSize, pages);
            if (!pageSize)
              pageSize = 2048 + 1024 + 512;
            var deduplicate = Buffer.allocUnsafe(pageSize);
            deduplicate.fill(255);
            this.indexSize = pageSize - 2048 - 1024;
            this.pages = pager(pageSize, {
              deduplicate
            });
            if (pages) {
              for (var i2 = 0; i2 < pages.length; i2++) {
                this.pages.set(i2, pages[i2]);
              }
            }
            this.data = bitfield({
              pageSize: 1024,
              pageOffset: 0,
              pages: this.pages,
              trackUpdates: true
            });
            this.tree = bitfield({
              pageSize: 2048,
              pageOffset: 1024,
              pages: this.pages,
              trackUpdates: true
            });
            this.index = bitfield({
              pageSize: this.indexSize,
              pageOffset: 1024 + 2048,
              pages: this.pages,
              trackUpdates: true
            });
            this.length = this.data.length;
            this._iterator = flat.iterator(0);
          }
          Bitfield.prototype.set = function(i2, value) {
            var o = i2 & 7;
            i2 = (i2 - o) / 8;
            var v = value ? this.data.getByte(i2) | 128 >> o : this.data.getByte(i2) & DATA_UPDATE_MASK[o];
            if (!this.data.setByte(i2, v))
              return false;
            this.length = this.data.length;
            this._setIndex(i2, v);
            return true;
          };
          Bitfield.prototype.get = function(i2) {
            return this.data.get(i2);
          };
          Bitfield.prototype.total = function(start, end) {
            if (!start || start < 0)
              start = 0;
            if (!end)
              end = this.data.length;
            if (end < start)
              return 0;
            if (end > this.data.length) {
              this._expand(end);
            }
            var o = start & 7;
            var e = end & 7;
            var pos = (start - o) / 8;
            var last = (end - e) / 8;
            var leftMask = 255 - (o ? DATA_ITERATE_MASK[o - 1] : 0);
            var rightMask = e ? DATA_ITERATE_MASK[e - 1] : 0;
            var byte = this.data.getByte(pos);
            if (pos === last) {
              return TOTAL_1_BITS[byte & leftMask & rightMask];
            }
            var total = TOTAL_1_BITS[byte & leftMask];
            for (var i2 = pos + 1; i2 < last; i2++) {
              total += TOTAL_1_BITS[this.data.getByte(i2)];
            }
            total += TOTAL_1_BITS[this.data.getByte(last) & rightMask];
            return total;
          };
          Bitfield.prototype.compress = function(start, length) {
            if (!start && !length)
              return rle.encode(this.data.toBuffer());
            if (start + length > this.length)
              length = Math.max(1, this.length - start);
            var buf = Buffer.alloc(Math.ceil(length / 8));
            var p = start / this.data.pageSize / 8;
            var end = p + length / this.data.pageSize / 8;
            var offset = p * this.data.pageSize;
            for (; p < end; p++) {
              var page = this.data.pages.get(p, true);
              if (!page || !page.buffer)
                continue;
              page.buffer.copy(buf, p * this.data.pageSize - offset, this.data.pageOffset, this.data.pageOffset + this.data.pageSize);
            }
            return rle.encode(buf);
          };
          Bitfield.prototype._setIndex = function(i2, value) {
            var o = i2 & 3;
            i2 = (i2 - o) / 4;
            var bitfield2 = this.index;
            var ite = this._iterator;
            var start = 2 * i2;
            var byte = bitfield2.getByte(start) & INDEX_UPDATE_MASK[o] | getIndexValue(value) >> 2 * o;
            var len = bitfield2.length;
            var maxLength = this.pages.length * this.indexSize;
            ite.seek(start);
            while (ite.index < maxLength && bitfield2.setByte(ite.index, byte)) {
              if (ite.isLeft()) {
                byte = MAP_PARENT_LEFT[byte] | MAP_PARENT_RIGHT[bitfield2.getByte(ite.sibling())];
              } else {
                byte = MAP_PARENT_RIGHT[byte] | MAP_PARENT_LEFT[bitfield2.getByte(ite.sibling())];
              }
              ite.parent();
            }
            if (len !== bitfield2.length)
              this._expand(len);
            return ite.index !== start;
          };
          Bitfield.prototype._expand = function(len) {
            var roots = flat.fullRoots(2 * len);
            var bitfield2 = this.index;
            var ite = this._iterator;
            var byte = 0;
            for (var i2 = 0; i2 < roots.length; i2++) {
              ite.seek(roots[i2]);
              byte = bitfield2.getByte(ite.index);
              do {
                if (ite.isLeft()) {
                  byte = MAP_PARENT_LEFT[byte] | MAP_PARENT_RIGHT[bitfield2.getByte(ite.sibling())];
                } else {
                  byte = MAP_PARENT_RIGHT[byte] | MAP_PARENT_LEFT[bitfield2.getByte(ite.sibling())];
                }
              } while (setByteNoAlloc(bitfield2, ite.parent(), byte));
            }
          };
          function setByteNoAlloc(bitfield2, i2, b2) {
            if (8 * i2 >= bitfield2.length)
              return false;
            return bitfield2.setByte(i2, b2);
          }
          Bitfield.prototype.iterator = function(start, end) {
            var ite = new Iterator(this);
            ite.range(start || 0, end || this.length);
            ite.seek(0);
            return ite;
          };
          function Iterator(bitfield2) {
            this.start = 0;
            this.end = 0;
            this._indexEnd = 0;
            this._pos = 0;
            this._byte = 0;
            this._bitfield = bitfield2;
          }
          Iterator.prototype.range = function(start, end) {
            this.start = start;
            this.end = end;
            this._indexEnd = 2 * Math.ceil(end / 32);
            if (this.end > this._bitfield.length) {
              this._bitfield._expand(this.end);
            }
            return this;
          };
          Iterator.prototype.seek = function(offset) {
            offset += this.start;
            if (offset < this.start)
              offset = this.start;
            if (offset >= this.end) {
              this._pos = -1;
              return this;
            }
            var o = offset & 7;
            this._pos = (offset - o) / 8;
            this._byte = this._bitfield.data.getByte(this._pos) | (o ? DATA_ITERATE_MASK[o - 1] : 0);
            return this;
          };
          Iterator.prototype.random = function() {
            var i2 = this.seek(Math.floor(Math.random() * (this.end - this.start))).next();
            return i2 === -1 ? this.seek(0).next() : i2;
          };
          Iterator.prototype.next = function() {
            if (this._pos === -1)
              return -1;
            var dataBitfield = this._bitfield.data;
            var free = NEXT_DATA_0_BIT[this._byte];
            while (free === -1) {
              this._byte = dataBitfield.getByte(++this._pos);
              free = NEXT_DATA_0_BIT[this._byte];
              if (free === -1) {
                this._pos = this._skipAhead(this._pos);
                if (this._pos === -1)
                  return -1;
                this._byte = dataBitfield.getByte(this._pos);
                free = NEXT_DATA_0_BIT[this._byte];
              }
            }
            this._byte |= DATA_ITERATE_MASK[free];
            var n = 8 * this._pos + free;
            return n < this.end ? n : -1;
          };
          Iterator.prototype.peek = function() {
            if (this._pos === -1)
              return -1;
            var free = NEXT_DATA_0_BIT[this._byte];
            var n = 8 * this._pos + free;
            return n < this.end ? n : -1;
          };
          Iterator.prototype._skipAhead = function(start) {
            var indexBitfield = this._bitfield.index;
            var treeEnd = this._indexEnd;
            var ite = this._bitfield._iterator;
            var o = start & 3;
            ite.seek(2 * ((start - o) / 4));
            var treeByte = indexBitfield.getByte(ite.index) | INDEX_ITERATE_MASK[o];
            while (NEXT_INDEX_0_BIT[treeByte] === -1) {
              if (ite.isLeft()) {
                ite.next();
              } else {
                ite.next();
                ite.parent();
              }
              if (rightSpan(ite) >= treeEnd) {
                while (rightSpan(ite) >= treeEnd && isParent(ite)) {
                  ite.leftChild();
                }
                if (rightSpan(ite) >= treeEnd)
                  return -1;
              }
              treeByte = indexBitfield.getByte(ite.index);
            }
            while (ite.factor > 2) {
              if (NEXT_INDEX_0_BIT[treeByte] < 2)
                ite.leftChild();
              else
                ite.rightChild();
              treeByte = indexBitfield.getByte(ite.index);
            }
            var free = NEXT_INDEX_0_BIT[treeByte];
            if (free === -1)
              free = 4;
            var next = ite.index * 2 + free;
            return next <= start ? start + 1 : next;
          };
          function rightSpan(ite) {
            return ite.index + ite.factor / 2 - 1;
          }
          function isParent(ite) {
            return ite.index & 1;
          }
          function getIndexValue(n) {
            switch (n) {
              case 255:
                return 192;
              case 0:
                return 0;
              default:
                return 64;
            }
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "bitfield-rle": 40, "buffer": 82, "flat-tree": 200, "memory-pager": 298, "sparse-bitfield": 479 }], 232: [function(require2, module2, exports2) {
      var HypercoreCache = require2("hypercore-cache");
      var DEFAULT_TREE_CACHE_SIZE = 65536 * 40;
      function createCache(opts) {
        if (opts.cache === false)
          return {};
        var cacheOpts = opts.cache || {};
        if (cacheOpts.tree === void 0 || typeof cacheOpts.tree === "number") {
          var cacheSize = cacheOpts.tree || opts.storageCacheSize;
          cacheOpts.tree = new HypercoreCache({
            maxByteSize: cacheSize !== void 0 ? cacheSize : DEFAULT_TREE_CACHE_SIZE,
            estimateSize: () => 40
          });
        }
        if (cacheOpts.data === void 0)
          return cacheOpts;
        if (typeof cacheOpts.data === "number") {
          cacheOpts.data = new HypercoreCache({
            maxByteSize: cacheOpts.data,
            estimateSize: (buf) => buf.length
          });
        }
        return cacheOpts;
      }
      module2.exports = createCache;
    }, { "hypercore-cache": 226 }], 233: [function(require2, module2, exports2) {
      var Protocol = require2("hypercore-protocol");
      var timeout = require2("timeout-refresh");
      var bitfield = require2("fast-bitfield");
      var set = require2("unordered-set");
      var rle = require2("bitfield-rle").align(4);
      var treeIndex = require2("./tree-index");
      var EMPTY = new Uint8Array(1024);
      module2.exports = replicate;
      function replicate(feed, initiator, opts) {
        feed.ifAvailable.wait();
        var stream = Protocol.isProtocolStream(initiator) ? initiator : opts.stream;
        if (!stream) {
          if (!opts.keyPair)
            opts.keyPair = feed.noiseKeyPair;
          stream = new Protocol(initiator, opts);
        }
        if (feed.opened)
          onready(null);
        else
          feed.ready(onready);
        return stream;
        function onready(err) {
          feed.ifAvailable.continue();
          if (err)
            return stream.destroy(err);
          if (stream.destroyed)
            return;
          if (stream.opened(feed.key))
            return;
          if (opts.noise !== false) {
            if (stream.remoteOpened(feed.key) && !stream.remoteVerified(feed.key)) {
              stream.close(feed.discoveryKey);
              return;
            }
          }
          var peer = new Peer(feed, opts);
          peer.feed = feed;
          peer.stream = stream.open(feed.key, peer);
          stream.setMaxListeners(0);
          peer.ready();
        }
      }
      function Peer(feed, opts) {
        if (opts.extensions)
          throw new Error("Per peer extensions is not supported. Use feed.registerExtension instead");
        this.feed = feed;
        this.stream = null;
        this.wants = bitfield();
        this.remoteBitfield = bitfield();
        this.remoteLength = 0;
        this.remoteWant = false;
        this.remoteTree = null;
        this.remoteAck = false;
        this.remoteOpened = false;
        this.live = !!opts.live;
        this.sparse = feed.sparse;
        this.ack = !!opts.ack;
        this.remoteDownloading = true;
        this.remoteUploading = true;
        this.remoteExtensions = feed.extensions.remote();
        this.downloading = typeof opts.download === "boolean" ? opts.download : feed.downloading;
        this.uploading = typeof opts.upload === "boolean" ? opts.upload : feed.uploading;
        this.updated = false;
        this.maxRequests = opts.maxRequests || feed.maxRequests || 16;
        this.urgentRequests = this.maxRequests + 16;
        this.inflightRequests = [];
        this.inflightWants = 0;
        this._index = -1;
        this._lastBytes = 0;
        this._first = true;
        this._closed = false;
        this._destroyed = false;
        this._defaultDownloading = this.downloading;
        this._iterator = this.remoteBitfield.iterator();
        this._requestTimeout = null;
        this.stats = !opts.stats ? null : {
          uploadedBytes: 0,
          uploadedBlocks: 0,
          downloadedBytes: 0,
          downloadedBlocks: 0
        };
      }
      Object.defineProperty(Peer.prototype, "remoteAddress", {
        enumerable: true,
        get: function get() {
          return this.stream.stream.remoteAddress;
        }
      });
      Object.defineProperty(Peer.prototype, "remoteType", {
        enumerable: true,
        get: function get() {
          return this.stream.stream.remoteType;
        }
      });
      Object.defineProperty(Peer.prototype, "remotePublicKey", {
        enumerable: true,
        get: function get() {
          return this.stream.state.remotePublicKey;
        }
      });
      Peer.prototype.onwant = function(want) {
        if (!this.uploading)
          return;
        if (want.start & 8191 || want.length & 8191)
          return;
        if (!this.remoteWant && this.feed.length && this.feed.bitfield.get(this.feed.length - 1)) {
          this.stream.have({
            start: this.feed.length - 1
          });
        }
        this.remoteWant = true;
        var rle2 = this.feed.bitfield.compress(want.start, want.length);
        this.stream.have({
          start: want.start,
          length: want.length,
          bitfield: rle2
        });
      };
      Peer.prototype.ondata = function(data) {
        var self2 = this;
        var allowPush = this.feed.allowPush || !data.value;
        if (!allowPush && !this.feed._reserved.get(data.index)) {
          if (!self2.feed.bitfield.get(data.index))
            self2.unhave({
              start: data.index
            });
          self2._clear(data.index, !data.value);
          return;
        }
        this.feed._putBuffer(data.index, data.value, data, this, function(err) {
          if (err)
            return self2.destroy(err);
          if (data.value)
            self2.remoteBitfield.set(data.index, false);
          if (self2.remoteAck) {
            self2.stream.have({
              start: data.index,
              length: 1,
              ack: true
            });
          }
          if (self2.stats && data.value) {
            self2.stats.downloadedBlocks += 1;
            self2.stats.downloadedBytes += data.value.length;
          }
          self2._clear(data.index, !data.value);
        });
      };
      Peer.prototype._clear = function(index, hash) {
        for (var i = 0; i < this.inflightRequests.length; i++) {
          if (this.inflightRequests[i].index === index) {
            if (this._requestTimeout !== null)
              this._requestTimeout.refresh();
            this.inflightRequests.splice(i, 1);
            i--;
          }
        }
        this.feed._reserved.set(index, false);
        this.feed._updatePeers();
        if (this.inflightRequests.length === 0 && this._requestTimeout !== null) {
          this._requestTimeout.destroy();
          this._requestTimeout = null;
        }
      };
      Peer.prototype.onrequest = function(request) {
        if (!this.uploading)
          return;
        if (request.bytes)
          return this._onbytes(request);
        if (!this.remoteTree)
          this.remoteTree = treeIndex();
        var self2 = this;
        var opts = {
          digest: request.nodes,
          hash: request.hash,
          tree: this.remoteTree
        };
        this.feed.proof(request.index, opts, onproof);
        function onproof(err, proof) {
          if (err)
            return self2.destroy(err);
          if (request.hash)
            onvalue(null, null);
          else if (self2.feed.bitfield.get(request.index))
            self2.feed._getBuffer(request.index, onvalue);
          function onvalue(err2, value) {
            if (!self2.uploading)
              return;
            if (err2)
              return self2.destroy(err2);
            if (value) {
              if (self2.stats) {
                self2.stats.uploadedBlocks += 1;
                self2.stats.uploadedBytes += value.length;
                self2.feed._stats.uploadedBlocks += 1;
                self2.feed._stats.uploadedBytes += value.length;
              }
              self2.feed.emit("upload", request.index, value, self2);
            }
            if (request.index + 1 > self2.remoteLength) {
              self2.remoteLength = request.index + 1;
              self2._updateEnd();
            }
            self2.stream.data({
              index: request.index,
              value,
              nodes: proof.nodes,
              signature: proof.signature
            });
          }
        }
      };
      Peer.prototype._updateOptions = function() {
        if (this.ack || this.feed.extensions.length) {
          this.stream.options({
            ack: this.ack,
            extensions: this.feed.extensions.names()
          });
        }
      };
      Peer.prototype.setDownloading = function(downloading) {
        if (downloading === this.downloading)
          return;
        this.downloading = downloading;
        this.stream.status({
          downloading,
          uploading: this.uploading
        });
        this.update();
      };
      Peer.prototype.setUploading = function(uploading) {
        if (uploading === this.uploading)
          return;
        this.uploading = uploading;
        this.stream.status({
          downloading: this.downloading,
          uploading
        });
        this.update();
      };
      Peer.prototype._onbytes = function(request) {
        var self2 = this;
        this.feed.seek(request.bytes, {
          wait: false
        }, function(err, index) {
          if (err) {
            request.bytes = 0;
            self2.onrequest(request);
            return;
          }
          if (self2._lastBytes === request.bytes)
            return;
          self2._lastBytes = request.bytes;
          request.bytes = 0;
          request.index = index;
          request.nodes = 0;
          self2.onrequest(request);
        });
      };
      Peer.prototype._onrequesttimeout = function() {
        this._requestTimeout = null;
        if (!this.inflightRequests.length)
          return;
        var first = this.inflightRequests[0];
        if (first.hash ? this.feed.tree.get(2 * first.index) : this.feed.bitfield.get(first.index)) {
          this.inflightRequests.shift();
          this.feed._reserved.set(first.index, false);
          if (this.stream.stream.timeout) {
            this._requestTimeout = timeout(this.stream.stream.timeout.ms, this._onrequesttimeout, this);
          }
          return;
        }
        this.destroy(new Error("Request timeout"));
      };
      Peer.prototype.onhave = function(have) {
        if (this.ack && have.ack && !have.bitfield && this.feed.bitfield.get(have.start)) {
          this.stream.stream.emit("ack", have);
          return;
        }
        var updated = this._first;
        if (this._first)
          this._first = false;
        if (have.length === 1024 * 1024 && this.inflightWants > 0) {
          this.feed.ifAvailable.continue();
          this.inflightWants--;
        }
        if (have.bitfield) {
          if (have.length === 0 || have.length === 1) {
            this.wants = null;
          }
          var buf = rle.decode(have.bitfield);
          var bits = buf.length * 8;
          remoteAndNotLocal(this.feed.bitfield, buf, this.remoteBitfield.littleEndian, have.start);
          this.remoteBitfield.fill(buf, have.start);
          if (bits > this.remoteLength) {
            this.remoteLength = this.remoteBitfield.last() + 1;
            updated = true;
          }
        } else {
          var start = have.start;
          var len = have.length || 1;
          while (len--) {
            this.remoteBitfield.set(start, !this.feed.bitfield.get(start++));
          }
          if (start > this.remoteLength) {
            this.remoteLength = start;
            updated = true;
          }
        }
        if (updated) {
          this.updated = true;
          this.feed.emit("remote-update", this);
        }
        this._updateEnd();
        this.update();
      };
      Peer.prototype._updateEnd = function() {
        if (this.live || this.feed.sparse || !this.feed._selections.length)
          return;
        var sel = this.feed._selections[0];
        var remoteLength = this.feed.length || -1;
        for (var i = 0; i < this.feed.peers.length; i++) {
          if (this.feed.peers[i].remoteLength > remoteLength) {
            remoteLength = this.feed.peers[i].remoteLength;
          }
        }
        sel.end = remoteLength;
      };
      Peer.prototype.onextension = function(id, message) {
        this.remoteExtensions.onmessage(id, message, this);
      };
      Peer.prototype.onstatus = function(info) {
        this.remoteUploading = info.uploading;
        this.remoteDownloading = info.downloading;
        if (!info.uploading) {
          while (this.inflightRequests.length) {
            var data = this.inflightRequests[0];
            this._clear(data.index, !data.value);
          }
          for (var i = 0; i < this.inflightWants; i++) {
            this.feed.ifAvailable.continue();
          }
          this.inflightWants = 0;
          this.wants = bitfield();
        }
        this.update();
        if (info.downloading || this.live)
          return;
        if (this.feed._selections.length && this.downloading)
          return;
        this._autoEnd();
      };
      Peer.prototype._autoEnd = function() {
        if (this.uploading && this.remoteDownloading)
          return;
        if ((this.sparse || this.live) && (this.remoteUploading || this.downloading))
          return;
        this.end();
      };
      Peer.prototype.onunhave = function(unhave) {
        var start = unhave.start;
        var len = unhave.length || 1;
        if (start === 0 && len >= this.remoteLength) {
          this.remoteLength = 0;
          this.remoteBitfield = bitfield();
          return;
        }
        while (len--) {
          this.remoteBitfield.set(start++, false);
        }
      };
      Peer.prototype.onunwant = Peer.prototype.oncancel = function() {
      };
      Peer.prototype.onclose = function() {
        this._close();
      };
      Peer.prototype.have = function(have) {
        if (this.stream && this.remoteWant)
          this.stream.have(have);
        var start = have.start;
        var len = have.length;
        while (len--) {
          this.remoteBitfield.set(start++, false);
        }
      };
      Peer.prototype.unhave = function(unhave) {
        if (this.stream && this.remoteWant)
          this.stream.unhave(unhave);
      };
      Peer.prototype.haveBytes = function(bytes) {
        for (var i = 0; i < this.inflightRequests.length; i++) {
          if (this.inflightRequests[i].bytes === bytes) {
            this.feed._reserved.set(this.inflightRequests[i].index, false);
            this.inflightRequests.splice(i, 1);
            i--;
          }
        }
        this.update();
        if (this.inflightRequests.length === 0 && this._requestTimeout !== null) {
          this._requestTimeout.destroy();
          this._requestTimeout = null;
        }
      };
      Peer.prototype.update = function() {
        while (this._update()) {
        }
        this._sendWantsMaybe();
      };
      Peer.prototype._update = function() {
        if (!this.downloading || !this.remoteUploading)
          return false;
        var selections = this.feed._selections;
        var waiting = this.feed._waiting;
        var wlen = waiting.length;
        var slen = selections.length;
        var inflight = this.inflightRequests.length;
        var offset = 0;
        var i = 0;
        while (inflight < this.urgentRequests) {
          offset = Math.floor(Math.random() * waiting.length);
          for (i = 0; i < waiting.length; i++) {
            var w = waiting[offset++];
            if (offset === waiting.length)
              offset = 0;
            this._downloadWaiting(w);
            if (waiting.length !== wlen)
              return true;
            if (this.inflightRequests.length >= this.urgentRequests)
              return false;
          }
          if (inflight === this.inflightRequests.length)
            break;
          inflight = this.inflightRequests.length;
        }
        while (inflight < this.maxRequests) {
          offset = Math.floor(Math.random() * selections.length);
          for (i = 0; i < selections.length; i++) {
            var s = selections[offset++];
            if (offset === selections.length)
              offset = 0;
            if (!s.iterator)
              s.iterator = this.feed.bitfield.iterator(s.start, s.end);
            if (s.blocks)
              this._downloadBlocks(s);
            else
              this._downloadRange(s);
            if (selections.length !== slen)
              return true;
            if (this.inflightRequests.length >= this.maxRequests)
              return false;
          }
          if (inflight === this.inflightRequests.length)
            return false;
          inflight = this.inflightRequests.length;
        }
        return false;
      };
      Peer.prototype.onopen = function() {
        this.feed.ifAvailable.continue();
        this.remoteOpened = true;
        this._updateOptions();
        if (!this.uploading || !this.downloading) {
          this.stream.status({
            uploading: this.uploading,
            downloading: this.downloading
          });
        }
        this._sendWants();
        this.feed.emit("peer-open", this);
      };
      Peer.prototype.onoptions = function(options) {
        this.remoteAck = options.ack;
        this.remoteExtensions.update(options.extensions);
      };
      Peer.prototype.ready = function() {
        this.feed.ifAvailable.wait();
        set.add(this.feed.peers, this);
        this.feed.emit("peer-add", this);
        if (this.stream.remoteOpened)
          this.onopen();
      };
      Peer.prototype.end = function() {
        if (!this.downloading && !this.remoteDownloading && !this.live) {
          if (!this._defaultDownloading) {
            this.stream.status({
              downloading: false,
              uploading: false
            });
          }
          this._close();
          return;
        }
        if (!this._closed) {
          this._closed = true;
          this.downloading = false;
          this.stream.status({
            downloading: false,
            uploading: true
          });
        } else {
          if (!this.live)
            this._close();
        }
      };
      Peer.prototype._close = function() {
        if (!this._destroyed) {
          this._destroyed = true;
          this.stream.close();
        }
        if (this._index === -1)
          return;
        set.remove(this.feed.peers, this);
        this._index = -1;
        for (var i = 0; i < this.inflightRequests.length; i++) {
          this.feed._reserved.set(this.inflightRequests[i].index, false);
        }
        if (this._requestTimeout !== null) {
          this._requestTimeout.destroy();
          this._requestTimeout = null;
        }
        this._updateEnd();
        this.remoteWant = false;
        this.feed._updatePeers();
        this.feed.emit("peer-remove", this);
        for (i = 0; i < this.inflightWants; i++) {
          this.feed.ifAvailable.continue();
        }
        if (!this.remoteOpened) {
          this.feed.ifAvailable.continue();
        }
      };
      Peer.prototype.destroy = function(err) {
        if (this._index === -1 || this._destroyed)
          return;
        this.stream.destroy(err);
        this._destroyed = true;
        this._close();
      };
      Peer.prototype._sendWantsMaybe = function() {
        if (this.inflightRequests.length < this.urgentRequests)
          this._sendWants();
      };
      Peer.prototype._sendWants = function() {
        if (!this.wants || !this.downloading || !this.remoteOpened || !this.remoteUploading)
          return;
        if (this.inflightWants >= 16)
          return;
        var i;
        for (i = 0; i < this.feed._waiting.length; i++) {
          var w = this.feed._waiting[i];
          if (w.index === -1)
            this._sendWantRange(w);
          else
            this._sendWant(w.index);
          if (this.inflightWants >= 16)
            return;
        }
        for (i = 0; i < this.feed._selections.length; i++) {
          var s = this.feed._selections[i];
          this._sendWantRange(s);
          if (this.inflightWants >= 16)
            return;
        }
        this._sendWant(0);
      };
      Peer.prototype._sendWantRange = function(s) {
        if (s.blocks) {
          if (!s.selected)
            s.selected = /* @__PURE__ */ new WeakSet();
          if (s.selected.has(this))
            return;
          s.selected.add(this);
          for (var block of s.blocks) {
            this._sendWant(block);
          }
          return;
        }
        var want = s.start ? 1024 * 1024 * Math.floor(s.start / 1024 / 1024) : 0;
        while (true) {
          if (want >= this.remoteLength)
            return;
          if (s.end !== -1 && want >= s.end)
            return;
          if (this._sendWant(want))
            return;
          if (!this.wants.get(Math.floor(want / 1024 / 1024)))
            return;
          want += 1024 * 1024;
        }
      };
      Peer.prototype._sendWant = function(index) {
        var len = 1024 * 1024;
        var j = Math.floor(index / len);
        if (this.wants.get(j))
          return false;
        this.wants.set(j, true);
        this.inflightWants++;
        this.feed.ifAvailable.wait();
        this.stream.want({
          start: j * len,
          length: len
        });
        return true;
      };
      Peer.prototype._downloadWaiting = function(wait) {
        if (!wait.bytes) {
          if (!this.remoteBitfield.get(wait.index) || !this.feed._reserved.set(wait.index, true)) {
            if (!wait.update || this.feed._reserved.get(wait.index))
              return;
            var i = this._iterator.seek(wait.index).next(true);
            if (i === -1 || !this.feed._reserved.set(i, true))
              return;
            wait.index = i;
          }
          this._request(wait.index, 0, wait.hash === true);
          return;
        }
        this._downloadRange(wait);
      };
      Peer.prototype._downloadBlocks = function(range) {
        while (range.blocksDownloaded < range.blocks.length) {
          var blk = range.blocks[range.blocksDownloaded];
          if (!this.feed.bitfield.get(blk))
            break;
          range.blocksDownloaded++;
        }
        if (range.blocksDownloaded >= range.blocks.length) {
          set.remove(this.feed._selections, range);
          range.callback(null);
          return;
        }
        for (var i = range.blocksDownloaded; i < range.blocks.length; i++) {
          var _blk = range.blocks[i];
          if (this.remoteBitfield.get(_blk) && this.feed._reserved.set(_blk, true)) {
            range.requested++;
            this._request(_blk, 0, false);
            return;
          }
        }
      };
      Peer.prototype._downloadRange = function(range) {
        if (!range.iterator)
          range.iterator = this.feed.bitfield.iterator(range.start, range.end);
        var reserved = this.feed._reserved;
        var ite = this._iterator;
        var wantedEnd = Math.min(range.end === -1 ? this.remoteLength : range.end, this.remoteLength);
        var i = range.linear ? ite.seek(range.start).next(true) : nextRandom(ite, range.start, wantedEnd);
        var start = i;
        if (i === -1 || i >= wantedEnd) {
          if (!range.bytes && range.end > -1 && this.feed.length >= range.end && range.iterator.seek(0).next() === -1) {
            set.remove(this.feed._selections, range);
            range.callback(null);
            if (!this.live && !this.sparse && !this.feed._selections.length)
              this.end();
          }
          return;
        }
        while (range.hash && this.feed.tree.get(2 * i) || !reserved.set(i, true)) {
          i = ite.next(true);
          if (i > -1 && i < wantedEnd) {
            continue;
          }
          if (!range.linear && start !== 0) {
            i = ite.seek(range.start).next(true);
            start = 0;
            if (i > -1 && i < wantedEnd)
              continue;
          }
          if (range.hash) {
            for (var j = range.start; j < wantedEnd; j++) {
              if (!this.feed.tree.get(2 * j))
                return;
            }
            if (!range.bytes) {
              set.remove(this.feed._selections, range);
              range.callback(null);
            }
          }
          return;
        }
        range.requested++;
        this._request(i, range.bytes || 0, range.hash);
      };
      Peer.prototype._request = function(index, bytes, hash) {
        var request = {
          bytes,
          index,
          hash,
          nodes: this.feed.digest(index)
        };
        if (this._requestTimeout === null && this.stream.stream.timeout) {
          this._requestTimeout = timeout(this.stream.stream.timeout.ms, this._onrequesttimeout, this);
        }
        this.inflightRequests.push(request);
        this.stream.request(request);
      };
      Peer.prototype.extension = function(id, message) {
        this.stream.extension(id, message);
      };
      function createView(page) {
        var buf = page ? page.buffer : EMPTY;
        return new DataView(buf.buffer, buf.byteOffset, 1024);
      }
      function remoteAndNotLocal(local, buf, le, start) {
        var remote = new DataView(buf.buffer, buf.byteOffset);
        var len = Math.floor(buf.length / 4);
        var arr = new Uint32Array(buf.buffer, buf.byteOffset, len);
        var p = start / 8192;
        var l = 0;
        var page = createView(local.pages.get(p++, true));
        for (var i = 0; i < len; i++) {
          arr[i] = remote.getUint32(4 * i, !le) & ~page.getUint32(4 * l++, !le);
          if (l === 256) {
            page = createView(local.pages.get(p++, true));
            l = 0;
          }
        }
      }
      function nextRandom(ite, start, end) {
        var len = end - start;
        var i = ite.seek(Math.floor(Math.random() * len) + start).next(true);
        return i === -1 || i >= end ? ite.seek(start).next(true) : i;
      }
    }, { "./tree-index": 236, "bitfield-rle": 40, "fast-bitfield": 195, "hypercore-protocol": 228, "timeout-refresh": 505, "unordered-set": 510 }], 234: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          module2.exports = function safeBufferEquals(a, b) {
            if (!a)
              return !b;
            if (!b)
              return !a;
            return Buffer.compare(a, b) === 0;
          };
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82 }], 235: [function(require2, module2, exports2) {
      (function(process, Buffer) {
        (function() {
          var uint64be = require2("uint64be");
          var flat = require2("flat-tree");
          var createCache = require2("./cache");
          module2.exports = Storage;
          var noarr = [];
          function Storage(create, opts) {
            if (!(this instanceof Storage))
              return new Storage(create, opts);
            var cache = createCache(opts);
            this.treeCache = cache.tree || null;
            this.dataCache = cache.data || null;
            this.key = null;
            this.secretKey = null;
            this.tree = null;
            this.data = null;
            this.bitfield = null;
            this.signatures = null;
            this.create = create;
          }
          Storage.prototype.putData = function(index, data, nodes, cb) {
            if (!cb)
              cb = noop;
            var self2 = this;
            if (!data.length)
              return cb(null);
            this.dataOffset(index, nodes, function(err, offset, size) {
              if (err)
                return cb(err);
              if (size !== data.length)
                return cb(new Error("Unexpected data size"));
              self2.data.write(offset, data, cb);
            });
          };
          Storage.prototype.getData = function(index, cb) {
            var self2 = this;
            var cached = this.dataCache && this.dataCache.get(index);
            if (cached)
              return process.nextTick(cb, null, cached);
            this.dataOffset(index, noarr, function(err, offset, size) {
              if (err)
                return cb(err);
              self2.data.read(offset, size, (err2, data) => {
                if (err2)
                  return cb(err2);
                if (self2.dataCache)
                  self2.dataCache.set(index, data);
                return cb(null, data);
              });
            });
          };
          Storage.prototype.nextSignature = function(index, cb) {
            var self2 = this;
            this._getSignature(index, function(err, signature) {
              if (err)
                return cb(err);
              if (isBlank(signature))
                return self2.nextSignature(index + 1, cb);
              cb(null, {
                index,
                signature
              });
            });
          };
          Storage.prototype.getSignature = function(index, cb) {
            this._getSignature(index, function(err, signature) {
              if (err)
                return cb(err);
              if (isBlank(signature))
                return cb(new Error("No signature found"));
              cb(null, signature);
            });
          };
          Storage.prototype._getSignature = function(index, cb) {
            this.signatures.read(32 + 64 * index, 64, cb);
          };
          Storage.prototype.putSignature = function(index, signature, cb) {
            this.signatures.write(32 + 64 * index, signature, cb);
          };
          Storage.prototype.deleteSignatures = function(start, end, cb) {
            this.signatures.del(32 + 64 * start, (end - start) * 64, cb);
          };
          Storage.prototype.dataOffset = function(index, cachedNodes, cb) {
            var roots = flat.fullRoots(2 * index);
            var self2 = this;
            var offset = 0;
            var pending = roots.length;
            var error = null;
            var blk = 2 * index;
            if (!pending) {
              pending = 1;
              onnode(null, null);
              return;
            }
            for (var i = 0; i < roots.length; i++) {
              var node = findNode(cachedNodes, roots[i]);
              if (node)
                onnode(null, node);
              else
                this.getNode(roots[i], onnode);
            }
            function onlast(err, node2) {
              if (err)
                return cb(err);
              cb(null, offset, node2.size);
            }
            function onnode(err, node2) {
              if (err)
                error = err;
              if (node2)
                offset += node2.size;
              if (--pending)
                return;
              if (error)
                return cb(error);
              var last = findNode(cachedNodes, blk);
              if (last)
                onlast(null, last);
              else
                self2.getNode(blk, onlast);
            }
          };
          Storage.prototype.getDataBatch = function(start, n, cb) {
            var result = new Array(n);
            var sizes = new Array(n);
            var self2 = this;
            this.dataOffset(start, noarr, function(err, offset, size) {
              if (err)
                return cb(err);
              start++;
              n--;
              if (n <= 0)
                return ontree(null, null);
              self2.tree.read(32 + 80 * start, 80 * n - 40, ontree);
              function ontree(err2, buf) {
                if (err2)
                  return cb(err2);
                var total = sizes[0] = size;
                if (buf) {
                  for (var i = 1; i < sizes.length; i++) {
                    sizes[i] = uint64be.decode(buf, 32 + (i - 1) * 80);
                    total += sizes[i];
                  }
                }
                self2.data.read(offset, total, ondata);
              }
              function ondata(err2, buf) {
                if (err2)
                  return cb(err2);
                var total = 0;
                for (var i = 0; i < result.length; i++) {
                  result[i] = buf.slice(total, total += sizes[i]);
                }
                cb(null, result);
              }
            });
          };
          Storage.prototype.getNode = function(index, cb) {
            if (this.treeCache) {
              var cached = this.treeCache.get(index);
              if (cached)
                return cb(null, cached);
            }
            var self2 = this;
            this.tree.read(32 + 40 * index, 40, function(err, buf) {
              if (err)
                return cb(err);
              var hash = buf.slice(0, 32);
              var size = uint64be.decode(buf, 32);
              if (!size && isBlank(hash))
                return cb(new Error("No node found"));
              var val = new Node(index, hash, size);
              if (self2.treeCache)
                self2.treeCache.set(index, val);
              cb(null, val);
            });
          };
          Storage.prototype.putNodeBatch = function(index, nodes, cb) {
            if (!cb)
              cb = noop;
            var buf = Buffer.alloc(nodes.length * 40);
            for (var i = 0; i < nodes.length; i++) {
              var offset = i * 40;
              var node = nodes[i];
              if (!node)
                continue;
              node.hash.copy(buf, offset);
              uint64be.encode(node.size, buf, 32 + offset);
            }
            this.tree.write(32 + 40 * index, buf, cb);
          };
          Storage.prototype.putNode = function(index, node, cb) {
            if (!cb)
              cb = noop;
            var buf = Buffer.allocUnsafe(40);
            node.hash.copy(buf, 0);
            uint64be.encode(node.size, buf, 32);
            this.tree.write(32 + 40 * index, buf, cb);
          };
          Storage.prototype.putBitfield = function(offset, data, cb) {
            this.bitfield.write(32 + offset, data, cb);
          };
          Storage.prototype.close = function(cb) {
            if (!cb)
              cb = noop;
            var missing = 6;
            var error = null;
            close(this.bitfield, done);
            close(this.tree, done);
            close(this.data, done);
            close(this.key, done);
            close(this.secretKey, done);
            close(this.signatures, done);
            function done(err) {
              if (err)
                error = err;
              if (--missing)
                return;
              cb(error);
            }
          };
          Storage.prototype.destroy = function(cb) {
            if (!cb)
              cb = noop;
            var missing = 6;
            var error = null;
            destroy(this.bitfield, done);
            destroy(this.tree, done);
            destroy(this.data, done);
            destroy(this.key, done);
            destroy(this.secretKey, done);
            destroy(this.signatures, done);
            function done(err) {
              if (err)
                error = err;
              if (--missing)
                return;
              cb(error);
            }
          };
          Storage.prototype.openKey = function(opts, cb) {
            if (typeof opts === "function")
              return this.openKey({}, opts);
            if (!this.key)
              this.key = this.create("key", opts);
            this.key.read(0, 32, cb);
          };
          Storage.prototype.open = function(opts, cb) {
            if (typeof opts === "function")
              return this.open({}, opts);
            var self2 = this;
            var error = null;
            var missing = 5;
            if (!this.key)
              this.key = this.create("key", opts);
            if (!this.secretKey)
              this.secretKey = this.create("secret_key", opts);
            if (!this.tree)
              this.tree = this.create("tree", opts);
            if (!this.data)
              this.data = this.create("data", opts);
            if (!this.bitfield)
              this.bitfield = this.create("bitfield", opts);
            if (!this.signatures)
              this.signatures = this.create("signatures", opts);
            var result = {
              bitfield: [],
              bitfieldPageSize: 3584,
              secretKey: null,
              key: null
            };
            this.bitfield.read(0, 32, function(err, h) {
              if (err && err.code === "ELOCKED")
                return cb(err);
              if (h)
                result.bitfieldPageSize = h.readUInt16BE(5);
              self2.bitfield.write(0, header(0, result.bitfieldPageSize, null), function(err2) {
                if (err2)
                  return cb(err2);
                readAll(self2.bitfield, 32, result.bitfieldPageSize, function(err3, pages) {
                  if (pages)
                    result.bitfield = pages;
                  done(err3);
                });
              });
            });
            this.signatures.write(0, header(1, 64, "Ed25519"), done);
            this.tree.write(0, header(2, 40, "BLAKE2b"), done);
            this.secretKey.read(0, 64, function(_, data) {
              if (data)
                result.secretKey = data;
              done(null);
            });
            this.key.read(0, 32, function(_, data) {
              if (data)
                result.key = data;
              done(null);
            });
            function done(err) {
              if (err)
                error = err;
              if (--missing)
                return;
              if (error)
                cb(error);
              else
                cb(null, result);
            }
          };
          Storage.Node = Node;
          function noop() {
          }
          function header(type, size, name) {
            var buf = Buffer.alloc(32);
            buf[0] = 5;
            buf[1] = 2;
            buf[2] = 87;
            buf[3] = type;
            buf[4] = 0;
            buf.writeUInt16BE(size, 5);
            if (name) {
              buf[7] = name.length;
              buf.write(name, 8);
            }
            return buf;
          }
          function Node(index, hash, size) {
            this.index = index;
            this.hash = hash;
            this.size = size;
          }
          function findNode(nodes, index) {
            for (var i = 0; i < nodes.length; i++) {
              if (nodes[i].index === index)
                return nodes[i];
            }
            return null;
          }
          function isBlank(buf) {
            for (var i = 0; i < buf.length; i++) {
              if (buf[i])
                return false;
            }
            return true;
          }
          function close(st, cb) {
            if (st.close)
              st.close(cb);
            else
              cb();
          }
          function destroy(st, cb) {
            if (st.destroy)
              st.destroy(cb);
            else
              cb();
          }
          function statAndReadAll(st, offset, pageSize, cb) {
            st.stat(function(err, stat) {
              if (err)
                return cb(null, []);
              var result = [];
              loop(null, null);
              function loop(err2, batch) {
                if (err2)
                  return cb(err2);
                if (batch) {
                  offset += batch.length;
                  for (var i = 0; i < batch.length; i += pageSize) {
                    result.push(batch.slice(i, i + pageSize));
                  }
                }
                var next = Math.min(stat.size - offset, 32 * pageSize);
                if (!next)
                  return cb(null, result);
                st.read(offset, next, loop);
              }
            });
          }
          function readAll(st, offset, pageSize, cb) {
            if (st.statable === true)
              return statAndReadAll(st, offset, pageSize, cb);
            var bufs = [];
            st.read(offset, pageSize, loop);
            function loop(err, buf) {
              if (err)
                return cb(null, bufs);
              bufs.push(buf);
              st.read(offset + bufs.length * pageSize, pageSize, loop);
            }
          }
        }).call(this);
      }).call(this, require2("_process"), require2("buffer").Buffer);
    }, { "./cache": 232, "_process": 361, "buffer": 82, "flat-tree": 200, "uint64be": 237 }], 236: [function(require2, module2, exports2) {
      var flat = require2("flat-tree");
      var bitfield = require2("sparse-bitfield");
      module2.exports = TreeIndex;
      function TreeIndex(bits) {
        if (!(this instanceof TreeIndex))
          return new TreeIndex(bits);
        this.bitfield = bits || bitfield();
      }
      TreeIndex.prototype.proof = function(index, opts) {
        if (!opts)
          opts = {};
        var nodes = [];
        var remoteTree = opts.tree || new TreeIndex();
        var digest = opts.digest || 0;
        if (!this.get(index))
          return null;
        if (opts.hash)
          nodes.push(index);
        if (digest === 1)
          return {
            nodes,
            verifiedBy: 0
          };
        var roots = null;
        var sibling = index;
        var next = index;
        var hasRoot = digest & 1;
        digest = rightShift(digest);
        while (digest) {
          if (digest === 1 && hasRoot) {
            if (this.get(next))
              remoteTree.set(next);
            if (flat.sibling(next) < next)
              next = flat.sibling(next);
            roots = flat.fullRoots(flat.rightSpan(next) + 2);
            for (var i = 0; i < roots.length; i++) {
              if (this.get(roots[i]))
                remoteTree.set(roots[i]);
            }
            break;
          }
          sibling = flat.sibling(next);
          if (digest & 1) {
            if (this.get(sibling))
              remoteTree.set(sibling);
          }
          next = flat.parent(next);
          digest = rightShift(digest);
        }
        next = index;
        while (!remoteTree.get(next)) {
          sibling = flat.sibling(next);
          if (!this.get(sibling)) {
            var verifiedBy = this.verifiedBy(next);
            addFullRoots(verifiedBy, nodes, next, remoteTree);
            return {
              nodes,
              verifiedBy
            };
          } else {
            if (!remoteTree.get(sibling))
              nodes.push(sibling);
          }
          next = flat.parent(next);
        }
        return {
          nodes,
          verifiedBy: 0
        };
      };
      TreeIndex.prototype.digest = function(index) {
        if (this.get(index))
          return 1;
        var digest = 0;
        var next = flat.sibling(index);
        var max = Math.max(next + 2, this.bitfield.length);
        var bit = 2;
        var depth = flat.depth(index);
        var parent = flat.parent(next, depth++);
        while (flat.rightSpan(next) < max || flat.leftSpan(parent) > 0) {
          if (this.get(next)) {
            digest += bit;
          }
          if (this.get(parent)) {
            digest += 2 * bit;
            if (!(digest & 1))
              digest += 1;
            if (digest + 1 === 4 * bit)
              return 1;
            return digest;
          }
          next = flat.sibling(parent);
          parent = flat.parent(next, depth++);
          bit *= 2;
        }
        return digest;
      };
      TreeIndex.prototype.blocks = function() {
        var top = 0;
        var next = 0;
        var max = this.bitfield.length;
        while (flat.rightSpan(next) < max) {
          next = flat.parent(next);
          if (this.get(next))
            top = next;
        }
        return (this.get(top) ? this.verifiedBy(top) : 0) / 2;
      };
      TreeIndex.prototype.roots = function() {
        return flat.fullRoots(2 * this.blocks());
      };
      TreeIndex.prototype.verifiedBy = function(index, nodes) {
        var hasIndex = this.get(index);
        if (!hasIndex)
          return 0;
        var depth = flat.depth(index);
        var top = index;
        var parent = flat.parent(top, depth++);
        while (this.get(parent) && this.get(flat.sibling(top))) {
          top = parent;
          parent = flat.parent(top, depth++);
        }
        depth--;
        while (depth) {
          top = flat.leftChild(flat.index(depth, flat.offset(top, depth) + 1), depth);
          depth--;
          while (!this.get(top) && depth) {
            top = flat.leftChild(top, depth--);
          }
          if (nodes && this.get(top))
            nodes.push(top);
        }
        return this.get(top) ? top + 2 : top;
      };
      TreeIndex.prototype.get = function(index) {
        return this.bitfield.get(index);
      };
      TreeIndex.prototype.truncate = function(len) {
        var currentLen = 2 * this.blocks();
        var roots = flat.fullRoots(len);
        for (var i = len; i < currentLen; i++) {
          this.bitfield.set(i, false);
        }
        for (var root of roots) {
          var p = flat.parent(root);
          while (p < len) {
            this.bitfield.set(p, false);
            p = flat.parent(p);
          }
        }
      };
      TreeIndex.prototype.set = function(index) {
        if (!this.bitfield.set(index, true))
          return false;
        while (this.bitfield.get(flat.sibling(index))) {
          index = flat.parent(index);
          if (!this.bitfield.set(index, true))
            break;
        }
        return true;
      };
      function rightShift(n) {
        return (n - (n & 1)) / 2;
      }
      function addFullRoots(verifiedBy, nodes, root, remoteTree) {
        var roots = flat.fullRoots(verifiedBy);
        for (var i = 0; i < roots.length; i++) {
          if (roots[i] !== root && !remoteTree.get(roots[i]))
            nodes.push(roots[i]);
        }
      }
    }, { "flat-tree": 200, "sparse-bitfield": 479 }], 237: [function(require2, module2, exports2) {
      var bufferAlloc = require2("buffer-alloc");
      var UINT_32_MAX = Math.pow(2, 32);
      exports2.encodingLength = function() {
        return 8;
      };
      exports2.encode = function(num, buf, offset) {
        if (!buf)
          buf = bufferAlloc(8);
        if (!offset)
          offset = 0;
        var top = Math.floor(num / UINT_32_MAX);
        var rem = num - top * UINT_32_MAX;
        buf.writeUInt32BE(top, offset);
        buf.writeUInt32BE(rem, offset + 4);
        return buf;
      };
      exports2.decode = function(buf, offset) {
        if (!offset)
          offset = 0;
        var top = buf.readUInt32BE(offset);
        var rem = buf.readUInt32BE(offset + 4);
        return top * UINT_32_MAX + rem;
      };
      exports2.encode.bytes = 8;
      exports2.decode.bytes = 8;
    }, { "buffer-alloc": 84 }], 238: [function(require2, module2, exports2) {
      (function(process, Buffer) {
        (function() {
          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              if (enumerableOnly)
                symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
              keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              if (i % 2) {
                ownKeys(Object(source), true).forEach(function(key) {
                  _defineProperty(target, key, source[key]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys(Object(source)).forEach(function(key) {
                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
              }
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var Corestore = require2("corestore");
          var hcrypto = require2("hypercore-crypto");
          var Protocol = require2("hypercore-protocol");
          var Nanoresource = require2("nanoresource/emitter");
          var collect = require2("stream-collector");
          var debug = require2("debug")("multifeed");
          var raf = require2("random-access-file");
          var through = require2("through2");
          var {
            MuxerTopic
          } = require2("./networker");
          var DEFAULT_ROOT_KEY = Buffer.from("bee80ff3a4ee5e727dc44197cb9d25bf8f19d50b0f3ad2984cfe5b7d14e75de7", "hex");
          var MULTIFEED_NAMESPACE_PREFIX = "@multifeed:";
          var FEED_NAMESPACE_PREFIX = "@multifeed:feed:";
          var PERSIST_NAMESPACE = "@multifeed:persist";
          class Multifeed extends Nanoresource {
            constructor(storage) {
              var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              super();
              this._opts = opts;
              this._id = hcrypto.randomBytes(2).toString("hex");
              this._rootKey = opts.rootKey || opts.encryptionKey || opts.key;
              if (this._rootKey && !Buffer.isBuffer(this._rootKey)) {
                this._rootKey = Buffer.from(this._rootKey, "hex");
              }
              if (!this._rootKey) {
                debug("WARNING: Using insecure default root key");
                this._rootKey = DEFAULT_ROOT_KEY;
              }
              this._corestore = defaultCorestore(storage, opts).namespace(MULTIFEED_NAMESPACE_PREFIX + this._rootKey.toString("hex"));
              this._handlers = opts.handlers || new MultifeedPersistence(this._corestore);
              this._feedsByKey = /* @__PURE__ */ new Map();
              this._feedsByName = /* @__PURE__ */ new Map();
              this.ready = this.open.bind(this);
            }
            get key() {
              return this._rootKey;
            }
            get discoveryKey() {
              if (!this._discoveryKey)
                this._discoveryKey = hcrypto.discoveryKey(this._rootKey);
              return this._discoveryKey;
            }
            _open(cb) {
              this._corestore.ready((err) => {
                if (err)
                  return cb(err);
                this._handlers.ready((err2) => {
                  if (err2)
                    return cb(err2);
                  this._muxer = this._opts.muxer || new MuxerTopic(this._corestore, this._rootKey, this._opts);
                  this._muxer.on("feed", (feed) => {
                    this._addFeed(feed, null, true);
                  });
                  this._fetchFeeds(cb);
                });
              });
            }
            _close(cb) {
              var self2 = this;
              var pending = 1;
              if (this._handlers.close)
                ++pending && this._handlers.close(onclose);
              this._corestore.close(onclose);
              function onclose() {
                if (--pending !== 0)
                  return;
                self2._feedsByKey = /* @__PURE__ */ new Map();
                self2._feedsByName = /* @__PURE__ */ new Map();
                self2._rootKey = null;
                cb();
              }
            }
            _addFeed(feed, name) {
              var save = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              if (this._feedsByKey.has(feed.key.toString("hex")))
                return;
              if (!name)
                name = String(this._feedsByKey.size);
              if (save)
                this._storeFeed(feed, name);
              this._feedsByName.set(name, feed);
              this._feedsByKey.set(feed.key.toString("hex"), feed);
              this._muxer.addFeed(feed);
              this.emit("feed", feed, name);
            }
            _storeFeed(feed, name) {
              var info = {
                key: feed.key.toString("hex"),
                name
              };
              this._handlers.storeFeed(info, (err) => {
                if (err)
                  this.emit("error", err);
              });
            }
            _fetchFeeds(cb) {
              this._handlers.fetchFeeds((err, infos) => {
                if (err)
                  return cb(err);
                for (var info of infos) {
                  var feed = this._corestore.get(_objectSpread({
                    key: info.key
                  }, this._opts));
                  this._addFeed(feed, info.name, false);
                }
                cb();
              });
            }
            writer(name, opts, cb) {
              if (!this.opened)
                return this.ready(() => this.writer(name, opts, cb));
              if (typeof name === "function" && !cb) {
                cb = name;
                name = void 0;
                opts = {};
              }
              if (typeof opts === "function" && !cb) {
                cb = opts;
                opts = {};
              }
              if (this._feedsByName.has(name))
                return cb(null, this._feedsByName.get(name));
              var namespace = FEED_NAMESPACE_PREFIX + name;
              var feed = this._corestore.namespace(namespace).default(_objectSpread({
                valueEncoding: this._opts.valueEncoding
              }, opts));
              this._addFeed(feed, name, true);
              feed.ready(() => {
                cb(null, feed);
              });
            }
            feeds() {
              return Array.from(this._feedsByKey.values());
            }
            feed(key) {
              if (Buffer.isBuffer(key))
                key = key.toString("hex");
              if (typeof key === "string")
                return this._feedsByKey.get(key);
              else
                return null;
            }
            replicate(isInitiator) {
              var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              if (!this.opened) {
                return errorStream(new Error('tried to use "replicate" before multifeed is ready'));
              }
              var stream = opts.stream || new Protocol(isInitiator, opts);
              this._muxer.addStream(stream, opts);
              return stream;
            }
          }
          class MultifeedPersistence {
            constructor(corestore) {
              this.storage = corestore.namespace(PERSIST_NAMESPACE);
              this.feed = null;
            }
            ready(cb) {
              this.feed = this.storage.default({
                valueEncoding: "json"
              });
              this.feed.ready(cb);
            }
            fetchFeeds(cb) {
              this.feed.ready((err) => {
                if (err)
                  return cb(err);
                collect(this.feed.createReadStream(), cb);
              });
            }
            storeFeed(info, cb) {
              this.feed.ready((err) => {
                if (err)
                  return cb(err);
                this.feed.append(info, cb);
              });
            }
            close(cb) {
              this.storage.close(cb);
            }
          }
          function errorStream(err) {
            var tmp = through();
            process.nextTick(function() {
              tmp.emit("error", err);
            });
            return tmp;
          }
          function isCorestore(storage) {
            return storage.default && storage.get && storage.replicate && storage.close;
          }
          function defaultCorestore(storage, opts) {
            if (isCorestore(storage))
              return storage;
            if (typeof storage === "function") {
              var factory = (path) => storage(path);
            } else if (typeof storage === "string") {
              factory = (path) => raf(storage + "/" + path);
            }
            return new Corestore(factory, opts);
          }
          module2.exports = function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return new Multifeed(...args);
          };
          module2.exports.defaultCorestore = defaultCorestore;
        }).call(this);
      }).call(this, require2("_process"), require2("buffer").Buffer);
    }, { "./networker": 240, "_process": 361, "buffer": 82, "corestore": 109, "debug": 119, "hypercore-crypto": 227, "hypercore-protocol": 228, "nanoresource/emitter": 327, "random-access-file": 379, "stream-collector": 496, "through2": 241 }], 239: [function(require2, module2, exports2) {
      (function(process, Buffer) {
        (function() {
          var Protocol = require2("hypercore-protocol");
          var readify = require2("./ready");
          var inherits = require2("inherits");
          var events = require2("events");
          var debug = require2("debug")("multifeed");
          var once = require2("once");
          var AbstractExtension = require2("abstract-extension");
          var MULTIFEED = "MULTIFEED";
          var PROTOCOL_VERSION = "4.0.0";
          var EXT_HANDSHAKE = "MULTIFEED_HANDSHAKE";
          var EXT_MANIFEST = "MULTIFEED_MANIFEST";
          var EXT_REQUEST_FEEDS = "MULTIFEED_REQUEST_FEEDS";
          var EXT_REPLICATE_FEEDS = "MULTIFEED_REPLICATE_FEEDS";
          var ERR_VERSION_MISMATCH = "ERR_VERSION_MISMATCH";
          var ERR_CLIENT_MISMATCH = "ERR_CLIENT_MISMATCH";
          var DEFAULT_TIMEOUT = 1e4;
          class Extension extends AbstractExtension {
            send(message) {
              this.local.handlers.send(this.id, this.encode(message));
            }
          }
          function Multiplexer(isInitiator, key, opts) {
            if (!(this instanceof Multiplexer))
              return new Multiplexer(isInitiator, key, opts);
            var self2 = this;
            self2._opts = opts = opts || {};
            this._id = opts._id || Math.floor(Math.random() * 1e4).toString(16);
            this._initiator = isInitiator;
            debug(this._id + " [REPLICATION] New mux initialized", opts);
            self2._localOffer = [];
            self2._requestedFeeds = [];
            self2._remoteOffer = [];
            self2._activeFeedStreams = {};
            if (opts.stream) {
              self2.stream = opts.stream;
            } else {
              self2.stream = new Protocol(isInitiator, Object.assign({}, opts));
            }
            self2._extensions = Extension.createLocal({
              send(id, message) {
                self2._channel.extension(id, message);
              }
            });
            self2._remoteExtensions = self2._extensions.remote();
            self2._channel = self2.stream.open(key, {
              onopen: function onopen() {
                if (!self2.stream.remoteVerified(key)) {
                  debug(self2._id + " [REPLICATION] aborting; shared key mismatch");
                  self2._finalize(new Error("shared key mismatch!"));
                  return;
                }
                self2._registerExtensions();
                self2._handshakeExt.send(Object.assign({}, {
                  client: MULTIFEED,
                  version: PROTOCOL_VERSION,
                  userData: opts.userData
                }));
              },
              onextension(id, message) {
                self2._remoteExtensions.onmessage(id, message, self2._channel);
              },
              onoptions(options) {
                self2._remoteExtensions.update(options.extensions);
              }
            });
            if (!self2._opts.live) {
              self2.stream.on("prefinalize", function() {
                self2._channel.close();
                debug(self2._id + " [REPLICATION] feed finish/prefinalize (" + self2.stream.prefinalize._tick + ")");
              });
            }
            if (opts.timeout !== false) {
              this.timeout = setTimeout(() => {
                this._finalize(new Error("Multifeed handshake remote timeout"));
              }, opts.timeout || DEFAULT_TIMEOUT);
            }
            this._ready = readify(function(done) {
              self2.on("ready", function(remote) {
                if (this.timeout)
                  clearTimeout(this.timeout);
                debug(self2._id + " [REPLICATION] remote connected and ready");
                done(remote);
              });
            });
          }
          inherits(Multiplexer, events.EventEmitter);
          Multiplexer.prototype.ready = function(cb) {
            this._ready(cb);
          };
          Multiplexer.prototype._registerExtensions = function() {
            var self2 = this;
            self2._handshakeExt = self2._extensions.add(EXT_HANDSHAKE, {
              onmessage: onHandshake,
              onerror: function onerror(err) {
                self2._finalize(err);
              },
              encoding: "json"
            });
            self2._manifestExt = self2._extensions.add(EXT_MANIFEST, {
              onmessage: function onmessage(msg) {
                debug(self2._id, "RECV'D Ext MANIFEST:", JSON.stringify(msg));
                self2._remoteOffer = uniq(self2._remoteOffer.concat(msg.keys));
                self2.emit("manifest", msg, self2.requestFeeds.bind(self2));
              },
              onerror: function onerror(err) {
                self2._finalize(err);
              },
              encoding: "json"
            });
            self2._requestFeedsExt = self2._extensions.add(EXT_REQUEST_FEEDS, {
              onmessage: function onmessage(msg) {
                debug(self2._id, "RECV'D Ext REQUEST_FEEDS:", msg);
                self2._onRequestFeeds(msg);
              },
              onerror: function onerror(err) {
                self2._finalize(err);
              },
              encoding: "json"
            });
            self2._replicateFeedsExt = self2._extensions.add(EXT_REPLICATE_FEEDS, {
              onmessage: function onmessage(msg) {
                debug(self2._id, "RECV'D Ext REPLICATE_FEEDS:", msg);
                self2._onRemoteReplicate(msg);
              },
              onerror: function onerror(err) {
                self2._finalize(err);
              },
              encoding: "json"
            });
            self2._channel.options({
              extensions: self2._extensions.names()
            });
            function onHandshake(header) {
              debug(self2._id + " [REPLICATION] recv'd handshake: ", JSON.stringify(header));
              var err;
              if (!compatibleVersions(header.version, PROTOCOL_VERSION)) {
                debug(self2._id + " [REPLICATION] aborting; version mismatch (us=" + PROTOCOL_VERSION + ")");
                err = new Error("protocol version mismatch! us=" + PROTOCOL_VERSION + " them=" + header.version);
                err.code = ERR_VERSION_MISMATCH;
                err.usVersion = PROTOCOL_VERSION;
                err.themVersion = header.version;
                self2._finalize(err);
                return;
              }
              if (header.client !== MULTIFEED) {
                debug(self2._id + " [REPLICATION] aborting; Client mismatch! expected ", MULTIFEED, "but got", header.client);
                err = new Error("Client mismatch! expected " + MULTIFEED + " but got " + header.client);
                err.code = ERR_CLIENT_MISMATCH;
                err.usClient = MULTIFEED;
                err.themClient = header.client;
                self2._finalize(err);
                return;
              }
              process.nextTick(function() {
                self2.emit("ready", header);
              });
            }
          };
          Multiplexer.prototype._finalize = function(err) {
            if (err) {
              debug(this._id + " [REPLICATION] destroyed due to", err);
              this.stream.emit("error", err);
              this.stream.destroy(err);
            } else {
              debug(this._id + " [REPLICATION] finalized", err);
              this.stream.finalize();
            }
          };
          Multiplexer.prototype.offerFeeds = function(keys, opts) {
            var manifest = Object.assign(opts || {}, {
              keys: extractKeys(keys)
            });
            debug(this._id + " [REPLICATON] sending manifest:", manifest);
            manifest.keys.forEach(function(key) {
              this._localOffer.push(key);
            }.bind(this));
            this._manifestExt.send(manifest);
          };
          Multiplexer.prototype.requestFeeds = function(keys) {
            keys = extractKeys(keys);
            keys.forEach(function(k) {
              this._requestedFeeds.push(k);
            }.bind(this));
            debug(this._id + " [REPLICATION] Sending feeds request", keys);
            this._requestFeedsExt.send(keys);
          };
          Multiplexer.prototype._onRequestFeeds = function(keys) {
            var self2 = this;
            var filtered = keys.filter(function(key) {
              if (self2._localOffer.indexOf(key) === -1) {
                debug("[REPLICATION] Warning, remote requested feed that is not in offer", key);
                return false;
              }
              return true;
            });
            filtered = uniq(filtered);
            debug(this._id, "[REPLICATION] Sending REPLICATE_FEEDS");
            this._replicateFeedsExt.send(filtered);
            this._replicateFeeds(filtered);
          };
          Multiplexer.prototype._onRemoteReplicate = function(keys) {
            var self2 = this;
            var filtered = keys.filter(function(key) {
              return self2._requestedFeeds.indexOf(key) !== -1;
            });
            this._replicateFeeds(filtered, function() {
              self2.stream.emit("remote-feeds");
            });
          };
          Multiplexer.prototype._replicateFeeds = function(keys, cb) {
            if (!cb)
              cb = noop;
            var self2 = this;
            keys = uniq(keys);
            debug(this._id, "[REPLICATION] _replicateFeeds", keys.length, keys);
            this.stream.prefinalize.wait();
            this.emit("replicate", keys, once(startFeedReplication));
            return keys;
            function startFeedReplication(feeds) {
              if (!Array.isArray(feeds))
                feeds = [feeds];
              var pending = feeds.length;
              self2.stream.prefinalize.continue();
              feeds.forEach(function(feed) {
                feed.ready(function() {
                  var hexKey = feed.key.toString("hex");
                  if (typeof self2._activeFeedStreams[hexKey] !== "undefined") {
                    if (!--pending)
                      cb();
                    return;
                  }
                  debug(self2._id, "[REPLICATION] replicating feed:", hexKey);
                  var fStream = feed.replicate(self2._initiator, Object.assign({}, {
                    live: self2._opts.live,
                    download: self2._opts.download,
                    upload: self2._opts.upload,
                    encrypt: self2._opts.encrypt,
                    stream: self2.stream
                  }));
                  self2._activeFeedStreams[hexKey] = fStream;
                  var cleanup = function cleanup2(_, res) {
                    if (!self2._activeFeedStreams[hexKey])
                      return;
                    delete self2._activeFeedStreams[hexKey];
                    debug(self2._id, "[REPLICATION] feedStream closed:", hexKey.substr(0, 8));
                  };
                  fStream.once("end", cleanup);
                  fStream.once("error", cleanup);
                  if (!--pending)
                    cb();
                });
              });
              if (feeds.length === 0 && Object.keys(self2._activeFeedStreams).length === 0) {
                debug("[REPLICATION] terminating mux: no feeds to sync");
                self2._channel.close();
                process.nextTick(cb);
              }
            }
          };
          Multiplexer.prototype.knownFeeds = function() {
            return this._localOffer.concat(this._remoteOffer);
          };
          module2.exports = Multiplexer;
          function compatibleVersions(v1, v2) {
            var major1 = v1.split(".")[0];
            var major2 = v2.split(".")[0];
            return parseInt(major1) === parseInt(major2);
          }
          function extractKeys(keys) {
            if (!Array.isArray(keys))
              keys = [keys];
            return keys.map(function(o) {
              if (typeof o === "string")
                return o;
              if (typeof o === "object" && o.key)
                return o.key.toString("hex");
              if (o instanceof Buffer)
                return o.toString("utf8");
            }).filter(function(o) {
              return !!o;
            });
          }
          function uniq(arr) {
            return Object.keys(arr.reduce(function(m, i) {
              m[i] = true;
              return m;
            }, {})).sort();
          }
          function noop() {
          }
        }).call(this);
      }).call(this, require2("_process"), require2("buffer").Buffer);
    }, { "./ready": 242, "_process": 361, "abstract-extension": 14, "buffer": 82, "debug": 119, "events": 193, "hypercore-protocol": 228, "inherits": 256, "once": 339 }], 240: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              if (enumerableOnly)
                symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
              keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              if (i % 2) {
                ownKeys(Object(source), true).forEach(function(key) {
                  _defineProperty(target, key, source[key]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys(Object(source)).forEach(function(key) {
                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
              }
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var hcrypto = require2("hypercore-crypto");
          var Multiplexer = require2("./mux");
          var debug = require2("debug")("multifeed");
          var {
            EventEmitter
          } = require2("events");
          class MuxerTopic extends EventEmitter {
            constructor(corestore, rootKey) {
              var opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
              super();
              this._id = hcrypto.randomBytes(2).toString("hex");
              this.corestore = corestore;
              this.rootKey = rootKey;
              this._feeds = /* @__PURE__ */ new Map();
              this._streams = /* @__PURE__ */ new Map();
              this._opts = opts;
              this.getFeed = opts.getFeed || this._getFeed.bind(this);
            }
            addStream(stream, opts) {
              var self2 = this;
              opts = _objectSpread(_objectSpread(_objectSpread({}, this._opts), opts), {}, {
                stream,
                live: true
              });
              var mux = new Multiplexer(null, this.rootKey, opts);
              mux.on("manifest", onmanifest);
              mux.on("replicate", onreplicate);
              mux.ready(onready);
              stream.once("end", cleanup);
              stream.once("error", cleanup);
              this._streams.set(stream, {
                mux,
                cleanup
              });
              function onready() {
                var keys = Array.from(self2._feeds.keys());
                mux.offerFeeds(keys);
              }
              function onmanifest(manifest) {
                mux.requestFeeds(manifest.keys);
              }
              function onreplicate(keys, repl) {
                var pending = keys.length;
                for (var key of keys) {
                  if (self2._feeds.has(key)) {
                    done();
                    continue;
                  }
                  self2.getFeed(key, (err, feed) => {
                    if (err)
                      return done();
                    self2.addFeed(feed);
                    self2.emit("feed", feed);
                    done();
                  });
                }
                function done() {
                  if (!--pending) {
                    var feeds = keys.map((key2) => self2._feeds.get(key2));
                    repl(feeds);
                  }
                }
              }
              function cleanup(_err) {
                mux.removeListener("manifest", onmanifest);
                mux.removeListener("replicate", onreplicate);
                self2._streams.delete(stream);
              }
            }
            removeStream(stream) {
              if (!this._streams.has(stream))
                return;
              var {
                cleanup
              } = this._streams.get(stream);
              cleanup();
            }
            feeds() {
              return Array.from(this._feeds.values());
            }
            _getFeed(key, cb) {
              var feed = this.corestore.get(_objectSpread({
                key
              }, this._opts));
              if (!feed)
                return cb(new Error("no feed matching that key"));
              cb(null, feed);
            }
            addFeed(feed) {
              var hkey = feed.key.toString("hex");
              this._feeds.set(hkey, feed);
              var _loop = function _loop2(mux2) {
                mux2.ready(() => {
                  if (mux2.knownFeeds().indexOf(hkey) === -1) {
                    debug("Forwarding new feed to existing peer:", hkey);
                    mux2.offerFeeds([hkey]);
                  }
                });
              };
              for (var {
                mux
              } of this._streams.values()) {
                _loop(mux);
              }
            }
          }
          module2.exports = class MultifeedNetworker {
            constructor(networker) {
              this.networker = networker;
              this.corestore = networker.corestore;
              this.muxers = /* @__PURE__ */ new Map();
              this.streamsByKey = /* @__PURE__ */ new Map();
              this._joinListener = this._onjoin.bind(this);
              this._leaveListener = this._onleave.bind(this);
              this.networker.on("handshake", this._joinListener);
              this.networker.on("stream-closed", this._leaveListener);
            }
            _onjoin(stream, info) {
              var remoteKey = stream.remotePublicKey;
              var keyString = remoteKey.toString("hex");
              this.streamsByKey.set(keyString, {
                stream,
                info
              });
              for (var mux of this.muxers.values()) {
                mux.addStream(stream);
              }
            }
            _onleave(stream, info, finishedHandshake) {
              if (!finishedHandshake || info && info.duplicate)
                return;
              for (var mux of this.muxers.values()) {
                mux.removeStream(stream);
              }
            }
            swarm(multifeed) {
              var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              multifeed.ready(() => {
                this.join(multifeed.key, _objectSpread({
                  live: true,
                  mux: multifeed._muxer
                }, opts));
              });
            }
            join(rootKey) {
              var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              if (!Buffer.isBuffer(rootKey))
                rootKey = Buffer.from(rootKey, "hex");
              var hkey = rootKey.toString("hex");
              if (this.muxers.has(hkey))
                return this.muxers.get(hkey);
              var mux = opts.mux || new MuxerTopic(this.corestore, rootKey, opts);
              var discoveryKey = hcrypto.discoveryKey(rootKey);
              this.networker.configure(discoveryKey, {
                announce: true,
                lookup: true
              });
              this.muxers.set(hkey, mux);
              for (var {
                stream
              } of this.streamsByKey.values()) {
                mux.addStream(stream);
              }
              return mux;
            }
            leave(rootKey) {
              if (!Buffer.isBuffer(rootKey))
                rootKey = Buffer.from(rootKey, "hex");
              var hkey = rootKey.toString("hex");
              var mux = this.muxers.get(hkey);
              if (!mux)
                return false;
              var discoveryKey = hcrypto.discoveryKey(rootKey);
              this.networker.configure(discoveryKey, {
                announce: false,
                lookup: false
              });
              this.muxers.delete(hkey);
              for (var {
                stream
              } of this.streamsByKey.values()) {
                mux.removeStream(stream);
              }
              return true;
            }
          };
          module2.exports.MuxerTopic = MuxerTopic;
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "./mux": 239, "buffer": 82, "debug": 119, "events": 193, "hypercore-crypto": 227 }], 241: [function(require2, module2, exports2) {
      arguments[4][2][0].apply(exports2, arguments);
    }, { "_process": 361, "dup": 2, "inherits": 256, "readable-stream": 412 }], 242: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          module2.exports = function(work, noauto) {
            var ready = false;
            var fns = [];
            var startWork = function startWork2() {
              process.nextTick(function() {
                work(function() {
                  ready = true;
                  fns.forEach(process.nextTick);
                });
              });
            };
            if (!noauto)
              startWork();
            return function(fn) {
              if (noauto) {
                noauto = false;
                startWork();
              }
              if (!ready)
                fns.push(fn);
              else
                process.nextTick(fn);
            };
          };
        }).call(this);
      }).call(this, require2("_process"));
    }, { "_process": 361 }], 243: [function(require2, module2, exports2) {
      var HyperswarmProxyClient = require2("hyperswarm-proxy/client");
      var websocket = require2("websocket-stream");
      var DEFAULT_PORT = "4977";
      var LOCAL_PROXY = "ws://localhost:".concat(DEFAULT_PORT);
      var DEFAULT_PROXY = [LOCAL_PROXY];
      var DEFAULT_RECONNECT_DELAY = 1e3;
      class HyperswarmProxyWSClient extends HyperswarmProxyClient {
        constructor() {
          var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          super(opts);
          var {
            proxy = DEFAULT_PROXY,
            reconnectDelay = DEFAULT_RECONNECT_DELAY
          } = opts;
          this.reconnectDelay = reconnectDelay;
          this.proxy = null;
          this._urls = typeof proxy === "string" ? [proxy] : proxy;
          this._urlIndex = 0;
          this.reconnect();
        }
        reconnect() {
          this._nextUrl();
          var localSocket = websocket(LOCAL_PROXY);
          localSocket.on("error", (e) => this.emit("connection-error", e));
          localSocket.once("error", () => {
            var proxySocket = websocket(this.proxy);
            proxySocket.on("error", (e) => this.emit("connection-error", e));
            proxySocket.once("close", () => {
              setTimeout(() => {
                if (this.destroyed)
                  return;
                this.reconnect();
              }, this.reconnectDelay);
            });
            super.reconnect(proxySocket);
          });
          super.reconnect(localSocket);
        }
        _nextUrl() {
          this.proxy = this._urls[this._urlIndex++ % this._urls.length];
          return this.proxy;
        }
      }
      module2.exports = HyperswarmProxyWSClient;
    }, { "hyperswarm-proxy/client": 244, "websocket-stream": 531 }], 244: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          var EventEmitter = require2("events");
          var HyperswarmProxyStream = require2("./");
          var NOT_CONNECTED = "Not connected to proxy";
          module2.exports = class HyperswarmProxyClient extends EventEmitter {
            constructor() {
              var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              super();
              var {
                connection,
                autoconnect = true,
                maxPeers = 24
              } = options;
              this.maxPeers = maxPeers;
              this._handleStream = this._handleStream.bind(this);
              this._handleClose = this._handleClose.bind(this);
              this._handlePeer = this._handlePeer.bind(this);
              this._handleError = this._handleError.bind(this);
              this._reJoin = this._reJoin.bind(this);
              this._protocol = null;
              this._connection = null;
              this._topics = [];
              this._connectedPeers = /* @__PURE__ */ new Set();
              this._seenPeers = [];
              this._autoconnect = autoconnect;
              this.destroyed = false;
              if (connection) {
                this.reconnect(connection);
              }
            }
            disconnect() {
              if (!this._protocol) {
                return;
              }
              this._protocol.removeListener("close", this._handleClose);
              this._connection.end();
              this._protocol.end();
              this._connection = null;
              this._protocol = null;
            }
            reconnect(connection) {
              this.disconnect();
              this._connection = connection;
              this._protocol = new HyperswarmProxyStream(connection);
              this._protocol.on("stream", this._handleStream);
              this._protocol.on("on_peer", this._handlePeer);
              this._protocol.once("close", this._handleClose);
              this._protocol.on("error", this._handleError);
              this._protocol.once("ready", this._reJoin);
              this._protocol.ready();
            }
            _handleStream(stream, _ref) {
              var {
                topic,
                peer
              } = _ref;
              if (this.destroyed) {
                stream.end();
                return;
              }
              var details = new Details(peer, topic);
              this._connectedPeers.add(peer);
              this.emit("connection", stream, details);
              stream.once("close", () => {
                if (this.destroyed) {
                  return;
                }
                this.emit("disconnection", stream, details);
                this._connectedPeers.delete(peer);
              });
            }
            _handleClose() {
              this._protocol = null;
              for (var peer of this._connectedPeers) {
                peer.end();
              }
              this.emit("disconnected");
            }
            _handleError(e) {
              this.emit("error", e);
            }
            _handlePeer(_ref2) {
              var {
                topic,
                peer
              } = _ref2;
              var peerData = {
                host: peer,
                port: 0,
                local: false,
                topic
              };
              this.emit("peer", peerData);
              var hasConnected = this._connectedPeers.has(peer);
              var hasMaxPeers = this._connectedPeers.size >= this.maxPeers;
              var shouldConnect = this._autoconnect && !hasConnected && !hasMaxPeers;
              if (shouldConnect) {
                this.connect(peerData);
              } else if (!this._seenPeers.find((data) => data.peer === peer)) {
                this._seenPeers.push(peerData);
              }
            }
            _reJoin() {
              for (var topic of this._topics) {
                this.join(topic);
              }
            }
            get connections() {
              if (!this._protocol)
                return /* @__PURE__ */ new Set();
              return this._protocol.connections;
            }
            join(topic) {
              if (!this._protocol)
                throw new Error(NOT_CONNECTED);
              this._protocol.join(topic);
              var hasSeen = this._topics.some((other) => other.equals(topic));
              if (!hasSeen) {
                this._topics.push(topic);
              }
            }
            leave(topic) {
              if (!this._protocol)
                throw new Error(NOT_CONNECTED);
              this._protocol.leave(topic);
              this._topics = this._topics.filter((other) => !other.equals(topic));
              this._seenPeers = this._seenPeers.filter((_ref3) => {
                var {
                  topic: other
                } = _ref3;
                return !other.equals(topic);
              });
            }
            connect(peer) {
              var cb = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
              if (!this._protocol)
                return setTimeout(() => cb(new Error(NOT_CONNECTED)), 0);
              var id = peer.host;
              var listenStreams = (stream, details) => {
                var foundId = details.peer.host;
                if (foundId !== id)
                  return;
                cb(null, stream, details);
                this.removeListener("connection", listenStreams);
              };
              if (cb) {
                this.on("connection", listenStreams);
              }
              this._protocol.connect(id);
            }
            flush() {
              var cb = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : noop;
              if (cb)
                process.nextTick(cb);
            }
            status() {
              return {
                lookup: true,
                announce: false
              };
            }
            destroy(cb) {
              this.destroyed = true;
              this.disconnect();
              this._topics = null;
              this._connectedPeers = null;
              this._seenPeers = null;
              if (cb)
                process.nextTick(cb);
            }
          };
          function noop() {
          }
          class Details {
            constructor(peer, topic) {
              this.type = "proxy";
              this.client = true;
              this.peer = {
                host: peer,
                port: 0,
                local: false,
                topic
              };
            }
            deduplicate() {
              return false;
            }
          }
        }).call(this);
      }).call(this, require2("_process"));
    }, { "./": 245, "_process": 361, "events": 193 }], 245: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              if (enumerableOnly)
                symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
              keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              if (i % 2) {
                ownKeys(Object(source), true).forEach(function(key) {
                  _defineProperty(target, key, source[key]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys(Object(source)).forEach(function(key) {
                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
              }
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var Duplex = require2("stream").Duplex;
          var lps = require2("length-prefixed-stream");
          var {
            SwarmEvent,
            EventType
          } = require2("./messages");
          var ProxyStream = require2("./proxystream");
          var pump = require2("pump");
          module2.exports = class HyperswarmProxyStream extends Duplex {
            constructor(stream) {
              super({
                emitClose: true
              });
              this.connections = /* @__PURE__ */ new Set();
              this.setMaxListeners(256);
              pump(stream, lps.decode(), this, lps.encode(), stream, () => {
                this._closeAllStreams();
              });
              this.on("on_stream_open", this._handleStreamOpen.bind(this));
            }
            ready() {
              this.sendMessage("READY");
            }
            join(topic) {
              this.sendMessage("JOIN", {
                topic
              });
            }
            leave(topic) {
              this.sendMessage("LEAVE", {
                topic
              });
            }
            onPeer(topic, peer) {
              this.sendMessage("ON_PEER", {
                topic,
                peer
              });
            }
            connect(peer) {
              this.sendMessage("CONNECT", {
                peer
              });
            }
            onStreamOpen(topic, peer, stream) {
              this.sendMessage("ON_STREAM_OPEN", {
                topic,
                peer,
                stream
              });
            }
            onStreamData(stream, data) {
              if (typeof data === "string") {
                data = Buffer.from(data, "utf8");
              }
              this.sendMessage("ON_STREAM_DATA", {
                stream,
                data
              });
            }
            onStreamClose(stream) {
              this.sendMessage("ON_STREAM_CLOSE", {
                stream
              });
            }
            onStreamError(stream, message, peer) {
              var data = Buffer.from(message, "utf8");
              this.sendMessage("ON_STREAM_ERROR", {
                stream,
                data
              });
            }
            openStream(topic, peer, stream) {
              var proxy = new ProxyStream(this, stream);
              this._addStream(proxy);
              this.onStreamOpen(topic, peer, stream);
              return proxy;
            }
            _closeAllStreams() {
              for (var connection of this.connections) {
                connection.end();
              }
            }
            _addStream(stream) {
              this.connections.add(stream);
              stream.once("close", () => {
                this.connections.delete(stream);
              });
            }
            _handleStreamOpen(_ref) {
              var {
                topic,
                peer,
                stream
              } = _ref;
              var proxy = new ProxyStream(this, stream);
              this._addStream(proxy);
              this.emit("stream", proxy, {
                topic,
                peer
              });
            }
            sendMessage(type) {
              var data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              this.push(SwarmEvent.encode(_objectSpread({
                type: EventType[type]
              }, data)));
            }
            _write(chunk, encoding, callback) {
              try {
                var decoded = SwarmEvent.decode(chunk);
                var {
                  type
                } = decoded;
                for (var name of Object.keys(EventType)) {
                  if (EventType[name] === type) {
                    this.emit(name.toLowerCase(), decoded);
                  }
                }
                callback();
              } catch (e) {
                callback(e);
              }
            }
            _read() {
            }
          };
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "./messages": 246, "./proxystream": 247, "buffer": 82, "length-prefixed-stream": 270, "pump": 376, "stream": 480 }], 246: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var encodings = require2("protocol-buffers-encodings");
          var varint = encodings.varint;
          var skip = encodings.skip;
          exports2.EventType = {
            READY: 1,
            JOIN: 2,
            LEAVE: 3,
            ON_STREAM_OPEN: 4,
            ON_STREAM_CLOSE: 5,
            ON_STREAM_DATA: 6,
            ON_STREAM_ERROR: 7,
            ON_PEER: 8,
            CONNECT: 9
          };
          var SwarmEvent = exports2.SwarmEvent = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          };
          defineSwarmEvent();
          function defineSwarmEvent() {
            var enc = [encodings.enum, encodings.bytes, encodings.string, encodings.int32];
            SwarmEvent.encodingLength = encodingLength;
            SwarmEvent.encode = encode;
            SwarmEvent.decode = decode;
            function encodingLength(obj) {
              var length = 0;
              if (!defined(obj.type))
                throw new Error("type is required");
              var len = enc[0].encodingLength(obj.type);
              length += 1 + len;
              if (defined(obj.topic)) {
                var len = enc[1].encodingLength(obj.topic);
                length += 1 + len;
              }
              if (defined(obj.data)) {
                var len = enc[1].encodingLength(obj.data);
                length += 1 + len;
              }
              if (defined(obj.peer)) {
                var len = enc[2].encodingLength(obj.peer);
                length += 1 + len;
              }
              if (defined(obj.stream)) {
                var len = enc[3].encodingLength(obj.stream);
                length += 1 + len;
              }
              return length;
            }
            function encode(obj, buf, offset) {
              if (!offset)
                offset = 0;
              if (!buf)
                buf = Buffer.allocUnsafe(encodingLength(obj));
              var oldOffset = offset;
              if (!defined(obj.type))
                throw new Error("type is required");
              buf[offset++] = 8;
              enc[0].encode(obj.type, buf, offset);
              offset += enc[0].encode.bytes;
              if (defined(obj.topic)) {
                buf[offset++] = 18;
                enc[1].encode(obj.topic, buf, offset);
                offset += enc[1].encode.bytes;
              }
              if (defined(obj.data)) {
                buf[offset++] = 26;
                enc[1].encode(obj.data, buf, offset);
                offset += enc[1].encode.bytes;
              }
              if (defined(obj.peer)) {
                buf[offset++] = 34;
                enc[2].encode(obj.peer, buf, offset);
                offset += enc[2].encode.bytes;
              }
              if (defined(obj.stream)) {
                buf[offset++] = 40;
                enc[3].encode(obj.stream, buf, offset);
                offset += enc[3].encode.bytes;
              }
              encode.bytes = offset - oldOffset;
              return buf;
            }
            function decode(buf, offset, end) {
              if (!offset)
                offset = 0;
              if (!end)
                end = buf.length;
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid");
              var oldOffset = offset;
              var obj = {
                type: 1,
                topic: null,
                data: null,
                peer: "",
                stream: 0
              };
              var found0 = false;
              while (true) {
                if (end <= offset) {
                  if (!found0)
                    throw new Error("Decoded message is not valid");
                  decode.bytes = offset - oldOffset;
                  return obj;
                }
                var prefix = varint.decode(buf, offset);
                offset += varint.decode.bytes;
                var tag = prefix >> 3;
                switch (tag) {
                  case 1:
                    obj.type = enc[0].decode(buf, offset);
                    offset += enc[0].decode.bytes;
                    found0 = true;
                    break;
                  case 2:
                    obj.topic = enc[1].decode(buf, offset);
                    offset += enc[1].decode.bytes;
                    break;
                  case 3:
                    obj.data = enc[1].decode(buf, offset);
                    offset += enc[1].decode.bytes;
                    break;
                  case 4:
                    obj.peer = enc[2].decode(buf, offset);
                    offset += enc[2].decode.bytes;
                    break;
                  case 5:
                    obj.stream = enc[3].decode(buf, offset);
                    offset += enc[3].decode.bytes;
                    break;
                  default:
                    offset = skip(prefix & 7, buf, offset);
                }
              }
            }
          }
          function defined(val) {
            return val !== null && val !== void 0 && (typeof val !== "number" || !isNaN(val));
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82, "protocol-buffers-encodings": 363 }], 247: [function(require2, module2, exports2) {
      var Duplex = require2("stream").Duplex;
      module2.exports = class ProxyStream extends Duplex {
        constructor(protocol, id) {
          super({
            emitClose: true
          });
          this._secretId = Math.random();
          this._id = id;
          this._protocol = protocol;
          this._isClosed = false;
          this._handle_data = this._handleData.bind(this);
          this._handle_close = this._handleClose.bind(this);
          this._handle_error = this._handleError.bind(this);
          this._protocol.on("on_stream_data", this._handle_data);
          this._protocol.on("on_stream_close", this._handle_close);
          this._protocol.on("on_stream_error", this._handle_error);
        }
        _handleData(_ref) {
          var {
            stream,
            data
          } = _ref;
          if (this._isId(stream)) {
            this.push(data);
          }
        }
        _handleClose(_ref2) {
          var {
            stream
          } = _ref2;
          if (this._isId(stream)) {
            this.destroy();
            this._cleanup();
          }
        }
        _handleError(_ref3) {
          var {
            stream,
            data
          } = _ref3;
          if (this._isId(stream)) {
            var message = data.toString("utf8");
            this.emit("error", new Error(message));
            this.destroy();
            this._cleanup();
          }
        }
        _cleanup() {
          this._isClosed = true;
          this._protocol.removeListener("on_stream_data", this._handle_data);
          this._protocol.removeListener("on_stream_close", this._handle_close);
          this._protocol.removeListener("on_stream_error", this._handle_error);
        }
        _isId(streamid) {
          return streamid === this._id;
        }
        _read() {
        }
        _write(chunk, encoding, callback) {
          this._protocol.onStreamData(this._id, chunk);
          callback();
        }
        _final(callback) {
          if (!this._isClosed) {
            this._protocol.onStreamClose(this._id);
            this._cleanup();
          }
          callback();
        }
      };
    }, { "stream": 480 }], 248: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          var {
            EventEmitter
          } = require2("events");
          var webRTCSwarm = require2("@geut/discovery-swarm-webrtc");
          var HyperswarmClient = require2("hyperswarm-proxy-ws/client");
          require2("duplexpair");
          var DEFAULT_WEBRTC_BOOTSTRAP = ["wss://geut-webrtc-signal-v3.herokuapp.com", "wss://signal.dat-web.eu", "wss://geut-webrtc-signal-v3.glitch.me"];
          var DEFAULT_PROXY_SERVER = "wss://hyperswarm.mauve.moe";
          module2.exports = function swarm(opts) {
            return new HyperswarmWeb(opts);
          };
          function getBootstrapUrls(path) {
            var defaultUrls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
            var specificUrls = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
            var urls = defaultUrls.map((url) => {
              if (url.endsWith("/")) {
                url = url.slice(0, -1);
              }
              return "".concat(url, "/").concat(path);
            });
            urls = urls.concat(specificUrls);
            if (urls.length === 0)
              return;
            return urls;
          }
          class HyperswarmWeb extends EventEmitter {
            constructor() {
              var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              super();
              var {
                bootstrap,
                webrtcBootstrap,
                wsProxy,
                maxPeers,
                simplePeer,
                wsReconnectDelay
              } = opts;
              this.webrtcOpts = {
                maxPeers,
                simplePeer,
                bootstrap: getBootstrapUrls("signal", bootstrap, webrtcBootstrap) || DEFAULT_WEBRTC_BOOTSTRAP
              };
              this.wsOpts = {
                maxPeers,
                proxy: getBootstrapUrls("proxy", bootstrap, wsProxy) || DEFAULT_PROXY_SERVER
              };
              if (wsReconnectDelay) {
                this.wsOpts.reconnectDelay = wsReconnectDelay;
              }
              this.isListening = false;
              this.destroyed = false;
            }
            _handleWS(connection, info) {
              this.emit("connection", connection, info);
            }
            _handleWebRTC(connection, info) {
              var {
                id,
                channel,
                initiator
              } = info;
              var peerInfo = {
                type: "webrtc",
                client: initiator,
                peer: {
                  port: 0,
                  host: id,
                  topic: channel
                },
                deduplicate: () => false
              };
              this.emit("connection", connection, peerInfo);
            }
            address() {
              return {
                port: 0,
                family: "IPv4",
                address: "127.0.0.1"
              };
            }
            listen(port, cb) {
              if (this.isListening)
                return setTimeout(cb, 0);
              this.isListening = true;
              this.webrtc = webRTCSwarm(this.webrtcOpts);
              this.ws = new HyperswarmClient(this.wsOpts);
              this.ws.on("connection", (connection, info) => this._handleWS(connection, info));
              this.webrtc.on("connection", (connection, info) => this._handleWebRTC(connection, info));
            }
            join(key, opts) {
              this.listen();
              this.webrtc.join(key);
              this.ws.join(key, opts);
            }
            leave(key) {
              this.listen();
              this.webrtc.leave(key);
              this.ws.leave(key);
            }
            connect(peer, cb) {
              this.listen();
              this.ws.connect(peer, cb);
            }
            connectivity(cb) {
              this.listen(() => {
                cb(null, {
                  bound: true,
                  bootstrapped: true,
                  holepunched: true
                });
              });
            }
            flush(cb) {
              process.nextTick(cb);
            }
            status() {
              return {
                lookup: true,
                announce: false
              };
            }
            destroy(cb) {
              this.destroyed = true;
              this.webrtc.close(() => {
                this.ws.destroy(cb);
              });
            }
          }
        }).call(this);
      }).call(this, require2("_process"));
    }, { "@geut/discovery-swarm-webrtc": 9, "_process": 361, "duplexpair": 155, "events": 193, "hyperswarm-proxy-ws/client": 243 }], 249: [function(require2, module2, exports2) {
      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
      exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s * 128;
      };
    }, {}], 250: [function(require2, module2, exports2) {
      var types = [require2("./nextTick"), require2("./queueMicrotask"), require2("./mutation.js"), require2("./messageChannel"), require2("./stateChange"), require2("./timeout")];
      var draining;
      var currentQueue;
      var queueIndex = -1;
      var queue = [];
      var scheduled = false;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          nextTick();
        }
      }
      function nextTick() {
        if (draining) {
          return;
        }
        scheduled = false;
        draining = true;
        var len2 = queue.length;
        var timeout = setTimeout(cleanUpNextTick);
        while (len2) {
          currentQueue = queue;
          queue = [];
          while (currentQueue && ++queueIndex < len2) {
            currentQueue[queueIndex].run();
          }
          queueIndex = -1;
          len2 = queue.length;
        }
        currentQueue = null;
        queueIndex = -1;
        draining = false;
        clearTimeout(timeout);
      }
      var scheduleDrain;
      var i = -1;
      var len = types.length;
      while (++i < len) {
        if (types[i] && types[i].test && types[i].test()) {
          scheduleDrain = types[i].install(nextTick);
          break;
        }
      }
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        var fun = this.fun;
        var array = this.array;
        switch (array.length) {
          case 0:
            return fun();
          case 1:
            return fun(array[0]);
          case 2:
            return fun(array[0], array[1]);
          case 3:
            return fun(array[0], array[1], array[2]);
          default:
            return fun.apply(null, array);
        }
      };
      module2.exports = immediate;
      function immediate(task) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            args[i2 - 1] = arguments[i2];
          }
        }
        queue.push(new Item(task, args));
        if (!scheduled && !draining) {
          scheduled = true;
          scheduleDrain();
        }
      }
    }, { "./messageChannel": 251, "./mutation.js": 252, "./nextTick": 53, "./queueMicrotask": 253, "./stateChange": 254, "./timeout": 255 }], 251: [function(require2, module2, exports2) {
      (function(global) {
        (function() {
          exports2.test = function() {
            if (global.setImmediate) {
              return false;
            }
            return typeof global.MessageChannel !== "undefined";
          };
          exports2.install = function(func) {
            var channel = new global.MessageChannel();
            channel.port1.onmessage = func;
            return function() {
              channel.port2.postMessage(0);
            };
          };
        }).call(this);
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 252: [function(require2, module2, exports2) {
      (function(global) {
        (function() {
          var Mutation = global.MutationObserver || global.WebKitMutationObserver;
          exports2.test = function() {
            return Mutation;
          };
          exports2.install = function(handle) {
            var called = 0;
            var observer = new Mutation(handle);
            var element = global.document.createTextNode("");
            observer.observe(element, {
              characterData: true
            });
            return function() {
              element.data = called = ++called % 2;
            };
          };
        }).call(this);
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 253: [function(require2, module2, exports2) {
      (function(global) {
        (function() {
          exports2.test = function() {
            return typeof global.queueMicrotask === "function";
          };
          exports2.install = function(func) {
            return function() {
              global.queueMicrotask(func);
            };
          };
        }).call(this);
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 254: [function(require2, module2, exports2) {
      (function(global) {
        (function() {
          exports2.test = function() {
            return "document" in global && "onreadystatechange" in global.document.createElement("script");
          };
          exports2.install = function(handle) {
            return function() {
              var scriptEl = global.document.createElement("script");
              scriptEl.onreadystatechange = function() {
                handle();
                scriptEl.onreadystatechange = null;
                scriptEl.parentNode.removeChild(scriptEl);
                scriptEl = null;
              };
              global.document.documentElement.appendChild(scriptEl);
              return handle;
            };
          };
        }).call(this);
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 255: [function(require2, module2, exports2) {
      exports2.test = function() {
        return true;
      };
      exports2.install = function(t) {
        return function() {
          setTimeout(t, 0);
        };
      };
    }, {}], 256: [function(require2, module2, exports2) {
      if (typeof Object.create === "function") {
        module2.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module2.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function TempCtor2() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }, {}], 257: [function(require2, module2, exports2) {
      module2.exports = Symbol.for("nodejs.util.inspect.custom");
    }, {}], 258: [function(require2, module2, exports2) {
      var hasToStringTag = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
      var callBound = require2("call-bind/callBound");
      var $toString = callBound("Object.prototype.toString");
      var isStandardArguments = function isArguments(value) {
        if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
          return false;
        }
        return $toString(value) === "[object Arguments]";
      };
      var isLegacyArguments = function isArguments(value) {
        if (isStandardArguments(value)) {
          return true;
        }
        return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
      };
      var supportsStandardArguments = function() {
        return isStandardArguments(arguments);
      }();
      isStandardArguments.isLegacyArguments = isLegacyArguments;
      module2.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    }, { "call-bind/callBound": 88 }], 259: [function(require2, module2, exports2) {
      /*!
       * Determine if an object is a Buffer
       *
       * @author   Feross Aboukhadijeh <https://feross.org>
       * @license  MIT
       */
      module2.exports = function(obj) {
        return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
      };
      function isBuffer(obj) {
        return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
      }
      function isSlowBuffer(obj) {
        return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
      }
    }, {}], 260: [function(require2, module2, exports2) {
      var toStr = Object.prototype.toString;
      var fnToStr = Function.prototype.toString;
      var isFnRegex = /^\s*(?:function)?\*/;
      var hasToStringTag = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
      var getProto = Object.getPrototypeOf;
      var getGeneratorFunc = function getGeneratorFunc2() {
        if (!hasToStringTag) {
          return false;
        }
        try {
          return Function("return function*() {}")();
        } catch (e) {
        }
      };
      var generatorFunc = getGeneratorFunc();
      var GeneratorFunction = getProto && generatorFunc ? getProto(generatorFunc) : false;
      module2.exports = function isGeneratorFunction(fn) {
        if (typeof fn !== "function") {
          return false;
        }
        if (isFnRegex.test(fnToStr.call(fn))) {
          return true;
        }
        if (!hasToStringTag) {
          var str = toStr.call(fn);
          return str === "[object GeneratorFunction]";
        }
        return getProto && getProto(fn) === GeneratorFunction;
      };
    }, {}], 261: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          module2.exports = isOptions;
          function isOptions(opts) {
            return typeof opts === "object" && opts && !Buffer.isBuffer(opts);
          }
        }).call(this);
      }).call(this, { "isBuffer": require2("../is-buffer/index.js") });
    }, { "../is-buffer/index.js": 259 }], 262: [function(require2, module2, exports2) {
      (function(global) {
        (function() {
          var forEach = require2("foreach");
          var availableTypedArrays = require2("available-typed-arrays");
          var callBound = require2("call-bind/callBound");
          var $toString = callBound("Object.prototype.toString");
          var hasSymbols = require2("has-symbols")();
          var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === "symbol";
          var typedArrays = availableTypedArrays();
          var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
            for (var i = 0; i < array.length; i += 1) {
              if (array[i] === value) {
                return i;
              }
            }
            return -1;
          };
          var $slice = callBound("String.prototype.slice");
          var toStrTags = {};
          var gOPD = require2("es-abstract/helpers/getOwnPropertyDescriptor");
          var getPrototypeOf = Object.getPrototypeOf;
          if (hasToStringTag && gOPD && getPrototypeOf) {
            forEach(typedArrays, function(typedArray) {
              var arr = new global[typedArray]();
              if (!(Symbol.toStringTag in arr)) {
                throw new EvalError("this engine has support for Symbol.toStringTag, but " + typedArray + " does not have the property! Please report this.");
              }
              var proto = getPrototypeOf(arr);
              var descriptor = gOPD(proto, Symbol.toStringTag);
              if (!descriptor) {
                var superProto = getPrototypeOf(proto);
                descriptor = gOPD(superProto, Symbol.toStringTag);
              }
              toStrTags[typedArray] = descriptor.get;
            });
          }
          var tryTypedArrays = function tryAllTypedArrays(value) {
            var anyTrue = false;
            forEach(toStrTags, function(getter, typedArray) {
              if (!anyTrue) {
                try {
                  anyTrue = getter.call(value) === typedArray;
                } catch (e) {
                }
              }
            });
            return anyTrue;
          };
          module2.exports = function isTypedArray(value) {
            if (!value || typeof value !== "object") {
              return false;
            }
            if (!hasToStringTag) {
              var tag = $slice($toString(value), 8, -1);
              return $indexOf(typedArrays, tag) > -1;
            }
            if (!gOPD) {
              return false;
            }
            return tryTypedArrays(value);
          };
        }).call(this);
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "available-typed-arrays": 38, "call-bind/callBound": 88, "es-abstract/helpers/getOwnPropertyDescriptor": 191, "foreach": 201, "has-symbols": 207 }], 263: [function(require2, module2, exports2) {
      var toString = {}.toString;
      module2.exports = Array.isArray || function(arr) {
        return toString.call(arr) == "[object Array]";
      };
    }, {}], 264: [function(require2, module2, exports2) {
      (function(global) {
        (function() {
          var ws = null;
          if (typeof WebSocket !== "undefined") {
            ws = WebSocket;
          } else if (typeof MozWebSocket !== "undefined") {
            ws = MozWebSocket;
          } else if (typeof global !== "undefined") {
            ws = global.WebSocket || global.MozWebSocket;
          } else if (typeof window !== "undefined") {
            ws = window.WebSocket || window.MozWebSocket;
          } else if (typeof self !== "undefined") {
            ws = self.WebSocket || self.MozWebSocket;
          }
          module2.exports = ws;
        }).call(this);
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 265: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var EventEmitter = require2("events").EventEmitter;
      var multifeed = require2("hypermultifeed");
      var indexer = require2("multifeed-index");
      module2.exports = Kappa;
      function Kappa(storage, opts) {
        if (!(this instanceof Kappa))
          return new Kappa(storage, opts);
        if (!opts)
          opts = {};
        this._logs = opts.multifeed || multifeed(storage, opts);
        this._indexes = {};
        this.api = {};
      }
      inherits(Kappa, EventEmitter);
      Kappa.prototype.use = function(name, version, view) {
        var self2 = this;
        if (typeof version !== "number") {
          view = version;
          version = void 0;
        }
        var idx = indexer(Object.assign({}, view, {
          log: this._logs,
          version,
          maxBatch: view.maxBatch || 10,
          batch: view.map
        }));
        idx.on("error", function(err) {
          self2.emit("error", err);
        });
        if (view.indexed)
          idx.on("indexed", view.indexed);
        this._indexes[name] = idx;
        this.api[name] = {};
        this.api[name].ready = idx.ready.bind(idx);
        for (var key in view.api) {
          if (typeof view.api[key] === "function")
            this.api[name][key] = view.api[key].bind(idx, this);
          else
            this.api[name][key] = view.api[key];
        }
      };
      Kappa.prototype.feeds = function() {
        return this._logs.feeds();
      };
      Kappa.prototype.ready = function(viewNames, cb) {
        if (typeof viewNames === "function") {
          cb = viewNames;
          viewNames = [];
        }
        if (typeof viewNames === "string")
          viewNames = [viewNames];
        if (viewNames.length === 0) {
          viewNames = Object.keys(this._indexes);
        }
        var pending = viewNames.length + 1;
        var self2 = this;
        this._logs.ready(function() {
          for (var i = 0; i < viewNames.length; i++) {
            self2._indexes[viewNames[i]].ready(done);
          }
          done();
        });
        function done() {
          if (!--pending)
            cb();
        }
      };
      Kappa.prototype.pause = function(viewNames, cb) {
        if (typeof viewNames === "function") {
          cb = viewNames;
          viewNames = [];
        }
        cb = cb || noop;
        if (!viewNames)
          viewNames = [];
        if (typeof viewNames === "string")
          viewNames = [viewNames];
        if (viewNames.length === 0) {
          viewNames = Object.keys(this._indexes);
        }
        var pending = viewNames.length + 1;
        var self2 = this;
        this._logs.ready(function() {
          for (var i = 0; i < viewNames.length; i++) {
            self2._indexes[viewNames[i]].pause(done);
          }
          done();
        });
        function done() {
          if (!--pending)
            cb();
        }
      };
      Kappa.prototype.resume = function(viewNames) {
        if (!viewNames)
          viewNames = [];
        if (typeof viewNames === "string")
          viewNames = [viewNames];
        if (viewNames.length === 0) {
          viewNames = Object.keys(this._indexes);
        }
        var self2 = this;
        this._logs.ready(function() {
          for (var i = 0; i < viewNames.length; i++) {
            self2._indexes[viewNames[i]].resume();
          }
        });
      };
      Kappa.prototype.writer = function(name, cb) {
        this._logs.writer(name, cb);
      };
      Kappa.prototype.feed = function(key) {
        return this._logs.feed(key);
      };
      Kappa.prototype.replicate = function(isInitiator, opts) {
        return this._logs.replicate(isInitiator, opts);
      };
      function noop() {
      }
    }, { "events": 193, "hypermultifeed": 238, "inherits": 256, "multifeed-index": 306 }], 266: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var Writable = require2("readable-stream").Writable;
          var pump = require2("pump");
          var sub = require2("subleveldown");
          module2.exports = createIndex;
          function createIndex(ldb, opts, makeFn) {
            if (typeof opts === "function" && !makeFn) {
              makeFn = opts;
              opts = {};
            }
            var stateDb = sub(ldb, "s");
            var dataDb = sub(ldb, "d", opts);
            var basic = {
              maxBatch: 100,
              storeState: function storeState(state, cb) {
                state = state.toString("base64");
                stateDb.put("state", state, cb);
              },
              fetchState: function fetchState(cb) {
                stateDb.get("state", function(err, state) {
                  if (err && err.notFound)
                    cb();
                  else if (err)
                    cb(err);
                  else
                    cb(null, Buffer.from(state, "base64"));
                });
              },
              clearIndex: function clearIndex(cb) {
                var batch = [];
                var maxSize = 5e3;
                pump(dataDb.createKeyStream(), new Writable({
                  objectMode: true,
                  write: function write(key, enc, next) {
                    batch.push({
                      type: "del",
                      key
                    });
                    if (batch.length >= maxSize) {
                      dataDb.batch(batch, next);
                    } else
                      next();
                  },
                  final: function final(next) {
                    if (batch.length > 0)
                      dataDb.batch(batch, next);
                    else
                      next();
                  }
                }), ondone);
                function ondone(err) {
                  if (err)
                    cb(err);
                  else
                    cb();
                }
              }
            };
            return Object.assign({}, basic, makeFn(dataDb));
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82, "pump": 376, "readable-stream": 412, "subleveldown": 500 }], 267: [function(require2, module2, exports2) {
      module2.exports = function(work) {
        var pending = null;
        var callback = null;
        var callbacks = null;
        var next = null;
        return function(val, cb) {
          next = val;
          update(cb || noop);
        };
        function update(cb) {
          if (callback) {
            if (!pending)
              pending = [];
            pending.push(cb);
            return;
          }
          var val = next;
          next = null;
          callback = cb;
          work(val, done);
        }
        function done(err) {
          var cb = callback;
          var cbs = callbacks;
          callbacks = null;
          callback = null;
          if (pending) {
            callbacks = pending;
            pending = null;
            update(noop);
          }
          if (cbs) {
            for (var i = 0; i < cbs.length; i++) {
              cbs[i](err);
            }
          }
          cb(err);
        }
      };
      function noop(_) {
      }
    }, {}], 268: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var varint = require2("varint");
          var stream = require2("readable-stream");
          var inherits = require2("inherits");
          var Decoder = function Decoder2(opts) {
            if (!(this instanceof Decoder2))
              return new Decoder2(opts);
            stream.Transform.call(this);
            this._destroyed = false;
            this._missing = 0;
            this._message = null;
            this._limit = opts && opts.limit || 0;
            this._allowEmpty = !!(opts && opts.allowEmpty);
            this._prefix = Buffer.allocUnsafe(this._limit ? varint.encodingLength(this._limit) : 100);
            this._ptr = 0;
            if (this._allowEmpty) {
              this._readableState.highWaterMark = 16;
              this._readableState.objectMode = true;
            }
          };
          inherits(Decoder, stream.Transform);
          Decoder.prototype._push = function(message) {
            this._ptr = 0;
            this._missing = 0;
            this._message = null;
            this.push(message);
          };
          Decoder.prototype._parseLength = function(data, offset) {
            for (offset; offset < data.length; offset++) {
              if (this._ptr >= this._prefix.length)
                return this._prefixError(data);
              this._prefix[this._ptr++] = data[offset];
              if (!(data[offset] & 128)) {
                this._missing = varint.decode(this._prefix);
                if (this._limit && this._missing > this._limit)
                  return this._prefixError(data);
                if (!this._missing && this._allowEmpty)
                  this._push(Buffer.alloc(0));
                this._ptr = 0;
                return offset + 1;
              }
            }
            return data.length;
          };
          Decoder.prototype._prefixError = function(data) {
            this.destroy(new Error("Message is larger than max length"));
            return data.length;
          };
          Decoder.prototype._parseMessage = function(data, offset) {
            var free = data.length - offset;
            var missing = this._missing;
            if (!this._message) {
              if (missing <= free) {
                this._push(data.slice(offset, offset + missing));
                return offset + missing;
              }
              this._message = Buffer.allocUnsafe(missing);
            }
            data.copy(this._message, this._ptr, offset, offset + missing);
            if (missing <= free) {
              this._push(this._message);
              return offset + missing;
            }
            this._missing -= free;
            this._ptr += free;
            return data.length;
          };
          Decoder.prototype._transform = function(data, enc, cb) {
            var offset = 0;
            while (!this._destroyed && offset < data.length) {
              if (this._missing)
                offset = this._parseMessage(data, offset);
              else
                offset = this._parseLength(data, offset);
            }
            cb();
          };
          Decoder.prototype.destroy = function(err) {
            if (this._destroyed)
              return;
            this._destroyed = true;
            if (err)
              this.emit("error", err);
            this.emit("close");
          };
          module2.exports = Decoder;
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82, "inherits": 256, "readable-stream": 412, "varint": 517 }], 269: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var varint = require2("varint");
          var stream = require2("readable-stream");
          var inherits = require2("inherits");
          var pool = Buffer.allocUnsafe(10 * 1024);
          var used = 0;
          var Encoder = function Encoder2() {
            if (!(this instanceof Encoder2))
              return new Encoder2();
            stream.Transform.call(this);
            this._destroyed = false;
          };
          inherits(Encoder, stream.Transform);
          Encoder.prototype._transform = function(data, enc, cb) {
            if (this._destroyed)
              return cb();
            varint.encode(data.length, pool, used);
            used += varint.encode.bytes;
            this.push(pool.slice(used - varint.encode.bytes, used));
            this.push(data);
            if (pool.length - used < 100) {
              pool = Buffer.allocUnsafe(10 * 1024);
              used = 0;
            }
            cb();
          };
          Encoder.prototype.destroy = function(err) {
            if (this._destroyed)
              return;
            this._destroyed = true;
            if (err)
              this.emit("error", err);
            this.emit("close");
          };
          module2.exports = Encoder;
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82, "inherits": 256, "readable-stream": 412, "varint": 517 }], 270: [function(require2, module2, exports2) {
      exports2.encode = require2("./encode");
      exports2.decode = require2("./decode");
    }, { "./decode": 268, "./encode": 269 }], 271: [function(require2, module2, exports2) {
      var encodings = require2("./lib/encodings");
      module2.exports = Codec;
      function Codec(opts) {
        if (!(this instanceof Codec)) {
          return new Codec(opts);
        }
        this.opts = opts || {};
        this.encodings = encodings;
      }
      Codec.prototype._encoding = function(encoding) {
        if (typeof encoding === "string")
          encoding = encodings[encoding];
        if (!encoding)
          encoding = encodings.id;
        return encoding;
      };
      Codec.prototype._keyEncoding = function(opts, batchOpts) {
        return this._encoding(batchOpts && batchOpts.keyEncoding || opts && opts.keyEncoding || this.opts.keyEncoding);
      };
      Codec.prototype._valueEncoding = function(opts, batchOpts) {
        return this._encoding(batchOpts && (batchOpts.valueEncoding || batchOpts.encoding) || opts && (opts.valueEncoding || opts.encoding) || this.opts.valueEncoding || this.opts.encoding);
      };
      Codec.prototype.encodeKey = function(key, opts, batchOpts) {
        return this._keyEncoding(opts, batchOpts).encode(key);
      };
      Codec.prototype.encodeValue = function(value, opts, batchOpts) {
        return this._valueEncoding(opts, batchOpts).encode(value);
      };
      Codec.prototype.decodeKey = function(key, opts) {
        return this._keyEncoding(opts).decode(key);
      };
      Codec.prototype.decodeValue = function(value, opts) {
        return this._valueEncoding(opts).decode(value);
      };
      Codec.prototype.encodeBatch = function(ops, opts) {
        var self2 = this;
        return ops.map(function(_op) {
          var op = {
            type: _op.type,
            key: self2.encodeKey(_op.key, opts, _op)
          };
          if (self2.keyAsBuffer(opts, _op))
            op.keyEncoding = "binary";
          if (_op.prefix)
            op.prefix = _op.prefix;
          if ("value" in _op) {
            op.value = self2.encodeValue(_op.value, opts, _op);
            if (self2.valueAsBuffer(opts, _op))
              op.valueEncoding = "binary";
          }
          return op;
        });
      };
      var ltgtKeys = ["lt", "gt", "lte", "gte", "start", "end"];
      Codec.prototype.encodeLtgt = function(ltgt) {
        var self2 = this;
        var ret = {};
        Object.keys(ltgt).forEach(function(key) {
          ret[key] = ltgtKeys.indexOf(key) > -1 ? self2.encodeKey(ltgt[key], ltgt) : ltgt[key];
        });
        return ret;
      };
      Codec.prototype.createStreamDecoder = function(opts) {
        var self2 = this;
        if (opts.keys && opts.values) {
          return function(key, value) {
            return {
              key: self2.decodeKey(key, opts),
              value: self2.decodeValue(value, opts)
            };
          };
        } else if (opts.keys) {
          return function(key) {
            return self2.decodeKey(key, opts);
          };
        } else if (opts.values) {
          return function(_, value) {
            return self2.decodeValue(value, opts);
          };
        } else {
          return function() {
          };
        }
      };
      Codec.prototype.keyAsBuffer = function(opts) {
        return this._keyEncoding(opts).buffer;
      };
      Codec.prototype.valueAsBuffer = function(opts) {
        return this._valueEncoding(opts).buffer;
      };
    }, { "./lib/encodings": 272 }], 272: [function(require2, module2, exports2) {
      var Buffer = require2("buffer").Buffer;
      exports2.utf8 = exports2["utf-8"] = {
        encode: function encode(data) {
          return isBinary(data) ? data : String(data);
        },
        decode: identity,
        buffer: false,
        type: "utf8"
      };
      exports2.json = {
        encode: JSON.stringify,
        decode: JSON.parse,
        buffer: false,
        type: "json"
      };
      exports2.binary = {
        encode: function encode(data) {
          return isBinary(data) ? data : Buffer.from(data);
        },
        decode: identity,
        buffer: true,
        type: "binary"
      };
      exports2.none = {
        encode: identity,
        decode: identity,
        buffer: false,
        type: "id"
      };
      exports2.id = exports2.none;
      var bufferEncodings = ["hex", "ascii", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le"];
      bufferEncodings.forEach(function(type) {
        exports2[type] = {
          encode: function encode(data) {
            return isBinary(data) ? data : Buffer.from(data, type);
          },
          decode: function decode(buffer) {
            return buffer.toString(type);
          },
          buffer: true,
          type
        };
      });
      function identity(value) {
        return value;
      }
      function isBinary(data) {
        return data === void 0 || data === null || Buffer.isBuffer(data);
      }
    }, { "buffer": 82 }], 273: [function(require2, module2, exports2) {
      var createError = require2("errno").create;
      var LevelUPError = createError("LevelUPError");
      var NotFoundError = createError("NotFoundError", LevelUPError);
      NotFoundError.prototype.notFound = true;
      NotFoundError.prototype.status = 404;
      module2.exports = {
        LevelUPError,
        InitializationError: createError("InitializationError", LevelUPError),
        OpenError: createError("OpenError", LevelUPError),
        ReadError: createError("ReadError", LevelUPError),
        WriteError: createError("WriteError", LevelUPError),
        NotFoundError,
        EncodingError: createError("EncodingError", LevelUPError)
      };
    }, { "errno": 190 }], 274: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Readable = require2("readable-stream").Readable;
      var extend = require2("xtend");
      module2.exports = ReadStream;
      inherits(ReadStream, Readable);
      function ReadStream(iterator, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(iterator, options);
        options = options || {};
        Readable.call(this, extend(options, {
          objectMode: true
        }));
        this._iterator = iterator;
        this._options = options;
        this.on("end", this.destroy.bind(this, null, null));
      }
      ReadStream.prototype._read = function() {
        var self2 = this;
        var options = this._options;
        if (this.destroyed)
          return;
        this._iterator.next(function(err, key, value) {
          if (self2.destroyed)
            return;
          if (err)
            return self2.destroy(err);
          if (key === void 0 && value === void 0) {
            self2.push(null);
          } else if (options.keys !== false && options.values === false) {
            self2.push(key);
          } else if (options.keys === false && options.values !== false) {
            self2.push(value);
          } else {
            self2.push({
              key,
              value
            });
          }
        });
      };
      ReadStream.prototype._destroy = function(err, callback) {
        this._iterator.end(function(err2) {
          callback(err || err2);
        });
      };
    }, { "inherits": 256, "readable-stream": 412, "xtend": 539 }], 275: [function(require2, module2, exports2) {
      module2.exports = require2("level-packager")(require2("memdown"));
    }, { "level-packager": 277, "memdown": 286 }], 276: [function(require2, module2, exports2) {
      var defined = require2("defined");
      module2.exports = function(opts, prefix) {
        if (!opts)
          opts = {};
        if (!prefix)
          prefix = {};
        var xopts = {};
        var gte = defined(prefix.gte, prefix.ge, prefix.start);
        var lte = defined(prefix.lte, prefix.le, prefix.end);
        var ogte = defined(opts.gte, opts.ge, opts.start);
        var olte = defined(opts.lte, opts.le, opts.end);
        if (prefix.gt) {
          if (ogte !== void 0) {
            xopts.gte = prefix.gt(ogte);
          } else
            xopts.gt = prefix.gt(opts.gt);
        } else if (gte) {
          if (ogte !== void 0) {
            xopts.gte = gte(ogte);
          } else
            xopts.gt = gte(opts.gt);
        }
        if (prefix.lt) {
          if (olte !== void 0) {
            xopts.lte = prefix.lt(olte);
          } else
            xopts.lt = prefix.lt(opts.lt);
        } else if (lte) {
          if (olte !== void 0) {
            xopts.lte = lte(olte);
          } else
            xopts.lt = lte(opts.lt);
        }
        if (prefix.limit !== void 0) {
          xopts.limit = prefix.limit(opts.limit);
        } else if (opts.limit !== void 0) {
          xopts.limit = opts.limit;
        }
        return xopts;
      };
    }, { "defined": 128 }], 277: [function(require2, module2, exports2) {
      var levelup = require2("levelup");
      var encode = require2("encoding-down");
      function packager(leveldown) {
        function Level(location2, options, callback) {
          if (typeof location2 === "function") {
            callback = location2;
          } else if (typeof options === "function") {
            callback = options;
          }
          if (!isObject(options)) {
            options = isObject(location2) ? location2 : {};
          }
          return levelup(encode(leveldown(location2, options), options), options, callback);
        }
        function isObject(o) {
          return typeof o === "object" && o !== null;
        }
        ["destroy", "repair"].forEach(function(m) {
          if (typeof leveldown[m] === "function") {
            Level[m] = function() {
              leveldown[m].apply(leveldown, arguments);
            };
          }
        });
        Level.errors = levelup.errors;
        return Level;
      }
      module2.exports = packager;
    }, { "encoding-down": 185, "levelup": 281 }], 278: [function(require2, module2, exports2) {
      var xtend = require2("xtend");
      var assign = require2("xtend/mutable");
      module2.exports = function supports() {
        var manifest = xtend.apply(null, arguments);
        return assign(manifest, {
          bufferKeys: manifest.bufferKeys || false,
          snapshots: manifest.snapshots || false,
          permanence: manifest.permanence || false,
          seek: manifest.seek || false,
          clear: manifest.clear || false,
          status: manifest.status || false,
          createIfMissing: manifest.createIfMissing || false,
          errorIfExists: manifest.errorIfExists || false,
          deferredOpen: manifest.deferredOpen || false,
          openCallback: manifest.openCallback || false,
          promises: manifest.promises || false,
          streams: manifest.streams || false,
          encodings: manifest.encodings || false,
          additionalMethods: xtend(manifest.additionalMethods)
        });
      };
    }, { "xtend": 539, "xtend/mutable": 540 }], 279: [function(require2, module2, exports2) {
      var WriteError = require2("level-errors").WriteError;
      var promisify = require2("./promisify");
      var getCallback = require2("./common").getCallback;
      var getOptions = require2("./common").getOptions;
      function Batch(levelup) {
        this.db = this._levelup = levelup;
        this.batch = levelup.db.batch();
        this.ops = [];
        this.length = 0;
      }
      Batch.prototype.put = function(key, value) {
        try {
          this.batch.put(key, value);
        } catch (e) {
          throw new WriteError(e);
        }
        this.ops.push({
          type: "put",
          key,
          value
        });
        this.length++;
        return this;
      };
      Batch.prototype.del = function(key) {
        try {
          this.batch.del(key);
        } catch (err) {
          throw new WriteError(err);
        }
        this.ops.push({
          type: "del",
          key
        });
        this.length++;
        return this;
      };
      Batch.prototype.clear = function() {
        try {
          this.batch.clear();
        } catch (err) {
          throw new WriteError(err);
        }
        this.ops = [];
        this.length = 0;
        return this;
      };
      Batch.prototype.write = function(options, callback) {
        var levelup = this._levelup;
        var ops = this.ops;
        var promise;
        callback = getCallback(options, callback);
        if (!callback) {
          callback = promisify();
          promise = callback.promise;
        }
        options = getOptions(options);
        try {
          this.batch.write(options, function(err) {
            if (err) {
              return callback(new WriteError(err));
            }
            levelup.emit("batch", ops);
            callback();
          });
        } catch (err) {
          throw new WriteError(err);
        }
        return promise;
      };
      module2.exports = Batch;
    }, { "./common": 280, "./promisify": 282, "level-errors": 273 }], 280: [function(require2, module2, exports2) {
      exports2.getCallback = function(options, callback) {
        return typeof options === "function" ? options : callback;
      };
      exports2.getOptions = function(options) {
        return typeof options === "object" && options !== null ? options : {};
      };
    }, {}], 281: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          var EventEmitter = require2("events").EventEmitter;
          var inherits = require2("../../util/util.js").inherits;
          var extend = require2("xtend");
          var DeferredLevelDOWN = require2("deferred-leveldown");
          var IteratorStream = require2("level-iterator-stream");
          var Batch = require2("./batch");
          var errors = require2("level-errors");
          var supports = require2("level-supports");
          var assert = require2("assert");
          var promisify = require2("./promisify");
          var getCallback = require2("./common").getCallback;
          var getOptions = require2("./common").getOptions;
          var WriteError = errors.WriteError;
          var ReadError = errors.ReadError;
          var NotFoundError = errors.NotFoundError;
          var OpenError = errors.OpenError;
          var InitializationError = errors.InitializationError;
          function LevelUP(db, options, callback) {
            if (!(this instanceof LevelUP)) {
              return new LevelUP(db, options, callback);
            }
            var error;
            var self2 = this;
            EventEmitter.call(this);
            this.setMaxListeners(Infinity);
            if (typeof options === "function") {
              callback = options;
              options = {};
            }
            options = options || {};
            if (!db || typeof db !== "object") {
              error = new InitializationError("First argument must be an abstract-leveldown compliant store");
              if (typeof callback === "function") {
                return process.nextTick(callback, error);
              }
              throw error;
            }
            assert.strictEqual(typeof db.status, "string", ".status required, old abstract-leveldown");
            this.options = getOptions(options);
            this._db = db;
            this.db = new DeferredLevelDOWN(db);
            this.open(callback || function(err) {
              if (err)
                self2.emit("error", err);
            });
            this.supports = supports(this.db.supports, {
              status: false,
              deferredOpen: true,
              openCallback: true,
              promises: true,
              streams: true
            });
            Object.keys(this.supports.additionalMethods).forEach(function(method) {
              if (this[method] != null)
                return;
              this[method] = function() {
                return this.db[method].apply(this.db, arguments);
              };
            }, this);
          }
          LevelUP.prototype.emit = EventEmitter.prototype.emit;
          LevelUP.prototype.once = EventEmitter.prototype.once;
          inherits(LevelUP, EventEmitter);
          LevelUP.prototype.open = function(opts, callback) {
            var self2 = this;
            var promise;
            if (typeof opts === "function") {
              callback = opts;
              opts = null;
            }
            if (!callback) {
              callback = promisify();
              promise = callback.promise;
            }
            if (!opts) {
              opts = this.options;
            }
            if (this.isOpen()) {
              process.nextTick(callback, null, self2);
              return promise;
            }
            if (this._isOpening()) {
              this.once("open", function() {
                callback(null, self2);
              });
              return promise;
            }
            this.emit("opening");
            this.db.open(opts, function(err) {
              if (err) {
                return callback(new OpenError(err));
              }
              self2.db = self2._db;
              callback(null, self2);
              self2.emit("open");
              self2.emit("ready");
            });
            return promise;
          };
          LevelUP.prototype.close = function(callback) {
            var self2 = this;
            var promise;
            if (!callback) {
              callback = promisify();
              promise = callback.promise;
            }
            if (this.isOpen()) {
              this.db.close(function() {
                self2.emit("closed");
                callback.apply(null, arguments);
              });
              this.emit("closing");
              this.db = new DeferredLevelDOWN(this._db);
            } else if (this.isClosed()) {
              process.nextTick(callback);
            } else if (this.db.status === "closing") {
              this.once("closed", callback);
            } else if (this._isOpening()) {
              this.once("open", function() {
                self2.close(callback);
              });
            }
            return promise;
          };
          LevelUP.prototype.isOpen = function() {
            return this.db.status === "open";
          };
          LevelUP.prototype._isOpening = function() {
            return this.db.status === "opening";
          };
          LevelUP.prototype.isClosed = function() {
            return /^clos|new/.test(this.db.status);
          };
          LevelUP.prototype.get = function(key, options, callback) {
            var promise;
            callback = getCallback(options, callback);
            if (!callback) {
              callback = promisify();
              promise = callback.promise;
            }
            if (maybeError(this, callback)) {
              return promise;
            }
            options = getOptions(options);
            this.db.get(key, options, function(err, value) {
              if (err) {
                if (/notfound/i.test(err) || err.notFound) {
                  err = new NotFoundError("Key not found in database [" + key + "]", err);
                } else {
                  err = new ReadError(err);
                }
                return callback(err);
              }
              callback(null, value);
            });
            return promise;
          };
          LevelUP.prototype.put = function(key, value, options, callback) {
            var self2 = this;
            var promise;
            callback = getCallback(options, callback);
            if (!callback) {
              callback = promisify();
              promise = callback.promise;
            }
            if (maybeError(this, callback)) {
              return promise;
            }
            options = getOptions(options);
            this.db.put(key, value, options, function(err) {
              if (err) {
                return callback(new WriteError(err));
              }
              self2.emit("put", key, value);
              callback();
            });
            return promise;
          };
          LevelUP.prototype.del = function(key, options, callback) {
            var self2 = this;
            var promise;
            callback = getCallback(options, callback);
            if (!callback) {
              callback = promisify();
              promise = callback.promise;
            }
            if (maybeError(this, callback)) {
              return promise;
            }
            options = getOptions(options);
            this.db.del(key, options, function(err) {
              if (err) {
                return callback(new WriteError(err));
              }
              self2.emit("del", key);
              callback();
            });
            return promise;
          };
          LevelUP.prototype.batch = function(arr, options, callback) {
            if (!arguments.length) {
              return new Batch(this);
            }
            var self2 = this;
            var promise;
            if (typeof arr === "function")
              callback = arr;
            else
              callback = getCallback(options, callback);
            if (!callback) {
              callback = promisify();
              promise = callback.promise;
            }
            if (maybeError(this, callback)) {
              return promise;
            }
            options = getOptions(options);
            this.db.batch(arr, options, function(err) {
              if (err) {
                return callback(new WriteError(err));
              }
              self2.emit("batch", arr);
              callback();
            });
            return promise;
          };
          LevelUP.prototype.iterator = function(options) {
            return this.db.iterator(options);
          };
          LevelUP.prototype.clear = function(options, callback) {
            var self2 = this;
            var promise;
            callback = getCallback(options, callback);
            options = getOptions(options);
            if (!callback) {
              callback = promisify();
              promise = callback.promise;
            }
            if (maybeError(this, callback)) {
              return promise;
            }
            this.db.clear(options, function(err) {
              if (err) {
                return callback(new WriteError(err));
              }
              self2.emit("clear", options);
              callback();
            });
            return promise;
          };
          LevelUP.prototype.readStream = LevelUP.prototype.createReadStream = function(options) {
            options = extend({
              keys: true,
              values: true
            }, options);
            if (typeof options.limit !== "number") {
              options.limit = -1;
            }
            return new IteratorStream(this.db.iterator(options), options);
          };
          LevelUP.prototype.keyStream = LevelUP.prototype.createKeyStream = function(options) {
            return this.createReadStream(extend(options, {
              keys: true,
              values: false
            }));
          };
          LevelUP.prototype.valueStream = LevelUP.prototype.createValueStream = function(options) {
            return this.createReadStream(extend(options, {
              keys: false,
              values: true
            }));
          };
          LevelUP.prototype.toString = function() {
            return "LevelUP";
          };
          LevelUP.prototype.type = "levelup";
          function maybeError(db, callback) {
            if (!db._isOpening() && !db.isOpen()) {
              process.nextTick(callback, new ReadError("Database is not open"));
              return true;
            }
          }
          LevelUP.errors = errors;
          module2.exports = LevelUP.default = LevelUP;
        }).call(this);
      }).call(this, require2("_process"));
    }, { "../../util/util.js": 514, "./batch": 279, "./common": 280, "./promisify": 282, "_process": 361, "assert": 36, "deferred-leveldown": 122, "events": 193, "level-errors": 273, "level-iterator-stream": 274, "level-supports": 278, "xtend": 539 }], 282: [function(require2, module2, exports2) {
      function promisify() {
        var callback;
        var promise = new Promise(function(resolve, reject) {
          callback = function callback2(err, value) {
            if (err)
              reject(err);
            else
              resolve(value);
          };
        });
        callback.promise = promise;
        return callback;
      }
      module2.exports = promisify;
    }, {}], 283: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          exports2.compare = function(a, b) {
            if (Buffer.isBuffer(a)) {
              var l = Math.min(a.length, b.length);
              for (var i = 0; i < l; i++) {
                var cmp = a[i] - b[i];
                if (cmp)
                  return cmp;
              }
              return a.length - b.length;
            }
            return a < b ? -1 : a > b ? 1 : 0;
          };
          function isDef(val) {
            return val !== void 0 && val !== "";
          }
          function has(range, name) {
            return Object.hasOwnProperty.call(range, name);
          }
          function hasKey(range, name) {
            return Object.hasOwnProperty.call(range, name) && name;
          }
          var lowerBoundKey = exports2.lowerBoundKey = function(range) {
            return hasKey(range, "gt") || hasKey(range, "gte") || hasKey(range, "min") || (range.reverse ? hasKey(range, "end") : hasKey(range, "start")) || void 0;
          };
          var lowerBound = exports2.lowerBound = function(range, def) {
            var k = lowerBoundKey(range);
            return k ? range[k] : def;
          };
          var lowerBoundInclusive = exports2.lowerBoundInclusive = function(range) {
            return has(range, "gt") ? false : true;
          };
          var upperBoundInclusive = exports2.upperBoundInclusive = function(range) {
            return has(range, "lt") ? false : true;
          };
          var lowerBoundExclusive = exports2.lowerBoundExclusive = function(range) {
            return !lowerBoundInclusive(range);
          };
          var upperBoundExclusive = exports2.upperBoundExclusive = function(range) {
            return !upperBoundInclusive(range);
          };
          var upperBoundKey = exports2.upperBoundKey = function(range) {
            return hasKey(range, "lt") || hasKey(range, "lte") || hasKey(range, "max") || (range.reverse ? hasKey(range, "start") : hasKey(range, "end")) || void 0;
          };
          var upperBound = exports2.upperBound = function(range, def) {
            var k = upperBoundKey(range);
            return k ? range[k] : def;
          };
          exports2.start = function(range, def) {
            return range.reverse ? upperBound(range, def) : lowerBound(range, def);
          };
          exports2.end = function(range, def) {
            return range.reverse ? lowerBound(range, def) : upperBound(range, def);
          };
          exports2.startInclusive = function(range) {
            return range.reverse ? upperBoundInclusive(range) : lowerBoundInclusive(range);
          };
          exports2.endInclusive = function(range) {
            return range.reverse ? lowerBoundInclusive(range) : upperBoundInclusive(range);
          };
          function id(e) {
            return e;
          }
          exports2.toLtgt = function(range, _range, map, lower, upper) {
            _range = _range || {};
            map = map || id;
            var defaults = arguments.length > 3;
            var lb = exports2.lowerBoundKey(range);
            var ub = exports2.upperBoundKey(range);
            if (lb) {
              if (lb === "gt")
                _range.gt = map(range.gt, false);
              else
                _range.gte = map(range[lb], false);
            } else if (defaults)
              _range.gte = map(lower, false);
            if (ub) {
              if (ub === "lt")
                _range.lt = map(range.lt, true);
              else
                _range.lte = map(range[ub], true);
            } else if (defaults)
              _range.lte = map(upper, true);
            if (range.reverse != null)
              _range.reverse = !!range.reverse;
            if (has(_range, "max"))
              delete _range.max;
            if (has(_range, "min"))
              delete _range.min;
            if (has(_range, "start"))
              delete _range.start;
            if (has(_range, "end"))
              delete _range.end;
            return _range;
          };
          exports2.contains = function(range, key, compare) {
            compare = compare || exports2.compare;
            var lb = lowerBound(range);
            if (isDef(lb)) {
              var cmp = compare(key, lb);
              if (cmp < 0 || cmp === 0 && lowerBoundExclusive(range))
                return false;
            }
            var ub = upperBound(range);
            if (isDef(ub)) {
              var cmp = compare(key, ub);
              if (cmp > 0 || cmp === 0 && upperBoundExclusive(range))
                return false;
            }
            return true;
          };
          exports2.filter = function(range, compare) {
            return function(key) {
              return exports2.contains(range, key, compare);
            };
          };
        }).call(this);
      }).call(this, { "isBuffer": require2("../is-buffer/index.js") });
    }, { "../is-buffer/index.js": 259 }], 284: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var HashBase = require2("hash-base");
      var Buffer = require2("safe-buffer").Buffer;
      var ARRAY16 = new Array(16);
      function MD5() {
        HashBase.call(this, 64);
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
      }
      inherits(MD5, HashBase);
      MD5.prototype._update = function() {
        var M = ARRAY16;
        for (var i = 0; i < 16; ++i) {
          M[i] = this._block.readInt32LE(i * 4);
        }
        var a = this._a;
        var b = this._b;
        var c = this._c;
        var d = this._d;
        a = fnF(a, b, c, d, M[0], 3614090360, 7);
        d = fnF(d, a, b, c, M[1], 3905402710, 12);
        c = fnF(c, d, a, b, M[2], 606105819, 17);
        b = fnF(b, c, d, a, M[3], 3250441966, 22);
        a = fnF(a, b, c, d, M[4], 4118548399, 7);
        d = fnF(d, a, b, c, M[5], 1200080426, 12);
        c = fnF(c, d, a, b, M[6], 2821735955, 17);
        b = fnF(b, c, d, a, M[7], 4249261313, 22);
        a = fnF(a, b, c, d, M[8], 1770035416, 7);
        d = fnF(d, a, b, c, M[9], 2336552879, 12);
        c = fnF(c, d, a, b, M[10], 4294925233, 17);
        b = fnF(b, c, d, a, M[11], 2304563134, 22);
        a = fnF(a, b, c, d, M[12], 1804603682, 7);
        d = fnF(d, a, b, c, M[13], 4254626195, 12);
        c = fnF(c, d, a, b, M[14], 2792965006, 17);
        b = fnF(b, c, d, a, M[15], 1236535329, 22);
        a = fnG(a, b, c, d, M[1], 4129170786, 5);
        d = fnG(d, a, b, c, M[6], 3225465664, 9);
        c = fnG(c, d, a, b, M[11], 643717713, 14);
        b = fnG(b, c, d, a, M[0], 3921069994, 20);
        a = fnG(a, b, c, d, M[5], 3593408605, 5);
        d = fnG(d, a, b, c, M[10], 38016083, 9);
        c = fnG(c, d, a, b, M[15], 3634488961, 14);
        b = fnG(b, c, d, a, M[4], 3889429448, 20);
        a = fnG(a, b, c, d, M[9], 568446438, 5);
        d = fnG(d, a, b, c, M[14], 3275163606, 9);
        c = fnG(c, d, a, b, M[3], 4107603335, 14);
        b = fnG(b, c, d, a, M[8], 1163531501, 20);
        a = fnG(a, b, c, d, M[13], 2850285829, 5);
        d = fnG(d, a, b, c, M[2], 4243563512, 9);
        c = fnG(c, d, a, b, M[7], 1735328473, 14);
        b = fnG(b, c, d, a, M[12], 2368359562, 20);
        a = fnH(a, b, c, d, M[5], 4294588738, 4);
        d = fnH(d, a, b, c, M[8], 2272392833, 11);
        c = fnH(c, d, a, b, M[11], 1839030562, 16);
        b = fnH(b, c, d, a, M[14], 4259657740, 23);
        a = fnH(a, b, c, d, M[1], 2763975236, 4);
        d = fnH(d, a, b, c, M[4], 1272893353, 11);
        c = fnH(c, d, a, b, M[7], 4139469664, 16);
        b = fnH(b, c, d, a, M[10], 3200236656, 23);
        a = fnH(a, b, c, d, M[13], 681279174, 4);
        d = fnH(d, a, b, c, M[0], 3936430074, 11);
        c = fnH(c, d, a, b, M[3], 3572445317, 16);
        b = fnH(b, c, d, a, M[6], 76029189, 23);
        a = fnH(a, b, c, d, M[9], 3654602809, 4);
        d = fnH(d, a, b, c, M[12], 3873151461, 11);
        c = fnH(c, d, a, b, M[15], 530742520, 16);
        b = fnH(b, c, d, a, M[2], 3299628645, 23);
        a = fnI(a, b, c, d, M[0], 4096336452, 6);
        d = fnI(d, a, b, c, M[7], 1126891415, 10);
        c = fnI(c, d, a, b, M[14], 2878612391, 15);
        b = fnI(b, c, d, a, M[5], 4237533241, 21);
        a = fnI(a, b, c, d, M[12], 1700485571, 6);
        d = fnI(d, a, b, c, M[3], 2399980690, 10);
        c = fnI(c, d, a, b, M[10], 4293915773, 15);
        b = fnI(b, c, d, a, M[1], 2240044497, 21);
        a = fnI(a, b, c, d, M[8], 1873313359, 6);
        d = fnI(d, a, b, c, M[15], 4264355552, 10);
        c = fnI(c, d, a, b, M[6], 2734768916, 15);
        b = fnI(b, c, d, a, M[13], 1309151649, 21);
        a = fnI(a, b, c, d, M[4], 4149444226, 6);
        d = fnI(d, a, b, c, M[11], 3174756917, 10);
        c = fnI(c, d, a, b, M[2], 718787259, 15);
        b = fnI(b, c, d, a, M[9], 3951481745, 21);
        this._a = this._a + a | 0;
        this._b = this._b + b | 0;
        this._c = this._c + c | 0;
        this._d = this._d + d | 0;
      };
      MD5.prototype._digest = function() {
        this._block[this._blockOffset++] = 128;
        if (this._blockOffset > 56) {
          this._block.fill(0, this._blockOffset, 64);
          this._update();
          this._blockOffset = 0;
        }
        this._block.fill(0, this._blockOffset, 56);
        this._block.writeUInt32LE(this._length[0], 56);
        this._block.writeUInt32LE(this._length[1], 60);
        this._update();
        var buffer = Buffer.allocUnsafe(16);
        buffer.writeInt32LE(this._a, 0);
        buffer.writeInt32LE(this._b, 4);
        buffer.writeInt32LE(this._c, 8);
        buffer.writeInt32LE(this._d, 12);
        return buffer;
      };
      function rotl(x, n) {
        return x << n | x >>> 32 - n;
      }
      function fnF(a, b, c, d, m, k, s) {
        return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
      }
      function fnG(a, b, c, d, m, k, s) {
        return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
      }
      function fnH(a, b, c, d, m, k, s) {
        return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
      }
      function fnI(a, b, c, d, m, k, s) {
        return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
      }
      module2.exports = MD5;
    }, { "hash-base": 210, "inherits": 256, "safe-buffer": 417 }], 285: [function(require2, module2, exports2) {
      module2.exports = require2("immediate");
    }, { "immediate": 292 }], 286: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var AbstractLevelDOWN = require2("abstract-leveldown").AbstractLevelDOWN;
      var AbstractIterator = require2("abstract-leveldown").AbstractIterator;
      var ltgt = require2("ltgt");
      var createRBT = require2("functional-red-black-tree");
      var Buffer = require2("safe-buffer").Buffer;
      var setImmediate = require2("./immediate");
      var NONE = {};
      function gt(value) {
        return ltgt.compare(value, this._upperBound) > 0;
      }
      function gte(value) {
        return ltgt.compare(value, this._upperBound) >= 0;
      }
      function lt(value) {
        return ltgt.compare(value, this._upperBound) < 0;
      }
      function lte(value) {
        return ltgt.compare(value, this._upperBound) <= 0;
      }
      function MemIterator(db, options) {
        AbstractIterator.call(this, db);
        this._limit = options.limit;
        if (this._limit === -1)
          this._limit = Infinity;
        var tree = db._store;
        this.keyAsBuffer = options.keyAsBuffer !== false;
        this.valueAsBuffer = options.valueAsBuffer !== false;
        this._reverse = options.reverse;
        this._options = options;
        this._done = 0;
        if (!this._reverse) {
          this._incr = "next";
          this._lowerBound = ltgt.lowerBound(options, NONE);
          this._upperBound = ltgt.upperBound(options, NONE);
          if (this._lowerBound === NONE) {
            this._tree = tree.begin;
          } else if (ltgt.lowerBoundInclusive(options)) {
            this._tree = tree.ge(this._lowerBound);
          } else {
            this._tree = tree.gt(this._lowerBound);
          }
          if (this._upperBound !== NONE) {
            if (ltgt.upperBoundInclusive(options)) {
              this._test = lte;
            } else {
              this._test = lt;
            }
          }
        } else {
          this._incr = "prev";
          this._lowerBound = ltgt.upperBound(options, NONE);
          this._upperBound = ltgt.lowerBound(options, NONE);
          if (this._lowerBound === NONE) {
            this._tree = tree.end;
          } else if (ltgt.upperBoundInclusive(options)) {
            this._tree = tree.le(this._lowerBound);
          } else {
            this._tree = tree.lt(this._lowerBound);
          }
          if (this._upperBound !== NONE) {
            if (ltgt.lowerBoundInclusive(options)) {
              this._test = gte;
            } else {
              this._test = gt;
            }
          }
        }
      }
      inherits(MemIterator, AbstractIterator);
      MemIterator.prototype._next = function(callback) {
        var key;
        var value;
        if (this._done++ >= this._limit)
          return setImmediate(callback);
        if (!this._tree.valid)
          return setImmediate(callback);
        key = this._tree.key;
        value = this._tree.value;
        if (!this._test(key))
          return setImmediate(callback);
        if (!this.keyAsBuffer) {
          key = key.toString();
        }
        if (!this.valueAsBuffer) {
          value = value.toString();
        }
        this._tree[this._incr]();
        setImmediate(function callNext() {
          callback(null, key, value);
        });
      };
      MemIterator.prototype._test = function() {
        return true;
      };
      MemIterator.prototype._outOfRange = function(target) {
        if (!this._test(target)) {
          return true;
        } else if (this._lowerBound === NONE) {
          return false;
        } else if (!this._reverse) {
          if (ltgt.lowerBoundInclusive(this._options)) {
            return ltgt.compare(target, this._lowerBound) < 0;
          } else {
            return ltgt.compare(target, this._lowerBound) <= 0;
          }
        } else {
          if (ltgt.upperBoundInclusive(this._options)) {
            return ltgt.compare(target, this._lowerBound) > 0;
          } else {
            return ltgt.compare(target, this._lowerBound) >= 0;
          }
        }
      };
      MemIterator.prototype._seek = function(target) {
        if (target.length === 0) {
          throw new Error("cannot seek() to an empty target");
        }
        if (this._outOfRange(target)) {
          this._tree = this.db._store.end;
          this._tree.next();
        } else if (this._reverse) {
          this._tree = this.db._store.le(target);
        } else {
          this._tree = this.db._store.ge(target);
        }
      };
      function MemDOWN() {
        if (!(this instanceof MemDOWN))
          return new MemDOWN();
        AbstractLevelDOWN.call(this, {
          bufferKeys: true,
          snapshots: true,
          permanence: false,
          seek: true,
          clear: true
        });
        this._store = createRBT(ltgt.compare);
      }
      inherits(MemDOWN, AbstractLevelDOWN);
      MemDOWN.prototype._open = function(options, callback) {
        var self2 = this;
        setImmediate(function callNext() {
          callback(null, self2);
        });
      };
      MemDOWN.prototype._serializeKey = function(key) {
        return Buffer.isBuffer(key) ? key : Buffer.from(String(key));
      };
      MemDOWN.prototype._serializeValue = function(value) {
        return Buffer.isBuffer(value) ? value : Buffer.from(String(value));
      };
      MemDOWN.prototype._put = function(key, value, options, callback) {
        var iter = this._store.find(key);
        if (iter.valid) {
          this._store = iter.update(value);
        } else {
          this._store = this._store.insert(key, value);
        }
        setImmediate(callback);
      };
      MemDOWN.prototype._get = function(key, options, callback) {
        var value = this._store.get(key);
        if (typeof value === "undefined") {
          return setImmediate(function callNext() {
            callback(new Error("NotFound"));
          });
        }
        if (!options.asBuffer) {
          value = value.toString();
        }
        setImmediate(function callNext() {
          callback(null, value);
        });
      };
      MemDOWN.prototype._del = function(key, options, callback) {
        this._store = this._store.remove(key);
        setImmediate(callback);
      };
      MemDOWN.prototype._batch = function(array, options, callback) {
        var i = -1;
        var key;
        var value;
        var iter;
        var len = array.length;
        var tree = this._store;
        while (++i < len) {
          key = array[i].key;
          iter = tree.find(key);
          if (array[i].type === "put") {
            value = array[i].value;
            tree = iter.valid ? iter.update(value) : tree.insert(key, value);
          } else {
            tree = iter.remove();
          }
        }
        this._store = tree;
        setImmediate(callback);
      };
      MemDOWN.prototype._iterator = function(options) {
        return new MemIterator(this, options);
      };
      module2.exports = MemDOWN.default = MemDOWN;
      module2.exports.MemIterator = MemIterator;
    }, { "./immediate": 285, "abstract-leveldown": 290, "functional-red-black-tree": 204, "inherits": 256, "ltgt": 283, "safe-buffer": 417 }], 287: [function(require2, module2, exports2) {
      arguments[4][15][0].apply(exports2, arguments);
    }, { "./next-tick": 291, "dup": 15 }], 288: [function(require2, module2, exports2) {
      arguments[4][16][0].apply(exports2, arguments);
    }, { "./next-tick": 291, "dup": 16 }], 289: [function(require2, module2, exports2) {
      arguments[4][17][0].apply(exports2, arguments);
    }, { "./abstract-chained-batch": 287, "./abstract-iterator": 288, "./next-tick": 291, "buffer": 82, "dup": 17, "level-supports": 278, "xtend": 539 }], 290: [function(require2, module2, exports2) {
      arguments[4][18][0].apply(exports2, arguments);
    }, { "./abstract-chained-batch": 287, "./abstract-iterator": 288, "./abstract-leveldown": 289, "dup": 18 }], 291: [function(require2, module2, exports2) {
      arguments[4][19][0].apply(exports2, arguments);
    }, { "dup": 19, "immediate": 292 }], 292: [function(require2, module2, exports2) {
      var types = [require2("./nextTick"), require2("./mutation.js"), require2("./messageChannel"), require2("./stateChange"), require2("./timeout")];
      var draining;
      var currentQueue;
      var queueIndex = -1;
      var queue = [];
      var scheduled = false;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          nextTick();
        }
      }
      function nextTick() {
        if (draining) {
          return;
        }
        scheduled = false;
        draining = true;
        var len2 = queue.length;
        var timeout = setTimeout(cleanUpNextTick);
        while (len2) {
          currentQueue = queue;
          queue = [];
          while (currentQueue && ++queueIndex < len2) {
            currentQueue[queueIndex].run();
          }
          queueIndex = -1;
          len2 = queue.length;
        }
        currentQueue = null;
        queueIndex = -1;
        draining = false;
        clearTimeout(timeout);
      }
      var scheduleDrain;
      var i = -1;
      var len = types.length;
      while (++i < len) {
        if (types[i] && types[i].test && types[i].test()) {
          scheduleDrain = types[i].install(nextTick);
          break;
        }
      }
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        var fun = this.fun;
        var array = this.array;
        switch (array.length) {
          case 0:
            return fun();
          case 1:
            return fun(array[0]);
          case 2:
            return fun(array[0], array[1]);
          case 3:
            return fun(array[0], array[1], array[2]);
          default:
            return fun.apply(null, array);
        }
      };
      module2.exports = immediate;
      function immediate(task) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            args[i2 - 1] = arguments[i2];
          }
        }
        queue.push(new Item(task, args));
        if (!scheduled && !draining) {
          scheduled = true;
          scheduleDrain();
        }
      }
    }, { "./messageChannel": 293, "./mutation.js": 294, "./nextTick": 295, "./stateChange": 296, "./timeout": 297 }], 293: [function(require2, module2, exports2) {
      arguments[4][251][0].apply(exports2, arguments);
    }, { "dup": 251 }], 294: [function(require2, module2, exports2) {
      arguments[4][252][0].apply(exports2, arguments);
    }, { "dup": 252 }], 295: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          exports2.test = function() {
            return typeof process !== "undefined" && !process.browser;
          };
          exports2.install = function(func) {
            return function() {
              process.nextTick(func);
            };
          };
        }).call(this);
      }).call(this, require2("_process"));
    }, { "_process": 361 }], 296: [function(require2, module2, exports2) {
      arguments[4][254][0].apply(exports2, arguments);
    }, { "dup": 254 }], 297: [function(require2, module2, exports2) {
      arguments[4][255][0].apply(exports2, arguments);
    }, { "dup": 255 }], 298: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          module2.exports = Pager;
          function Pager(pageSize, opts) {
            if (!(this instanceof Pager))
              return new Pager(pageSize, opts);
            this.length = 0;
            this.updates = [];
            this.path = new Uint16Array(4);
            this.pages = new Array(32768);
            this.maxPages = this.pages.length;
            this.level = 0;
            this.pageSize = pageSize || 1024;
            this.deduplicate = opts ? opts.deduplicate : null;
            this.zeros = this.deduplicate ? alloc(this.deduplicate.length) : null;
          }
          Pager.prototype.updated = function(page) {
            while (this.deduplicate && page.buffer[page.deduplicate] === this.deduplicate[page.deduplicate]) {
              page.deduplicate++;
              if (page.deduplicate === this.deduplicate.length) {
                page.deduplicate = 0;
                if (page.buffer.equals && page.buffer.equals(this.deduplicate))
                  page.buffer = this.deduplicate;
                break;
              }
            }
            if (page.updated || !this.updates)
              return;
            page.updated = true;
            this.updates.push(page);
          };
          Pager.prototype.lastUpdate = function() {
            if (!this.updates || !this.updates.length)
              return null;
            var page = this.updates.pop();
            page.updated = false;
            return page;
          };
          Pager.prototype._array = function(i, noAllocate) {
            if (i >= this.maxPages) {
              if (noAllocate)
                return;
              grow(this, i);
            }
            factor(i, this.path);
            var arr = this.pages;
            for (var j = this.level; j > 0; j--) {
              var p = this.path[j];
              var next = arr[p];
              if (!next) {
                if (noAllocate)
                  return;
                next = arr[p] = new Array(32768);
              }
              arr = next;
            }
            return arr;
          };
          Pager.prototype.get = function(i, noAllocate) {
            var arr = this._array(i, noAllocate);
            var first = this.path[0];
            var page = arr && arr[first];
            if (!page && !noAllocate) {
              page = arr[first] = new Page(i, alloc(this.pageSize));
              if (i >= this.length)
                this.length = i + 1;
            }
            if (page && page.buffer === this.deduplicate && this.deduplicate && !noAllocate) {
              page.buffer = copy(page.buffer);
              page.deduplicate = 0;
            }
            return page;
          };
          Pager.prototype.set = function(i, buf) {
            var arr = this._array(i, false);
            var first = this.path[0];
            if (i >= this.length)
              this.length = i + 1;
            if (!buf || this.zeros && buf.equals && buf.equals(this.zeros)) {
              arr[first] = void 0;
              return;
            }
            if (this.deduplicate && buf.equals && buf.equals(this.deduplicate)) {
              buf = this.deduplicate;
            }
            var page = arr[first];
            var b = truncate(buf, this.pageSize);
            if (page)
              page.buffer = b;
            else
              arr[first] = new Page(i, b);
          };
          Pager.prototype.toBuffer = function() {
            var list = new Array(this.length);
            var empty = alloc(this.pageSize);
            var ptr = 0;
            while (ptr < list.length) {
              var arr = this._array(ptr, true);
              for (var i = 0; i < 32768 && ptr < list.length; i++) {
                list[ptr++] = arr && arr[i] ? arr[i].buffer : empty;
              }
            }
            return Buffer.concat(list);
          };
          function grow(pager, index) {
            while (pager.maxPages < index) {
              var old = pager.pages;
              pager.pages = new Array(32768);
              pager.pages[0] = old;
              pager.level++;
              pager.maxPages *= 32768;
            }
          }
          function truncate(buf, len) {
            if (buf.length === len)
              return buf;
            if (buf.length > len)
              return buf.slice(0, len);
            var cpy = alloc(len);
            buf.copy(cpy);
            return cpy;
          }
          function alloc(size) {
            if (Buffer.alloc)
              return Buffer.alloc(size);
            var buf = new Buffer(size);
            buf.fill(0);
            return buf;
          }
          function copy(buf) {
            var cpy = Buffer.allocUnsafe ? Buffer.allocUnsafe(buf.length) : new Buffer(buf.length);
            buf.copy(cpy);
            return cpy;
          }
          function Page(i, buf) {
            this.offset = i * buf.length;
            this.buffer = buf;
            this.updated = false;
            this.deduplicate = 0;
          }
          function factor(n, out) {
            n = (n - (out[0] = n & 32767)) / 32768;
            n = (n - (out[1] = n & 32767)) / 32768;
            out[3] = (n - (out[2] = n & 32767)) / 32768 & 32767;
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82 }], 299: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var flat = require2("flat-tree");
          module2.exports = class MerkleGenerator {
            constructor(opts, roots) {
              if (!opts || !opts.leaf || !opts.parent)
                throw new Error("opts.leaf and opts.parent required");
              this.roots = roots || opts.roots || [];
              this.blocks = this.roots.length ? 1 + flat.rightSpan(this.roots[this.roots.length - 1].index) / 2 : 0;
              for (var i = 0; i < this.roots.length; i++) {
                var r = this.roots[i];
                if (r && !r.parent)
                  r.parent = flat.parent(r.index);
              }
              this._leaf = opts.leaf;
              this._parent = opts.parent;
            }
            next(data, nodes) {
              if (!Buffer.isBuffer(data))
                data = Buffer.from(data);
              if (!nodes)
                nodes = [];
              var index = 2 * this.blocks++;
              var leaf = {
                index,
                parent: flat.parent(index),
                hash: null,
                size: data.length,
                data
              };
              leaf.hash = this._leaf(leaf, this.roots);
              this.roots.push(leaf);
              nodes.push(leaf);
              while (this.roots.length > 1) {
                var left = this.roots[this.roots.length - 2];
                var right = this.roots[this.roots.length - 1];
                if (left.parent !== right.parent)
                  break;
                this.roots.pop();
                this.roots[this.roots.length - 1] = leaf = {
                  index: left.parent,
                  parent: flat.parent(left.parent),
                  hash: this._parent(left, right),
                  size: left.size + right.size,
                  data: null
                };
                nodes.push(leaf);
              }
              return nodes;
            }
          };
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82, "flat-tree": 200 }], 300: [function(require2, module2, exports2) {
      var bn = require2("bn.js");
      var brorand = require2("brorand");
      function MillerRabin(rand) {
        this.rand = rand || new brorand.Rand();
      }
      module2.exports = MillerRabin;
      MillerRabin.create = function create(rand) {
        return new MillerRabin(rand);
      };
      MillerRabin.prototype._randbelow = function _randbelow(n) {
        var len = n.bitLength();
        var min_bytes = Math.ceil(len / 8);
        do {
          var a = new bn(this.rand.generate(min_bytes));
        } while (a.cmp(n) >= 0);
        return a;
      };
      MillerRabin.prototype._randrange = function _randrange(start, stop) {
        var size = stop.sub(start);
        return start.add(this._randbelow(size));
      };
      MillerRabin.prototype.test = function test(n, k, cb) {
        var len = n.bitLength();
        var red = bn.mont(n);
        var rone = new bn(1).toRed(red);
        if (!k)
          k = Math.max(1, len / 48 | 0);
        var n1 = n.subn(1);
        for (var s = 0; !n1.testn(s); s++) {
        }
        var d = n.shrn(s);
        var rn1 = n1.toRed(red);
        var prime = true;
        for (; k > 0; k--) {
          var a = this._randrange(new bn(2), n1);
          if (cb)
            cb(a);
          var x = a.toRed(red).redPow(d);
          if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
            continue;
          for (var i = 1; i < s; i++) {
            x = x.redSqr();
            if (x.cmp(rone) === 0)
              return false;
            if (x.cmp(rn1) === 0)
              break;
          }
          if (i === s)
            return false;
        }
        return prime;
      };
      MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
        var len = n.bitLength();
        var red = bn.mont(n);
        var rone = new bn(1).toRed(red);
        if (!k)
          k = Math.max(1, len / 48 | 0);
        var n1 = n.subn(1);
        for (var s = 0; !n1.testn(s); s++) {
        }
        var d = n.shrn(s);
        var rn1 = n1.toRed(red);
        for (; k > 0; k--) {
          var a = this._randrange(new bn(2), n1);
          var g = n.gcd(a);
          if (g.cmpn(1) !== 0)
            return g;
          var x = a.toRed(red).redPow(d);
          if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
            continue;
          for (var i = 1; i < s; i++) {
            x = x.redSqr();
            if (x.cmp(rone) === 0)
              return x.fromRed().subn(1).gcd(n);
            if (x.cmp(rn1) === 0)
              break;
          }
          if (i === s) {
            x = x.redSqr();
            return x.fromRed().subn(1).gcd(n);
          }
        }
        return false;
      };
    }, { "bn.js": 301, "brorand": 52 }], 301: [function(require2, module2, exports2) {
      arguments[4][35][0].apply(exports2, arguments);
    }, { "buffer": 53, "dup": 35 }], 302: [function(require2, module2, exports2) {
      module2.exports = assert;
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      assert.equal = function assertEqual(l, r, msg) {
        if (l != r)
          throw new Error(msg || "Assertion failed: " + l + " != " + r);
      };
    }, {}], 303: [function(require2, module2, exports2) {
      var utils = exports2;
      function toArray(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg !== "string") {
          for (var i = 0; i < msg.length; i++) {
            res[i] = msg[i] | 0;
          }
          return res;
        }
        if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (var i = 0; i < msg.length; i += 2) {
            res.push(parseInt(msg[i] + msg[i + 1], 16));
          }
        } else {
          for (var i = 0; i < msg.length; i++) {
            var c = msg.charCodeAt(i);
            var hi = c >> 8;
            var lo = c & 255;
            if (hi)
              res.push(hi, lo);
            else
              res.push(lo);
          }
        }
        return res;
      }
      utils.toArray = toArray;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      utils.zero2 = zero2;
      function toHex(msg) {
        var res = "";
        for (var i = 0; i < msg.length; i++) {
          res += zero2(msg[i].toString(16));
        }
        return res;
      }
      utils.toHex = toHex;
      utils.encode = function encode(arr, enc) {
        if (enc === "hex")
          return toHex(arr);
        else
          return arr;
      };
    }, {}], 304: [function(require2, module2, exports2) {
      function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator(fn) {
        return function() {
          var self2 = this, args = arguments;
          return new Promise(function(resolve, reject) {
            var gen = fn.apply(self2, args);
            function _next(value) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(void 0);
          });
        };
      }
      var delay = require2("delay");
      var eos = require2("end-of-stream-promise");
      var defer = require2("promise-defer");
      var randomize = require2("randomize-array");
      var distance = require2("xor-distance");
      var PQueue = require2("p-queue").default;
      var EventEmitter = require2("events");
      var DEFAULT_SAMPLE_SIZE = 10;
      var DEFAULT_PERCENT_FAR = 0.33;
      var DEFAULT_LOOKUP_TIMEOUT = 1e3;
      var DEFAULT_MAX_PEERS = 4;
      module2.exports = class MMST extends EventEmitter {
        constructor(_ref) {
          var {
            id,
            lookup,
            connect,
            sampleSize = DEFAULT_SAMPLE_SIZE,
            percentFar = DEFAULT_PERCENT_FAR,
            maxPeers = DEFAULT_MAX_PEERS,
            lookupTimeout = DEFAULT_LOOKUP_TIMEOUT,
            queueTimeout = lookupTimeout + 2 * 1e3
          } = _ref;
          super();
          this.id = id;
          this._lookup = lookup;
          this._connect = connect;
          this.sampleSize = sampleSize;
          this.percentFar = percentFar;
          this.maxPeers = maxPeers;
          if (lookupTimeout > queueTimeout) {
            throw new Error("queueTimeout must be higher than lookupTimeout");
          }
          this.lookupTimeout = lookupTimeout;
          this.queue = new PQueue({
            concurrency: 1,
            timeout: queueTimeout
          });
          this.connectedPeers = /* @__PURE__ */ new Set();
          this.hasConnectedFar = false;
          this.destroyed = false;
        }
        shouldHandleIncoming() {
          return this.connectedPeers.size < this.maxPeers;
        }
        handleIncoming(id, connection) {
          if (!this.shouldHandleIncoming(id)) {
            connection.close();
            return;
          }
          this.addConnection(id, connection);
        }
        addConnection(id, connection) {
          var stringId = id.toString("hex");
          this.connectedPeers.add(stringId);
          connection.once("close", () => {
            this.connectedPeers.delete(stringId);
            this.queue.add(() => this.run());
          });
        }
        run() {
          var _this = this;
          return _asyncToGenerator(function* () {
            if (!_this.shouldHandleIncoming())
              return;
            if (_this.destroyed)
              return;
            var found = [];
            var stream = _this._lookup();
            var gotEnough = defer();
            var finish = Promise.race([eos(stream), delay(_this.lookupTimeout), gotEnough.promise]);
            stream.on("data", (peers) => {
              found.push(...peers);
              if (found.length >= _this.sampleSize)
                gotEnough.resolve();
            });
            yield finish;
            if (_this.destroyed)
              return;
            var sample = found.slice();
            if (sample.length > _this.sampleSize) {
              sample = randomize(found).slice(0, _this.sampleSize);
            }
            sample.sort((a, b) => distance.gt(distance(_this.id, a), distance(_this.id, b)));
            var connected = false;
            for (var peer of sample) {
              if (_this.destroyed)
                return;
              var stringId = peer.toString("hex");
              if (_this.connectedPeers.has(stringId))
                continue;
              try {
                var connection = yield _this._connect(peer);
                connected = true;
                _this.addConnection(peer, connection);
                break;
              } catch (e) {
              }
            }
            if (!connected) {
              _this.emit("nopeers");
              return;
            }
            if (_this.hasConnectedFar)
              return;
            if (_this.connectedPeers.size >= _this.maxPeers)
              return;
            var chanceFar = Math.random();
            if (chanceFar > _this.percentFar)
              return;
            sample.reverse();
            for (var _peer of sample) {
              if (_this.destroyed)
                return;
              var _stringId = _peer.toString("hex");
              if (_this.connectedPeers.has(_stringId))
                continue;
              try {
                var _connection = yield _this._connect(_peer);
                _this.addConnection(_peer, _connection);
                _this.hasConnectedFar = true;
                _connection.once("close", () => {
                  _this.hasConnectedFar = false;
                });
                break;
              } catch (e) {
              }
            }
          })();
        }
        destroy() {
          var _this2 = this;
          return _asyncToGenerator(function* () {
            _this2.destroyed = true;
          })();
        }
      };
    }, { "delay": 129, "end-of-stream-promise": 186, "events": 193, "p-queue": 343, "promise-defer": 362, "randomize-array": 384, "xor-distance": 535 }], 305: [function(require2, module2, exports2) {
      var s = 1e3;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var w = d * 7;
      var y = d * 365.25;
      module2.exports = function(val, options) {
        options = options || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse(val);
        } else if (type === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
      };
      function parse(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return Math.round(ms / d) + "d";
        }
        if (msAbs >= h) {
          return Math.round(ms / h) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms / m) + "m";
        }
        if (msAbs >= s) {
          return Math.round(ms / s) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return plural(ms, msAbs, d, "day");
        }
        if (msAbs >= h) {
          return plural(ms, msAbs, h, "hour");
        }
        if (msAbs >= m) {
          return plural(ms, msAbs, m, "minute");
        }
        if (msAbs >= s) {
          return plural(ms, msAbs, s, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
      }
    }, {}], 306: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          var inherits = require2("inherits");
          var EventEmitter = require2("events").EventEmitter;
          var IndexState = require2("./lib/state");
          var clone = require2("clone");
          module2.exports = Indexer;
          var State = {
            PreIndexing: "preindexing",
            Indexing: "indexing",
            Idle: "idle",
            Paused: "paused",
            Error: "error"
          };
          function Indexer(opts) {
            if (!(this instanceof Indexer))
              return new Indexer(opts);
            if (!opts)
              throw new Error("missing opts param");
            if (!opts.log)
              throw new Error('missing opts param "log"');
            if (!opts.batch)
              throw new Error('missing opts param "batch"');
            if (!allOrNone(!!opts.storeState, !!opts.fetchState)) {
              throw new Error("either none or all of (opts.storeState, opts.fetchState) must be provided");
            }
            if (!unset(opts.version) && typeof opts.version !== "number")
              throw new Error("opts.version must be a number");
            this._version = unset(opts.version) ? 1 : opts.version;
            this._log = opts.log;
            this._batch = opts.batch;
            this._maxBatch = unset(opts.maxBatch) ? 50 : opts.maxBatch;
            this._pending = false;
            this._state = {
              state: State.Indexing,
              context: {
                totalBlocks: 0,
                indexedBlocks: 0,
                prevIndexedBlocks: 0,
                indexStartTime: Date.now(),
                error: null
              }
            };
            this._at = null;
            this._freshRun = this._run.bind(this, false);
            this._onNewFeed = this._onNewFeed.bind(this);
            if (!opts.storeState && !opts.fetchState && !opts.clearIndex) {
              var state;
              this._storeIndexState = function(buf, cb) {
                state = buf;
                process.nextTick(cb);
              };
              this._fetchIndexState = function(cb) {
                process.nextTick(cb, null, state);
              };
              this._clearIndex = function(cb) {
                state = null;
                process.nextTick(cb);
              };
            } else {
              this._storeIndexState = opts.storeState;
              this._fetchIndexState = opts.fetchState;
              this._clearIndex = opts.clearIndex || null;
            }
            var self2 = this;
            this._onError = function(err) {
              self2._setState(State.Error, {
                error: err
              });
              self2.emit("error", err);
            };
            this._log.ready(function() {
              self2._fetchIndexState(function(err, state2) {
                if (err && !err.notFound) {
                  self2._onError(err);
                  return;
                }
                if (!state2) {
                  start();
                  return;
                }
                try {
                  state2 = IndexState.deserialize(state2);
                } catch (e) {
                  self2._onError(e);
                  return;
                }
                var storedVersion = state2.version;
                if (storedVersion !== self2._version && self2._clearIndex) {
                  self2._clearIndex(function(err2) {
                    if (err2) {
                      self2._onError(err2);
                    } else {
                      start();
                    }
                  });
                } else {
                  start();
                }
              });
            });
            function start() {
              self2._setState(State.Idle);
              self2._freshRun();
            }
            this._log.on("feed", this._onNewFeed);
            this.setMaxListeners(1024);
          }
          inherits(Indexer, EventEmitter);
          Indexer.prototype._onNewFeed = function(feed, idx) {
            var self2 = this;
            feed.setMaxListeners(128);
            feed.ready(function() {
              feed.removeListener("append", self2._freshRun);
              feed.removeListener("download", self2._freshRun);
              feed.on("append", self2._freshRun);
              feed.on("download", self2._freshRun);
              if (self2._state.state === State.Idle)
                self2._freshRun();
            });
          };
          Indexer.prototype.pause = function(cb) {
            cb = cb || function() {
            };
            var self2 = this;
            if (this._state.state === State.Paused || this._wantPause) {
              process.nextTick(cb);
            } else if (this._state.state === State.Idle) {
              self2._setState(State.Paused);
              process.nextTick(cb);
            } else {
              this._wantPause = true;
              this.once("pause", function() {
                self2._wantPause = false;
                self2._setState(State.Paused);
                cb();
              });
            }
          };
          Indexer.prototype.resume = function() {
            if (this._state.state !== State.Paused)
              return;
            this._setState(State.Idle);
            this._freshRun();
          };
          Indexer.prototype.ready = function(fn) {
            if (this._state.state === State.Idle || this._state.state === State.Paused)
              process.nextTick(fn);
            else
              this.once("ready", fn);
          };
          Indexer.prototype._run = function(continuedRun) {
            if (this._wantPause) {
              this._wantPause = false;
              this._pending = true;
              this.emit("pause");
              return;
            }
            if (!continuedRun && this._state.state !== State.Idle) {
              this._pending = true;
              return;
            }
            var self2 = this;
            this._state.state = State.PreIndexing;
            var didWork = false;
            if (!this._at) {
              this._fetchIndexState(function(err, state) {
                if (err && !err.notFound)
                  return self2._onError(err);
                if (!state) {
                  if (!self2._clearIndex)
                    return resetAt();
                  self2._clearIndex(function(err2) {
                    if (err2)
                      return self2._onError(err2);
                    resetAt();
                  });
                } else {
                  self2._at = IndexState.deserialize(state).keys;
                  withState();
                }
                function resetAt() {
                  self2._at = {};
                  self2._log.feeds().forEach(function(feed) {
                    self2._at[feed.key.toString("hex")] = {
                      key: feed.key,
                      min: 0,
                      max: 0
                    };
                  });
                  withState();
                }
                function withState() {
                  self2._log.feeds().forEach(function(feed) {
                    feed.setMaxListeners(128);
                    feed.removeListener("append", self2._freshRun);
                    feed.removeListener("download", self2._freshRun);
                    feed.on("append", self2._freshRun);
                    feed.on("download", self2._freshRun);
                  });
                  work();
                }
              });
            } else {
              work();
            }
            function work() {
              var feeds = self2._log.feeds();
              var nodes = [];
              var indexedBlocks = Object.values(self2._at).reduce((accum, entry) => accum + entry.max, 0);
              var totalBlocks = self2._log.feeds().reduce((accum, feed) => accum + feed.length, 0);
              if (indexedBlocks === totalBlocks) {
                return done();
              }
              if (!continuedRun) {
                var context = {
                  indexStartTime: Date.now(),
                  prevIndexedBlocks: self2._state.context.indexedBlocks,
                  indexedBlocks,
                  totalBlocks
                };
                self2._setState(State.Indexing, context);
              }
              (function collect(i) {
                if (i >= feeds.length)
                  return done();
                feeds[i].ready(function() {
                  var key = feeds[i].key.toString("hex");
                  if (self2._at[key] === void 0) {
                    self2._at[key] = {
                      key: feeds[i].key,
                      min: 0,
                      max: 0
                    };
                  }
                  var at = self2._at[key].max;
                  var to = Math.min(feeds[i].length, at + self2._maxBatch);
                  if (!feeds[i].has(at, to)) {
                    return collect(i + 1);
                  } else if (at < to) {
                    feeds[i].getBatch(at, to, {
                      wait: false
                    }, function(err, res) {
                      if (err || !res.length) {
                        return collect(i + 1);
                      }
                      for (var j = 0; j < res.length; j++) {
                        var node = res[j];
                        nodes.push({
                          key: feeds[i].key.toString("hex"),
                          seq: j + at,
                          value: node
                        });
                      }
                      didWork = true;
                      self2._batch(nodes, function(err2) {
                        if (err2)
                          return done(err2);
                        self2._at[key].max += nodes.length;
                        self2._storeIndexState(IndexState.serialize(self2._at, self2._version), function(err3) {
                          if (err3)
                            return done(err3);
                          self2.emit("indexed", nodes);
                          done();
                        });
                      });
                    });
                  } else {
                    collect(i + 1);
                  }
                });
              })(0);
              function done(err) {
                if (err) {
                  self2._onError(err);
                  return;
                }
                if (didWork || self2._pending) {
                  self2._state.context.totalBlocks = self2._log.feeds().reduce((accum, feed) => accum + feed.length, 0);
                  self2._state.context.indexedBlocks = Object.values(self2._at).reduce((accum, entry) => accum + entry.max, 0);
                  self2._pending = false;
                  self2._run(true);
                } else {
                  if (self2._wantPause) {
                    self2._wantPause = false;
                    self2._pending = true;
                    self2.emit("pause");
                  } else {
                    if (continuedRun)
                      self2._setState(State.Idle);
                    else
                      self2._state.state = State.Idle;
                    self2.emit("ready");
                  }
                }
              }
            }
          };
          Indexer.prototype._setState = function(state, context) {
            if (state === this._state.state)
              return;
            if (!context)
              context = {};
            this._state.state = state;
            this._state.context = Object.assign({}, this._state.context, context);
            this.emit("state-update", clone(this._state, false));
          };
          Indexer.prototype.getState = function() {
            var state = clone(this._state, false);
            if (state.state === State.PreIndexing)
              state.state = State.Idle;
            return state;
          };
          function allOrNone(a, b) {
            return !!a && !!b || !a && !b;
          }
          function unset(x) {
            return x === null || x === void 0;
          }
        }).call(this);
      }).call(this, require2("_process"));
    }, { "./lib/state": 307, "_process": 361, "clone": 93, "events": 193, "inherits": 256 }], 307: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          module2.exports = {
            serialize: serializeState,
            deserialize: deserializeState
          };
          function int32buf(n) {
            var buf = Buffer.alloc(4);
            buf.writeUInt32LE(n, 0);
            return buf;
          }
          function serializeState(at, version) {
            at = values(at);
            var len = int32buf(at.length);
            var bufs = [len];
            for (var i = 0; i < at.length; i++) {
              bufs.push(at[i].key);
              bufs.push(int32buf(at[i].min));
              bufs.push(int32buf(at[i].max));
            }
            if (version && typeof version === "number")
              bufs.push(int32buf(version));
            return Buffer.concat(bufs);
          }
          function deserializeState(buf) {
            var state = {
              keys: {}
            };
            var len = buf.readUInt32LE(0);
            for (var i = 0; i < len; i++) {
              var pos = 4 + i * 40;
              var key = buf.slice(pos, pos + 32);
              var min = buf.readUInt32LE(pos + 32);
              var max = buf.readUInt32LE(pos + 36);
              state.keys[key.toString("hex")] = {
                key,
                min,
                max
              };
            }
            if (4 + len * 40 + 4 <= buf.length) {
              var version = buf.readUInt32LE(4 + len * 40);
              state.version = version;
            } else {
              state.version = 1;
            }
            return state;
          }
          function values(dict) {
            return Object.keys(dict).map((k) => dict[k]);
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82 }], 308: [function(require2, module2, exports2) {
      module2.exports = assert;
      class AssertionError extends Error {
      }
      AssertionError.prototype.name = "AssertionError";
      function assert(t, m) {
        if (!t) {
          var err = new AssertionError(m);
          if (Error.captureStackTrace)
            Error.captureStackTrace(err, assert);
          throw err;
        }
      }
    }, {}], 309: [function(require2, module2, exports2) {
      module2.exports = assert;
      class AssertionError extends Error {
      }
      AssertionError.prototype.name = "AssertionError";
      function assert(t, m) {
        if (!t) {
          var err;
          if (!m || typeof m === "string") {
            err = new AssertionError(m);
          }
          if (typeof m === "function") {
            for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              rest[_key - 2] = arguments[_key];
            }
            err = new m(...rest);
          }
          if (Error.captureStackTrace)
            Error.captureStackTrace(err, assert);
          throw err;
        }
      }
    }, {}], 310: [function(require2, module2, exports2) {
      var format = require2("quick-format-unescaped");
      class Nanoerror extends Error {
        static get code() {
          return this.name;
        }
        static equals(err) {
          return err && typeof err === "object" && err.isNanoerror && err.code === this.code;
        }
        constructor() {
          super();
          var code = this.constructor.code;
          var unformatMessage = this.constructor.message;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          this.message = format(unformatMessage, args);
          this.name = code;
          this.code = this.name;
          this.args = args;
          this.unformatMessage = unformatMessage;
          if (typeof Error.captureStackTrace === "function") {
            Error.captureStackTrace(this, this.constructor);
          } else {
            this.stack = new Error(this.message).stack;
          }
        }
        get isNanoerror() {
          return true;
        }
      }
      Nanoerror.message = "";
      function createError(code) {
        var message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "%s";
        var obj = {
          [code]: class extends Nanoerror {
            static from(err) {
              var newErr = new obj[code]("[".concat(err.toString(), "]"));
              newErr.stack = err.stack || newErr.stack;
              return newErr;
            }
          }
        };
        obj[code].message = message;
        return obj[code];
      }
      module2.exports = createError;
    }, { "quick-format-unescaped": 378 }], 311: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          module2.exports = class Nanoguard {
            constructor() {
              this._tick = 0;
              this._fns = [];
              this._dep = null;
            }
            get waiting() {
              return this._tick > 0;
            }
            depend(dep) {
              if (this._dep !== null)
                throw new Error("Can only depend on one other guard currently");
              this._dep = dep;
            }
            wait() {
              this._tick++;
            }
            continue(cb, err, val) {
              if (this._tick === 1)
                process.nextTick(continueNT, this);
              else
                this._tick--;
              if (cb)
                cb(err, val);
            }
            waitAndContinue() {
              var once = false;
              this.wait();
              return () => {
                if (once)
                  return false;
                once = true;
                this.continue();
                return true;
              };
            }
            continueSync(cb, err, val) {
              if (--this._tick)
                return;
              while (this._fns !== null && this._fns.length) {
                this._ready(this._fns.pop());
              }
              if (cb)
                cb(err, val);
            }
            destroy() {
              var fns = this._fns;
              if (fns)
                return;
              this._fns = null;
              while (fns.length) {
                fns.pop()();
              }
            }
            ready(fn) {
              if (this._fns === null || this._tick === 0)
                this._ready(fn);
              else
                this._fns.push(fn);
            }
            _ready(fn) {
              if (this._dep === null)
                fn();
              else
                this._dep.ready(fn);
            }
          };
          function continueNT(guard) {
            guard.continueSync();
          }
        }).call(this);
      }).call(this, require2("_process"));
    }, { "_process": 361 }], 312: [function(require2, module2, exports2) {
      var NanomessageRPC = require2("./src/nanomessage-rpc");
      module2.exports = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return new NanomessageRPC(...args);
      };
      module2.exports.NanomessageRPC = NanomessageRPC;
      module2.exports.useSocket = require2("./src/use-socket");
      module2.exports.errors = require2("./src/errors");
    }, { "./src/errors": 314, "./src/nanomessage-rpc": 315, "./src/use-socket": 316 }], 313: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var varint = require2("varint");
          var {
            BJSON
          } = require2("nanomessage");
          var {
            NRPC_ERR_ENCODE,
            NRPC_ERR_DECODE
          } = require2("./errors");
          function writeNumber(value, dest) {
            varint.encode(value, dest.buf, dest.offset);
            dest.offset += varint.encode.bytes;
          }
          function writeCodec(enc, length, value, dest) {
            writeNumber(length, dest);
            enc.encode(value, dest.buf, dest.offset);
            dest.offset += length;
          }
          function writeString(value, length, dest) {
            writeNumber(length, dest);
            dest.buf.write(value, dest.offset, length, "utf8");
            dest.offset += length;
          }
          function readNumber(source) {
            var num = varint.decode(source.buf, source.offset);
            source.offset += varint.decode.bytes;
            return num;
          }
          function readCodec(enc, source) {
            var length = readNumber(source);
            var buf = enc.decode(source.buf, source.offset, source.offset + length);
            source.offset += length;
            return buf;
          }
          function readBuffer(source) {
            var length = readNumber(source);
            var buf = source.buf.slice(source.offset, source.offset + length);
            source.offset += length;
            return buf;
          }
          var ATTR_RESPONSE = 1;
          var ATTR_EVENT = 1 << 1;
          var ATTR_ERROR = 1 << 2;
          class Codec {
            constructor() {
              var valueEncoding = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : BJSON;
              this._valueEncoding = valueEncoding;
              this._lastHeader = null;
              this._lastDataLength = null;
              this._lastNameLength = null;
            }
            encode(obj, buf) {
              var offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
              try {
                if (obj.name) {
                  return this._encodeRequest(obj, buf, offset);
                }
                return this._encodeResponse(obj, buf, offset);
              } catch (_err) {
                var err = new NRPC_ERR_ENCODE(_err.message);
                err.stack = _err.stack || err.stack;
                throw _err;
              }
            }
            decode(buf) {
              var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
              try {
                var header = varint.decode(buf, offset);
                offset += varint.decode.bytes;
                if (header & ATTR_RESPONSE) {
                  return this._decodeResponse(header, buf, offset);
                }
                return this._decodeRequest(header, buf, offset);
              } catch (_err) {
                var err = new NRPC_ERR_DECODE(_err.message);
                err.stack = _err.stack || err.stack;
                throw _err;
              }
            }
            encodingLength(obj) {
              if (obj.name) {
                return this._encodingLengthRequest(obj);
              }
              return this._encodingLengthResponse(obj);
            }
            _headerRequest(obj) {
              var header = 0;
              if (obj.event)
                header = header | ATTR_EVENT;
              this._lastHeader = header;
              return header;
            }
            _headerResponse(obj) {
              var header = 0;
              header = header | ATTR_RESPONSE;
              if (obj.error)
                header = header | ATTR_ERROR;
              this._lastHeader = header;
              return header;
            }
            _encodeRequest(obj, buf, offset) {
              var result = {
                buf,
                offset
              };
              writeNumber(this._lastHeader, result);
              writeString(obj.name, this._lastNameLength, result);
              writeCodec(this._valueEncoding, this._lastDataLength, obj.data, result);
              return result.buf;
            }
            _decodeRequest(header, buf, offset) {
              var obj = {};
              var result = {
                buf,
                offset
              };
              obj.event = !!(header & ATTR_EVENT);
              obj.name = readBuffer(result).toString();
              obj.data = readCodec(this._valueEncoding, result);
              return obj;
            }
            _encodingLengthRequest(obj) {
              var header = this._headerRequest(obj);
              this._lastDataLength = this._valueEncoding.encodingLength(obj.data);
              this._lastNameLength = Buffer.byteLength(obj.name, "utf8");
              return varint.encodingLength(header) + varint.encodingLength(this._lastDataLength) + this._lastDataLength + varint.encodingLength(this._lastNameLength) + this._lastNameLength;
            }
            _encodingLengthResponse(obj) {
              var header = this._headerResponse(obj);
              var codec = this._valueEncoding;
              if (obj.error)
                codec = BJSON;
              var dataLength = codec.encodingLength(obj.data);
              return varint.encodingLength(header) + varint.encodingLength(dataLength) + dataLength;
            }
            _encodeResponse(obj, buf, offset) {
              var codec = this._valueEncoding;
              if (obj.error)
                codec = BJSON;
              var dataLength = codec.encodingLength(obj.data);
              var result = {
                buf,
                offset
              };
              writeNumber(this._lastHeader, result);
              writeCodec(codec, dataLength, obj.data, result);
              return result.buf;
            }
            _decodeResponse(header, buf, offset) {
              var obj = {};
              var result = {
                buf,
                offset
              };
              obj.error = !!(header & ATTR_ERROR);
              var codec = this._valueEncoding;
              if (obj.error)
                codec = BJSON;
              obj.data = readCodec(codec, result);
              return obj;
            }
          }
          module2.exports = Codec;
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "./errors": 314, "buffer": 82, "nanomessage": 317, "varint": 517 }], 314: [function(require2, module2, exports2) {
      var nanoerror = require2("nanoerror");
      exports2.encodeError = encodeError;
      exports2.decodeError = decodeError;
      var errors = /* @__PURE__ */ new Map();
      function createError(code, message) {
        exports2[code] = nanoerror(code, message);
      }
      function encodeError(err) {
        return {
          error: true,
          data: {
            code: err.code,
            unformatMessage: err.unformatMessage,
            args: err.args,
            stack: err.stack
          }
        };
      }
      function decodeError(code, message) {
        if (exports2[code])
          return exports2[code];
        if (errors.has(code))
          return errors.get(code);
        var error = nanoerror(code, message);
        errors.set(code, error);
        return error;
      }
      createError("NRPC_ERR_NAME_MISSING", "missing action handler for: %s");
      createError("NRPC_ERR_RESPONSE_ERROR", "%s");
      createError("NRPC_ERR_REQUEST_CANCELED", "%s");
      createError("NRPC_ERR_CLOSE", "nanomessage-rpc was closed");
      createError("NRPC_ERR_NOT_OPEN", "nanomessage-rpc is not open");
      createError("NRPC_ERR_ENCODE", "error encoding the request: %s");
      createError("NRPC_ERR_DECODE", "error decoding the request: %s");
    }, { "nanoerror": 310 }], 315: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
            try {
              var info = gen[key](arg);
              var value = info.value;
            } catch (error) {
              reject(error);
              return;
            }
            if (info.done) {
              resolve(value);
            } else {
              Promise.resolve(value).then(_next, _throw);
            }
          }
          function _asyncToGenerator(fn) {
            return function() {
              var self2 = this, args = arguments;
              return new Promise(function(resolve, reject) {
                var gen = fn.apply(self2, args);
                function _next(value) {
                  asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
                }
                function _throw(err) {
                  asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
                }
                _next(void 0);
              });
            };
          }
          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              if (enumerableOnly)
                symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
              keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              if (i % 2) {
                ownKeys(Object(source), true).forEach(function(key) {
                  _defineProperty(target, key, source[key]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys(Object(source)).forEach(function(key) {
                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
              }
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          function _objectWithoutProperties(source, excluded) {
            if (source == null)
              return {};
            var target = _objectWithoutPropertiesLoose(source, excluded);
            var key, i;
            if (Object.getOwnPropertySymbols) {
              var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
              for (i = 0; i < sourceSymbolKeys.length; i++) {
                key = sourceSymbolKeys[i];
                if (excluded.indexOf(key) >= 0)
                  continue;
                if (!Object.prototype.propertyIsEnumerable.call(source, key))
                  continue;
                target[key] = source[key];
              }
            }
            return target;
          }
          function _objectWithoutPropertiesLoose(source, excluded) {
            if (source == null)
              return {};
            var target = {};
            var sourceKeys = Object.keys(source);
            var key, i;
            for (i = 0; i < sourceKeys.length; i++) {
              key = sourceKeys[i];
              if (excluded.indexOf(key) >= 0)
                continue;
              target[key] = source[key];
            }
            return target;
          }
          var {
            EventEmitter
          } = require2("events");
          var Emittery = require2("emittery");
          var nanomessage = require2("nanomessage");
          var assert = require2("nanocustomassert");
          var {
            NanoresourcePromise
          } = require2("nanoresource-promise");
          var Codec = require2("./codec");
          var {
            encodeError,
            decodeError,
            NRPC_ERR_NAME_MISSING,
            NRPC_ERR_RESPONSE_ERROR,
            NRPC_ERR_CLOSE,
            NRPC_ERR_NOT_OPEN,
            NRPC_ERR_REQUEST_CANCELED
          } = require2("./errors");
          var kNanomessage = Symbol("nrpc.nanomessage");
          var kOnmessage = Symbol("nrpc.onmessage");
          var kSubscribe = Symbol("nrpc.subscribe");
          var kActions = Symbol("nrpc.actions");
          var kEmittery = Symbol("nrpc.emittery");
          var kFastCheckOpen = Symbol("nrpc.fastcheckopen");
          var kCreateRequest = Symbol("nrpc.createrequest");
          var noop = () => {
          };
          class NanomessageRPC extends NanoresourcePromise {
            constructor() {
              var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              super();
              var {
                onError = () => {
                },
                valueEncoding,
                send,
                subscribe,
                open = noop,
                close = noop
              } = opts, nanomessageOpts = _objectWithoutProperties(opts, ["onError", "valueEncoding", "send", "subscribe", "open", "close"]);
              assert(send, "send is required");
              assert(subscribe, "subscribe is required");
              this.ee = new EventEmitter();
              this[kNanomessage] = nanomessage(_objectSpread(_objectSpread({}, nanomessageOpts), {}, {
                send: send.bind(this),
                open: open.bind(this),
                close: close.bind(this),
                onMessage: this[kOnmessage].bind(this),
                subscribe: this[kSubscribe](subscribe),
                valueEncoding: new Codec(valueEncoding)
              }));
              this[kEmittery] = new Emittery();
              this[kActions] = /* @__PURE__ */ new Map();
              this._onError = onError;
              this.ee.on("error", (err) => {
                this._onError(err);
              });
            }
            get requests() {
              return this[kNanomessage].requests;
            }
            get inflightRequests() {
              return this[kNanomessage].inflightRequests;
            }
            get requestTimeout() {
              return this[kNanomessage].timeout;
            }
            get concurrency() {
              return this[kNanomessage].concurrency;
            }
            setRequestsTimeout(timeout) {
              this[kNanomessage].setRequestsTimeout(timeout);
            }
            setConcurrency(concurrency) {
              this[kNanomessage].setConcurrency(concurrency);
            }
            onError(cb) {
              this._onError = cb;
            }
            action(name, handler) {
              this[kActions].set(name, handler);
              return this;
            }
            actions(actions) {
              Object.keys(actions).forEach((name) => this.action(name, actions[name]));
              return this;
            }
            call(name, data) {
              return this[kCreateRequest](name, data);
            }
            emit(name, data) {
              return this[kCreateRequest](name, data, true);
            }
            on() {
              return this[kEmittery].on(...arguments);
            }
            once() {
              return this[kEmittery].once(...arguments);
            }
            off() {
              return this[kEmittery].off(...arguments);
            }
            events(name) {
              return this[kEmittery].events(name);
            }
            _open() {
              var _this = this;
              return _asyncToGenerator(function* () {
                yield _this[kNanomessage].open();
                _this.ee.emit("opened");
              })();
            }
            _close() {
              var _this2 = this;
              return _asyncToGenerator(function* () {
                yield _this2[kNanomessage].close();
                _this2.ee.emit("closed");
              })();
            }
            [kFastCheckOpen]() {
              var _this3 = this;
              return _asyncToGenerator(function* () {
                if (_this3.closed || _this3.closing)
                  throw new NRPC_ERR_CLOSE();
                if (_this3.opening)
                  return _this3.open();
                if (!_this3.opened)
                  throw new NRPC_ERR_NOT_OPEN();
              })();
            }
            [kSubscribe](subscribe) {
              return (next) => {
                subscribe((data) => {
                  try {
                    next(data);
                  } catch (err) {
                    process.nextTick(() => this.ee.emit("error", err));
                  }
                });
              };
            }
            [kCreateRequest](name, data, event) {
              assert(name && typeof name === "string", "name is required");
              var packet = {
                name,
                data,
                event
              };
              var errCanceled;
              var request;
              var promise = this[kFastCheckOpen]().then(() => {
                if (errCanceled)
                  throw errCanceled;
                request = this[kNanomessage].request(packet);
                this.ee.emit("request-created", request, packet);
                return request;
              }).then((result) => {
                if (result.error) {
                  var {
                    code,
                    unformatMessage,
                    args,
                    stack
                  } = result.data;
                  var ErrorDecoded = decodeError(code, unformatMessage);
                  var err = new ErrorDecoded(...args);
                  err.stack = stack || err.stack;
                  throw err;
                } else {
                  return result.data;
                }
              });
              promise.cancel = (err) => {
                if (!err) {
                  errCanceled = new NRPC_ERR_REQUEST_CANCELED("request canceled");
                } else if (typeof err === "string") {
                  errCanceled = new NRPC_ERR_REQUEST_CANCELED(err);
                }
                if (request)
                  return request.cancel(errCanceled);
                errCanceled = err;
              };
              return promise;
            }
            [kOnmessage](message) {
              var _this4 = this;
              return _asyncToGenerator(function* () {
                _this4.ee.emit("message", message);
                try {
                  if (message.event) {
                    yield _this4[kEmittery].emit(message.name, message.data);
                    return {
                      data: null
                    };
                  }
                  var action = _this4[kActions].get(message.name);
                  if (!action) {
                    return encodeError(new NRPC_ERR_NAME_MISSING(message.name));
                  }
                  var result = yield action(message.data);
                  return {
                    data: result
                  };
                } catch (err) {
                  if (err.isNanoerror) {
                    return encodeError(err);
                  }
                  var rErr = new NRPC_ERR_RESPONSE_ERROR(err.message);
                  rErr.stack = err.stack || rErr.stack;
                  return encodeError(rErr);
                }
              })();
            }
          }
          module2.exports = NanomessageRPC;
        }).call(this);
      }).call(this, require2("_process"));
    }, { "./codec": 313, "./errors": 314, "_process": 361, "emittery": 184, "events": 193, "nanocustomassert": 309, "nanomessage": 317, "nanoresource-promise": 325 }], 316: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          var eos = require2("end-of-stream");
          function useSocket(socket) {
            var onCloseDestroyStream = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
            return {
              send(buf) {
                if (socket.destroyed)
                  return;
                socket.write(buf);
              },
              subscribe(next) {
                socket.on("data", next);
                return () => socket.removeListener("data", next);
              },
              open() {
                eos(socket, () => {
                  this.close().catch((err) => process.nextTick(() => this.ee.emit("error", err)));
                });
              },
              close() {
                return new Promise((resolve) => {
                  if (socket.destroyed || !onCloseDestroyStream)
                    return resolve();
                  eos(socket, () => resolve());
                  socket.destroy();
                });
              }
            };
          }
          module2.exports = useSocket;
        }).call(this);
      }).call(this, require2("_process"));
    }, { "_process": 361, "end-of-stream": 187 }], 317: [function(require2, module2, exports2) {
      var Nanomessage = require2("./src/nanomessage");
      var nanomessage = (opts) => new Nanomessage(opts);
      nanomessage.Nanomessage = Nanomessage;
      nanomessage.errors = require2("./src/errors");
      nanomessage.BJSON = require2("./src/buffer-json");
      module2.exports = nanomessage;
    }, { "./src/buffer-json": 318, "./src/errors": 320, "./src/nanomessage": 322 }], 318: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          function iterate(x, decode) {
            if (typeof x !== "object") {
              if (decode && Object.prototype.toString.call(x) === "[object String]" && x.startsWith("base64:")) {
                return Buffer.from(x.slice("base64:".length), "base64");
              }
              return x;
            }
            var k;
            var tmp;
            var type = Object.prototype.toString.call(x);
            if (!decode && type === "[object Uint8Array]" && Buffer.isBuffer(x)) {
              return "base64:" + Buffer.from(x).toString("base64");
            }
            if (type === "[object Object]") {
              tmp = {};
              for (k in x) {
                tmp[k] = iterate(x[k], decode);
              }
              return tmp;
            }
            if (type === "[object Array]") {
              k = x.length;
              for (tmp = Array(k); k--; ) {
                tmp[k] = iterate(x[k], decode);
              }
              return tmp;
            }
            return x;
          }
          module2.exports = {
            _lastObj: null,
            _lastStr: null,
            _lastLength: null,
            encode(obj, buf, offset) {
              var str;
              var length;
              if (this._lastObj === obj) {
                str = this._lastStr;
                length = this._lastLength;
              } else {
                str = JSON.stringify(iterate({
                  data: obj
                }));
                length = Buffer.byteLength(str, "utf8");
              }
              buf.write(str, offset, length, "utf8");
              this._lastObj = null;
              this._lastStr = null;
              this._lastLength = null;
              return buf.slice(offset, offset + length);
            },
            decode(buf, start, end) {
              start = start || 0;
              end = end || buf.length;
              return iterate(JSON.parse(buf.slice(start, end)), true).data;
            },
            encodingLength(obj) {
              this._lastObj = obj;
              this._lastStr = JSON.stringify(iterate({
                data: obj
              }));
              this._lastLength = Buffer.byteLength(this._lastStr, "utf8");
              return this._lastLength;
            }
          };
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82 }], 319: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var varint = require2("varint");
          var BJSON = require2("./buffer-json");
          var {
            NMSG_ERR_ENCODE,
            NMSG_ERR_DECODE
          } = require2("./errors");
          var ATTR_RESPONSE = 1;
          module2.exports = function createCodec() {
            var valueEncoding = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : BJSON;
            return {
              encode(info) {
                try {
                  var header = info.id << 1;
                  if (info.response)
                    header = header | ATTR_RESPONSE;
                  var dataLength = valueEncoding.encodingLength(info.data);
                  var buf = Buffer.allocUnsafe(varint.encodingLength(header) + varint.encodingLength(dataLength) + dataLength);
                  var offset = 0;
                  varint.encode(header, buf, offset);
                  offset += varint.encode.bytes;
                  varint.encode(dataLength, buf, offset);
                  offset += varint.encode.bytes;
                  valueEncoding.encode(info.data, buf, offset);
                  return buf;
                } catch (err) {
                  throw new NMSG_ERR_ENCODE(err.message);
                }
              },
              decode(buf) {
                try {
                  var request = {};
                  var offset = 0;
                  var header = varint.decode(buf, offset);
                  offset += varint.decode.bytes;
                  var dataLength = varint.decode(buf, offset);
                  offset += varint.decode.bytes;
                  request.data = valueEncoding.decode(buf, offset, offset + dataLength);
                  request.response = !!(header & ATTR_RESPONSE);
                  request.id = header >> 1;
                  return request;
                } catch (err) {
                  throw new NMSG_ERR_DECODE(err.message);
                }
              }
            };
          };
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "./buffer-json": 318, "./errors": 320, "buffer": 82, "varint": 517 }], 320: [function(require2, module2, exports2) {
      var nanoerror = require2("nanoerror");
      var errors = {};
      function createError(code, message) {
        errors[code] = nanoerror(code, message);
      }
      createError("NMSG_ERR_TIMEOUT", "timeout on request: %s");
      createError("NMSG_ERR_ENCODE", "error encoding the request: %s");
      createError("NMSG_ERR_DECODE", "error decoding the request: %s");
      createError("NMSG_ERR_RESPONSE", "response error on request: %s");
      createError("NMSG_ERR_CLOSE", "nanomessage was closed");
      createError("NMSG_ERR_NOT_OPEN", "nanomessage is not open");
      createError("NMSG_ERR_CANCEL", "request canceled: %s");
      module2.exports = errors;
    }, { "nanoerror": 310 }], 321: [function(require2, module2, exports2) {
      module2.exports = class IdGenerator {
        constructor(generate) {
          this._generate = generate;
          this._free = [];
        }
        get() {
          if (!this._free.length) {
            return this._generate();
          }
          return this._free.pop();
        }
        release(id) {
          this._free.push(id);
        }
      };
    }, {}], 322: [function(require2, module2, exports2) {
      function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator(fn) {
        return function() {
          var self2 = this, args = arguments;
          return new Promise(function(resolve, reject) {
            var gen = fn.apply(self2, args);
            function _next(value) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(void 0);
          });
        };
      }
      var assert = require2("nanocustomassert");
      var {
        NanoresourcePromise
      } = require2("nanoresource-promise/emitter");
      var fastq = require2("fastq");
      var Request = require2("./request");
      var createCodec = require2("./codec");
      var {
        NMSG_ERR_CLOSE,
        NMSG_ERR_NOT_OPEN,
        NMSG_ERR_RESPONSE
      } = require2("./errors");
      var IdGenerator = require2("./id-generator");
      var kRequests = Symbol("nanomessage.requests");
      var kInQueue = Symbol("nanomessage.inqueue");
      var kOutQueue = Symbol("nanomessage.outqueue");
      var kUnsubscribe = Symbol("nanomessage.unsubscribe");
      var kMessageHandler = Symbol("nanomessage.messagehandler");
      var kOpen = Symbol("nanomessage.open");
      var kClose = Symbol("nanomessage.close");
      var kFastCheckOpen = Symbol("nanomessage.fastcheckopen");
      var kTimeout = Symbol("nanomessage.timeout");
      var kIdGenerator = Symbol("nanomessage.idgenerator");
      var kCodec = Symbol("nanomessage.codec");
      function inWorker(info, done) {
        this[kFastCheckOpen]().then(() => this._onMessage(info.data, info)).then((data) => {
          if (this.closed || this.closing)
            return done();
          info.responseData = data;
          return this._send(this[kCodec].encode({
            id: info.id,
            response: info.response,
            data
          }), info);
        }).then(() => done()).catch((err) => done(err));
      }
      function outWorker(request, done) {
        var info = request.info();
        this[kFastCheckOpen]().then(() => {
          if (request.finished)
            return;
          request.start();
          return this._send(this[kCodec].encode(info), info);
        }).then(() => {
          if (request.finished)
            return;
          return request.promise;
        }).then((data) => done(null, data)).catch((err) => done(err));
      }
      class Nanomessage extends NanoresourcePromise {
        constructor() {
          var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          super();
          var {
            send,
            subscribe,
            onMessage,
            open,
            close,
            timeout,
            valueEncoding
          } = opts;
          var {
            concurrency = {}
          } = opts;
          if (send)
            this._send = send;
          if (subscribe)
            this._subscribe = subscribe;
          if (onMessage)
            this.setMessageHandler(onMessage);
          if (open)
            this[kOpen] = open;
          if (close)
            this[kClose] = close;
          this.setRequestTimeout(timeout);
          this[kCodec] = createCodec(valueEncoding);
          this[kInQueue] = fastq(this, inWorker, 256);
          this[kOutQueue] = fastq(this, outWorker, 256);
          this.setConcurrency(concurrency);
          this[kRequests] = /* @__PURE__ */ new Map();
          this[kIdGenerator] = new IdGenerator(() => this[kRequests].size + 1);
        }
        get codec() {
          return this[kCodec];
        }
        get requests() {
          return Array.from(this[kRequests].values());
        }
        get inflightRequests() {
          return this[kOutQueue].running();
        }
        get requestTimeout() {
          return this[kTimeout];
        }
        get concurrency() {
          return {
            incoming: this[kInQueue].concurrency,
            outgoing: this[kOutQueue].concurrency
          };
        }
        setRequestTimeout(timeout) {
          this[kTimeout] = timeout;
          return this;
        }
        setConcurrency(value) {
          if (typeof value === "number") {
            this[kInQueue].concurrency = value;
            this[kOutQueue].concurrency = value;
          } else {
            this[kInQueue].concurrency = value.incoming || this[kInQueue].concurrency;
            this[kOutQueue].concurrency = value.outgoing || this[kOutQueue].concurrency;
          }
          return this;
        }
        request(data) {
          var request = new Request({
            id: this[kIdGenerator].get(),
            data,
            timeout: this[kTimeout]
          });
          var info = request.info();
          this[kRequests].set(request.id, request);
          request.onFinish(() => {
            this[kRequests].delete(request.id);
            this[kIdGenerator].release(request.id);
          });
          this.emit("request-created", info);
          this[kOutQueue].push(request, (err, data2) => {
            info.response = true;
            info.responseData = data2;
            this.emit("request-ended", err, info);
          });
          return request.promise;
        }
        send(data) {
          return this[kFastCheckOpen]().then(() => {
            var info = Request.info({
              id: 0,
              data
            });
            return this._send(this[kCodec].encode(info), info);
          });
        }
        setMessageHandler(onMessage) {
          this._onMessage = onMessage;
          return this;
        }
        _send(buf, info) {
          return _asyncToGenerator(function* () {
            throw new Error("_send not implemented");
          })();
        }
        _onMessage(data, info) {
          return _asyncToGenerator(function* () {
            throw new Error("_onMessage not implemented");
          })();
        }
        _open() {
          var _this = this;
          return _asyncToGenerator(function* () {
            assert(!!_this._subscribe, "subscribe is required");
            yield _this[kOpen] && _this[kOpen]();
            _this[kUnsubscribe] = _this._subscribe(_this[kMessageHandler].bind(_this));
          })();
        }
        _close() {
          var _this2 = this;
          return _asyncToGenerator(function* () {
            if (_this2[kUnsubscribe])
              _this2[kUnsubscribe]();
            var requestsToClose = [];
            _this2[kRequests].forEach((request) => request.reject(new NMSG_ERR_CLOSE()));
            _this2[kRequests].clear();
            _this2[kInQueue] && _this2[kInQueue].kill();
            _this2[kOutQueue] && _this2[kOutQueue].kill();
            yield _this2[kClose] && _this2[kClose]();
            yield Promise.all(requestsToClose);
          })();
        }
        [kFastCheckOpen]() {
          var _this3 = this;
          return _asyncToGenerator(function* () {
            if (_this3.closed || _this3.closing)
              throw new NMSG_ERR_CLOSE();
            if (_this3.opening)
              return _this3.open();
            if (!_this3.opened)
              throw new NMSG_ERR_NOT_OPEN();
          })();
        }
        [kMessageHandler](message) {
          if (this.closed || this.closing)
            return;
          var info = Request.info(this[kCodec].decode(message));
          if (info.response) {
            var request = this[kRequests].get(info.id);
            if (request)
              request.resolve(info.data);
            return;
          }
          if (info.ephemeral) {
            this.emit("request-received", info);
            this[kFastCheckOpen]().then(() => this._onMessage(info.data, info)).catch((err) => {
              var rErr = new NMSG_ERR_RESPONSE(err.message);
              rErr.stack = err.stack || rErr.stack;
              this.emit("response-error", rErr, info);
            });
            return;
          }
          info.response = true;
          this.emit("request-received", info);
          this[kInQueue].push(info, (err) => {
            if (err) {
              var rErr = new NMSG_ERR_RESPONSE(err.message);
              rErr.stack = err.stack || rErr.stack;
              this.emit("response-error", rErr, info);
            }
          });
        }
      }
      module2.exports = Nanomessage;
    }, { "./codec": 319, "./errors": 320, "./id-generator": 321, "./request": 323, "fastq": 198, "nanocustomassert": 309, "nanoresource-promise/emitter": 324 }], 323: [function(require2, module2, exports2) {
      var {
        NMSG_ERR_CANCEL,
        NMSG_ERR_TIMEOUT
      } = require2("./errors");
      class Request {
        static info() {
          var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          return {
            id: obj.id,
            data: obj.data,
            response: obj.response || false,
            ephemeral: obj.id === 0
          };
        }
        constructor(info) {
          var {
            id,
            data,
            response = false,
            timeout
          } = info;
          this.id = id;
          this.data = data;
          this.response = response;
          this.finished = false;
          this.timeout = timeout;
          this.timer = null;
          var _resolve, _reject;
          this.promise = new Promise((resolve, reject) => {
            _resolve = resolve;
            _reject = reject;
          });
          this.resolve = (data2) => {
            if (!this.finished) {
              this.timer && clearTimeout(this.timer);
              this.finished = true;
              this._onFinish();
              _resolve(data2);
            }
          };
          this.reject = (err) => {
            if (!this.finished) {
              this.timer && clearTimeout(this.timer);
              this.finished = true;
              this._onFinish(err);
              _reject(err);
            }
          };
          this.promise.cancel = this.cancel.bind(this);
        }
        start() {
          if (this.timeout) {
            this.timer = setTimeout(() => {
              this.reject(new NMSG_ERR_TIMEOUT(this.id));
            }, this.timeout);
          }
        }
        onFinish(cb) {
          this._onFinish = cb;
        }
        cancel(err) {
          if (!err) {
            err = new NMSG_ERR_CANCEL(this.id);
          } else if (typeof err === "string") {
            err = new NMSG_ERR_CANCEL(this.id, err);
          }
          this.reject(err);
        }
        info() {
          return Request.info(this);
        }
      }
      module2.exports = Request;
    }, { "./errors": 320 }], 324: [function(require2, module2, exports2) {
      function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator(fn) {
        return function() {
          var self2 = this, args = arguments;
          return new Promise(function(resolve, reject) {
            var gen = fn.apply(self2, args);
            function _next(value) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(void 0);
          });
        };
      }
      var {
        EventEmitter
      } = require2("events");
      var nanoresource = require2(".");
      var kNanoresource = Symbol("nanoresource");
      class NanoresourcePromise extends EventEmitter {
        constructor() {
          var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          super();
          this[kNanoresource] = nanoresource({
            open: opts.open || this._open.bind(this),
            close: opts.close || this._close.bind(this),
            reopen: opts.reopen
          });
        }
        get opened() {
          return this[kNanoresource].opened;
        }
        get opening() {
          return this[kNanoresource].opening;
        }
        get closed() {
          return this[kNanoresource].closed;
        }
        get closing() {
          return this[kNanoresource].closing;
        }
        get actives() {
          return this[kNanoresource].actives;
        }
        open() {
          var _this = this;
          return _asyncToGenerator(function* () {
            yield _this[kNanoresource].open();
            _this.emit("opened");
          })();
        }
        close(allowActive) {
          var _this2 = this;
          return _asyncToGenerator(function* () {
            yield _this2[kNanoresource].close(allowActive);
            _this2.emit("closed");
          })();
        }
        active(cb) {
          return this[kNanoresource].active(cb);
        }
        inactive(cb, err, value) {
          return this[kNanoresource].inactive(cb, err, value);
        }
        _open() {
          return _asyncToGenerator(function* () {
          })();
        }
        _close() {
          return _asyncToGenerator(function* () {
          })();
        }
      }
      module2.exports = (opts) => new NanoresourcePromise(opts);
      module2.exports.NanoresourcePromise = NanoresourcePromise;
    }, { ".": 325, "events": 193 }], 325: [function(require2, module2, exports2) {
      function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator(fn) {
        return function() {
          var self2 = this, args = arguments;
          return new Promise(function(resolve, reject) {
            var gen = fn.apply(self2, args);
            function _next(value) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(void 0);
          });
        };
      }
      var nanoresource = require2("./nanoresource-cb");
      function callbackPromise() {
        var callback;
        var promise = new Promise((resolve, reject) => {
          callback = (err, value) => {
            if (err)
              reject(err);
            else
              resolve(value);
          };
        });
        callback.promise = promise;
        return callback;
      }
      var kNanoresource = Symbol("nanoresource");
      var kProcessPromise = Symbol("processpromise");
      class NanoresourcePromise {
        constructor() {
          var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var _open = opts.open || this._open.bind(this);
          var _close = opts.close || this._close.bind(this);
          this[kNanoresource] = nanoresource({
            open: (cb) => this[kProcessPromise](_open, cb),
            close: (cb) => this[kProcessPromise](_close, cb),
            reopen: opts.reopen
          });
        }
        get opened() {
          return this[kNanoresource].opened;
        }
        get opening() {
          return this[kNanoresource].opening;
        }
        get closed() {
          return this[kNanoresource].closed;
        }
        get closing() {
          return this[kNanoresource].closing;
        }
        get actives() {
          return this[kNanoresource].actives;
        }
        open() {
          var callback = callbackPromise();
          this[kNanoresource].open(callback);
          return callback.promise;
        }
        close() {
          var allowActive = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
          var callback = callbackPromise();
          this[kNanoresource].close(allowActive, callback);
          return callback.promise;
        }
        active(cb) {
          return this[kNanoresource].active(cb);
        }
        inactive(cb, err, value) {
          return this[kNanoresource].inactive(cb, err, value);
        }
        _open() {
          return _asyncToGenerator(function* () {
          })();
        }
        _close() {
          return _asyncToGenerator(function* () {
          })();
        }
        [kProcessPromise](fnPromise, cb) {
          return _asyncToGenerator(function* () {
            try {
              yield fnPromise();
              cb();
            } catch (err) {
              cb(err);
            }
          })();
        }
      }
      module2.exports = (opts) => new NanoresourcePromise(opts);
      module2.exports.NanoresourcePromise = NanoresourcePromise;
    }, { "./nanoresource-cb": 326 }], 326: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          var preopening = Symbol("opening when closing");
          var opening = Symbol("opening queue");
          var preclosing = Symbol("closing when inactive");
          var closing = Symbol("closing queue");
          var sync = Symbol("sync");
          var fastClose = Symbol("fast close");
          var reopen = Symbol("allow reopen");
          var init = Symbol("init state");
          class Nanoresource {
            constructor(opts) {
              if (!opts)
                opts = {};
              if (opts.open)
                this._open = opts.open;
              if (opts.close)
                this._close = opts.close;
              this[init]();
              this[reopen] = opts.reopen || false;
              this[preopening] = null;
              this[opening] = null;
              this[preclosing] = null;
              this[closing] = null;
              this[sync] = false;
              this[fastClose] = true;
            }
            [init]() {
              this.opening = false;
              this.opened = false;
              this.closing = false;
              this.closed = false;
              this.actives = 0;
            }
            _open(cb) {
              cb(null);
            }
            _close(cb) {
              cb(null);
            }
            open(cb) {
              if (!cb)
                cb = noop;
              if (this.closing || this.closed) {
                if (!this[reopen]) {
                  return process.nextTick(cb, new Error("Resource is closed"));
                }
                if (this.closing) {
                  if (!this[preopening])
                    this[preopening] = [];
                  this[preopening].push(cb);
                  return;
                }
                this[init]();
              }
              if (this.opened)
                return process.nextTick(cb);
              if (this[opening]) {
                this[opening].push(cb);
                return;
              }
              this.opening = true;
              this[opening] = [cb];
              this[sync] = true;
              this._open(onopen.bind(this));
              this[sync] = false;
            }
            active(cb) {
              if (this[fastClose] && this[preclosing] || this[closing] || this.closed) {
                if (cb)
                  process.nextTick(cb, new Error("Resource is closed"));
                return false;
              }
              this.actives++;
              return true;
            }
            inactive(cb, err, val) {
              if (!--this.actives) {
                var queue = this[preclosing];
                if (queue) {
                  this[preclosing] = null;
                  while (queue.length) {
                    this.close(queue.shift());
                  }
                }
              }
              if (cb)
                cb(err, val);
            }
            close(allowActive, cb) {
              if (typeof allowActive === "function")
                return this.close(false, allowActive);
              if (!cb)
                cb = noop;
              if (allowActive)
                this[fastClose] = false;
              if (this.closed)
                return process.nextTick(cb);
              if (this.actives || this[opening]) {
                if (!this[preclosing])
                  this[preclosing] = [];
                this[preclosing].push(cb);
                return;
              }
              if (!this.opened) {
                this.closed = true;
                process.nextTick(cb);
                return;
              }
              if (this[closing]) {
                this[closing].push(cb);
                return;
              }
              this.closing = true;
              this[closing] = [cb];
              this[sync] = true;
              this._close(onclose.bind(this));
              this[sync] = false;
            }
          }
          function onopen(err) {
            if (this[sync])
              return process.nextTick(onopen.bind(this), err);
            var oqueue = this[opening];
            this[opening] = null;
            this.opening = false;
            this.opened = !err;
            while (oqueue.length) {
              oqueue.shift()(err);
            }
            var cqueue = this[preclosing];
            if (cqueue && !this.actives) {
              this[preclosing] = null;
              while (cqueue.length) {
                this.close(cqueue.shift());
              }
            }
          }
          function onclose(err) {
            if (this[sync])
              return process.nextTick(onclose.bind(this), err);
            var queue = this[closing];
            this.closing = false;
            this[closing] = null;
            this.closed = !err;
            while (queue.length) {
              queue.shift()(err);
            }
            var cqueue = this[preopening];
            if (cqueue) {
              this[preopening] = null;
              while (cqueue.length) {
                this.open(cqueue.shift());
              }
            }
          }
          function noop() {
          }
          module2.exports = (opts) => new Nanoresource(opts);
          module2.exports.Nanoresource = Nanoresource;
        }).call(this);
      }).call(this, require2("_process"));
    }, { "_process": 361 }], 327: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          var events = require2("events");
          var inherits = require2("inherits");
          var opening = Symbol("opening queue");
          var preclosing = Symbol("closing when inactive");
          var closing = Symbol("closing queue");
          var sync = Symbol("sync");
          var fastClose = Symbol("fast close");
          module2.exports = Nanoresource;
          function Nanoresource(opts) {
            if (!(this instanceof Nanoresource))
              return new Nanoresource(opts);
            events.EventEmitter.call(this);
            if (!opts)
              opts = {};
            if (opts.open)
              this._open = opts.open;
            if (opts.close)
              this._close = opts.close;
            this.opening = false;
            this.opened = false;
            this.closing = false;
            this.closed = false;
            this.actives = 0;
            this[opening] = null;
            this[preclosing] = null;
            this[closing] = null;
            this[sync] = false;
            this[fastClose] = true;
          }
          inherits(Nanoresource, events.EventEmitter);
          Nanoresource.prototype._open = function(cb) {
            cb(null);
          };
          Nanoresource.prototype._close = function(cb) {
            cb(null);
          };
          Nanoresource.prototype.open = function(cb) {
            if (!cb)
              cb = noop;
            if (this[closing] || this.closed)
              return process.nextTick(cb, new Error("Resource is closed"));
            if (this.opened)
              return process.nextTick(cb);
            if (this[opening]) {
              this[opening].push(cb);
              return;
            }
            this.opening = true;
            this[opening] = [cb];
            this[sync] = true;
            this._open(onopen.bind(this));
            this[sync] = false;
          };
          Nanoresource.prototype.active = function(cb) {
            if (this[fastClose] && this[preclosing] || this[closing] || this.closed) {
              if (cb)
                process.nextTick(cb, new Error("Resource is closed"));
              return false;
            }
            this.actives++;
            return true;
          };
          Nanoresource.prototype.inactive = function(cb, err, val) {
            if (!--this.actives) {
              var queue = this[preclosing];
              if (queue) {
                this[preclosing] = null;
                while (queue.length) {
                  this.close(queue.shift());
                }
              }
            }
            if (cb)
              cb(err, val);
          };
          Nanoresource.prototype.close = function(allowActive, cb) {
            if (typeof allowActive === "function")
              return this.close(false, allowActive);
            if (!cb)
              cb = noop;
            if (allowActive)
              this[fastClose] = false;
            if (this.closed)
              return process.nextTick(cb);
            if (this.actives || this[opening]) {
              if (!this[preclosing])
                this[preclosing] = [];
              this[preclosing].push(cb);
              return;
            }
            if (!this.opened) {
              this.closed = true;
              process.nextTick(cb);
              return;
            }
            if (this[closing]) {
              this[closing].push(cb);
              return;
            }
            this.closing = true;
            this[closing] = [cb];
            this[sync] = true;
            this._close(onclose.bind(this));
            this[sync] = false;
          };
          function onopen(err) {
            if (this[sync])
              return process.nextTick(onopen.bind(this), err);
            var oqueue = this[opening];
            this[opening] = null;
            this.opening = false;
            this.opened = !err;
            while (oqueue.length) {
              oqueue.shift()(err);
            }
            var cqueue = this[preclosing];
            if (cqueue && !this.actives) {
              this[preclosing] = null;
              while (cqueue.length) {
                this.close(cqueue.shift());
              }
            }
          }
          function onclose(err) {
            if (this[sync])
              return process.nextTick(onclose.bind(this), err);
            var queue = this[closing];
            this.closing = false;
            this[closing] = null;
            this.closed = !err;
            while (queue.length) {
              queue.shift()(err);
            }
          }
          function noop() {
          }
        }).call(this);
      }).call(this, require2("_process"));
    }, { "_process": 361, "events": 193, "inherits": 256 }], 328: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          var opening = Symbol("opening queue");
          var preclosing = Symbol("closing when inactive");
          var closing = Symbol("closing queue");
          var sync = Symbol("sync");
          var fastClose = Symbol("fast close");
          module2.exports = Nanoresource;
          function Nanoresource(opts) {
            if (!(this instanceof Nanoresource))
              return new Nanoresource(opts);
            if (!opts)
              opts = {};
            if (opts.open)
              this._open = opts.open;
            if (opts.close)
              this._close = opts.close;
            this.opening = false;
            this.opened = false;
            this.closing = false;
            this.closed = false;
            this.actives = 0;
            this[opening] = null;
            this[preclosing] = null;
            this[closing] = null;
            this[sync] = false;
            this[fastClose] = true;
          }
          Nanoresource.prototype._open = function(cb) {
            cb(null);
          };
          Nanoresource.prototype._close = function(cb) {
            cb(null);
          };
          Nanoresource.prototype.open = function(cb) {
            if (!cb)
              cb = noop;
            if (this[closing] || this.closed)
              return process.nextTick(cb, new Error("Resource is closed"));
            if (this.opened)
              return process.nextTick(cb);
            if (this[opening]) {
              this[opening].push(cb);
              return;
            }
            this.opening = true;
            this[opening] = [cb];
            this[sync] = true;
            this._open(onopen.bind(this));
            this[sync] = false;
          };
          Nanoresource.prototype.active = function(cb) {
            if (this[fastClose] && this[preclosing] || this[closing] || this.closed) {
              if (cb)
                process.nextTick(cb, new Error("Resource is closed"));
              return false;
            }
            this.actives++;
            return true;
          };
          Nanoresource.prototype.inactive = function(cb, err, val) {
            if (!--this.actives) {
              var queue = this[preclosing];
              if (queue) {
                this[preclosing] = null;
                while (queue.length) {
                  this.close(queue.shift());
                }
              }
            }
            if (cb)
              cb(err, val);
          };
          Nanoresource.prototype.close = function(allowActive, cb) {
            if (typeof allowActive === "function")
              return this.close(false, allowActive);
            if (!cb)
              cb = noop;
            if (allowActive)
              this[fastClose] = false;
            if (this.closed)
              return process.nextTick(cb);
            if (this.actives || this[opening]) {
              if (!this[preclosing])
                this[preclosing] = [];
              this[preclosing].push(cb);
              return;
            }
            if (!this.opened) {
              this.closed = true;
              process.nextTick(cb);
              return;
            }
            if (this[closing]) {
              this[closing].push(cb);
              return;
            }
            this.closing = true;
            this[closing] = [cb];
            this[sync] = true;
            this._close(onclose.bind(this));
            this[sync] = false;
          };
          function onopen(err) {
            if (this[sync])
              return process.nextTick(onopen.bind(this), err);
            var oqueue = this[opening];
            this[opening] = null;
            this.opening = false;
            this.opened = !err;
            while (oqueue.length) {
              oqueue.shift()(err);
            }
            var cqueue = this[preclosing];
            if (cqueue && !this.actives) {
              this[preclosing] = null;
              while (cqueue.length) {
                this.close(cqueue.shift());
              }
            }
          }
          function onclose(err) {
            if (this[sync])
              return process.nextTick(onclose.bind(this), err);
            var queue = this[closing];
            this.closing = false;
            this[closing] = null;
            this.closed = !err;
            while (queue.length) {
              queue.shift()(err);
            }
          }
          function noop() {
          }
        }).call(this);
      }).call(this, require2("_process"));
    }, { "_process": 361 }], 329: [function(require2, module2, exports2) {
      (function(process, setImmediate) {
        (function() {
          var ensureCallable = function ensureCallable2(fn) {
            if (typeof fn !== "function")
              throw new TypeError(fn + " is not a function");
            return fn;
          };
          var byObserver = function byObserver2(Observer) {
            var node = document.createTextNode(""), queue, currentQueue, i = 0;
            new Observer(function() {
              var callback;
              if (!queue) {
                if (!currentQueue)
                  return;
                queue = currentQueue;
              } else if (currentQueue) {
                queue = currentQueue.concat(queue);
              }
              currentQueue = queue;
              queue = null;
              if (typeof currentQueue === "function") {
                callback = currentQueue;
                currentQueue = null;
                callback();
                return;
              }
              node.data = i = ++i % 2;
              while (currentQueue) {
                callback = currentQueue.shift();
                if (!currentQueue.length)
                  currentQueue = null;
                callback();
              }
            }).observe(node, {
              characterData: true
            });
            return function(fn) {
              ensureCallable(fn);
              if (queue) {
                if (typeof queue === "function")
                  queue = [queue, fn];
                else
                  queue.push(fn);
                return;
              }
              queue = fn;
              node.data = i = ++i % 2;
            };
          };
          module2.exports = function() {
            if (typeof process === "object" && process && typeof process.nextTick === "function") {
              return process.nextTick;
            }
            if (typeof queueMicrotask === "function") {
              return function(cb) {
                queueMicrotask(ensureCallable(cb));
              };
            }
            if (typeof document === "object" && document) {
              if (typeof MutationObserver === "function")
                return byObserver(MutationObserver);
              if (typeof WebKitMutationObserver === "function")
                return byObserver(WebKitMutationObserver);
            }
            if (typeof setImmediate === "function") {
              return function(cb) {
                setImmediate(ensureCallable(cb));
              };
            }
            if (typeof setTimeout === "function" || typeof setTimeout === "object") {
              return function(cb) {
                setTimeout(ensureCallable(cb), 0);
              };
            }
            return null;
          }();
        }).call(this);
      }).call(this, require2("_process"), require2("timers").setImmediate);
    }, { "_process": 361, "timers": 506 }], 330: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          var fs = require2("fs");
          var path = require2("path");
          var os = require2("os");
          var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require2;
          var vars = process.config && process.config.variables || {};
          var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
          var abi = process.versions.modules;
          var runtime = isElectron() ? "electron" : "node";
          var arch = os.arch();
          var platform = os.platform();
          var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
          var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
          var uv = (process.versions.uv || "").split(".")[0];
          module2.exports = load;
          function load(dir) {
            return runtimeRequire(load.path(dir));
          }
          load.path = function(dir) {
            dir = path.resolve(dir || ".");
            try {
              var name = runtimeRequire(path.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
              if (process.env[name + "_PREBUILD"])
                dir = process.env[name + "_PREBUILD"];
            } catch (err) {
            }
            if (!prebuildsOnly) {
              var release = getFirst(path.join(dir, "build/Release"), matchBuild);
              if (release)
                return release;
              var debug = getFirst(path.join(dir, "build/Debug"), matchBuild);
              if (debug)
                return debug;
            }
            var prebuild = resolve(dir);
            if (prebuild)
              return prebuild;
            var nearby = resolve(path.dirname(process.execPath));
            if (nearby)
              return nearby;
            var target = [
              "platform=" + platform,
              "arch=" + arch,
              "runtime=" + runtime,
              "abi=" + abi,
              "uv=" + uv,
              armv ? "armv=" + armv : "",
              "libc=" + libc,
              "node=" + process.versions.node,
              process.versions && process.versions.electron ? "electron=" + process.versions.electron : "",
              typeof __webpack_require__ === "function" ? "webpack=true" : ""
            ].filter(Boolean).join(" ");
            throw new Error("No native build was found for " + target + "\n    loaded from: " + dir + "\n");
            function resolve(dir2) {
              var prebuilds = path.join(dir2, "prebuilds", platform + "-" + arch);
              var parsed = readdirSync(prebuilds).map(parseTags);
              var candidates = parsed.filter(matchTags(runtime, abi));
              var winner = candidates.sort(compareTags(runtime))[0];
              if (winner)
                return path.join(prebuilds, winner.file);
            }
          };
          function readdirSync(dir) {
            try {
              return fs.readdirSync(dir);
            } catch (err) {
              return [];
            }
          }
          function getFirst(dir, filter) {
            var files = readdirSync(dir).filter(filter);
            return files[0] && path.join(dir, files[0]);
          }
          function matchBuild(name) {
            return /\.node$/.test(name);
          }
          function parseTags(file) {
            var arr = file.split(".");
            var extension = arr.pop();
            var tags = {
              file,
              specificity: 0
            };
            if (extension !== "node")
              return;
            for (var i = 0; i < arr.length; i++) {
              var tag = arr[i];
              if (tag === "node" || tag === "electron" || tag === "node-webkit") {
                tags.runtime = tag;
              } else if (tag === "napi") {
                tags.napi = true;
              } else if (tag.slice(0, 3) === "abi") {
                tags.abi = tag.slice(3);
              } else if (tag.slice(0, 2) === "uv") {
                tags.uv = tag.slice(2);
              } else if (tag.slice(0, 4) === "armv") {
                tags.armv = tag.slice(4);
              } else if (tag === "glibc" || tag === "musl") {
                tags.libc = tag;
              } else {
                continue;
              }
              tags.specificity++;
            }
            return tags;
          }
          function matchTags(runtime2, abi2) {
            return function(tags) {
              if (tags == null)
                return false;
              if (tags.runtime !== runtime2 && !runtimeAgnostic(tags))
                return false;
              if (tags.abi !== abi2 && !tags.napi)
                return false;
              if (tags.uv && tags.uv !== uv)
                return false;
              if (tags.armv && tags.armv !== armv)
                return false;
              if (tags.libc && tags.libc !== libc)
                return false;
              return true;
            };
          }
          function runtimeAgnostic(tags) {
            return tags.runtime === "node" && tags.napi;
          }
          function compareTags(runtime2) {
            return function(a, b) {
              if (a.runtime !== b.runtime) {
                return a.runtime === runtime2 ? -1 : 1;
              } else if (a.abi !== b.abi) {
                return a.abi ? -1 : 1;
              } else if (a.specificity !== b.specificity) {
                return a.specificity > b.specificity ? -1 : 1;
              } else {
                return 0;
              }
            };
          }
          function isElectron() {
            if (process.versions && process.versions.electron)
              return true;
            if (process.env.ELECTRON_RUN_AS_NODE)
              return true;
            return typeof window !== "undefined" && window.process && window.process.type === "renderer";
          }
          function isAlpine(platform2) {
            return platform2 === "linux" && fs.existsSync("/etc/alpine-release");
          }
          load.parseTags = parseTags;
          load.matchTags = matchTags;
          load.compareTags = compareTags;
        }).call(this);
      }).call(this, require2("_process"));
    }, { "_process": 361, "fs": 81, "os": 340, "path": 352 }], 331: [function(require2, module2, exports2) {
      var {
        sodium_memzero
      } = require2("sodium-universal/memory");
      var {
        sodium_increment,
        sodium_memcmp,
        sodium_is_zero
      } = require2("sodium-universal/helpers");
      var assert = require2("nanoassert");
      var cipher = require2("./cipher");
      var STATELEN = cipher.KEYLEN + cipher.NONCELEN;
      var NONCELEN = cipher.NONCELEN;
      var MACLEN = cipher.MACLEN;
      module2.exports = {
        STATELEN,
        NONCELEN,
        MACLEN,
        initializeKey,
        hasKey,
        setNonce,
        encryptWithAd,
        decryptWithAd,
        rekey
      };
      var KEY_BEGIN = 0;
      var KEY_END = cipher.KEYLEN;
      var NONCE_BEGIN = KEY_END;
      var NONCE_END = NONCE_BEGIN + cipher.NONCELEN;
      function initializeKey(state, key) {
        assert(state.byteLength === STATELEN);
        assert(key == null ? true : key.byteLength === cipher.KEYLEN);
        if (key == null) {
          sodium_memzero(state.subarray(KEY_BEGIN, KEY_END));
          return;
        }
        state.set(key);
        sodium_memzero(state.subarray(NONCE_BEGIN, NONCE_END));
      }
      function hasKey(state) {
        assert(state.byteLength === STATELEN);
        var k = state.subarray(KEY_BEGIN, KEY_END);
        return sodium_is_zero(k) === false;
      }
      function setNonce(state, nonce) {
        assert(state.byteLength === STATELEN);
        assert(nonce.byteLength === NONCELEN);
        state.set(nonce, NONCE_BEGIN);
      }
      var maxnonce = new Uint8Array(8).fill(255);
      function encryptWithAd(state, out, ad, plaintext) {
        assert(state.byteLength === STATELEN);
        assert(out.byteLength != null);
        assert(plaintext.byteLength != null);
        var n = state.subarray(NONCE_BEGIN, NONCE_END);
        if (sodium_memcmp(n, maxnonce))
          throw new Error("Nonce overflow");
        if (hasKey(state) === false) {
          out.set(plaintext);
          encryptWithAd.bytesRead = plaintext.byteLength;
          encryptWithAd.bytesWritten = encryptWithAd.bytesRead;
          return;
        }
        var k = state.subarray(KEY_BEGIN, KEY_END);
        cipher.encrypt(out, k, n, ad, plaintext);
        encryptWithAd.bytesRead = cipher.encrypt.bytesRead;
        encryptWithAd.bytesWritten = cipher.encrypt.bytesWritten;
        sodium_increment(n);
      }
      encryptWithAd.bytesRead = 0;
      encryptWithAd.bytesWritten = 0;
      function decryptWithAd(state, out, ad, ciphertext) {
        assert(state.byteLength === STATELEN);
        assert(out.byteLength != null);
        assert(ciphertext.byteLength != null);
        var n = state.subarray(NONCE_BEGIN, NONCE_END);
        if (sodium_memcmp(n, maxnonce))
          throw new Error("Nonce overflow");
        if (hasKey(state) === false) {
          out.set(ciphertext);
          decryptWithAd.bytesRead = ciphertext.byteLength;
          decryptWithAd.bytesWritten = decryptWithAd.bytesRead;
          return;
        }
        var k = state.subarray(KEY_BEGIN, KEY_END);
        cipher.decrypt(out, k, n, ad, ciphertext);
        decryptWithAd.bytesRead = cipher.decrypt.bytesRead;
        decryptWithAd.bytesWritten = cipher.decrypt.bytesWritten;
        sodium_increment(n);
      }
      decryptWithAd.bytesRead = 0;
      decryptWithAd.bytesWritten = 0;
      function rekey(state) {
        assert(state.byteLength === STATELEN);
        var k = state.subarray(KEY_BEGIN, KEY_END);
        cipher.rekey(k, k);
        rekey.bytesRead = cipher.rekey.bytesRead;
        rekey.bytesWritten = cipher.rekey.bytesWritten;
      }
      rekey.bytesRead = 0;
      rekey.bytesWritten = 0;
    }, { "./cipher": 332, "nanoassert": 308, "sodium-universal/helpers": 473, "sodium-universal/memory": 477 }], 332: [function(require2, module2, exports2) {
      var {
        sodium_malloc,
        sodium_memzero
      } = require2("sodium-universal/memory");
      var {
        crypto_aead_chacha20poly1305_ietf_KEYBYTES,
        crypto_aead_chacha20poly1305_ietf_NPUBBYTES,
        crypto_aead_chacha20poly1305_ietf_ABYTES,
        crypto_aead_chacha20poly1305_ietf_encrypt,
        crypto_aead_chacha20poly1305_ietf_decrypt
      } = require2("sodium-universal/crypto_aead");
      var assert = require2("nanoassert");
      var KEYLEN = 32;
      var NONCELEN = 8;
      var MACLEN = 16;
      assert(crypto_aead_chacha20poly1305_ietf_KEYBYTES === KEYLEN);
      assert(crypto_aead_chacha20poly1305_ietf_NPUBBYTES === 4 + NONCELEN);
      assert(crypto_aead_chacha20poly1305_ietf_ABYTES === MACLEN);
      module2.exports = {
        KEYLEN,
        NONCELEN,
        MACLEN,
        encrypt,
        decrypt,
        rekey
      };
      var ElongatedNonce = sodium_malloc(crypto_aead_chacha20poly1305_ietf_NPUBBYTES);
      function encrypt(out, k, n, ad, plaintext) {
        assert(out.byteLength >= plaintext.byteLength + MACLEN, "output buffer must be at least plaintext plus MACLEN bytes long");
        assert(k.byteLength === KEYLEN);
        assert(n.byteLength === NONCELEN);
        assert(ad == null ? true : ad.byteLength != null);
        sodium_memzero(ElongatedNonce);
        ElongatedNonce.set(n, 4);
        encrypt.bytesWritten = crypto_aead_chacha20poly1305_ietf_encrypt(out.subarray(0, plaintext.byteLength + MACLEN), plaintext, ad, null, ElongatedNonce, k);
        encrypt.bytesRead = encrypt.bytesWritten - MACLEN;
        sodium_memzero(ElongatedNonce);
      }
      encrypt.bytesWritten = 0;
      encrypt.bytesRead = 0;
      function decrypt(out, k, n, ad, ciphertext) {
        assert(out.byteLength >= ciphertext.byteLength - MACLEN);
        assert(k.byteLength === KEYLEN);
        assert(n.byteLength === NONCELEN);
        assert(ad == null ? true : ad.byteLength != null);
        sodium_memzero(ElongatedNonce);
        ElongatedNonce.set(n, 4);
        decrypt.bytesWritten = crypto_aead_chacha20poly1305_ietf_decrypt(out.subarray(0, ciphertext.byteLength - MACLEN), null, ciphertext, ad, ElongatedNonce, k);
        decrypt.bytesRead = decrypt.bytesWritten + MACLEN;
        sodium_memzero(ElongatedNonce);
      }
      decrypt.bytesWritten = 0;
      decrypt.bytesRead = 0;
      var maxnonce = new Uint8Array(8).fill(255);
      var zerolen = new Uint8Array(0);
      var zeros = new Uint8Array(32);
      var IntermediateKey = sodium_malloc(KEYLEN + MACLEN);
      sodium_memzero(IntermediateKey);
      function rekey(out, k) {
        assert(out.byteLength === KEYLEN);
        assert(k.byteLength === KEYLEN);
        sodium_memzero(IntermediateKey);
        IntermediateKey.set(k);
        encrypt(IntermediateKey, k, maxnonce, zerolen, zeros);
        rekey.bytesWritten = encrypt.bytesWritten;
        rekey.bytesRead = encrypt.bytesRead;
        out.set(IntermediateKey.subarray(0, KEYLEN));
        sodium_memzero(IntermediateKey);
      }
      rekey.bytesWritten = 0;
      rekey.bytesRead = 0;
    }, { "nanoassert": 308, "sodium-universal/crypto_aead": 458, "sodium-universal/memory": 477 }], 333: [function(require2, module2, exports2) {
      var {
        crypto_kx_SEEDBYTES,
        crypto_kx_keypair,
        crypto_kx_seed_keypair
      } = require2("sodium-universal/crypto_kx");
      var {
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_scalarmult
      } = require2("sodium-universal/crypto_scalarmult");
      var assert = require2("nanoassert");
      var DHLEN = crypto_scalarmult_BYTES;
      var PKLEN = crypto_scalarmult_BYTES;
      var SKLEN = crypto_scalarmult_SCALARBYTES;
      var SEEDLEN = crypto_kx_SEEDBYTES;
      module2.exports = {
        DHLEN,
        PKLEN,
        SKLEN,
        SEEDLEN,
        generateKeypair,
        generateSeedKeypair,
        dh
      };
      function generateKeypair(pk, sk) {
        assert(pk.byteLength === PKLEN);
        assert(sk.byteLength === SKLEN);
        crypto_kx_keypair(pk, sk);
      }
      function generateSeedKeypair(pk, sk, seed) {
        assert(pk.byteLength === PKLEN);
        assert(sk.byteLength === SKLEN);
        assert(seed.byteLength === SKLEN);
        crypto_kx_seed_keypair(pk, sk, seed);
      }
      function dh(output, lsk, pk) {
        assert(output.byteLength === DHLEN);
        assert(lsk.byteLength === SKLEN);
        assert(pk.byteLength === PKLEN);
        crypto_scalarmult(output, lsk, pk);
      }
    }, { "nanoassert": 308, "sodium-universal/crypto_kx": 464, "sodium-universal/crypto_scalarmult": 466 }], 334: [function(require2, module2, exports2) {
      var {
        sodium_malloc,
        sodium_memzero,
        sodium_free
      } = require2("sodium-universal/memory");
      var assert = require2("nanoassert");
      var clone = require2("clone");
      var symmetricState = require2("./symmetric-state");
      var cipherState = require2("./cipher-state");
      var dh = require2("./dh");
      var PKLEN = dh.PKLEN;
      var SKLEN = dh.SKLEN;
      module2.exports = Object.freeze({
        initialize,
        writeMessage,
        readMessage,
        destroy,
        keygen,
        seedKeygen,
        SKLEN,
        PKLEN
      });
      function HandshakeState() {
        this.symmetricState = sodium_malloc(symmetricState.STATELEN);
        this.initiator = null;
        this.spk = null;
        this.ssk = null;
        this.epk = null;
        this.esk = null;
        this.rs = null;
        this.re = null;
        this.messagePatterns = null;
      }
      var INITIATOR = Symbol("initiator");
      var RESPONDER = Symbol("responder");
      var TOK_S = Symbol("s");
      var TOK_E = Symbol("e");
      var TOK_ES = Symbol("es");
      var TOK_SE = Symbol("se");
      var TOK_EE = Symbol("ee");
      var TOK_SS = Symbol("es");
      var PATTERNS = Object.freeze({
        N: {
          premessages: [[RESPONDER, TOK_S]],
          messagePatterns: [[INITIATOR, TOK_E, TOK_ES]]
        },
        K: {
          premessages: [[INITIATOR, TOK_S], [RESPONDER, TOK_S]],
          messagePatterns: [[INITIATOR, TOK_E, TOK_ES, TOK_SS]]
        },
        X: {
          premessages: [[RESPONDER, TOK_S]],
          messagePatterns: [[INITIATOR, TOK_E, TOK_ES, TOK_S, TOK_SS]]
        },
        NN: {
          premessages: [],
          messagePatterns: [[INITIATOR, TOK_E], [RESPONDER, TOK_E, TOK_EE]]
        },
        KN: {
          premessages: [[INITIATOR, TOK_S]],
          messagePatterns: [[INITIATOR, TOK_E], [RESPONDER, TOK_E, TOK_EE, TOK_SE]]
        },
        NK: {
          premessages: [[RESPONDER, TOK_S]],
          messagePatterns: [[INITIATOR, TOK_E, TOK_ES], [RESPONDER, TOK_E, TOK_EE]]
        },
        KK: {
          premessages: [[INITIATOR, TOK_S], [RESPONDER, TOK_S]],
          messagePatterns: [[INITIATOR, TOK_E, TOK_ES, TOK_SS], [RESPONDER, TOK_E, TOK_EE, TOK_SE]]
        },
        NX: {
          premessages: [],
          messagePatterns: [[INITIATOR, TOK_E], [RESPONDER, TOK_E, TOK_EE, TOK_S, TOK_ES]]
        },
        KX: {
          premessages: [[INITIATOR, TOK_S]],
          messagePatterns: [[INITIATOR, TOK_E], [RESPONDER, TOK_E, TOK_EE, TOK_SE, TOK_S, TOK_ES]]
        },
        XN: {
          premessages: [],
          messagePatterns: [[INITIATOR, TOK_E], [RESPONDER, TOK_E, TOK_EE], [INITIATOR, TOK_S, TOK_SE]]
        },
        IN: {
          premessages: [],
          messagePatterns: [[INITIATOR, TOK_E, TOK_S], [RESPONDER, TOK_E, TOK_EE, TOK_SE]]
        },
        XK: {
          premessages: [[RESPONDER, TOK_S]],
          messagePatterns: [[INITIATOR, TOK_E, TOK_ES], [RESPONDER, TOK_E, TOK_EE], [INITIATOR, TOK_S, TOK_SE]]
        },
        IK: {
          premessages: [[RESPONDER, TOK_S]],
          messagePatterns: [[INITIATOR, TOK_E, TOK_ES, TOK_S, TOK_SS], [RESPONDER, TOK_E, TOK_EE, TOK_SE]]
        },
        XX: {
          premessages: [],
          messagePatterns: [[INITIATOR, TOK_E], [RESPONDER, TOK_E, TOK_EE, TOK_S, TOK_ES], [INITIATOR, TOK_S, TOK_SE]]
        },
        IX: {
          premessages: [],
          messagePatterns: [[INITIATOR, TOK_E, TOK_S], [RESPONDER, TOK_E, TOK_EE, TOK_SE, TOK_S, TOK_ES]]
        }
      });
      function sodiumBufferCopy(src) {
        var buf = sodium_malloc(src.byteLength);
        buf.set(src);
        return buf;
      }
      function initialize(handshakePattern, initiator, prologue, s, e, rs, re) {
        assert(Object.keys(PATTERNS).includes(handshakePattern), "Unsupported handshake pattern");
        assert(typeof initiator === "boolean", "Initiator must be a boolean");
        assert(prologue.byteLength != null, "prolouge must be a Buffer");
        assert(e == null ? true : e.publicKey.byteLength === dh.PKLEN, "e.publicKey must be ".concat(dh.PKLEN, " bytes"));
        assert(e == null ? true : e.secretKey.byteLength === dh.SKLEN, "e.secretKey must be ".concat(dh.SKLEN, " bytes"));
        assert(rs == null ? true : rs.byteLength === dh.PKLEN, "rs must be ".concat(dh.PKLEN, " bytes"));
        assert(re == null ? true : re.byteLength === dh.PKLEN, "re must be ".concat(dh.PKLEN, " bytes"));
        var state = new HandshakeState();
        var protocolName = Uint8Array.from("Noise_".concat(handshakePattern, "_25519_ChaChaPoly_BLAKE2b"), toCharCode);
        symmetricState.initializeSymmetric(state.symmetricState, protocolName);
        symmetricState.mixHash(state.symmetricState, prologue);
        state.role = initiator === true ? INITIATOR : RESPONDER;
        if (s != null) {
          assert(s.publicKey.byteLength === dh.PKLEN, "s.publicKey must be ".concat(dh.PKLEN, " bytes"));
          assert(s.secretKey.byteLength === dh.SKLEN, "s.secretKey must be ".concat(dh.SKLEN, " bytes"));
          state.spk = sodiumBufferCopy(s.publicKey);
          state.ssk = sodiumBufferCopy(s.secretKey);
        }
        if (e != null) {
          assert(e.publicKey.byteLength === dh.PKLEN);
          assert(e.secretKey.byteLength === dh.SKLEN);
          state.epk = sodiumBufferCopy(e.publicKey);
          state.esk = sodiumBufferCopy(e.secretKey);
        }
        if (rs != null) {
          assert(rs.byteLength === dh.PKLEN);
          state.rs = sodiumBufferCopy(rs);
        }
        if (re != null) {
          assert(re.byteLength === dh.PKLEN);
          state.re = sodiumBufferCopy(re);
        }
        var pat = PATTERNS[handshakePattern];
        for (var pattern of clone(pat.premessages)) {
          var patternRole = pattern.shift();
          for (var token of pattern) {
            switch (token) {
              case TOK_E:
                assert(state.role === patternRole ? state.epk.byteLength != null : state.re.byteLength != null);
                symmetricState.mixHash(state.symmetricState, state.role === patternRole ? state.epk : state.re);
                break;
              case TOK_S:
                assert(state.role === patternRole ? state.spk.byteLength != null : state.rs.byteLength != null);
                symmetricState.mixHash(state.symmetricState, state.role === patternRole ? state.spk : state.rs);
                break;
              default:
                throw new Error("Invalid premessage pattern");
            }
          }
        }
        state.messagePatterns = clone(pat.messagePatterns);
        assert(
          state.messagePatterns.filter((p) => p[0] === INITIATOR).some((p) => p.includes(TOK_S)) ? state.spk !== null && state.ssk !== null : true,
          "This handshake pattern requires a static keypair"
        );
        return state;
      }
      var DhResult = sodium_malloc(dh.DHLEN);
      function writeMessage(state, payload, messageBuffer) {
        assert(state instanceof HandshakeState);
        assert(payload.byteLength != null);
        assert(messageBuffer.byteLength != null);
        var mpat = state.messagePatterns.shift();
        var moffset = 0;
        assert(mpat != null);
        assert(state.role === mpat.shift());
        for (var token of mpat) {
          switch (token) {
            case TOK_E:
              assert(state.epk == null);
              assert(state.esk == null);
              state.epk = sodium_malloc(dh.PKLEN);
              state.esk = sodium_malloc(dh.SKLEN);
              dh.generateKeypair(state.epk, state.esk);
              messageBuffer.set(state.epk, moffset);
              moffset += state.epk.byteLength;
              symmetricState.mixHash(state.symmetricState, state.epk);
              break;
            case TOK_S:
              assert(state.spk.byteLength === dh.PKLEN);
              symmetricState.encryptAndHash(state.symmetricState, messageBuffer.subarray(moffset), state.spk);
              moffset += symmetricState.encryptAndHash.bytesWritten;
              break;
            case TOK_EE:
              dh.dh(DhResult, state.esk, state.re);
              symmetricState.mixKey(state.symmetricState, DhResult);
              sodium_memzero(DhResult);
              break;
            case TOK_ES:
              if (state.role === INITIATOR)
                dh.dh(DhResult, state.esk, state.rs);
              else
                dh.dh(DhResult, state.ssk, state.re);
              symmetricState.mixKey(state.symmetricState, DhResult);
              sodium_memzero(DhResult);
              break;
            case TOK_SE:
              if (state.role === INITIATOR)
                dh.dh(DhResult, state.ssk, state.re);
              else
                dh.dh(DhResult, state.esk, state.rs);
              symmetricState.mixKey(state.symmetricState, DhResult);
              sodium_memzero(DhResult);
              break;
            case TOK_SS:
              dh.dh(DhResult, state.ssk, state.rs);
              symmetricState.mixKey(state.symmetricState, DhResult);
              sodium_memzero(DhResult);
              break;
            default:
              throw new Error("Invalid message pattern");
          }
        }
        symmetricState.encryptAndHash(state.symmetricState, messageBuffer.subarray(moffset), payload);
        moffset += symmetricState.encryptAndHash.bytesWritten;
        writeMessage.bytes = moffset;
        if (state.messagePatterns.length === 0) {
          var tx = sodium_malloc(cipherState.STATELEN);
          var rx = sodium_malloc(cipherState.STATELEN);
          symmetricState.split(state.symmetricState, tx, rx);
          return {
            tx,
            rx
          };
        }
      }
      writeMessage.bytes = 0;
      function readMessage(state, message, payloadBuffer) {
        assert(state instanceof HandshakeState);
        assert(message.byteLength != null);
        assert(payloadBuffer.byteLength != null);
        var mpat = state.messagePatterns.shift();
        var moffset = 0;
        assert(mpat != null);
        assert(mpat.shift() !== state.role);
        for (var token of mpat) {
          switch (token) {
            case TOK_E:
              assert(state.re == null);
              assert(message.byteLength - moffset >= dh.PKLEN);
              state.re = sodium_malloc(dh.PKLEN);
              state.re.set(message.subarray(moffset, moffset + dh.PKLEN));
              moffset += dh.PKLEN;
              symmetricState.mixHash(state.symmetricState, state.re);
              break;
            case TOK_S:
              assert(state.rs == null);
              state.rs = sodium_malloc(dh.PKLEN);
              var bytes = 0;
              if (symmetricState._hasKey(state.symmetricState)) {
                bytes = dh.PKLEN + 16;
              } else {
                bytes = dh.PKLEN;
              }
              assert(message.byteLength - moffset >= bytes);
              symmetricState.decryptAndHash(
                state.symmetricState,
                state.rs,
                message.subarray(moffset, moffset + bytes)
              );
              moffset += symmetricState.decryptAndHash.bytesRead;
              break;
            case TOK_EE:
              dh.dh(DhResult, state.esk, state.re);
              symmetricState.mixKey(state.symmetricState, DhResult);
              sodium_memzero(DhResult);
              break;
            case TOK_ES:
              if (state.role === INITIATOR)
                dh.dh(DhResult, state.esk, state.rs);
              else
                dh.dh(DhResult, state.ssk, state.re);
              symmetricState.mixKey(state.symmetricState, DhResult);
              sodium_memzero(DhResult);
              break;
            case TOK_SE:
              if (state.role === INITIATOR)
                dh.dh(DhResult, state.ssk, state.re);
              else
                dh.dh(DhResult, state.esk, state.rs);
              symmetricState.mixKey(state.symmetricState, DhResult);
              sodium_memzero(DhResult);
              break;
            case TOK_SS:
              dh.dh(DhResult, state.ssk, state.rs);
              symmetricState.mixKey(state.symmetricState, DhResult);
              sodium_memzero(DhResult);
              break;
            default:
              throw new Error("Invalid message pattern");
          }
        }
        symmetricState.decryptAndHash(state.symmetricState, payloadBuffer, message.subarray(moffset));
        readMessage.bytes = symmetricState.decryptAndHash.bytesWritten;
        if (state.messagePatterns.length === 0) {
          var tx = sodium_malloc(cipherState.STATELEN);
          var rx = sodium_malloc(cipherState.STATELEN);
          symmetricState.split(state.symmetricState, rx, tx);
          return {
            tx,
            rx
          };
        }
      }
      readMessage.bytes = 0;
      function destroy(state) {
        if (state.symmetricState != null) {
          sodium_free(state.symmetricState);
          state.symmetricState = null;
        }
        state.role = null;
        if (state.spk != null) {
          sodium_free(state.spk);
          state.spk = null;
        }
        if (state.ssk != null) {
          sodium_free(state.ssk);
          state.ssk = null;
        }
        if (state.epk != null) {
          sodium_free(state.epk);
          state.epk = null;
        }
        if (state.esk != null) {
          sodium_free(state.esk);
          state.esk = null;
        }
        if (state.rs != null) {
          sodium_free(state.rs);
          state.rs = null;
        }
        if (state.re != null) {
          sodium_free(state.re);
          state.re = null;
        }
        state.messagePatterns = null;
      }
      function keygen(obj, sk) {
        if (!obj) {
          obj = {
            publicKey: sodium_malloc(PKLEN),
            secretKey: sodium_malloc(SKLEN)
          };
          return keygen(obj);
        }
        if (obj.publicKey) {
          dh.generateKeypair(obj.publicKey, obj.secretKey);
          return obj;
        }
        if (obj.byteLength != null)
          dh.generateKeypair(null, obj);
      }
      function seedKeygen(seed) {
        var obj = {
          publicKey: sodium_malloc(PKLEN),
          secretKey: sodium_malloc(SKLEN)
        };
        dh.generateSeedKeypair(obj.publicKey, obj.secretKey, seed);
        return obj;
      }
      function toCharCode(s) {
        return s.charCodeAt(0);
      }
    }, { "./cipher-state": 331, "./dh": 333, "./symmetric-state": 337, "clone": 93, "nanoassert": 308, "sodium-universal/memory": 477 }], 335: [function(require2, module2, exports2) {
      var {
        sodium_malloc,
        sodium_memzero
      } = require2("sodium-universal/memory");
      var {
        crypto_generichash_batch
      } = require2("sodium-universal/crypto_generichash");
      var assert = require2("nanoassert");
      var hmacBlake2b = require2("hmac-blake2b");
      var dh = require2("./dh");
      var HASHLEN = 64;
      var BLOCKLEN = 128;
      assert(hmacBlake2b.KEYBYTES === BLOCKLEN, "mismatching hmac BLOCKLEN");
      assert(hmacBlake2b.BYTES === HASHLEN, "mismatching hmac HASHLEN");
      module2.exports = {
        HASHLEN,
        BLOCKLEN,
        hash,
        hkdf
      };
      function hash(out, data) {
        assert(out.byteLength === HASHLEN);
        assert(Array.isArray(data));
        crypto_generichash_batch(out, data);
      }
      function hmac(out, key, data) {
        return hmacBlake2b(out, data, key);
      }
      var TempKey = sodium_malloc(HASHLEN);
      var Byte0x01 = new Uint8Array([1]);
      var Byte0x02 = new Uint8Array([2]);
      var Byte0x03 = new Uint8Array([3]);
      function hkdf(out1, out2, out3, chainingKey, inputKeyMaterial) {
        assert(out1.byteLength === HASHLEN);
        assert(out2.byteLength === HASHLEN);
        assert(out3 == null ? true : out3.byteLength === HASHLEN);
        assert(chainingKey.byteLength === HASHLEN);
        assert([0, 32, dh.DHLEN, dh.PKLEN].includes(inputKeyMaterial.byteLength));
        sodium_memzero(TempKey);
        hmac(TempKey, chainingKey, [inputKeyMaterial]);
        hmac(out1, TempKey, [Byte0x01]);
        hmac(out2, TempKey, [out1, Byte0x02]);
        if (out3 != null) {
          hmac(out3, TempKey, [out2, Byte0x03]);
        }
        sodium_memzero(TempKey);
      }
    }, { "./dh": 333, "hmac-blake2b": 223, "nanoassert": 308, "sodium-universal/crypto_generichash": 460, "sodium-universal/memory": 477 }], 336: [function(require2, module2, exports2) {
      module2.exports = require2("./handshake-state");
    }, { "./handshake-state": 334 }], 337: [function(require2, module2, exports2) {
      var {
        sodium_malloc,
        sodium_memzero
      } = require2("sodium-universal/memory");
      var assert = require2("nanoassert");
      var cipherState = require2("./cipher-state");
      var hash = require2("./hash");
      var STATELEN = hash.HASHLEN + hash.HASHLEN + cipherState.STATELEN;
      var HASHLEN = hash.HASHLEN;
      module2.exports = {
        STATELEN,
        initializeSymmetric,
        mixKey,
        mixHash,
        mixKeyAndHash,
        getHandshakeHash,
        encryptAndHash,
        decryptAndHash,
        split,
        _hasKey
      };
      var CHAINING_KEY_BEGIN = 0;
      var CHAINING_KEY_END = hash.HASHLEN;
      var HASH_BEGIN = CHAINING_KEY_END;
      var HASH_END = HASH_BEGIN + hash.HASHLEN;
      var CIPHER_BEGIN = HASH_END;
      var CIPHER_END = CIPHER_BEGIN + cipherState.STATELEN;
      function initializeSymmetric(state, protocolName) {
        assert(state.byteLength === STATELEN);
        assert(protocolName.byteLength != null);
        sodium_memzero(state);
        if (protocolName.byteLength <= HASHLEN)
          state.set(protocolName, HASH_BEGIN);
        else
          hash.hash(state.subarray(HASH_BEGIN, HASH_END), [protocolName]);
        state.subarray(CHAINING_KEY_BEGIN, CHAINING_KEY_END).set(state.subarray(HASH_BEGIN, HASH_END));
        cipherState.initializeKey(state.subarray(CIPHER_BEGIN, CIPHER_END), null);
      }
      var TempKey = sodium_malloc(HASHLEN);
      function mixKey(state, inputKeyMaterial) {
        assert(state.byteLength === STATELEN);
        assert(inputKeyMaterial.byteLength != null);
        hash.hkdf(state.subarray(CHAINING_KEY_BEGIN, CHAINING_KEY_END), TempKey, null, state.subarray(CHAINING_KEY_BEGIN, CHAINING_KEY_END), inputKeyMaterial);
        cipherState.initializeKey(state.subarray(CIPHER_BEGIN, CIPHER_END), TempKey.subarray(0, 32));
        sodium_memzero(TempKey);
      }
      function mixHash(state, data) {
        assert(state.byteLength === STATELEN);
        var h = state.subarray(HASH_BEGIN, HASH_END);
        hash.hash(h, [h, data]);
      }
      var TempHash = sodium_malloc(HASHLEN);
      function mixKeyAndHash(state, inputKeyMaterial) {
        assert(state.byteLength === STATELEN);
        assert(inputKeyMaterial.byteLength != null);
        hash.hkdf(state.subarray(CHAINING_KEY_BEGIN, CHAINING_KEY_END), TempHash, TempKey, state.subarray(CHAINING_KEY_BEGIN, CHAINING_KEY_END), inputKeyMaterial);
        mixHash(state, TempHash);
        sodium_memzero(TempHash);
        cipherState.initializeKey(state.subarray(CIPHER_BEGIN, CIPHER_END), TempKey.subarray(0, 32));
        sodium_memzero(TempKey);
      }
      function getHandshakeHash(state, out) {
        assert(state.byteLength === STATELEN);
        assert(out.byteLength === HASHLEN);
        out.set(state.subarray(HASH_BEGIN, HASH_END));
      }
      function encryptAndHash(state, ciphertext, plaintext) {
        assert(state.byteLength === STATELEN);
        assert(ciphertext.byteLength != null);
        assert(plaintext.byteLength != null);
        var cstate = state.subarray(CIPHER_BEGIN, CIPHER_END);
        var h = state.subarray(HASH_BEGIN, HASH_END);
        cipherState.encryptWithAd(cstate, ciphertext, h, plaintext);
        encryptAndHash.bytesRead = cipherState.encryptWithAd.bytesRead;
        encryptAndHash.bytesWritten = cipherState.encryptWithAd.bytesWritten;
        mixHash(state, ciphertext.subarray(0, encryptAndHash.bytesWritten));
      }
      encryptAndHash.bytesRead = 0;
      encryptAndHash.bytesWritten = 0;
      function decryptAndHash(state, plaintext, ciphertext) {
        assert(state.byteLength === STATELEN);
        assert(plaintext.byteLength != null);
        assert(ciphertext.byteLength != null);
        var cstate = state.subarray(CIPHER_BEGIN, CIPHER_END);
        var h = state.subarray(HASH_BEGIN, HASH_END);
        cipherState.decryptWithAd(cstate, plaintext, h, ciphertext);
        decryptAndHash.bytesRead = cipherState.decryptWithAd.bytesRead;
        decryptAndHash.bytesWritten = cipherState.decryptWithAd.bytesWritten;
        mixHash(state, ciphertext.subarray(0, decryptAndHash.bytesRead));
      }
      decryptAndHash.bytesRead = 0;
      decryptAndHash.bytesWritten = 0;
      var TempKey1 = sodium_malloc(HASHLEN);
      var TempKey2 = sodium_malloc(HASHLEN);
      var zerolen = new Uint8Array(0);
      function split(state, cipherstate1, cipherstate2) {
        assert(state.byteLength === STATELEN);
        assert(cipherstate1.byteLength === cipherState.STATELEN);
        assert(cipherstate2.byteLength === cipherState.STATELEN);
        hash.hkdf(TempKey1, TempKey2, null, state.subarray(CHAINING_KEY_BEGIN, CHAINING_KEY_END), zerolen);
        cipherState.initializeKey(cipherstate1, TempKey1.subarray(0, 32));
        cipherState.initializeKey(cipherstate2, TempKey2.subarray(0, 32));
        sodium_memzero(TempKey1);
        sodium_memzero(TempKey2);
      }
      function _hasKey(state) {
        return cipherState.hasKey(state.subarray(CIPHER_BEGIN, CIPHER_END));
      }
    }, { "./cipher-state": 331, "./hash": 335, "nanoassert": 308, "sodium-universal/memory": 477 }], 338: [function(require2, module2, exports2) {
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val) {
        if (val === null || val === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
      }
      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }
          var test1 = new String("abc");
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }
          var test2 = {};
          for (var i = 0; i < 10; i++) {
            test2["_" + String.fromCharCode(i)] = i;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
        var from;
        var to = toObject(target);
        var symbols;
        for (var s = 1; s < arguments.length; s++) {
          from = Object(arguments[s]);
          for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
              to[key] = from[key];
            }
          }
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from, symbols[i])) {
                to[symbols[i]] = from[symbols[i]];
              }
            }
          }
        }
        return to;
      };
    }, {}], 339: [function(require2, module2, exports2) {
      var wrappy = require2("wrappy");
      module2.exports = wrappy(once);
      module2.exports.strict = wrappy(onceStrict);
      once.proto = once(function() {
        Object.defineProperty(Function.prototype, "once", {
          value: function value() {
            return once(this);
          },
          configurable: true
        });
        Object.defineProperty(Function.prototype, "onceStrict", {
          value: function value() {
            return onceStrict(this);
          },
          configurable: true
        });
      });
      function once(fn) {
        var f = function f2() {
          if (f2.called)
            return f2.value;
          f2.called = true;
          return f2.value = fn.apply(this, arguments);
        };
        f.called = false;
        return f;
      }
      function onceStrict(fn) {
        var f = function f2() {
          if (f2.called)
            throw new Error(f2.onceError);
          f2.called = true;
          return f2.value = fn.apply(this, arguments);
        };
        var name = fn.name || "Function wrapped with `once`";
        f.onceError = name + " shouldn't be called more than once";
        f.called = false;
        return f;
      }
    }, { "wrappy": 534 }], 340: [function(require2, module2, exports2) {
      exports2.endianness = function() {
        return "LE";
      };
      exports2.hostname = function() {
        if (typeof location !== "undefined") {
          return location.hostname;
        } else
          return "";
      };
      exports2.loadavg = function() {
        return [];
      };
      exports2.uptime = function() {
        return 0;
      };
      exports2.freemem = function() {
        return Number.MAX_VALUE;
      };
      exports2.totalmem = function() {
        return Number.MAX_VALUE;
      };
      exports2.cpus = function() {
        return [];
      };
      exports2.type = function() {
        return "Browser";
      };
      exports2.release = function() {
        if (typeof navigator !== "undefined") {
          return navigator.appVersion;
        }
        return "";
      };
      exports2.networkInterfaces = exports2.getNetworkInterfaces = function() {
        return {};
      };
      exports2.arch = function() {
        return "javascript";
      };
      exports2.platform = function() {
        return "browser";
      };
      exports2.tmpdir = exports2.tmpDir = function() {
        return "/tmp";
      };
      exports2.EOL = "\n";
      exports2.homedir = function() {
        return "/";
      };
    }, {}], 341: [function(require2, module2, exports2) {
      function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator(fn) {
        return function() {
          var self2 = this, args = arguments;
          return new Promise(function(resolve, reject) {
            var gen = fn.apply(self2, args);
            function _next(value) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(void 0);
          });
        };
      }
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var pTimeout = require2("p-timeout");
      var symbolAsyncIterator = Symbol.asyncIterator || "@@asyncIterator";
      var normalizeEmitter = (emitter) => {
        var addListener = emitter.on || emitter.addListener || emitter.addEventListener;
        var removeListener = emitter.off || emitter.removeListener || emitter.removeEventListener;
        if (!addListener || !removeListener) {
          throw new TypeError("Emitter is not compatible");
        }
        return {
          addListener: addListener.bind(emitter),
          removeListener: removeListener.bind(emitter)
        };
      };
      var toArray = (value) => Array.isArray(value) ? value : [value];
      var multiple = (emitter, event, options) => {
        var cancel;
        var ret = new Promise((resolve, reject) => {
          options = _objectSpread({
            rejectionEvents: ["error"],
            multiArgs: false,
            resolveImmediately: false
          }, options);
          if (!(options.count >= 0 && (options.count === Infinity || Number.isInteger(options.count)))) {
            throw new TypeError("The `count` option should be at least 0 or more");
          }
          var events = toArray(event);
          var items = [];
          var {
            addListener,
            removeListener
          } = normalizeEmitter(emitter);
          var onItem = function onItem2() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            var value = options.multiArgs ? args : args[0];
            if (options.filter && !options.filter(value)) {
              return;
            }
            items.push(value);
            if (options.count === items.length) {
              cancel();
              resolve(items);
            }
          };
          var rejectHandler = (error) => {
            cancel();
            reject(error);
          };
          cancel = () => {
            for (var _event of events) {
              removeListener(_event, onItem);
            }
            for (var rejectionEvent2 of options.rejectionEvents) {
              removeListener(rejectionEvent2, rejectHandler);
            }
          };
          for (var _event2 of events) {
            addListener(_event2, onItem);
          }
          for (var rejectionEvent of options.rejectionEvents) {
            addListener(rejectionEvent, rejectHandler);
          }
          if (options.resolveImmediately) {
            resolve(items);
          }
        });
        ret.cancel = cancel;
        if (typeof options.timeout === "number") {
          var timeout = pTimeout(ret, options.timeout);
          timeout.cancel = cancel;
          return timeout;
        }
        return ret;
      };
      var pEvent = (emitter, event, options) => {
        if (typeof options === "function") {
          options = {
            filter: options
          };
        }
        options = _objectSpread(_objectSpread({}, options), {}, {
          count: 1,
          resolveImmediately: false
        });
        var arrayPromise = multiple(emitter, event, options);
        var promise = arrayPromise.then((array) => array[0]);
        promise.cancel = arrayPromise.cancel;
        return promise;
      };
      module2.exports = pEvent;
      module2.exports.default = pEvent;
      module2.exports.multiple = multiple;
      module2.exports.iterator = (emitter, event, options) => {
        if (typeof options === "function") {
          options = {
            filter: options
          };
        }
        var events = toArray(event);
        options = _objectSpread({
          rejectionEvents: ["error"],
          resolutionEvents: [],
          limit: Infinity,
          multiArgs: false
        }, options);
        var {
          limit
        } = options;
        var isValidLimit = limit >= 0 && (limit === Infinity || Number.isInteger(limit));
        if (!isValidLimit) {
          throw new TypeError("The `limit` option should be a non-negative integer or Infinity");
        }
        if (limit === 0) {
          return {
            [Symbol.asyncIterator]() {
              return this;
            },
            next() {
              return _asyncToGenerator(function* () {
                return {
                  done: true,
                  value: void 0
                };
              })();
            }
          };
        }
        var {
          addListener,
          removeListener
        } = normalizeEmitter(emitter);
        var isDone = false;
        var error;
        var hasPendingError = false;
        var nextQueue = [];
        var valueQueue = [];
        var eventCount = 0;
        var isLimitReached = false;
        var valueHandler = function valueHandler2() {
          eventCount++;
          isLimitReached = eventCount === limit;
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          var value = options.multiArgs ? args : args[0];
          if (nextQueue.length > 0) {
            var {
              resolve
            } = nextQueue.shift();
            resolve({
              done: false,
              value
            });
            if (isLimitReached) {
              cancel();
            }
            return;
          }
          valueQueue.push(value);
          if (isLimitReached) {
            cancel();
          }
        };
        var cancel = () => {
          isDone = true;
          for (var _event3 of events) {
            removeListener(_event3, valueHandler);
          }
          for (var rejectionEvent2 of options.rejectionEvents) {
            removeListener(rejectionEvent2, rejectHandler);
          }
          for (var resolutionEvent2 of options.resolutionEvents) {
            removeListener(resolutionEvent2, resolveHandler);
          }
          while (nextQueue.length > 0) {
            var {
              resolve
            } = nextQueue.shift();
            resolve({
              done: true,
              value: void 0
            });
          }
        };
        var rejectHandler = function rejectHandler2() {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }
          error = options.multiArgs ? args : args[0];
          if (nextQueue.length > 0) {
            var {
              reject
            } = nextQueue.shift();
            reject(error);
          } else {
            hasPendingError = true;
          }
          cancel();
        };
        var resolveHandler = function resolveHandler2() {
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }
          var value = options.multiArgs ? args : args[0];
          if (options.filter && !options.filter(value)) {
            return;
          }
          if (nextQueue.length > 0) {
            var {
              resolve
            } = nextQueue.shift();
            resolve({
              done: true,
              value
            });
          } else {
            valueQueue.push(value);
          }
          cancel();
        };
        for (var _event4 of events) {
          addListener(_event4, valueHandler);
        }
        for (var rejectionEvent of options.rejectionEvents) {
          addListener(rejectionEvent, rejectHandler);
        }
        for (var resolutionEvent of options.resolutionEvents) {
          addListener(resolutionEvent, resolveHandler);
        }
        return {
          [symbolAsyncIterator]() {
            return this;
          },
          next() {
            return _asyncToGenerator(function* () {
              if (valueQueue.length > 0) {
                var value = valueQueue.shift();
                return {
                  done: isDone && valueQueue.length === 0 && !isLimitReached,
                  value
                };
              }
              if (hasPendingError) {
                hasPendingError = false;
                throw error;
              }
              if (isDone) {
                return {
                  done: true,
                  value: void 0
                };
              }
              return new Promise((resolve, reject) => nextQueue.push({
                resolve,
                reject
              }));
            })();
          },
          return(value) {
            return _asyncToGenerator(function* () {
              cancel();
              return {
                done: isDone,
                value
              };
            })();
          }
        };
      };
      module2.exports.TimeoutError = pTimeout.TimeoutError;
    }, { "p-timeout": 346 }], 342: [function(require2, module2, exports2) {
      module2.exports = (promise, onFinally) => {
        onFinally = onFinally || (() => {
        });
        return promise.then((val) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => val), (err) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => {
          throw err;
        }));
      };
    }, {}], 343: [function(require2, module2, exports2) {
      function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator(fn) {
        return function() {
          var self2 = this, args = arguments;
          return new Promise(function(resolve, reject) {
            var gen = fn.apply(self2, args);
            function _next(value) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(void 0);
          });
        };
      }
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      var EventEmitter = require2("eventemitter3");
      var p_timeout_1 = require2("p-timeout");
      var priority_queue_1 = require2("./priority-queue");
      var empty = () => {
      };
      var timeoutError = new p_timeout_1.TimeoutError();
      class PQueue extends EventEmitter {
        constructor(options) {
          var _a, _b, _c, _d;
          super();
          this._intervalCount = 0;
          this._intervalEnd = 0;
          this._pendingCount = 0;
          this._resolveEmpty = empty;
          this._resolveIdle = empty;
          options = Object.assign({
            carryoverConcurrencyCount: false,
            intervalCap: Infinity,
            interval: 0,
            concurrency: Infinity,
            autoStart: true,
            queueClass: priority_queue_1.default
          }, options);
          if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
            throw new TypeError("Expected `intervalCap` to be a number from 1 and up, got `".concat((_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : "", "` (").concat(typeof options.intervalCap, ")"));
          }
          if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
            throw new TypeError("Expected `interval` to be a finite number >= 0, got `".concat((_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : "", "` (").concat(typeof options.interval, ")"));
          }
          this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;
          this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;
          this._intervalCap = options.intervalCap;
          this._interval = options.interval;
          this._queue = new options.queueClass();
          this._queueClass = options.queueClass;
          this.concurrency = options.concurrency;
          this._timeout = options.timeout;
          this._throwOnTimeout = options.throwOnTimeout === true;
          this._isPaused = options.autoStart === false;
        }
        get _doesIntervalAllowAnother() {
          return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
        }
        get _doesConcurrentAllowAnother() {
          return this._pendingCount < this._concurrency;
        }
        _next() {
          this._pendingCount--;
          this._tryToStartAnother();
          this.emit("next");
        }
        _resolvePromises() {
          this._resolveEmpty();
          this._resolveEmpty = empty;
          if (this._pendingCount === 0) {
            this._resolveIdle();
            this._resolveIdle = empty;
            this.emit("idle");
          }
        }
        _onResumeInterval() {
          this._onInterval();
          this._initializeIntervalIfNeeded();
          this._timeoutId = void 0;
        }
        _isIntervalPaused() {
          var now = Date.now();
          if (this._intervalId === void 0) {
            var delay = this._intervalEnd - now;
            if (delay < 0) {
              this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
            } else {
              if (this._timeoutId === void 0) {
                this._timeoutId = setTimeout(() => {
                  this._onResumeInterval();
                }, delay);
              }
              return true;
            }
          }
          return false;
        }
        _tryToStartAnother() {
          if (this._queue.size === 0) {
            if (this._intervalId) {
              clearInterval(this._intervalId);
            }
            this._intervalId = void 0;
            this._resolvePromises();
            return false;
          }
          if (!this._isPaused) {
            var canInitializeInterval = !this._isIntervalPaused();
            if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
              var job = this._queue.dequeue();
              if (!job) {
                return false;
              }
              this.emit("active");
              job();
              if (canInitializeInterval) {
                this._initializeIntervalIfNeeded();
              }
              return true;
            }
          }
          return false;
        }
        _initializeIntervalIfNeeded() {
          if (this._isIntervalIgnored || this._intervalId !== void 0) {
            return;
          }
          this._intervalId = setInterval(() => {
            this._onInterval();
          }, this._interval);
          this._intervalEnd = Date.now() + this._interval;
        }
        _onInterval() {
          if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {
            clearInterval(this._intervalId);
            this._intervalId = void 0;
          }
          this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
          this._processQueue();
        }
        _processQueue() {
          while (this._tryToStartAnother()) {
          }
        }
        get concurrency() {
          return this._concurrency;
        }
        set concurrency(newConcurrency) {
          if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
            throw new TypeError("Expected `concurrency` to be a number from 1 and up, got `".concat(newConcurrency, "` (").concat(typeof newConcurrency, ")"));
          }
          this._concurrency = newConcurrency;
          this._processQueue();
        }
        add(fn) {
          var _arguments = arguments, _this = this;
          return _asyncToGenerator(function* () {
            var options = _arguments.length > 1 && _arguments[1] !== void 0 ? _arguments[1] : {};
            return new Promise((resolve, reject) => {
              var run = /* @__PURE__ */ function() {
                var _ref = _asyncToGenerator(function* () {
                  _this._pendingCount++;
                  _this._intervalCount++;
                  try {
                    var operation = _this._timeout === void 0 && options.timeout === void 0 ? fn() : p_timeout_1.default(Promise.resolve(fn()), options.timeout === void 0 ? _this._timeout : options.timeout, () => {
                      if (options.throwOnTimeout === void 0 ? _this._throwOnTimeout : options.throwOnTimeout) {
                        reject(timeoutError);
                      }
                      return void 0;
                    });
                    resolve(yield operation);
                  } catch (error) {
                    reject(error);
                  }
                  _this._next();
                });
                return function run2() {
                  return _ref.apply(this, arguments);
                };
              }();
              _this._queue.enqueue(run, options);
              _this._tryToStartAnother();
              _this.emit("add");
            });
          })();
        }
        addAll(functions, options) {
          var _this2 = this;
          return _asyncToGenerator(function* () {
            return Promise.all(functions.map(/* @__PURE__ */ function() {
              var _ref2 = _asyncToGenerator(function* (function_) {
                return _this2.add(function_, options);
              });
              return function(_x) {
                return _ref2.apply(this, arguments);
              };
            }()));
          })();
        }
        start() {
          if (!this._isPaused) {
            return this;
          }
          this._isPaused = false;
          this._processQueue();
          return this;
        }
        pause() {
          this._isPaused = true;
        }
        clear() {
          this._queue = new this._queueClass();
        }
        onEmpty() {
          var _this3 = this;
          return _asyncToGenerator(function* () {
            if (_this3._queue.size === 0) {
              return;
            }
            return new Promise((resolve) => {
              var existingResolve = _this3._resolveEmpty;
              _this3._resolveEmpty = () => {
                existingResolve();
                resolve();
              };
            });
          })();
        }
        onIdle() {
          var _this4 = this;
          return _asyncToGenerator(function* () {
            if (_this4._pendingCount === 0 && _this4._queue.size === 0) {
              return;
            }
            return new Promise((resolve) => {
              var existingResolve = _this4._resolveIdle;
              _this4._resolveIdle = () => {
                existingResolve();
                resolve();
              };
            });
          })();
        }
        get size() {
          return this._queue.size;
        }
        sizeBy(options) {
          return this._queue.filter(options).length;
        }
        get pending() {
          return this._pendingCount;
        }
        get isPaused() {
          return this._isPaused;
        }
        get timeout() {
          return this._timeout;
        }
        set timeout(milliseconds) {
          this._timeout = milliseconds;
        }
      }
      exports2.default = PQueue;
    }, { "./priority-queue": 345, "eventemitter3": 192, "p-timeout": 346 }], 344: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      function lowerBound(array, value, comparator) {
        var first = 0;
        var count = array.length;
        while (count > 0) {
          var step = count / 2 | 0;
          var it = first + step;
          if (comparator(array[it], value) <= 0) {
            first = ++it;
            count -= step + 1;
          } else {
            count = step;
          }
        }
        return first;
      }
      exports2.default = lowerBound;
    }, {}], 345: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      var lower_bound_1 = require2("./lower-bound");
      class PriorityQueue {
        constructor() {
          this._queue = [];
        }
        enqueue(run, options) {
          options = Object.assign({
            priority: 0
          }, options);
          var element = {
            priority: options.priority,
            run
          };
          if (this.size && this._queue[this.size - 1].priority >= options.priority) {
            this._queue.push(element);
            return;
          }
          var index = lower_bound_1.default(this._queue, element, (a, b) => b.priority - a.priority);
          this._queue.splice(index, 0, element);
        }
        dequeue() {
          var item = this._queue.shift();
          return item === null || item === void 0 ? void 0 : item.run;
        }
        filter(options) {
          return this._queue.filter((element) => element.priority === options.priority).map((element) => element.run);
        }
        get size() {
          return this._queue.length;
        }
      }
      exports2.default = PriorityQueue;
    }, { "./lower-bound": 344 }], 346: [function(require2, module2, exports2) {
      var pFinally = require2("p-finally");
      class TimeoutError extends Error {
        constructor(message) {
          super(message);
          this.name = "TimeoutError";
        }
      }
      var pTimeout = (promise, milliseconds, fallback) => new Promise((resolve, reject) => {
        if (typeof milliseconds !== "number" || milliseconds < 0) {
          throw new TypeError("Expected `milliseconds` to be a positive number");
        }
        if (milliseconds === Infinity) {
          resolve(promise);
          return;
        }
        var timer = setTimeout(() => {
          if (typeof fallback === "function") {
            try {
              resolve(fallback());
            } catch (error) {
              reject(error);
            }
            return;
          }
          var message = typeof fallback === "string" ? fallback : "Promise timed out after ".concat(milliseconds, " milliseconds");
          var timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
          if (typeof promise.cancel === "function") {
            promise.cancel();
          }
          reject(timeoutError);
        }, milliseconds);
        pFinally(
          promise.then(resolve, reject),
          () => {
            clearTimeout(timer);
          }
        );
      });
      module2.exports = pTimeout;
      module2.exports.default = pTimeout;
      module2.exports.TimeoutError = TimeoutError;
    }, { "p-finally": 342 }], 347: [function(require2, module2, exports2) {
      module2.exports = {
        "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
        "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
        "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
        "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
        "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
        "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
        "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
        "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
        "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
        "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
        "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
        "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
      };
    }, {}], 348: [function(require2, module2, exports2) {
      var asn1 = require2("asn1.js");
      exports2.certificate = require2("./certificate");
      var RSAPrivateKey = asn1.define("RSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
      });
      exports2.RSAPrivateKey = RSAPrivateKey;
      var RSAPublicKey = asn1.define("RSAPublicKey", function() {
        this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
      });
      exports2.RSAPublicKey = RSAPublicKey;
      var PublicKey = asn1.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
      });
      exports2.PublicKey = PublicKey;
      var AlgorithmIdentifier = asn1.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
      });
      var PrivateKeyInfo = asn1.define("PrivateKeyInfo", function() {
        this.seq().obj(this.key("version").int(), this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPrivateKey").octstr());
      });
      exports2.PrivateKey = PrivateKeyInfo;
      var EncryptedPrivateKeyInfo = asn1.define("EncryptedPrivateKeyInfo", function() {
        this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
      });
      exports2.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
      var DSAPrivateKey = asn1.define("DSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
      });
      exports2.DSAPrivateKey = DSAPrivateKey;
      exports2.DSAparam = asn1.define("DSAparam", function() {
        this.int();
      });
      var ECPrivateKey = asn1.define("ECPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(ECParameters), this.key("publicKey").optional().explicit(1).bitstr());
      });
      exports2.ECPrivateKey = ECPrivateKey;
      var ECParameters = asn1.define("ECParameters", function() {
        this.choice({
          namedCurve: this.objid()
        });
      });
      exports2.signature = asn1.define("signature", function() {
        this.seq().obj(this.key("r").int(), this.key("s").int());
      });
    }, { "./certificate": 349, "asn1.js": 21 }], 349: [function(require2, module2, exports2) {
      var asn = require2("asn1.js");
      var Time = asn.define("Time", function() {
        this.choice({
          utcTime: this.utctime(),
          generalTime: this.gentime()
        });
      });
      var AttributeTypeValue = asn.define("AttributeTypeValue", function() {
        this.seq().obj(this.key("type").objid(), this.key("value").any());
      });
      var AlgorithmIdentifier = asn.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
      });
      var SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
      });
      var RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
        this.setof(AttributeTypeValue);
      });
      var RDNSequence = asn.define("RDNSequence", function() {
        this.seqof(RelativeDistinguishedName);
      });
      var Name = asn.define("Name", function() {
        this.choice({
          rdnSequence: this.use(RDNSequence)
        });
      });
      var Validity = asn.define("Validity", function() {
        this.seq().obj(this.key("notBefore").use(Time), this.key("notAfter").use(Time));
      });
      var Extension = asn.define("Extension", function() {
        this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
      });
      var TBSCertificate = asn.define("TBSCertificate", function() {
        this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(AlgorithmIdentifier), this.key("issuer").use(Name), this.key("validity").use(Validity), this.key("subject").use(Name), this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(Extension).optional());
      });
      var X509Certificate = asn.define("X509Certificate", function() {
        this.seq().obj(this.key("tbsCertificate").use(TBSCertificate), this.key("signatureAlgorithm").use(AlgorithmIdentifier), this.key("signatureValue").bitstr());
      });
      module2.exports = X509Certificate;
    }, { "asn1.js": 21 }], 350: [function(require2, module2, exports2) {
      var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
      var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
      var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
      var evp = require2("evp_bytestokey");
      var ciphers = require2("browserify-aes");
      var Buffer = require2("safe-buffer").Buffer;
      module2.exports = function(okey, password) {
        var key = okey.toString();
        var match = key.match(findProc);
        var decrypted;
        if (!match) {
          var match2 = key.match(fullRegex);
          decrypted = Buffer.from(match2[2].replace(/[\r\n]/g, ""), "base64");
        } else {
          var suite = "aes" + match[1];
          var iv = Buffer.from(match[2], "hex");
          var cipherText = Buffer.from(match[3].replace(/[\r\n]/g, ""), "base64");
          var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
          var out = [];
          var cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
          out.push(cipher.update(cipherText));
          out.push(cipher.final());
          decrypted = Buffer.concat(out);
        }
        var tag = key.match(startRegex)[1];
        return {
          tag,
          data: decrypted
        };
      };
    }, { "browserify-aes": 56, "evp_bytestokey": 194, "safe-buffer": 417 }], 351: [function(require2, module2, exports2) {
      var asn1 = require2("./asn1");
      var aesid = require2("./aesid.json");
      var fixProc = require2("./fixProc");
      var ciphers = require2("browserify-aes");
      var compat = require2("pbkdf2");
      var Buffer = require2("safe-buffer").Buffer;
      module2.exports = parseKeys;
      function parseKeys(buffer) {
        var password;
        if (typeof buffer === "object" && !Buffer.isBuffer(buffer)) {
          password = buffer.passphrase;
          buffer = buffer.key;
        }
        if (typeof buffer === "string") {
          buffer = Buffer.from(buffer);
        }
        var stripped = fixProc(buffer, password);
        var type = stripped.tag;
        var data = stripped.data;
        var subtype, ndata;
        switch (type) {
          case "CERTIFICATE":
            ndata = asn1.certificate.decode(data, "der").tbsCertificate.subjectPublicKeyInfo;
          case "PUBLIC KEY":
            if (!ndata) {
              ndata = asn1.PublicKey.decode(data, "der");
            }
            subtype = ndata.algorithm.algorithm.join(".");
            switch (subtype) {
              case "1.2.840.113549.1.1.1":
                return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
              case "1.2.840.10045.2.1":
                ndata.subjectPrivateKey = ndata.subjectPublicKey;
                return {
                  type: "ec",
                  data: ndata
                };
              case "1.2.840.10040.4.1":
                ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, "der");
                return {
                  type: "dsa",
                  data: ndata.algorithm.params
                };
              default:
                throw new Error("unknown key id " + subtype);
            }
          case "ENCRYPTED PRIVATE KEY":
            data = asn1.EncryptedPrivateKey.decode(data, "der");
            data = decrypt(data, password);
          case "PRIVATE KEY":
            ndata = asn1.PrivateKey.decode(data, "der");
            subtype = ndata.algorithm.algorithm.join(".");
            switch (subtype) {
              case "1.2.840.113549.1.1.1":
                return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
              case "1.2.840.10045.2.1":
                return {
                  curve: ndata.algorithm.curve,
                  privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey
                };
              case "1.2.840.10040.4.1":
                ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, "der");
                return {
                  type: "dsa",
                  params: ndata.algorithm.params
                };
              default:
                throw new Error("unknown key id " + subtype);
            }
          case "RSA PUBLIC KEY":
            return asn1.RSAPublicKey.decode(data, "der");
          case "RSA PRIVATE KEY":
            return asn1.RSAPrivateKey.decode(data, "der");
          case "DSA PRIVATE KEY":
            return {
              type: "dsa",
              params: asn1.DSAPrivateKey.decode(data, "der")
            };
          case "EC PRIVATE KEY":
            data = asn1.ECPrivateKey.decode(data, "der");
            return {
              curve: data.parameters.value,
              privateKey: data.privateKey
            };
          default:
            throw new Error("unknown key type " + type);
        }
      }
      parseKeys.signature = asn1.signature;
      function decrypt(data, password) {
        var salt = data.algorithm.decrypt.kde.kdeparams.salt;
        var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
        var algo = aesid[data.algorithm.decrypt.cipher.algo.join(".")];
        var iv = data.algorithm.decrypt.cipher.iv;
        var cipherText = data.subjectPrivateKey;
        var keylen = parseInt(algo.split("-")[1], 10) / 8;
        var key = compat.pbkdf2Sync(password, salt, iters, keylen, "sha1");
        var cipher = ciphers.createDecipheriv(algo, key, iv);
        var out = [];
        out.push(cipher.update(cipherText));
        out.push(cipher.final());
        return Buffer.concat(out);
      }
    }, { "./aesid.json": 347, "./asn1": 348, "./fixProc": 350, "browserify-aes": 56, "pbkdf2": 353, "safe-buffer": 417 }], 352: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          function normalizeArray(parts, allowAboveRoot) {
            var up = 0;
            for (var i = parts.length - 1; i >= 0; i--) {
              var last = parts[i];
              if (last === ".") {
                parts.splice(i, 1);
              } else if (last === "..") {
                parts.splice(i, 1);
                up++;
              } else if (up) {
                parts.splice(i, 1);
                up--;
              }
            }
            if (allowAboveRoot) {
              for (; up--; up) {
                parts.unshift("..");
              }
            }
            return parts;
          }
          exports2.resolve = function() {
            var resolvedPath = "", resolvedAbsolute = false;
            for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
              var path = i >= 0 ? arguments[i] : process.cwd();
              if (typeof path !== "string") {
                throw new TypeError("Arguments to path.resolve must be strings");
              } else if (!path) {
                continue;
              }
              resolvedPath = path + "/" + resolvedPath;
              resolvedAbsolute = path.charAt(0) === "/";
            }
            resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p) {
              return !!p;
            }), !resolvedAbsolute).join("/");
            return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
          };
          exports2.normalize = function(path) {
            var isAbsolute = exports2.isAbsolute(path), trailingSlash = substr(path, -1) === "/";
            path = normalizeArray(filter(path.split("/"), function(p) {
              return !!p;
            }), !isAbsolute).join("/");
            if (!path && !isAbsolute) {
              path = ".";
            }
            if (path && trailingSlash) {
              path += "/";
            }
            return (isAbsolute ? "/" : "") + path;
          };
          exports2.isAbsolute = function(path) {
            return path.charAt(0) === "/";
          };
          exports2.join = function() {
            var paths = Array.prototype.slice.call(arguments, 0);
            return exports2.normalize(filter(paths, function(p, index) {
              if (typeof p !== "string") {
                throw new TypeError("Arguments to path.join must be strings");
              }
              return p;
            }).join("/"));
          };
          exports2.relative = function(from, to) {
            from = exports2.resolve(from).substr(1);
            to = exports2.resolve(to).substr(1);
            function trim(arr) {
              var start = 0;
              for (; start < arr.length; start++) {
                if (arr[start] !== "")
                  break;
              }
              var end = arr.length - 1;
              for (; end >= 0; end--) {
                if (arr[end] !== "")
                  break;
              }
              if (start > end)
                return [];
              return arr.slice(start, end - start + 1);
            }
            var fromParts = trim(from.split("/"));
            var toParts = trim(to.split("/"));
            var length = Math.min(fromParts.length, toParts.length);
            var samePartsLength = length;
            for (var i = 0; i < length; i++) {
              if (fromParts[i] !== toParts[i]) {
                samePartsLength = i;
                break;
              }
            }
            var outputParts = [];
            for (var i = samePartsLength; i < fromParts.length; i++) {
              outputParts.push("..");
            }
            outputParts = outputParts.concat(toParts.slice(samePartsLength));
            return outputParts.join("/");
          };
          exports2.sep = "/";
          exports2.delimiter = ":";
          exports2.dirname = function(path) {
            if (typeof path !== "string")
              path = path + "";
            if (path.length === 0)
              return ".";
            var code = path.charCodeAt(0);
            var hasRoot = code === 47;
            var end = -1;
            var matchedSlash = true;
            for (var i = path.length - 1; i >= 1; --i) {
              code = path.charCodeAt(i);
              if (code === 47) {
                if (!matchedSlash) {
                  end = i;
                  break;
                }
              } else {
                matchedSlash = false;
              }
            }
            if (end === -1)
              return hasRoot ? "/" : ".";
            if (hasRoot && end === 1) {
              return "/";
            }
            return path.slice(0, end);
          };
          function basename(path) {
            if (typeof path !== "string")
              path = path + "";
            var start = 0;
            var end = -1;
            var matchedSlash = true;
            var i;
            for (i = path.length - 1; i >= 0; --i) {
              if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
              }
            }
            if (end === -1)
              return "";
            return path.slice(start, end);
          }
          exports2.basename = function(path, ext) {
            var f = basename(path);
            if (ext && f.substr(-1 * ext.length) === ext) {
              f = f.substr(0, f.length - ext.length);
            }
            return f;
          };
          exports2.extname = function(path) {
            if (typeof path !== "string")
              path = path + "";
            var startDot = -1;
            var startPart = 0;
            var end = -1;
            var matchedSlash = true;
            var preDotState = 0;
            for (var i = path.length - 1; i >= 0; --i) {
              var code = path.charCodeAt(i);
              if (code === 47) {
                if (!matchedSlash) {
                  startPart = i + 1;
                  break;
                }
                continue;
              }
              if (end === -1) {
                matchedSlash = false;
                end = i + 1;
              }
              if (code === 46) {
                if (startDot === -1)
                  startDot = i;
                else if (preDotState !== 1)
                  preDotState = 1;
              } else if (startDot !== -1) {
                preDotState = -1;
              }
            }
            if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
              return "";
            }
            return path.slice(startDot, end);
          };
          function filter(xs, f) {
            if (xs.filter)
              return xs.filter(f);
            var res = [];
            for (var i = 0; i < xs.length; i++) {
              if (f(xs[i], i, xs))
                res.push(xs[i]);
            }
            return res;
          }
          var substr = "ab".substr(-1) === "b" ? function(str, start, len) {
            return str.substr(start, len);
          } : function(str, start, len) {
            if (start < 0)
              start = str.length + start;
            return str.substr(start, len);
          };
        }).call(this);
      }).call(this, require2("_process"));
    }, { "_process": 361 }], 353: [function(require2, module2, exports2) {
      exports2.pbkdf2 = require2("./lib/async");
      exports2.pbkdf2Sync = require2("./lib/sync");
    }, { "./lib/async": 354, "./lib/sync": 357 }], 354: [function(require2, module2, exports2) {
      (function(process, global) {
        (function() {
          var Buffer = require2("safe-buffer").Buffer;
          var checkParameters = require2("./precondition");
          var defaultEncoding = require2("./default-encoding");
          var sync = require2("./sync");
          var toBuffer = require2("./to-buffer");
          var ZERO_BUF;
          var subtle = global.crypto && global.crypto.subtle;
          var toBrowser = {
            sha: "SHA-1",
            "sha-1": "SHA-1",
            sha1: "SHA-1",
            sha256: "SHA-256",
            "sha-256": "SHA-256",
            sha384: "SHA-384",
            "sha-384": "SHA-384",
            "sha-512": "SHA-512",
            sha512: "SHA-512"
          };
          var checks = [];
          function checkNative(algo) {
            if (global.process && !global.process.browser) {
              return Promise.resolve(false);
            }
            if (!subtle || !subtle.importKey || !subtle.deriveBits) {
              return Promise.resolve(false);
            }
            if (checks[algo] !== void 0) {
              return checks[algo];
            }
            ZERO_BUF = ZERO_BUF || Buffer.alloc(8);
            var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(function() {
              return true;
            }).catch(function() {
              return false;
            });
            checks[algo] = prom;
            return prom;
          }
          function browserPbkdf2(password, salt, iterations, length, algo) {
            return subtle.importKey("raw", password, {
              name: "PBKDF2"
            }, false, ["deriveBits"]).then(function(key) {
              return subtle.deriveBits({
                name: "PBKDF2",
                salt,
                iterations,
                hash: {
                  name: algo
                }
              }, key, length << 3);
            }).then(function(res) {
              return Buffer.from(res);
            });
          }
          function resolvePromise(promise, callback) {
            promise.then(function(out) {
              process.nextTick(function() {
                callback(null, out);
              });
            }, function(e) {
              process.nextTick(function() {
                callback(e);
              });
            });
          }
          module2.exports = function(password, salt, iterations, keylen, digest, callback) {
            if (typeof digest === "function") {
              callback = digest;
              digest = void 0;
            }
            digest = digest || "sha1";
            var algo = toBrowser[digest.toLowerCase()];
            if (!algo || typeof global.Promise !== "function") {
              return process.nextTick(function() {
                var out;
                try {
                  out = sync(password, salt, iterations, keylen, digest);
                } catch (e) {
                  return callback(e);
                }
                callback(null, out);
              });
            }
            checkParameters(iterations, keylen);
            password = toBuffer(password, defaultEncoding, "Password");
            salt = toBuffer(salt, defaultEncoding, "Salt");
            if (typeof callback !== "function")
              throw new Error("No callback provided to pbkdf2");
            resolvePromise(checkNative(algo).then(function(resp) {
              if (resp)
                return browserPbkdf2(password, salt, iterations, keylen, algo);
              return sync(password, salt, iterations, keylen, digest);
            }), callback);
          };
        }).call(this);
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "./default-encoding": 355, "./precondition": 356, "./sync": 357, "./to-buffer": 358, "_process": 361, "safe-buffer": 417 }], 355: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          var defaultEncoding;
          if (process.browser) {
            defaultEncoding = "utf-8";
          } else if (process.version) {
            var pVersionMajor = parseInt(process.version.split(".")[0].slice(1), 10);
            defaultEncoding = pVersionMajor >= 6 ? "utf-8" : "binary";
          } else {
            defaultEncoding = "utf-8";
          }
          module2.exports = defaultEncoding;
        }).call(this);
      }).call(this, require2("_process"));
    }, { "_process": 361 }], 356: [function(require2, module2, exports2) {
      var MAX_ALLOC = Math.pow(2, 30) - 1;
      module2.exports = function(iterations, keylen) {
        if (typeof iterations !== "number") {
          throw new TypeError("Iterations not a number");
        }
        if (iterations < 0) {
          throw new TypeError("Bad iterations");
        }
        if (typeof keylen !== "number") {
          throw new TypeError("Key length not a number");
        }
        if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) {
          throw new TypeError("Bad key length");
        }
      };
    }, {}], 357: [function(require2, module2, exports2) {
      var md5 = require2("create-hash/md5");
      var RIPEMD160 = require2("ripemd160");
      var sha = require2("sha.js");
      var Buffer = require2("safe-buffer").Buffer;
      var checkParameters = require2("./precondition");
      var defaultEncoding = require2("./default-encoding");
      var toBuffer = require2("./to-buffer");
      var ZEROS = Buffer.alloc(128);
      var sizes = {
        md5: 16,
        sha1: 20,
        sha224: 28,
        sha256: 32,
        sha384: 48,
        sha512: 64,
        rmd160: 20,
        ripemd160: 20
      };
      function Hmac(alg, key, saltLen) {
        var hash = getDigest(alg);
        var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
        if (key.length > blocksize) {
          key = hash(key);
        } else if (key.length < blocksize) {
          key = Buffer.concat([key, ZEROS], blocksize);
        }
        var ipad = Buffer.allocUnsafe(blocksize + sizes[alg]);
        var opad = Buffer.allocUnsafe(blocksize + sizes[alg]);
        for (var i = 0; i < blocksize; i++) {
          ipad[i] = key[i] ^ 54;
          opad[i] = key[i] ^ 92;
        }
        var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4);
        ipad.copy(ipad1, 0, 0, blocksize);
        this.ipad1 = ipad1;
        this.ipad2 = ipad;
        this.opad = opad;
        this.alg = alg;
        this.blocksize = blocksize;
        this.hash = hash;
        this.size = sizes[alg];
      }
      Hmac.prototype.run = function(data, ipad) {
        data.copy(ipad, this.blocksize);
        var h = this.hash(ipad);
        h.copy(this.opad, this.blocksize);
        return this.hash(this.opad);
      };
      function getDigest(alg) {
        function shaFunc(data) {
          return sha(alg).update(data).digest();
        }
        function rmd160Func(data) {
          return new RIPEMD160().update(data).digest();
        }
        if (alg === "rmd160" || alg === "ripemd160")
          return rmd160Func;
        if (alg === "md5")
          return md5;
        return shaFunc;
      }
      function pbkdf2(password, salt, iterations, keylen, digest) {
        checkParameters(iterations, keylen);
        password = toBuffer(password, defaultEncoding, "Password");
        salt = toBuffer(salt, defaultEncoding, "Salt");
        digest = digest || "sha1";
        var hmac = new Hmac(digest, password, salt.length);
        var DK = Buffer.allocUnsafe(keylen);
        var block1 = Buffer.allocUnsafe(salt.length + 4);
        salt.copy(block1, 0, 0, salt.length);
        var destPos = 0;
        var hLen = sizes[digest];
        var l = Math.ceil(keylen / hLen);
        for (var i = 1; i <= l; i++) {
          block1.writeUInt32BE(i, salt.length);
          var T = hmac.run(block1, hmac.ipad1);
          var U = T;
          for (var j = 1; j < iterations; j++) {
            U = hmac.run(U, hmac.ipad2);
            for (var k = 0; k < hLen; k++) {
              T[k] ^= U[k];
            }
          }
          T.copy(DK, destPos);
          destPos += hLen;
        }
        return DK;
      }
      module2.exports = pbkdf2;
    }, { "./default-encoding": 355, "./precondition": 356, "./to-buffer": 358, "create-hash/md5": 114, "ripemd160": 416, "safe-buffer": 417, "sha.js": 420 }], 358: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      module2.exports = function(thing, encoding, name) {
        if (Buffer.isBuffer(thing)) {
          return thing;
        } else if (typeof thing === "string") {
          return Buffer.from(thing, encoding);
        } else if (ArrayBuffer.isView(thing)) {
          return Buffer.from(thing.buffer);
        } else {
          throw new TypeError(name + " must be a string, a Buffer, a typed array or a DataView");
        }
      };
    }, { "safe-buffer": 417 }], 359: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          module2.exports = function prettyHash(buf) {
            if (Buffer.isBuffer(buf))
              buf = buf.toString("hex");
            if (typeof buf === "string" && buf.length > 8) {
              return buf.slice(0, 6) + ".." + buf.slice(-2);
            }
            return buf;
          };
        }).call(this);
      }).call(this, { "isBuffer": require2("../is-buffer/index.js") });
    }, { "../is-buffer/index.js": 259 }], 360: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
            module2.exports = {
              nextTick
            };
          } else {
            module2.exports = process;
          }
          function nextTick(fn, arg1, arg2, arg3) {
            if (typeof fn !== "function") {
              throw new TypeError('"callback" argument must be a function');
            }
            var len = arguments.length;
            var args, i;
            switch (len) {
              case 0:
              case 1:
                return process.nextTick(fn);
              case 2:
                return process.nextTick(function afterTickOne() {
                  fn.call(null, arg1);
                });
              case 3:
                return process.nextTick(function afterTickTwo() {
                  fn.call(null, arg1, arg2);
                });
              case 4:
                return process.nextTick(function afterTickThree() {
                  fn.call(null, arg1, arg2, arg3);
                });
              default:
                args = new Array(len - 1);
                i = 0;
                while (i < args.length) {
                  args[i++] = arguments[i];
                }
                return process.nextTick(function afterTick() {
                  fn.apply(null, args);
                });
            }
          }
        }).call(this);
      }).call(this, require2("_process"));
    }, { "_process": 361 }], 361: [function(require2, module2, exports2) {
      var process = module2.exports = {};
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process.title = "browser";
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = "";
      process.versions = {};
      function noop() {
      }
      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;
      process.listeners = function(name) {
        return [];
      };
      process.binding = function(name) {
        throw new Error("process.binding is not supported");
      };
      process.cwd = function() {
        return "/";
      };
      process.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process.umask = function() {
        return 0;
      };
    }, {}], 362: [function(require2, module2, exports2) {
      (function(global) {
        (function() {
          module2.exports = Deferred;
          Deferred.defer = defer;
          function Deferred(Promise2) {
            if (Promise2 == null)
              Promise2 = global.Promise;
            if (this instanceof Deferred)
              return defer(Promise2, this);
            else
              return defer(Promise2, Object.create(Deferred.prototype));
          }
          function defer(Promise2, deferred) {
            deferred.promise = new Promise2(function(resolve, reject) {
              deferred.resolve = resolve;
              deferred.reject = reject;
            });
            return deferred;
          }
        }).call(this);
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 363: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var varint = require2("varint");
          var svarint = require2("signed-varint");
          exports2.make = encoder;
          exports2.name = function(enc) {
            var keys = Object.keys(exports2);
            for (var i = 0; i < keys.length; i++) {
              if (exports2[keys[i]] === enc)
                return keys[i];
            }
            return null;
          };
          exports2.skip = function(type, buffer, offset) {
            switch (type) {
              case 0:
                varint.decode(buffer, offset);
                return offset + varint.decode.bytes;
              case 1:
                return offset + 8;
              case 2:
                var len = varint.decode(buffer, offset);
                return offset + varint.decode.bytes + len;
              case 3:
              case 4:
                throw new Error("Groups are not supported");
              case 5:
                return offset + 4;
            }
            throw new Error("Unknown wire type: " + type);
          };
          exports2.bytes = encoder(2, function encode(val, buffer, offset) {
            var oldOffset = offset;
            var len = bufferLength(val);
            varint.encode(len, buffer, offset);
            offset += varint.encode.bytes;
            if (Buffer.isBuffer(val))
              val.copy(buffer, offset);
            else
              buffer.write(val, offset, len);
            offset += len;
            encode.bytes = offset - oldOffset;
            return buffer;
          }, function decode(buffer, offset) {
            var oldOffset = offset;
            var len = varint.decode(buffer, offset);
            offset += varint.decode.bytes;
            var val = buffer.slice(offset, offset + len);
            offset += val.length;
            decode.bytes = offset - oldOffset;
            return val;
          }, function encodingLength(val) {
            var len = bufferLength(val);
            return varint.encodingLength(len) + len;
          });
          exports2.string = encoder(2, function encode(val, buffer, offset) {
            var oldOffset = offset;
            var len = Buffer.byteLength(val);
            varint.encode(len, buffer, offset, "utf-8");
            offset += varint.encode.bytes;
            buffer.write(val, offset, len);
            offset += len;
            encode.bytes = offset - oldOffset;
            return buffer;
          }, function decode(buffer, offset) {
            var oldOffset = offset;
            var len = varint.decode(buffer, offset);
            offset += varint.decode.bytes;
            var val = buffer.toString("utf-8", offset, offset + len);
            offset += len;
            decode.bytes = offset - oldOffset;
            return val;
          }, function encodingLength(val) {
            var len = Buffer.byteLength(val);
            return varint.encodingLength(len) + len;
          });
          exports2.bool = encoder(0, function encode(val, buffer, offset) {
            buffer[offset] = val ? 1 : 0;
            encode.bytes = 1;
            return buffer;
          }, function decode(buffer, offset) {
            var bool = buffer[offset] > 0;
            decode.bytes = 1;
            return bool;
          }, function encodingLength() {
            return 1;
          });
          exports2.int32 = encoder(0, function encode(val, buffer, offset) {
            varint.encode(val < 0 ? val + 4294967296 : val, buffer, offset);
            encode.bytes = varint.encode.bytes;
            return buffer;
          }, function decode(buffer, offset) {
            var val = varint.decode(buffer, offset);
            decode.bytes = varint.decode.bytes;
            return val > 2147483647 ? val - 4294967296 : val;
          }, function encodingLength(val) {
            return varint.encodingLength(val < 0 ? val + 4294967296 : val);
          });
          exports2.int64 = encoder(0, function encode(val, buffer, offset) {
            if (val < 0) {
              var last = offset + 9;
              varint.encode(val * -1, buffer, offset);
              offset += varint.encode.bytes - 1;
              buffer[offset] = buffer[offset] | 128;
              while (offset < last - 1) {
                offset++;
                buffer[offset] = 255;
              }
              buffer[last] = 1;
              encode.bytes = 10;
            } else {
              varint.encode(val, buffer, offset);
              encode.bytes = varint.encode.bytes;
            }
            return buffer;
          }, function decode(buffer, offset) {
            var val = varint.decode(buffer, offset);
            if (val >= Math.pow(2, 63)) {
              var limit = 9;
              while (buffer[offset + limit - 1] === 255) {
                limit--;
              }
              limit = limit || 9;
              var subset = Buffer.allocUnsafe(limit);
              buffer.copy(subset, 0, offset, offset + limit);
              subset[limit - 1] = subset[limit - 1] & 127;
              val = -1 * varint.decode(subset, 0);
              decode.bytes = 10;
            } else {
              decode.bytes = varint.decode.bytes;
            }
            return val;
          }, function encodingLength(val) {
            return val < 0 ? 10 : varint.encodingLength(val);
          });
          exports2.sint32 = exports2.sint64 = encoder(0, svarint.encode, svarint.decode, svarint.encodingLength);
          exports2.uint32 = exports2.uint64 = exports2.enum = exports2.varint = encoder(0, varint.encode, varint.decode, varint.encodingLength);
          exports2.fixed64 = exports2.sfixed64 = encoder(1, function encode(val, buffer, offset) {
            val.copy(buffer, offset);
            encode.bytes = 8;
            return buffer;
          }, function decode(buffer, offset) {
            var val = buffer.slice(offset, offset + 8);
            decode.bytes = 8;
            return val;
          }, function encodingLength() {
            return 8;
          });
          exports2.double = encoder(1, function encode(val, buffer, offset) {
            buffer.writeDoubleLE(val, offset);
            encode.bytes = 8;
            return buffer;
          }, function decode(buffer, offset) {
            var val = buffer.readDoubleLE(offset);
            decode.bytes = 8;
            return val;
          }, function encodingLength() {
            return 8;
          });
          exports2.fixed32 = encoder(5, function encode(val, buffer, offset) {
            buffer.writeUInt32LE(val, offset);
            encode.bytes = 4;
            return buffer;
          }, function decode(buffer, offset) {
            var val = buffer.readUInt32LE(offset);
            decode.bytes = 4;
            return val;
          }, function encodingLength() {
            return 4;
          });
          exports2.sfixed32 = encoder(5, function encode(val, buffer, offset) {
            buffer.writeInt32LE(val, offset);
            encode.bytes = 4;
            return buffer;
          }, function decode(buffer, offset) {
            var val = buffer.readInt32LE(offset);
            decode.bytes = 4;
            return val;
          }, function encodingLength() {
            return 4;
          });
          exports2.float = encoder(5, function encode(val, buffer, offset) {
            buffer.writeFloatLE(val, offset);
            encode.bytes = 4;
            return buffer;
          }, function decode(buffer, offset) {
            var val = buffer.readFloatLE(offset);
            decode.bytes = 4;
            return val;
          }, function encodingLength() {
            return 4;
          });
          function encoder(type, encode, decode, encodingLength) {
            encode.bytes = decode.bytes = 0;
            return {
              type,
              encode,
              decode,
              encodingLength
            };
          }
          function bufferLength(val) {
            return Buffer.isBuffer(val) ? val.length : Buffer.byteLength(val);
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82, "signed-varint": 435, "varint": 366 }], 364: [function(require2, module2, exports2) {
      module2.exports = read;
      var MSB = 128, REST = 127;
      function read(buf, offset) {
        var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
        do {
          if (counter >= l) {
            read.bytes = 0;
            throw new RangeError("Could not decode varint");
          }
          b = buf[counter++];
          res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
          shift += 7;
        } while (b >= MSB);
        read.bytes = counter - offset;
        return res;
      }
    }, {}], 365: [function(require2, module2, exports2) {
      arguments[4][42][0].apply(exports2, arguments);
    }, { "dup": 42 }], 366: [function(require2, module2, exports2) {
      arguments[4][43][0].apply(exports2, arguments);
    }, { "./decode.js": 364, "./encode.js": 365, "./length.js": 367, "dup": 43 }], 367: [function(require2, module2, exports2) {
      arguments[4][44][0].apply(exports2, arguments);
    }, { "dup": 44 }], 368: [function(require2, module2, exports2) {
      /*!
        * prr
        * (c) 2013 Rod Vagg <rod@vagg.org>
        * https://github.com/rvagg/prr
        * License: MIT
        */
      (function(name, context, definition) {
        if (typeof module2 != "undefined" && module2.exports)
          module2.exports = definition();
        else
          context[name] = definition();
      })("prr", void 0, function() {
        var setProperty = typeof Object.defineProperty == "function" ? function(obj, key, options) {
          Object.defineProperty(obj, key, options);
          return obj;
        } : function(obj, key, options) {
          obj[key] = options.value;
          return obj;
        }, makeOptions = function makeOptions2(value, options) {
          var oo = typeof options == "object", os = !oo && typeof options == "string", op = function op2(p) {
            return oo ? !!options[p] : os ? options.indexOf(p[0]) > -1 : false;
          };
          return {
            enumerable: op("enumerable"),
            configurable: op("configurable"),
            writable: op("writable"),
            value
          };
        }, prr = function prr2(obj, key, value, options) {
          var k;
          options = makeOptions(value, options);
          if (typeof key == "object") {
            for (k in key) {
              if (Object.hasOwnProperty.call(key, k)) {
                options.value = key[k];
                setProperty(obj, k, options);
              }
            }
            return obj;
          }
          return setProperty(obj, key, options);
        };
        return prr;
      });
    }, {}], 369: [function(require2, module2, exports2) {
      exports2.publicEncrypt = require2("./publicEncrypt");
      exports2.privateDecrypt = require2("./privateDecrypt");
      exports2.privateEncrypt = function privateEncrypt(key, buf) {
        return exports2.publicEncrypt(key, buf, true);
      };
      exports2.publicDecrypt = function publicDecrypt(key, buf) {
        return exports2.privateDecrypt(key, buf, true);
      };
    }, { "./privateDecrypt": 372, "./publicEncrypt": 373 }], 370: [function(require2, module2, exports2) {
      var createHash = require2("create-hash");
      var Buffer = require2("safe-buffer").Buffer;
      module2.exports = function(seed, len) {
        var t = Buffer.alloc(0);
        var i = 0;
        var c;
        while (t.length < len) {
          c = i2ops(i++);
          t = Buffer.concat([t, createHash("sha1").update(seed).update(c).digest()]);
        }
        return t.slice(0, len);
      };
      function i2ops(c) {
        var out = Buffer.allocUnsafe(4);
        out.writeUInt32BE(c, 0);
        return out;
      }
    }, { "create-hash": 113, "safe-buffer": 417 }], 371: [function(require2, module2, exports2) {
      arguments[4][35][0].apply(exports2, arguments);
    }, { "buffer": 53, "dup": 35 }], 372: [function(require2, module2, exports2) {
      var parseKeys = require2("parse-asn1");
      var mgf = require2("./mgf");
      var xor = require2("./xor");
      var BN = require2("bn.js");
      var crt = require2("browserify-rsa");
      var createHash = require2("create-hash");
      var withPublic = require2("./withPublic");
      var Buffer = require2("safe-buffer").Buffer;
      module2.exports = function privateDecrypt(privateKey, enc, reverse) {
        var padding;
        if (privateKey.padding) {
          padding = privateKey.padding;
        } else if (reverse) {
          padding = 1;
        } else {
          padding = 4;
        }
        var key = parseKeys(privateKey);
        var k = key.modulus.byteLength();
        if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
          throw new Error("decryption error");
        }
        var msg;
        if (reverse) {
          msg = withPublic(new BN(enc), key);
        } else {
          msg = crt(enc, key);
        }
        var zBuffer = Buffer.alloc(k - msg.length);
        msg = Buffer.concat([zBuffer, msg], k);
        if (padding === 4) {
          return oaep(key, msg);
        } else if (padding === 1) {
          return pkcs1(key, msg, reverse);
        } else if (padding === 3) {
          return msg;
        } else {
          throw new Error("unknown padding");
        }
      };
      function oaep(key, msg) {
        var k = key.modulus.byteLength();
        var iHash = createHash("sha1").update(Buffer.alloc(0)).digest();
        var hLen = iHash.length;
        if (msg[0] !== 0) {
          throw new Error("decryption error");
        }
        var maskedSeed = msg.slice(1, hLen + 1);
        var maskedDb = msg.slice(hLen + 1);
        var seed = xor(maskedSeed, mgf(maskedDb, hLen));
        var db = xor(maskedDb, mgf(seed, k - hLen - 1));
        if (compare(iHash, db.slice(0, hLen))) {
          throw new Error("decryption error");
        }
        var i = hLen;
        while (db[i] === 0) {
          i++;
        }
        if (db[i++] !== 1) {
          throw new Error("decryption error");
        }
        return db.slice(i);
      }
      function pkcs1(key, msg, reverse) {
        var p1 = msg.slice(0, 2);
        var i = 2;
        var status = 0;
        while (msg[i++] !== 0) {
          if (i >= msg.length) {
            status++;
            break;
          }
        }
        var ps = msg.slice(2, i - 1);
        if (p1.toString("hex") !== "0002" && !reverse || p1.toString("hex") !== "0001" && reverse) {
          status++;
        }
        if (ps.length < 8) {
          status++;
        }
        if (status) {
          throw new Error("decryption error");
        }
        return msg.slice(i);
      }
      function compare(a, b) {
        a = Buffer.from(a);
        b = Buffer.from(b);
        var dif = 0;
        var len = a.length;
        if (a.length !== b.length) {
          dif++;
          len = Math.min(a.length, b.length);
        }
        var i = -1;
        while (++i < len) {
          dif += a[i] ^ b[i];
        }
        return dif;
      }
    }, { "./mgf": 370, "./withPublic": 374, "./xor": 375, "bn.js": 371, "browserify-rsa": 74, "create-hash": 113, "parse-asn1": 351, "safe-buffer": 417 }], 373: [function(require2, module2, exports2) {
      var parseKeys = require2("parse-asn1");
      var randomBytes = require2("randombytes");
      var createHash = require2("create-hash");
      var mgf = require2("./mgf");
      var xor = require2("./xor");
      var BN = require2("bn.js");
      var withPublic = require2("./withPublic");
      var crt = require2("browserify-rsa");
      var Buffer = require2("safe-buffer").Buffer;
      module2.exports = function publicEncrypt(publicKey, msg, reverse) {
        var padding;
        if (publicKey.padding) {
          padding = publicKey.padding;
        } else if (reverse) {
          padding = 1;
        } else {
          padding = 4;
        }
        var key = parseKeys(publicKey);
        var paddedMsg;
        if (padding === 4) {
          paddedMsg = oaep(key, msg);
        } else if (padding === 1) {
          paddedMsg = pkcs1(key, msg, reverse);
        } else if (padding === 3) {
          paddedMsg = new BN(msg);
          if (paddedMsg.cmp(key.modulus) >= 0) {
            throw new Error("data too long for modulus");
          }
        } else {
          throw new Error("unknown padding");
        }
        if (reverse) {
          return crt(paddedMsg, key);
        } else {
          return withPublic(paddedMsg, key);
        }
      };
      function oaep(key, msg) {
        var k = key.modulus.byteLength();
        var mLen = msg.length;
        var iHash = createHash("sha1").update(Buffer.alloc(0)).digest();
        var hLen = iHash.length;
        var hLen2 = 2 * hLen;
        if (mLen > k - hLen2 - 2) {
          throw new Error("message too long");
        }
        var ps = Buffer.alloc(k - mLen - hLen2 - 2);
        var dblen = k - hLen - 1;
        var seed = randomBytes(hLen);
        var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen));
        var maskedSeed = xor(seed, mgf(maskedDb, hLen));
        return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k));
      }
      function pkcs1(key, msg, reverse) {
        var mLen = msg.length;
        var k = key.modulus.byteLength();
        if (mLen > k - 11) {
          throw new Error("message too long");
        }
        var ps;
        if (reverse) {
          ps = Buffer.alloc(k - mLen - 3, 255);
        } else {
          ps = nonZero(k - mLen - 3);
        }
        return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k));
      }
      function nonZero(len) {
        var out = Buffer.allocUnsafe(len);
        var i = 0;
        var cache = randomBytes(len * 2);
        var cur = 0;
        var num;
        while (i < len) {
          if (cur === cache.length) {
            cache = randomBytes(len * 2);
            cur = 0;
          }
          num = cache[cur++];
          if (num) {
            out[i++] = num;
          }
        }
        return out;
      }
    }, { "./mgf": 370, "./withPublic": 374, "./xor": 375, "bn.js": 371, "browserify-rsa": 74, "create-hash": 113, "parse-asn1": 351, "randombytes": 382, "safe-buffer": 417 }], 374: [function(require2, module2, exports2) {
      var BN = require2("bn.js");
      var Buffer = require2("safe-buffer").Buffer;
      function withPublic(paddedMsg, key) {
        return Buffer.from(paddedMsg.toRed(BN.mont(key.modulus)).redPow(new BN(key.publicExponent)).fromRed().toArray());
      }
      module2.exports = withPublic;
    }, { "bn.js": 371, "safe-buffer": 417 }], 375: [function(require2, module2, exports2) {
      module2.exports = function xor(a, b) {
        var len = a.length;
        var i = -1;
        while (++i < len) {
          a[i] ^= b[i];
        }
        return a;
      };
    }, {}], 376: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          var once = require2("once");
          var eos = require2("end-of-stream");
          var fs = require2("fs");
          var noop = function noop2() {
          };
          var ancient = /^v?\.0/.test(process.version);
          var isFn = function isFn2(fn) {
            return typeof fn === "function";
          };
          var isFS = function isFS2(stream) {
            if (!ancient)
              return false;
            if (!fs)
              return false;
            return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close);
          };
          var isRequest = function isRequest2(stream) {
            return stream.setHeader && isFn(stream.abort);
          };
          var destroyer = function destroyer2(stream, reading, writing, callback) {
            callback = once(callback);
            var closed = false;
            stream.on("close", function() {
              closed = true;
            });
            eos(stream, {
              readable: reading,
              writable: writing
            }, function(err) {
              if (err)
                return callback(err);
              closed = true;
              callback();
            });
            var destroyed = false;
            return function(err) {
              if (closed)
                return;
              if (destroyed)
                return;
              destroyed = true;
              if (isFS(stream))
                return stream.close(noop);
              if (isRequest(stream))
                return stream.abort();
              if (isFn(stream.destroy))
                return stream.destroy();
              callback(err || new Error("stream was destroyed"));
            };
          };
          var call = function call2(fn) {
            fn();
          };
          var pipe = function pipe2(from, to) {
            return from.pipe(to);
          };
          var pump = function pump2() {
            var streams = Array.prototype.slice.call(arguments);
            var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
            if (Array.isArray(streams[0]))
              streams = streams[0];
            if (streams.length < 2)
              throw new Error("pump requires two streams per minimum");
            var error;
            var destroys = streams.map(function(stream, i) {
              var reading = i < streams.length - 1;
              var writing = i > 0;
              return destroyer(stream, reading, writing, function(err) {
                if (!error)
                  error = err;
                if (err)
                  destroys.forEach(call);
                if (reading)
                  return;
                destroys.forEach(call);
                callback(error);
              });
            });
            return streams.reduce(pipe);
          };
          module2.exports = pump;
        }).call(this);
      }).call(this, require2("_process"));
    }, { "_process": 361, "end-of-stream": 187, "fs": 53, "once": 339 }], 377: [function(require2, module2, exports2) {
      /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
      var promise;
      module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(globalThis) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
        throw err;
      }, 0));
    }, {}], 378: [function(require2, module2, exports2) {
      function tryStringify(o) {
        try {
          return JSON.stringify(o);
        } catch (e) {
          return '"[Circular]"';
        }
      }
      module2.exports = format;
      function format(f, args, opts) {
        var ss = opts && opts.stringify || tryStringify;
        var offset = 1;
        if (f === null) {
          f = args[0];
          offset = 0;
        }
        if (typeof f === "object" && f !== null) {
          var len = args.length + offset;
          if (len === 1)
            return f;
          var objects = new Array(len);
          objects[0] = ss(f);
          for (var index = 1; index < len; index++) {
            objects[index] = ss(args[index]);
          }
          return objects.join(" ");
        }
        var argLen = args.length;
        if (argLen === 0)
          return f;
        var x = "";
        var str = "";
        var a = 1 - offset;
        var lastPos = 0;
        var flen = f && f.length || 0;
        for (var i = 0; i < flen; ) {
          if (f.charCodeAt(i) === 37 && i + 1 < flen) {
            switch (f.charCodeAt(i + 1)) {
              case 100:
                if (a >= argLen)
                  break;
                if (lastPos < i)
                  str += f.slice(lastPos, i);
                if (args[a] == null)
                  break;
                str += Number(args[a]);
                lastPos = i = i + 2;
                break;
              case 79:
              case 111:
              case 106:
                if (a >= argLen)
                  break;
                if (lastPos < i)
                  str += f.slice(lastPos, i);
                if (args[a] === void 0)
                  break;
                var type = typeof args[a];
                if (type === "string") {
                  str += "'" + args[a] + "'";
                  lastPos = i + 2;
                  i++;
                  break;
                }
                if (type === "function") {
                  str += args[a].name || "<anonymous>";
                  lastPos = i + 2;
                  i++;
                  break;
                }
                str += ss(args[a]);
                lastPos = i + 2;
                i++;
                break;
              case 115:
                if (a >= argLen)
                  break;
                if (lastPos < i)
                  str += f.slice(lastPos, i);
                str += String(args[a]);
                lastPos = i + 2;
                i++;
                break;
              case 37:
                if (lastPos < i)
                  str += f.slice(lastPos, i);
                str += "%";
                lastPos = i + 2;
                i++;
                break;
            }
            ++a;
          }
          ++i;
        }
        if (lastPos === 0)
          str = f;
        else if (lastPos < flen) {
          str += f.slice(lastPos);
        }
        while (a < argLen) {
          x = args[a++];
          if (x === null || typeof x !== "object") {
            str += " " + String(x);
          } else {
            str += " " + ss(x);
          }
        }
        return str;
      }
    }, {}], 379: [function(require2, module2, exports2) {
      module2.exports = function() {
        throw new Error("random-access-file is not supported in the browser");
      };
    }, {}], 380: [function(require2, module2, exports2) {
      (function(process, Buffer) {
        (function() {
          var RandomAccess = require2("random-access-storage");
          var isOptions = require2("is-options");
          var inherits = require2("inherits");
          var DEFAULT_PAGE_SIZE = 1024 * 1024;
          module2.exports = RAM;
          function RAM(opts) {
            if (!(this instanceof RAM))
              return new RAM(opts);
            if (typeof opts === "number")
              opts = {
                length: opts
              };
            if (!opts)
              opts = {};
            RandomAccess.call(this);
            if (Buffer.isBuffer(opts)) {
              opts = {
                length: opts.length,
                buffer: opts
              };
            }
            if (!isOptions(opts))
              opts = {};
            this.length = opts.length || 0;
            this.pageSize = opts.length || opts.pageSize || DEFAULT_PAGE_SIZE;
            this.buffers = [];
            if (opts.buffer)
              this.buffers.push(opts.buffer);
          }
          inherits(RAM, RandomAccess);
          RAM.prototype._stat = function(req) {
            callback(req, null, {
              size: this.length
            });
          };
          RAM.prototype._write = function(req) {
            var i = Math.floor(req.offset / this.pageSize);
            var rel = req.offset - i * this.pageSize;
            var start = 0;
            var len = req.offset + req.size;
            if (len > this.length)
              this.length = len;
            while (start < req.size) {
              var page = this._page(i++, true);
              var free = this.pageSize - rel;
              var end = free < req.size - start ? start + free : req.size;
              req.data.copy(page, rel, start, end);
              start = end;
              rel = 0;
            }
            callback(req, null, null);
          };
          RAM.prototype._read = function(req) {
            var i = Math.floor(req.offset / this.pageSize);
            var rel = req.offset - i * this.pageSize;
            var start = 0;
            if (req.offset + req.size > this.length) {
              return callback(req, new Error("Could not satisfy length"), null);
            }
            var data = Buffer.alloc(req.size);
            while (start < req.size) {
              var page = this._page(i++, false);
              var avail = this.pageSize - rel;
              var wanted = req.size - start;
              var len = avail < wanted ? avail : wanted;
              if (page)
                page.copy(data, start, rel, rel + len);
              start += len;
              rel = 0;
            }
            callback(req, null, data);
          };
          RAM.prototype._del = function(req) {
            var i = Math.floor(req.offset / this.pageSize);
            var rel = req.offset - i * this.pageSize;
            var start = 0;
            if (req.offset + req.size > this.length) {
              req.size = Math.max(0, this.length - req.offset);
            }
            while (start < req.size) {
              if (rel === 0 && req.size - start >= this.pageSize) {
                this.buffers[i++] = void 0;
              }
              rel = 0;
              start += this.pageSize - rel;
            }
            if (req.offset + req.size >= this.length) {
              this.length = req.offset;
            }
            callback(req, null, null);
          };
          RAM.prototype._destroy = function(req) {
            this._buffers = [];
            this.length = 0;
            callback(req, null, null);
          };
          RAM.prototype._page = function(i, upsert) {
            var page = this.buffers[i];
            if (page || !upsert)
              return page;
            page = this.buffers[i] = Buffer.alloc(this.pageSize);
            return page;
          };
          RAM.prototype.toBuffer = function() {
            var buf = Buffer.alloc(this.length);
            for (var i = 0; i < this.buffers.length; i++) {
              if (this.buffers[i])
                this.buffers[i].copy(buf, i * this.pageSize);
            }
            return buf;
          };
          function callback(req, err, data) {
            process.nextTick(callbackNT, req, err, data);
          }
          function callbackNT(req, err, data) {
            req.callback(err, data);
          }
        }).call(this);
      }).call(this, require2("_process"), require2("buffer").Buffer);
    }, { "_process": 361, "buffer": 82, "inherits": 256, "is-options": 261, "random-access-storage": 381 }], 381: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          var events = require2("events");
          var inherits = require2("inherits");
          var NOT_READABLE = defaultImpl(new Error("Not readable"));
          var NOT_WRITABLE = defaultImpl(new Error("Not writable"));
          var NOT_DELETABLE = defaultImpl(new Error("Not deletable"));
          var NOT_STATABLE = defaultImpl(new Error("Not statable"));
          var NO_OPEN_READABLE = defaultImpl(new Error("No readonly open"));
          var READ_OP = 0;
          var WRITE_OP = 1;
          var DEL_OP = 2;
          var STAT_OP = 3;
          var OPEN_OP = 4;
          var CLOSE_OP = 5;
          var DESTROY_OP = 6;
          module2.exports = RandomAccess;
          function RandomAccess(opts) {
            if (!(this instanceof RandomAccess))
              return new RandomAccess(opts);
            events.EventEmitter.call(this);
            this._queued = [];
            this._pending = 0;
            this._needsOpen = true;
            this.opened = false;
            this.closed = false;
            this.destroyed = false;
            if (opts) {
              if (opts.openReadonly)
                this._openReadonly = opts.openReadonly;
              if (opts.open)
                this._open = opts.open;
              if (opts.read)
                this._read = opts.read;
              if (opts.write)
                this._write = opts.write;
              if (opts.del)
                this._del = opts.del;
              if (opts.stat)
                this._stat = opts.stat;
              if (opts.close)
                this._close = opts.close;
              if (opts.destroy)
                this._destroy = opts.destroy;
            }
            this.preferReadonly = this._openReadonly !== NO_OPEN_READABLE;
            this.readable = this._read !== NOT_READABLE;
            this.writable = this._write !== NOT_WRITABLE;
            this.deletable = this._del !== NOT_DELETABLE;
            this.statable = this._stat !== NOT_STATABLE;
          }
          inherits(RandomAccess, events.EventEmitter);
          RandomAccess.prototype.read = function(offset, size, cb) {
            this.run(new Request(this, READ_OP, offset, size, null, cb));
          };
          RandomAccess.prototype._read = NOT_READABLE;
          RandomAccess.prototype.write = function(offset, data, cb) {
            if (!cb)
              cb = noop;
            openWritable(this);
            this.run(new Request(this, WRITE_OP, offset, data.length, data, cb));
          };
          RandomAccess.prototype._write = NOT_WRITABLE;
          RandomAccess.prototype.del = function(offset, size, cb) {
            if (!cb)
              cb = noop;
            openWritable(this);
            this.run(new Request(this, DEL_OP, offset, size, null, cb));
          };
          RandomAccess.prototype._del = NOT_DELETABLE;
          RandomAccess.prototype.stat = function(cb) {
            this.run(new Request(this, STAT_OP, 0, 0, null, cb));
          };
          RandomAccess.prototype._stat = NOT_STATABLE;
          RandomAccess.prototype.open = function(cb) {
            if (!cb)
              cb = noop;
            if (this.opened && !this._needsOpen)
              return process.nextTick(cb, null);
            queueAndRun(this, new Request(this, OPEN_OP, 0, 0, null, cb));
          };
          RandomAccess.prototype._open = defaultImpl(null);
          RandomAccess.prototype._openReadonly = NO_OPEN_READABLE;
          RandomAccess.prototype.close = function(cb) {
            if (!cb)
              cb = noop;
            if (this.closed)
              return process.nextTick(cb, null);
            queueAndRun(this, new Request(this, CLOSE_OP, 0, 0, null, cb));
          };
          RandomAccess.prototype._close = defaultImpl(null);
          RandomAccess.prototype.destroy = function(cb) {
            if (!cb)
              cb = noop;
            if (!this.closed)
              this.close(noop);
            queueAndRun(this, new Request(this, DESTROY_OP, 0, 0, null, cb));
          };
          RandomAccess.prototype._destroy = defaultImpl(null);
          RandomAccess.prototype.run = function(req) {
            if (this._needsOpen)
              this.open(noop);
            if (this._queued.length)
              this._queued.push(req);
            else
              req._run();
          };
          function noop() {
          }
          function Request(self2, type, offset, size, data, cb) {
            this.type = type;
            this.offset = offset;
            this.data = data;
            this.size = size;
            this.storage = self2;
            this._sync = false;
            this._callback = cb;
            this._openError = null;
          }
          Request.prototype._maybeOpenError = function(err) {
            if (this.type !== OPEN_OP)
              return;
            var queued = this.storage._queued;
            for (var i = 0; i < queued.length; i++) {
              queued[i]._openError = err;
            }
          };
          Request.prototype._unqueue = function(err) {
            var ra = this.storage;
            var queued = ra._queued;
            if (!err) {
              switch (this.type) {
                case OPEN_OP:
                  if (!ra.opened) {
                    ra.opened = true;
                    ra.emit("open");
                  }
                  break;
                case CLOSE_OP:
                  if (!ra.closed) {
                    ra.closed = true;
                    ra.emit("close");
                  }
                  break;
                case DESTROY_OP:
                  if (!ra.destroyed) {
                    ra.destroyed = true;
                    ra.emit("destroy");
                  }
                  break;
              }
            } else {
              this._maybeOpenError(err);
            }
            if (queued.length && queued[0] === this)
              queued.shift();
            if (!--ra._pending)
              drainQueue(ra);
          };
          Request.prototype.callback = function(err, val) {
            if (this._sync)
              return nextTick(this, err, val);
            this._unqueue(err);
            this._callback(err, val);
          };
          Request.prototype._openAndNotClosed = function() {
            var ra = this.storage;
            if (ra.opened && !ra.closed)
              return true;
            if (!ra.opened)
              nextTick(this, this._openError || new Error("Not opened"));
            else if (ra.closed)
              nextTick(this, new Error("Closed"));
            return false;
          };
          Request.prototype._open = function() {
            var ra = this.storage;
            if (ra.opened && !ra._needsOpen)
              return nextTick(this, null);
            if (ra.closed)
              return nextTick(this, new Error("Closed"));
            ra._needsOpen = false;
            if (ra.preferReadonly)
              ra._openReadonly(this);
            else
              ra._open(this);
          };
          Request.prototype._run = function() {
            var ra = this.storage;
            ra._pending++;
            this._sync = true;
            switch (this.type) {
              case READ_OP:
                if (this._openAndNotClosed())
                  ra._read(this);
                break;
              case WRITE_OP:
                if (this._openAndNotClosed())
                  ra._write(this);
                break;
              case DEL_OP:
                if (this._openAndNotClosed())
                  ra._del(this);
                break;
              case STAT_OP:
                if (this._openAndNotClosed())
                  ra._stat(this);
                break;
              case OPEN_OP:
                this._open();
                break;
              case CLOSE_OP:
                if (ra.closed || !ra.opened)
                  nextTick(this, null);
                else
                  ra._close(this);
                break;
              case DESTROY_OP:
                if (ra.destroyed)
                  nextTick(this, null);
                else
                  ra._destroy(this);
                break;
            }
            this._sync = false;
          };
          function queueAndRun(self2, req) {
            self2._queued.push(req);
            if (!self2._pending)
              req._run();
          }
          function drainQueue(self2) {
            var queued = self2._queued;
            while (queued.length > 0) {
              var blocking = queued[0].type > 3;
              if (!blocking || !self2._pending)
                queued[0]._run();
              if (blocking)
                return;
              queued.shift();
            }
          }
          function openWritable(self2) {
            if (self2.preferReadonly) {
              self2._needsOpen = true;
              self2.preferReadonly = false;
            }
          }
          function defaultImpl(err) {
            return overridable;
            function overridable(req) {
              nextTick(req, err);
            }
          }
          function nextTick(req, err, val) {
            process.nextTick(nextTickCallback, req, err, val);
          }
          function nextTickCallback(req, err, val) {
            req.callback(err, val);
          }
        }).call(this);
      }).call(this, require2("_process"));
    }, { "_process": 361, "events": 193, "inherits": 256 }], 382: [function(require2, module2, exports2) {
      (function(process, global) {
        (function() {
          var MAX_BYTES = 65536;
          var MAX_UINT32 = 4294967295;
          function oldBrowser() {
            throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
          }
          var Buffer = require2("safe-buffer").Buffer;
          var crypto = global.crypto || global.msCrypto;
          if (crypto && crypto.getRandomValues) {
            module2.exports = randomBytes;
          } else {
            module2.exports = oldBrowser;
          }
          function randomBytes(size, cb) {
            if (size > MAX_UINT32)
              throw new RangeError("requested too many random bytes");
            var bytes = Buffer.allocUnsafe(size);
            if (size > 0) {
              if (size > MAX_BYTES) {
                for (var generated = 0; generated < size; generated += MAX_BYTES) {
                  crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
                }
              } else {
                crypto.getRandomValues(bytes);
              }
            }
            if (typeof cb === "function") {
              return process.nextTick(function() {
                cb(null, bytes);
              });
            }
            return bytes;
          }
        }).call(this);
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "_process": 361, "safe-buffer": 417 }], 383: [function(require2, module2, exports2) {
      (function(process, global) {
        (function() {
          function oldBrowser() {
            throw new Error("secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11");
          }
          var safeBuffer = require2("safe-buffer");
          var randombytes = require2("randombytes");
          var Buffer = safeBuffer.Buffer;
          var kBufferMaxLength = safeBuffer.kMaxLength;
          var crypto = global.crypto || global.msCrypto;
          var kMaxUint32 = Math.pow(2, 32) - 1;
          function assertOffset(offset, length) {
            if (typeof offset !== "number" || offset !== offset) {
              throw new TypeError("offset must be a number");
            }
            if (offset > kMaxUint32 || offset < 0) {
              throw new TypeError("offset must be a uint32");
            }
            if (offset > kBufferMaxLength || offset > length) {
              throw new RangeError("offset out of range");
            }
          }
          function assertSize(size, offset, length) {
            if (typeof size !== "number" || size !== size) {
              throw new TypeError("size must be a number");
            }
            if (size > kMaxUint32 || size < 0) {
              throw new TypeError("size must be a uint32");
            }
            if (size + offset > length || size > kBufferMaxLength) {
              throw new RangeError("buffer too small");
            }
          }
          if (crypto && crypto.getRandomValues || !process.browser) {
            exports2.randomFill = randomFill;
            exports2.randomFillSync = randomFillSync;
          } else {
            exports2.randomFill = oldBrowser;
            exports2.randomFillSync = oldBrowser;
          }
          function randomFill(buf, offset, size, cb) {
            if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
              throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
            }
            if (typeof offset === "function") {
              cb = offset;
              offset = 0;
              size = buf.length;
            } else if (typeof size === "function") {
              cb = size;
              size = buf.length - offset;
            } else if (typeof cb !== "function") {
              throw new TypeError('"cb" argument must be a function');
            }
            assertOffset(offset, buf.length);
            assertSize(size, offset, buf.length);
            return actualFill(buf, offset, size, cb);
          }
          function actualFill(buf, offset, size, cb) {
            if (process.browser) {
              var ourBuf = buf.buffer;
              var uint = new Uint8Array(ourBuf, offset, size);
              crypto.getRandomValues(uint);
              if (cb) {
                process.nextTick(function() {
                  cb(null, buf);
                });
                return;
              }
              return buf;
            }
            if (cb) {
              randombytes(size, function(err, bytes2) {
                if (err) {
                  return cb(err);
                }
                bytes2.copy(buf, offset);
                cb(null, buf);
              });
              return;
            }
            var bytes = randombytes(size);
            bytes.copy(buf, offset);
            return buf;
          }
          function randomFillSync(buf, offset, size) {
            if (typeof offset === "undefined") {
              offset = 0;
            }
            if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
              throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
            }
            assertOffset(offset, buf.length);
            if (size === void 0)
              size = buf.length - offset;
            assertSize(size, offset, buf.length);
            return actualFill(buf, offset, size);
          }
        }).call(this);
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "_process": 361, "randombytes": 382, "safe-buffer": 417 }], 384: [function(require2, module2, exports2) {
      module2.exports = function(arr) {
        if (!Array.isArray(arr))
          throw "C'mon pal. You gotta feed this thing *arrays*!";
        var randomized = [];
        var copy = arr.slice();
        while (copy.length) {
          var num = Math.floor(Math.random() * copy.length);
          randomized.push(copy.splice(num, 1)[0]);
        }
        return randomized;
      };
    }, {}], 385: [function(require2, module2, exports2) {
      function reachdown(db, visit, strict) {
        return walk(db, visitor(visit), !!visit && strict !== false);
      }
      function walk(db, visit, strict) {
        if (visit(db, type(db)))
          return db;
        if (isAbstract(db.db))
          return walk(db.db, visit, strict);
        if (isAbstract(db._db))
          return walk(db._db, visit, strict);
        if (isLevelup(db.db))
          return walk(db.db, visit, strict);
        if (strict)
          return null;
        return db;
      }
      function isAbstract(db) {
        return isObject(db) && typeof db._batch === "function" && typeof db._iterator === "function";
      }
      function visitor(v) {
        return typeof v === "function" ? v : v ? typeVisitor(v) : none;
      }
      function typeVisitor(wanted) {
        return function(db, type2) {
          return type2 ? type2 === wanted : false;
        };
      }
      function none() {
        return false;
      }
      function type(db) {
        if (db.type)
          return db.type;
        if (isLevelup(db))
          return "levelup";
        if (isEncdown(db))
          return "encoding-down";
        if (isDeferred(db))
          return "deferred-leveldown";
      }
      function isLevelup(db) {
        return isObject(db) && /^levelup$/i.test(db);
      }
      function isEncdown(db) {
        return isObject(db) && isObject(db.codec) && isObject(db.codec.encodings);
      }
      function isDeferred(db) {
        return isObject(db) && Array.isArray(db._operations) && Array.isArray(db._iterators);
      }
      function isObject(o) {
        return typeof o === "object" && o !== null;
      }
      function is(db, visit) {
        return !!visitor(visit)(db, type(db));
      }
      reachdown.is = is;
      module2.exports = reachdown;
    }, {}], 386: [function(require2, module2, exports2) {
      var Readable = require2("readable-stream").Readable;
      module2.exports = function(stream) {
        var opts = stream._readableState;
        if (typeof stream.read !== "function") {
          stream = new Readable(opts).wrap(stream);
        }
        var ro = new Readable({
          objectMode: opts && opts.objectMode
        });
        var waiting = false;
        stream.on("readable", function() {
          if (waiting) {
            waiting = false;
            ro._read();
          }
        });
        ro._read = function() {
          var buf, reads = 0;
          while ((buf = stream.read()) !== null) {
            ro.push(buf);
            reads++;
          }
          if (reads === 0)
            waiting = true;
        };
        stream.once("end", function() {
          ro.push(null);
        });
        stream.on("error", function(err) {
          ro.emit("error", err);
        });
        return ro;
      };
    }, { "readable-stream": 395 }], 387: [function(require2, module2, exports2) {
      arguments[4][97][0].apply(exports2, arguments);
    }, { "./_stream_readable": 389, "./_stream_writable": 391, "core-util-is": 108, "dup": 97, "inherits": 256, "process-nextick-args": 360 }], 388: [function(require2, module2, exports2) {
      arguments[4][98][0].apply(exports2, arguments);
    }, { "./_stream_transform": 390, "core-util-is": 108, "dup": 98, "inherits": 256 }], 389: [function(require2, module2, exports2) {
      arguments[4][99][0].apply(exports2, arguments);
    }, { "../../../../util/util.js": 514, "./_stream_duplex": 387, "./internal/streams/BufferList": 392, "./internal/streams/destroy": 393, "./internal/streams/stream": 394, "_process": 361, "core-util-is": 108, "dup": 99, "events": 193, "inherits": 256, "isarray": 263, "process-nextick-args": 360, "safe-buffer": 396, "string_decoder/": 397 }], 390: [function(require2, module2, exports2) {
      arguments[4][100][0].apply(exports2, arguments);
    }, { "./_stream_duplex": 387, "core-util-is": 108, "dup": 100, "inherits": 256 }], 391: [function(require2, module2, exports2) {
      arguments[4][101][0].apply(exports2, arguments);
    }, { "./_stream_duplex": 387, "./internal/streams/destroy": 393, "./internal/streams/stream": 394, "_process": 361, "core-util-is": 108, "dup": 101, "inherits": 256, "process-nextick-args": 360, "safe-buffer": 396, "timers": 506, "util-deprecate": 511 }], 392: [function(require2, module2, exports2) {
      arguments[4][102][0].apply(exports2, arguments);
    }, { "../../../../../../util/util.js": 514, "dup": 102, "safe-buffer": 396 }], 393: [function(require2, module2, exports2) {
      arguments[4][103][0].apply(exports2, arguments);
    }, { "dup": 103, "process-nextick-args": 360 }], 394: [function(require2, module2, exports2) {
      arguments[4][104][0].apply(exports2, arguments);
    }, { "dup": 104, "events": 193 }], 395: [function(require2, module2, exports2) {
      arguments[4][105][0].apply(exports2, arguments);
    }, { "./lib/_stream_duplex.js": 387, "./lib/_stream_passthrough.js": 388, "./lib/_stream_readable.js": 389, "./lib/_stream_transform.js": 390, "./lib/_stream_writable.js": 391, "dup": 105 }], 396: [function(require2, module2, exports2) {
      arguments[4][106][0].apply(exports2, arguments);
    }, { "buffer": 82, "dup": 106 }], 397: [function(require2, module2, exports2) {
      arguments[4][107][0].apply(exports2, arguments);
    }, { "dup": 107, "safe-buffer": 396 }], 398: [function(require2, module2, exports2) {
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type = includes(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module2.exports.codes = codes;
    }, {}], 399: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          var objectKeys = Object.keys || function(obj) {
            var keys2 = [];
            for (var key in obj) {
              keys2.push(key);
            }
            return keys2;
          };
          module2.exports = Duplex;
          var Readable = require2("./_stream_readable");
          var Writable = require2("./_stream_writable");
          require2("inherits")(Duplex, Readable);
          {
            var keys = objectKeys(Writable.prototype);
            for (var v = 0; v < keys.length; v++) {
              var method = keys[v];
              if (!Duplex.prototype[method])
                Duplex.prototype[method] = Writable.prototype[method];
            }
          }
          function Duplex(options) {
            if (!(this instanceof Duplex))
              return new Duplex(options);
            Readable.call(this, options);
            Writable.call(this, options);
            this.allowHalfOpen = true;
            if (options) {
              if (options.readable === false)
                this.readable = false;
              if (options.writable === false)
                this.writable = false;
              if (options.allowHalfOpen === false) {
                this.allowHalfOpen = false;
                this.once("end", onend);
              }
            }
          }
          Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
            enumerable: false,
            get: function get() {
              return this._writableState.highWaterMark;
            }
          });
          Object.defineProperty(Duplex.prototype, "writableBuffer", {
            enumerable: false,
            get: function get() {
              return this._writableState && this._writableState.getBuffer();
            }
          });
          Object.defineProperty(Duplex.prototype, "writableLength", {
            enumerable: false,
            get: function get() {
              return this._writableState.length;
            }
          });
          function onend() {
            if (this._writableState.ended)
              return;
            process.nextTick(onEndNT, this);
          }
          function onEndNT(self2) {
            self2.end();
          }
          Object.defineProperty(Duplex.prototype, "destroyed", {
            enumerable: false,
            get: function get() {
              if (this._readableState === void 0 || this._writableState === void 0) {
                return false;
              }
              return this._readableState.destroyed && this._writableState.destroyed;
            },
            set: function set(value) {
              if (this._readableState === void 0 || this._writableState === void 0) {
                return;
              }
              this._readableState.destroyed = value;
              this._writableState.destroyed = value;
            }
          });
        }).call(this);
      }).call(this, require2("_process"));
    }, { "./_stream_readable": 401, "./_stream_writable": 403, "_process": 361, "inherits": 256 }], 400: [function(require2, module2, exports2) {
      module2.exports = PassThrough;
      var Transform = require2("./_stream_transform");
      require2("inherits")(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough))
          return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }, { "./_stream_transform": 402, "inherits": 256 }], 401: [function(require2, module2, exports2) {
      (function(process, global) {
        (function() {
          module2.exports = Readable;
          var Duplex;
          Readable.ReadableState = ReadableState;
          require2("events").EventEmitter;
          var EElistenerCount = function EElistenerCount2(emitter, type) {
            return emitter.listeners(type).length;
          };
          var Stream = require2("./internal/streams/stream");
          var Buffer = require2("buffer").Buffer;
          var OurUint8Array = global.Uint8Array || function() {
          };
          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk);
          }
          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
          }
          var debugUtil = require2("../../util/util.js");
          var debug;
          if (debugUtil && debugUtil.debuglog) {
            debug = debugUtil.debuglog("stream");
          } else {
            debug = function debug2() {
            };
          }
          var BufferList = require2("./internal/streams/buffer_list");
          var destroyImpl = require2("./internal/streams/destroy");
          var _require = require2("./internal/streams/state"), getHighWaterMark = _require.getHighWaterMark;
          var _require$codes = require2("../errors").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
          var StringDecoder;
          var createReadableStreamAsyncIterator;
          var from;
          require2("inherits")(Readable, Stream);
          var errorOrDestroy = destroyImpl.errorOrDestroy;
          var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
          function prependListener(emitter, event, fn) {
            if (typeof emitter.prependListener === "function")
              return emitter.prependListener(event, fn);
            if (!emitter._events || !emitter._events[event])
              emitter.on(event, fn);
            else if (Array.isArray(emitter._events[event]))
              emitter._events[event].unshift(fn);
            else
              emitter._events[event] = [fn, emitter._events[event]];
          }
          function ReadableState(options, stream, isDuplex) {
            Duplex = Duplex || require2("./_stream_duplex");
            options = options || {};
            if (typeof isDuplex !== "boolean")
              isDuplex = stream instanceof Duplex;
            this.objectMode = !!options.objectMode;
            if (isDuplex)
              this.objectMode = this.objectMode || !!options.readableObjectMode;
            this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
            this.buffer = new BufferList();
            this.length = 0;
            this.pipes = null;
            this.pipesCount = 0;
            this.flowing = null;
            this.ended = false;
            this.endEmitted = false;
            this.reading = false;
            this.sync = true;
            this.needReadable = false;
            this.emittedReadable = false;
            this.readableListening = false;
            this.resumeScheduled = false;
            this.paused = true;
            this.emitClose = options.emitClose !== false;
            this.autoDestroy = !!options.autoDestroy;
            this.destroyed = false;
            this.defaultEncoding = options.defaultEncoding || "utf8";
            this.awaitDrain = 0;
            this.readingMore = false;
            this.decoder = null;
            this.encoding = null;
            if (options.encoding) {
              if (!StringDecoder)
                StringDecoder = require2("string_decoder/").StringDecoder;
              this.decoder = new StringDecoder(options.encoding);
              this.encoding = options.encoding;
            }
          }
          function Readable(options) {
            Duplex = Duplex || require2("./_stream_duplex");
            if (!(this instanceof Readable))
              return new Readable(options);
            var isDuplex = this instanceof Duplex;
            this._readableState = new ReadableState(options, this, isDuplex);
            this.readable = true;
            if (options) {
              if (typeof options.read === "function")
                this._read = options.read;
              if (typeof options.destroy === "function")
                this._destroy = options.destroy;
            }
            Stream.call(this);
          }
          Object.defineProperty(Readable.prototype, "destroyed", {
            enumerable: false,
            get: function get() {
              if (this._readableState === void 0) {
                return false;
              }
              return this._readableState.destroyed;
            },
            set: function set(value) {
              if (!this._readableState) {
                return;
              }
              this._readableState.destroyed = value;
            }
          });
          Readable.prototype.destroy = destroyImpl.destroy;
          Readable.prototype._undestroy = destroyImpl.undestroy;
          Readable.prototype._destroy = function(err, cb) {
            cb(err);
          };
          Readable.prototype.push = function(chunk, encoding) {
            var state = this._readableState;
            var skipChunkCheck;
            if (!state.objectMode) {
              if (typeof chunk === "string") {
                encoding = encoding || state.defaultEncoding;
                if (encoding !== state.encoding) {
                  chunk = Buffer.from(chunk, encoding);
                  encoding = "";
                }
                skipChunkCheck = true;
              }
            } else {
              skipChunkCheck = true;
            }
            return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
          };
          Readable.prototype.unshift = function(chunk) {
            return readableAddChunk(this, chunk, null, true, false);
          };
          function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
            debug("readableAddChunk", chunk);
            var state = stream._readableState;
            if (chunk === null) {
              state.reading = false;
              onEofChunk(stream, state);
            } else {
              var er;
              if (!skipChunkCheck)
                er = chunkInvalid(state, chunk);
              if (er) {
                errorOrDestroy(stream, er);
              } else if (state.objectMode || chunk && chunk.length > 0) {
                if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                  chunk = _uint8ArrayToBuffer(chunk);
                }
                if (addToFront) {
                  if (state.endEmitted)
                    errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                  else
                    addChunk(stream, state, chunk, true);
                } else if (state.ended) {
                  errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
                } else if (state.destroyed) {
                  return false;
                } else {
                  state.reading = false;
                  if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0)
                      addChunk(stream, state, chunk, false);
                    else
                      maybeReadMore(stream, state);
                  } else {
                    addChunk(stream, state, chunk, false);
                  }
                }
              } else if (!addToFront) {
                state.reading = false;
                maybeReadMore(stream, state);
              }
            }
            return !state.ended && (state.length < state.highWaterMark || state.length === 0);
          }
          function addChunk(stream, state, chunk, addToFront) {
            if (state.flowing && state.length === 0 && !state.sync) {
              state.awaitDrain = 0;
              stream.emit("data", chunk);
            } else {
              state.length += state.objectMode ? 1 : chunk.length;
              if (addToFront)
                state.buffer.unshift(chunk);
              else
                state.buffer.push(chunk);
              if (state.needReadable)
                emitReadable(stream);
            }
            maybeReadMore(stream, state);
          }
          function chunkInvalid(state, chunk) {
            var er;
            if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
              er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
            }
            return er;
          }
          Readable.prototype.isPaused = function() {
            return this._readableState.flowing === false;
          };
          Readable.prototype.setEncoding = function(enc) {
            if (!StringDecoder)
              StringDecoder = require2("string_decoder/").StringDecoder;
            var decoder = new StringDecoder(enc);
            this._readableState.decoder = decoder;
            this._readableState.encoding = this._readableState.decoder.encoding;
            var p = this._readableState.buffer.head;
            var content = "";
            while (p !== null) {
              content += decoder.write(p.data);
              p = p.next;
            }
            this._readableState.buffer.clear();
            if (content !== "")
              this._readableState.buffer.push(content);
            this._readableState.length = content.length;
            return this;
          };
          var MAX_HWM = 1073741824;
          function computeNewHighWaterMark(n) {
            if (n >= MAX_HWM) {
              n = MAX_HWM;
            } else {
              n--;
              n |= n >>> 1;
              n |= n >>> 2;
              n |= n >>> 4;
              n |= n >>> 8;
              n |= n >>> 16;
              n++;
            }
            return n;
          }
          function howMuchToRead(n, state) {
            if (n <= 0 || state.length === 0 && state.ended)
              return 0;
            if (state.objectMode)
              return 1;
            if (n !== n) {
              if (state.flowing && state.length)
                return state.buffer.head.data.length;
              else
                return state.length;
            }
            if (n > state.highWaterMark)
              state.highWaterMark = computeNewHighWaterMark(n);
            if (n <= state.length)
              return n;
            if (!state.ended) {
              state.needReadable = true;
              return 0;
            }
            return state.length;
          }
          Readable.prototype.read = function(n) {
            debug("read", n);
            n = parseInt(n, 10);
            var state = this._readableState;
            var nOrig = n;
            if (n !== 0)
              state.emittedReadable = false;
            if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
              debug("read: emitReadable", state.length, state.ended);
              if (state.length === 0 && state.ended)
                endReadable(this);
              else
                emitReadable(this);
              return null;
            }
            n = howMuchToRead(n, state);
            if (n === 0 && state.ended) {
              if (state.length === 0)
                endReadable(this);
              return null;
            }
            var doRead = state.needReadable;
            debug("need readable", doRead);
            if (state.length === 0 || state.length - n < state.highWaterMark) {
              doRead = true;
              debug("length less than watermark", doRead);
            }
            if (state.ended || state.reading) {
              doRead = false;
              debug("reading or ended", doRead);
            } else if (doRead) {
              debug("do read");
              state.reading = true;
              state.sync = true;
              if (state.length === 0)
                state.needReadable = true;
              this._read(state.highWaterMark);
              state.sync = false;
              if (!state.reading)
                n = howMuchToRead(nOrig, state);
            }
            var ret;
            if (n > 0)
              ret = fromList(n, state);
            else
              ret = null;
            if (ret === null) {
              state.needReadable = state.length <= state.highWaterMark;
              n = 0;
            } else {
              state.length -= n;
              state.awaitDrain = 0;
            }
            if (state.length === 0) {
              if (!state.ended)
                state.needReadable = true;
              if (nOrig !== n && state.ended)
                endReadable(this);
            }
            if (ret !== null)
              this.emit("data", ret);
            return ret;
          };
          function onEofChunk(stream, state) {
            debug("onEofChunk");
            if (state.ended)
              return;
            if (state.decoder) {
              var chunk = state.decoder.end();
              if (chunk && chunk.length) {
                state.buffer.push(chunk);
                state.length += state.objectMode ? 1 : chunk.length;
              }
            }
            state.ended = true;
            if (state.sync) {
              emitReadable(stream);
            } else {
              state.needReadable = false;
              if (!state.emittedReadable) {
                state.emittedReadable = true;
                emitReadable_(stream);
              }
            }
          }
          function emitReadable(stream) {
            var state = stream._readableState;
            debug("emitReadable", state.needReadable, state.emittedReadable);
            state.needReadable = false;
            if (!state.emittedReadable) {
              debug("emitReadable", state.flowing);
              state.emittedReadable = true;
              process.nextTick(emitReadable_, stream);
            }
          }
          function emitReadable_(stream) {
            var state = stream._readableState;
            debug("emitReadable_", state.destroyed, state.length, state.ended);
            if (!state.destroyed && (state.length || state.ended)) {
              stream.emit("readable");
              state.emittedReadable = false;
            }
            state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
            flow(stream);
          }
          function maybeReadMore(stream, state) {
            if (!state.readingMore) {
              state.readingMore = true;
              process.nextTick(maybeReadMore_, stream, state);
            }
          }
          function maybeReadMore_(stream, state) {
            while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
              var len = state.length;
              debug("maybeReadMore read 0");
              stream.read(0);
              if (len === state.length)
                break;
            }
            state.readingMore = false;
          }
          Readable.prototype._read = function(n) {
            errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
          };
          Readable.prototype.pipe = function(dest, pipeOpts) {
            var src = this;
            var state = this._readableState;
            switch (state.pipesCount) {
              case 0:
                state.pipes = dest;
                break;
              case 1:
                state.pipes = [state.pipes, dest];
                break;
              default:
                state.pipes.push(dest);
                break;
            }
            state.pipesCount += 1;
            debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
            var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
            var endFn = doEnd ? onend : unpipe;
            if (state.endEmitted)
              process.nextTick(endFn);
            else
              src.once("end", endFn);
            dest.on("unpipe", onunpipe);
            function onunpipe(readable, unpipeInfo) {
              debug("onunpipe");
              if (readable === src) {
                if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                  unpipeInfo.hasUnpiped = true;
                  cleanup();
                }
              }
            }
            function onend() {
              debug("onend");
              dest.end();
            }
            var ondrain = pipeOnDrain(src);
            dest.on("drain", ondrain);
            var cleanedUp = false;
            function cleanup() {
              debug("cleanup");
              dest.removeListener("close", onclose);
              dest.removeListener("finish", onfinish);
              dest.removeListener("drain", ondrain);
              dest.removeListener("error", onerror);
              dest.removeListener("unpipe", onunpipe);
              src.removeListener("end", onend);
              src.removeListener("end", unpipe);
              src.removeListener("data", ondata);
              cleanedUp = true;
              if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
                ondrain();
            }
            src.on("data", ondata);
            function ondata(chunk) {
              debug("ondata");
              var ret = dest.write(chunk);
              debug("dest.write", ret);
              if (ret === false) {
                if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                  debug("false write response, pause", state.awaitDrain);
                  state.awaitDrain++;
                }
                src.pause();
              }
            }
            function onerror(er) {
              debug("onerror", er);
              unpipe();
              dest.removeListener("error", onerror);
              if (EElistenerCount(dest, "error") === 0)
                errorOrDestroy(dest, er);
            }
            prependListener(dest, "error", onerror);
            function onclose() {
              dest.removeListener("finish", onfinish);
              unpipe();
            }
            dest.once("close", onclose);
            function onfinish() {
              debug("onfinish");
              dest.removeListener("close", onclose);
              unpipe();
            }
            dest.once("finish", onfinish);
            function unpipe() {
              debug("unpipe");
              src.unpipe(dest);
            }
            dest.emit("pipe", src);
            if (!state.flowing) {
              debug("pipe resume");
              src.resume();
            }
            return dest;
          };
          function pipeOnDrain(src) {
            return function pipeOnDrainFunctionResult() {
              var state = src._readableState;
              debug("pipeOnDrain", state.awaitDrain);
              if (state.awaitDrain)
                state.awaitDrain--;
              if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
                state.flowing = true;
                flow(src);
              }
            };
          }
          Readable.prototype.unpipe = function(dest) {
            var state = this._readableState;
            var unpipeInfo = {
              hasUnpiped: false
            };
            if (state.pipesCount === 0)
              return this;
            if (state.pipesCount === 1) {
              if (dest && dest !== state.pipes)
                return this;
              if (!dest)
                dest = state.pipes;
              state.pipes = null;
              state.pipesCount = 0;
              state.flowing = false;
              if (dest)
                dest.emit("unpipe", this, unpipeInfo);
              return this;
            }
            if (!dest) {
              var dests = state.pipes;
              var len = state.pipesCount;
              state.pipes = null;
              state.pipesCount = 0;
              state.flowing = false;
              for (var i = 0; i < len; i++) {
                dests[i].emit("unpipe", this, {
                  hasUnpiped: false
                });
              }
              return this;
            }
            var index = indexOf(state.pipes, dest);
            if (index === -1)
              return this;
            state.pipes.splice(index, 1);
            state.pipesCount -= 1;
            if (state.pipesCount === 1)
              state.pipes = state.pipes[0];
            dest.emit("unpipe", this, unpipeInfo);
            return this;
          };
          Readable.prototype.on = function(ev, fn) {
            var res = Stream.prototype.on.call(this, ev, fn);
            var state = this._readableState;
            if (ev === "data") {
              state.readableListening = this.listenerCount("readable") > 0;
              if (state.flowing !== false)
                this.resume();
            } else if (ev === "readable") {
              if (!state.endEmitted && !state.readableListening) {
                state.readableListening = state.needReadable = true;
                state.flowing = false;
                state.emittedReadable = false;
                debug("on readable", state.length, state.reading);
                if (state.length) {
                  emitReadable(this);
                } else if (!state.reading) {
                  process.nextTick(nReadingNextTick, this);
                }
              }
            }
            return res;
          };
          Readable.prototype.addListener = Readable.prototype.on;
          Readable.prototype.removeListener = function(ev, fn) {
            var res = Stream.prototype.removeListener.call(this, ev, fn);
            if (ev === "readable") {
              process.nextTick(updateReadableListening, this);
            }
            return res;
          };
          Readable.prototype.removeAllListeners = function(ev) {
            var res = Stream.prototype.removeAllListeners.apply(this, arguments);
            if (ev === "readable" || ev === void 0) {
              process.nextTick(updateReadableListening, this);
            }
            return res;
          };
          function updateReadableListening(self2) {
            var state = self2._readableState;
            state.readableListening = self2.listenerCount("readable") > 0;
            if (state.resumeScheduled && !state.paused) {
              state.flowing = true;
            } else if (self2.listenerCount("data") > 0) {
              self2.resume();
            }
          }
          function nReadingNextTick(self2) {
            debug("readable nexttick read 0");
            self2.read(0);
          }
          Readable.prototype.resume = function() {
            var state = this._readableState;
            if (!state.flowing) {
              debug("resume");
              state.flowing = !state.readableListening;
              resume(this, state);
            }
            state.paused = false;
            return this;
          };
          function resume(stream, state) {
            if (!state.resumeScheduled) {
              state.resumeScheduled = true;
              process.nextTick(resume_, stream, state);
            }
          }
          function resume_(stream, state) {
            debug("resume", state.reading);
            if (!state.reading) {
              stream.read(0);
            }
            state.resumeScheduled = false;
            stream.emit("resume");
            flow(stream);
            if (state.flowing && !state.reading)
              stream.read(0);
          }
          Readable.prototype.pause = function() {
            debug("call pause flowing=%j", this._readableState.flowing);
            if (this._readableState.flowing !== false) {
              debug("pause");
              this._readableState.flowing = false;
              this.emit("pause");
            }
            this._readableState.paused = true;
            return this;
          };
          function flow(stream) {
            var state = stream._readableState;
            debug("flow", state.flowing);
            while (state.flowing && stream.read() !== null) {
            }
          }
          Readable.prototype.wrap = function(stream) {
            var _this = this;
            var state = this._readableState;
            var paused = false;
            stream.on("end", function() {
              debug("wrapped end");
              if (state.decoder && !state.ended) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length)
                  _this.push(chunk);
              }
              _this.push(null);
            });
            stream.on("data", function(chunk) {
              debug("wrapped data");
              if (state.decoder)
                chunk = state.decoder.write(chunk);
              if (state.objectMode && (chunk === null || chunk === void 0))
                return;
              else if (!state.objectMode && (!chunk || !chunk.length))
                return;
              var ret = _this.push(chunk);
              if (!ret) {
                paused = true;
                stream.pause();
              }
            });
            for (var i in stream) {
              if (this[i] === void 0 && typeof stream[i] === "function") {
                this[i] = function methodWrap(method) {
                  return function methodWrapReturnFunction() {
                    return stream[method].apply(stream, arguments);
                  };
                }(i);
              }
            }
            for (var n = 0; n < kProxyEvents.length; n++) {
              stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
            }
            this._read = function(n2) {
              debug("wrapped _read", n2);
              if (paused) {
                paused = false;
                stream.resume();
              }
            };
            return this;
          };
          if (typeof Symbol === "function") {
            Readable.prototype[Symbol.asyncIterator] = function() {
              if (createReadableStreamAsyncIterator === void 0) {
                createReadableStreamAsyncIterator = require2("./internal/streams/async_iterator");
              }
              return createReadableStreamAsyncIterator(this);
            };
          }
          Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
            enumerable: false,
            get: function get() {
              return this._readableState.highWaterMark;
            }
          });
          Object.defineProperty(Readable.prototype, "readableBuffer", {
            enumerable: false,
            get: function get() {
              return this._readableState && this._readableState.buffer;
            }
          });
          Object.defineProperty(Readable.prototype, "readableFlowing", {
            enumerable: false,
            get: function get() {
              return this._readableState.flowing;
            },
            set: function set(state) {
              if (this._readableState) {
                this._readableState.flowing = state;
              }
            }
          });
          Readable._fromList = fromList;
          Object.defineProperty(Readable.prototype, "readableLength", {
            enumerable: false,
            get: function get() {
              return this._readableState.length;
            }
          });
          function fromList(n, state) {
            if (state.length === 0)
              return null;
            var ret;
            if (state.objectMode)
              ret = state.buffer.shift();
            else if (!n || n >= state.length) {
              if (state.decoder)
                ret = state.buffer.join("");
              else if (state.buffer.length === 1)
                ret = state.buffer.first();
              else
                ret = state.buffer.concat(state.length);
              state.buffer.clear();
            } else {
              ret = state.buffer.consume(n, state.decoder);
            }
            return ret;
          }
          function endReadable(stream) {
            var state = stream._readableState;
            debug("endReadable", state.endEmitted);
            if (!state.endEmitted) {
              state.ended = true;
              process.nextTick(endReadableNT, state, stream);
            }
          }
          function endReadableNT(state, stream) {
            debug("endReadableNT", state.endEmitted, state.length);
            if (!state.endEmitted && state.length === 0) {
              state.endEmitted = true;
              stream.readable = false;
              stream.emit("end");
              if (state.autoDestroy) {
                var wState = stream._writableState;
                if (!wState || wState.autoDestroy && wState.finished) {
                  stream.destroy();
                }
              }
            }
          }
          if (typeof Symbol === "function") {
            Readable.from = function(iterable, opts) {
              if (from === void 0) {
                from = require2("./internal/streams/from");
              }
              return from(Readable, iterable, opts);
            };
          }
          function indexOf(xs, x) {
            for (var i = 0, l = xs.length; i < l; i++) {
              if (xs[i] === x)
                return i;
            }
            return -1;
          }
        }).call(this);
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "../../util/util.js": 514, "../errors": 398, "./_stream_duplex": 399, "./internal/streams/async_iterator": 404, "./internal/streams/buffer_list": 405, "./internal/streams/destroy": 406, "./internal/streams/from": 408, "./internal/streams/state": 410, "./internal/streams/stream": 411, "_process": 361, "buffer": 82, "events": 193, "inherits": 256, "string_decoder/": 499 }], 402: [function(require2, module2, exports2) {
      module2.exports = Transform;
      var _require$codes = require2("../errors").codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex = require2("./_stream_duplex");
      require2("inherits")(Transform, Duplex);
      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform))
          return new Transform(options);
        Duplex.call(this, options);
        this._transformState = {
          afterTransform: afterTransform.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      };
      Transform.prototype._transform = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform.prototype._destroy = function(err, cb) {
        Duplex.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }, { "../errors": 398, "./_stream_duplex": 399, "inherits": 256 }], 403: [function(require2, module2, exports2) {
      (function(process, global) {
        (function() {
          module2.exports = Writable;
          function CorkedRequest(state) {
            var _this = this;
            this.next = null;
            this.entry = null;
            this.finish = function() {
              onCorkedFinish(_this, state);
            };
          }
          var Duplex;
          Writable.WritableState = WritableState;
          var internalUtil = {
            deprecate: require2("util-deprecate")
          };
          var Stream = require2("./internal/streams/stream");
          var Buffer = require2("buffer").Buffer;
          var OurUint8Array = global.Uint8Array || function() {
          };
          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk);
          }
          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
          }
          var destroyImpl = require2("./internal/streams/destroy");
          var _require = require2("./internal/streams/state"), getHighWaterMark = _require.getHighWaterMark;
          var _require$codes = require2("../errors").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
          var errorOrDestroy = destroyImpl.errorOrDestroy;
          require2("inherits")(Writable, Stream);
          function nop() {
          }
          function WritableState(options, stream, isDuplex) {
            Duplex = Duplex || require2("./_stream_duplex");
            options = options || {};
            if (typeof isDuplex !== "boolean")
              isDuplex = stream instanceof Duplex;
            this.objectMode = !!options.objectMode;
            if (isDuplex)
              this.objectMode = this.objectMode || !!options.writableObjectMode;
            this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
            this.finalCalled = false;
            this.needDrain = false;
            this.ending = false;
            this.ended = false;
            this.finished = false;
            this.destroyed = false;
            var noDecode = options.decodeStrings === false;
            this.decodeStrings = !noDecode;
            this.defaultEncoding = options.defaultEncoding || "utf8";
            this.length = 0;
            this.writing = false;
            this.corked = 0;
            this.sync = true;
            this.bufferProcessing = false;
            this.onwrite = function(er) {
              onwrite(stream, er);
            };
            this.writecb = null;
            this.writelen = 0;
            this.bufferedRequest = null;
            this.lastBufferedRequest = null;
            this.pendingcb = 0;
            this.prefinished = false;
            this.errorEmitted = false;
            this.emitClose = options.emitClose !== false;
            this.autoDestroy = !!options.autoDestroy;
            this.bufferedRequestCount = 0;
            this.corkedRequestsFree = new CorkedRequest(this);
          }
          WritableState.prototype.getBuffer = function getBuffer() {
            var current = this.bufferedRequest;
            var out = [];
            while (current) {
              out.push(current);
              current = current.next;
            }
            return out;
          };
          (function() {
            try {
              Object.defineProperty(WritableState.prototype, "buffer", {
                get: internalUtil.deprecate(function writableStateBufferGetter() {
                  return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
              });
            } catch (_) {
            }
          })();
          var realHasInstance;
          if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
            realHasInstance = Function.prototype[Symbol.hasInstance];
            Object.defineProperty(Writable, Symbol.hasInstance, {
              value: function value(object) {
                if (realHasInstance.call(this, object))
                  return true;
                if (this !== Writable)
                  return false;
                return object && object._writableState instanceof WritableState;
              }
            });
          } else {
            realHasInstance = function realHasInstance2(object) {
              return object instanceof this;
            };
          }
          function Writable(options) {
            Duplex = Duplex || require2("./_stream_duplex");
            var isDuplex = this instanceof Duplex;
            if (!isDuplex && !realHasInstance.call(Writable, this))
              return new Writable(options);
            this._writableState = new WritableState(options, this, isDuplex);
            this.writable = true;
            if (options) {
              if (typeof options.write === "function")
                this._write = options.write;
              if (typeof options.writev === "function")
                this._writev = options.writev;
              if (typeof options.destroy === "function")
                this._destroy = options.destroy;
              if (typeof options.final === "function")
                this._final = options.final;
            }
            Stream.call(this);
          }
          Writable.prototype.pipe = function() {
            errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
          };
          function writeAfterEnd(stream, cb) {
            var er = new ERR_STREAM_WRITE_AFTER_END();
            errorOrDestroy(stream, er);
            process.nextTick(cb, er);
          }
          function validChunk(stream, state, chunk, cb) {
            var er;
            if (chunk === null) {
              er = new ERR_STREAM_NULL_VALUES();
            } else if (typeof chunk !== "string" && !state.objectMode) {
              er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
            }
            if (er) {
              errorOrDestroy(stream, er);
              process.nextTick(cb, er);
              return false;
            }
            return true;
          }
          Writable.prototype.write = function(chunk, encoding, cb) {
            var state = this._writableState;
            var ret = false;
            var isBuf = !state.objectMode && _isUint8Array(chunk);
            if (isBuf && !Buffer.isBuffer(chunk)) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (typeof encoding === "function") {
              cb = encoding;
              encoding = null;
            }
            if (isBuf)
              encoding = "buffer";
            else if (!encoding)
              encoding = state.defaultEncoding;
            if (typeof cb !== "function")
              cb = nop;
            if (state.ending)
              writeAfterEnd(this, cb);
            else if (isBuf || validChunk(this, state, chunk, cb)) {
              state.pendingcb++;
              ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
            }
            return ret;
          };
          Writable.prototype.cork = function() {
            this._writableState.corked++;
          };
          Writable.prototype.uncork = function() {
            var state = this._writableState;
            if (state.corked) {
              state.corked--;
              if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
                clearBuffer(this, state);
            }
          };
          Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
            if (typeof encoding === "string")
              encoding = encoding.toLowerCase();
            if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
              throw new ERR_UNKNOWN_ENCODING(encoding);
            this._writableState.defaultEncoding = encoding;
            return this;
          };
          Object.defineProperty(Writable.prototype, "writableBuffer", {
            enumerable: false,
            get: function get() {
              return this._writableState && this._writableState.getBuffer();
            }
          });
          function decodeChunk(state, chunk, encoding) {
            if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
              chunk = Buffer.from(chunk, encoding);
            }
            return chunk;
          }
          Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
            enumerable: false,
            get: function get() {
              return this._writableState.highWaterMark;
            }
          });
          function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
            if (!isBuf) {
              var newChunk = decodeChunk(state, chunk, encoding);
              if (chunk !== newChunk) {
                isBuf = true;
                encoding = "buffer";
                chunk = newChunk;
              }
            }
            var len = state.objectMode ? 1 : chunk.length;
            state.length += len;
            var ret = state.length < state.highWaterMark;
            if (!ret)
              state.needDrain = true;
            if (state.writing || state.corked) {
              var last = state.lastBufferedRequest;
              state.lastBufferedRequest = {
                chunk,
                encoding,
                isBuf,
                callback: cb,
                next: null
              };
              if (last) {
                last.next = state.lastBufferedRequest;
              } else {
                state.bufferedRequest = state.lastBufferedRequest;
              }
              state.bufferedRequestCount += 1;
            } else {
              doWrite(stream, state, false, len, chunk, encoding, cb);
            }
            return ret;
          }
          function doWrite(stream, state, writev, len, chunk, encoding, cb) {
            state.writelen = len;
            state.writecb = cb;
            state.writing = true;
            state.sync = true;
            if (state.destroyed)
              state.onwrite(new ERR_STREAM_DESTROYED("write"));
            else if (writev)
              stream._writev(chunk, state.onwrite);
            else
              stream._write(chunk, encoding, state.onwrite);
            state.sync = false;
          }
          function onwriteError(stream, state, sync, er, cb) {
            --state.pendingcb;
            if (sync) {
              process.nextTick(cb, er);
              process.nextTick(finishMaybe, stream, state);
              stream._writableState.errorEmitted = true;
              errorOrDestroy(stream, er);
            } else {
              cb(er);
              stream._writableState.errorEmitted = true;
              errorOrDestroy(stream, er);
              finishMaybe(stream, state);
            }
          }
          function onwriteStateUpdate(state) {
            state.writing = false;
            state.writecb = null;
            state.length -= state.writelen;
            state.writelen = 0;
          }
          function onwrite(stream, er) {
            var state = stream._writableState;
            var sync = state.sync;
            var cb = state.writecb;
            if (typeof cb !== "function")
              throw new ERR_MULTIPLE_CALLBACK();
            onwriteStateUpdate(state);
            if (er)
              onwriteError(stream, state, sync, er, cb);
            else {
              var finished = needFinish(state) || stream.destroyed;
              if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                clearBuffer(stream, state);
              }
              if (sync) {
                process.nextTick(afterWrite, stream, state, finished, cb);
              } else {
                afterWrite(stream, state, finished, cb);
              }
            }
          }
          function afterWrite(stream, state, finished, cb) {
            if (!finished)
              onwriteDrain(stream, state);
            state.pendingcb--;
            cb();
            finishMaybe(stream, state);
          }
          function onwriteDrain(stream, state) {
            if (state.length === 0 && state.needDrain) {
              state.needDrain = false;
              stream.emit("drain");
            }
          }
          function clearBuffer(stream, state) {
            state.bufferProcessing = true;
            var entry = state.bufferedRequest;
            if (stream._writev && entry && entry.next) {
              var l = state.bufferedRequestCount;
              var buffer = new Array(l);
              var holder = state.corkedRequestsFree;
              holder.entry = entry;
              var count = 0;
              var allBuffers = true;
              while (entry) {
                buffer[count] = entry;
                if (!entry.isBuf)
                  allBuffers = false;
                entry = entry.next;
                count += 1;
              }
              buffer.allBuffers = allBuffers;
              doWrite(stream, state, true, state.length, buffer, "", holder.finish);
              state.pendingcb++;
              state.lastBufferedRequest = null;
              if (holder.next) {
                state.corkedRequestsFree = holder.next;
                holder.next = null;
              } else {
                state.corkedRequestsFree = new CorkedRequest(state);
              }
              state.bufferedRequestCount = 0;
            } else {
              while (entry) {
                var chunk = entry.chunk;
                var encoding = entry.encoding;
                var cb = entry.callback;
                var len = state.objectMode ? 1 : chunk.length;
                doWrite(stream, state, false, len, chunk, encoding, cb);
                entry = entry.next;
                state.bufferedRequestCount--;
                if (state.writing) {
                  break;
                }
              }
              if (entry === null)
                state.lastBufferedRequest = null;
            }
            state.bufferedRequest = entry;
            state.bufferProcessing = false;
          }
          Writable.prototype._write = function(chunk, encoding, cb) {
            cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
          };
          Writable.prototype._writev = null;
          Writable.prototype.end = function(chunk, encoding, cb) {
            var state = this._writableState;
            if (typeof chunk === "function") {
              cb = chunk;
              chunk = null;
              encoding = null;
            } else if (typeof encoding === "function") {
              cb = encoding;
              encoding = null;
            }
            if (chunk !== null && chunk !== void 0)
              this.write(chunk, encoding);
            if (state.corked) {
              state.corked = 1;
              this.uncork();
            }
            if (!state.ending)
              endWritable(this, state, cb);
            return this;
          };
          Object.defineProperty(Writable.prototype, "writableLength", {
            enumerable: false,
            get: function get() {
              return this._writableState.length;
            }
          });
          function needFinish(state) {
            return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
          }
          function callFinal(stream, state) {
            stream._final(function(err) {
              state.pendingcb--;
              if (err) {
                errorOrDestroy(stream, err);
              }
              state.prefinished = true;
              stream.emit("prefinish");
              finishMaybe(stream, state);
            });
          }
          function prefinish(stream, state) {
            if (!state.prefinished && !state.finalCalled) {
              if (typeof stream._final === "function" && !state.destroyed) {
                state.pendingcb++;
                state.finalCalled = true;
                process.nextTick(callFinal, stream, state);
              } else {
                state.prefinished = true;
                stream.emit("prefinish");
              }
            }
          }
          function finishMaybe(stream, state) {
            var need = needFinish(state);
            if (need) {
              prefinish(stream, state);
              if (state.pendingcb === 0) {
                state.finished = true;
                stream.emit("finish");
                if (state.autoDestroy) {
                  var rState = stream._readableState;
                  if (!rState || rState.autoDestroy && rState.endEmitted) {
                    stream.destroy();
                  }
                }
              }
            }
            return need;
          }
          function endWritable(stream, state, cb) {
            state.ending = true;
            finishMaybe(stream, state);
            if (cb) {
              if (state.finished)
                process.nextTick(cb);
              else
                stream.once("finish", cb);
            }
            state.ended = true;
            stream.writable = false;
          }
          function onCorkedFinish(corkReq, state, err) {
            var entry = corkReq.entry;
            corkReq.entry = null;
            while (entry) {
              var cb = entry.callback;
              state.pendingcb--;
              cb(err);
              entry = entry.next;
            }
            state.corkedRequestsFree.next = corkReq;
          }
          Object.defineProperty(Writable.prototype, "destroyed", {
            enumerable: false,
            get: function get() {
              if (this._writableState === void 0) {
                return false;
              }
              return this._writableState.destroyed;
            },
            set: function set(value) {
              if (!this._writableState) {
                return;
              }
              this._writableState.destroyed = value;
            }
          });
          Writable.prototype.destroy = destroyImpl.destroy;
          Writable.prototype._undestroy = destroyImpl.undestroy;
          Writable.prototype._destroy = function(err, cb) {
            cb(err);
          };
        }).call(this);
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "../errors": 398, "./_stream_duplex": 399, "./internal/streams/destroy": 406, "./internal/streams/state": 410, "./internal/streams/stream": 411, "_process": 361, "buffer": 82, "inherits": 256, "util-deprecate": 511 }], 404: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          var _Object$setPrototypeO;
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var finished = require2("./end-of-stream");
          var kLastResolve = Symbol("lastResolve");
          var kLastReject = Symbol("lastReject");
          var kError = Symbol("error");
          var kEnded = Symbol("ended");
          var kLastPromise = Symbol("lastPromise");
          var kHandlePromise = Symbol("handlePromise");
          var kStream = Symbol("stream");
          function createIterResult(value, done) {
            return {
              value,
              done
            };
          }
          function readAndResolve(iter) {
            var resolve = iter[kLastResolve];
            if (resolve !== null) {
              var data = iter[kStream].read();
              if (data !== null) {
                iter[kLastPromise] = null;
                iter[kLastResolve] = null;
                iter[kLastReject] = null;
                resolve(createIterResult(data, false));
              }
            }
          }
          function onReadable(iter) {
            process.nextTick(readAndResolve, iter);
          }
          function wrapForNext(lastPromise, iter) {
            return function(resolve, reject) {
              lastPromise.then(function() {
                if (iter[kEnded]) {
                  resolve(createIterResult(void 0, true));
                  return;
                }
                iter[kHandlePromise](resolve, reject);
              }, reject);
            };
          }
          var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
          });
          var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
            get stream() {
              return this[kStream];
            },
            next: function next() {
              var _this = this;
              var error = this[kError];
              if (error !== null) {
                return Promise.reject(error);
              }
              if (this[kEnded]) {
                return Promise.resolve(createIterResult(void 0, true));
              }
              if (this[kStream].destroyed) {
                return new Promise(function(resolve, reject) {
                  process.nextTick(function() {
                    if (_this[kError]) {
                      reject(_this[kError]);
                    } else {
                      resolve(createIterResult(void 0, true));
                    }
                  });
                });
              }
              var lastPromise = this[kLastPromise];
              var promise;
              if (lastPromise) {
                promise = new Promise(wrapForNext(lastPromise, this));
              } else {
                var data = this[kStream].read();
                if (data !== null) {
                  return Promise.resolve(createIterResult(data, false));
                }
                promise = new Promise(this[kHandlePromise]);
              }
              this[kLastPromise] = promise;
              return promise;
            }
          }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
            return this;
          }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
            var _this2 = this;
            return new Promise(function(resolve, reject) {
              _this2[kStream].destroy(null, function(err) {
                if (err) {
                  reject(err);
                  return;
                }
                resolve(createIterResult(void 0, true));
              });
            });
          }), _Object$setPrototypeO), AsyncIteratorPrototype);
          var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
            var _Object$create;
            var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
              value: stream,
              writable: true
            }), _defineProperty(_Object$create, kLastResolve, {
              value: null,
              writable: true
            }), _defineProperty(_Object$create, kLastReject, {
              value: null,
              writable: true
            }), _defineProperty(_Object$create, kError, {
              value: null,
              writable: true
            }), _defineProperty(_Object$create, kEnded, {
              value: stream._readableState.endEmitted,
              writable: true
            }), _defineProperty(_Object$create, kHandlePromise, {
              value: function value(resolve, reject) {
                var data = iterator[kStream].read();
                if (data) {
                  iterator[kLastPromise] = null;
                  iterator[kLastResolve] = null;
                  iterator[kLastReject] = null;
                  resolve(createIterResult(data, false));
                } else {
                  iterator[kLastResolve] = resolve;
                  iterator[kLastReject] = reject;
                }
              },
              writable: true
            }), _Object$create));
            iterator[kLastPromise] = null;
            finished(stream, function(err) {
              if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var reject = iterator[kLastReject];
                if (reject !== null) {
                  iterator[kLastPromise] = null;
                  iterator[kLastResolve] = null;
                  iterator[kLastReject] = null;
                  reject(err);
                }
                iterator[kError] = err;
                return;
              }
              var resolve = iterator[kLastResolve];
              if (resolve !== null) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                resolve(createIterResult(void 0, true));
              }
              iterator[kEnded] = true;
            });
            stream.on("readable", onReadable.bind(null, iterator));
            return iterator;
          };
          module2.exports = createReadableStreamAsyncIterator;
        }).call(this);
      }).call(this, require2("_process"));
    }, { "./end-of-stream": 407, "_process": 361 }], 405: [function(require2, module2, exports2) {
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require2("buffer"), Buffer = _require.Buffer;
      var _require2 = require2("../../../../util/util.js"), inspect = _require2.inspect;
      var custom = inspect && inspect.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer.prototype.copy.call(src, target, offset);
      }
      module2.exports = /* @__PURE__ */ function() {
        function BufferList() {
          _classCallCheck(this, BufferList);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat(n) {
            if (this.length === 0)
              return Buffer.alloc(0);
            var ret = Buffer.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect(this, _objectSpread({}, options, {
              depth: 0,
              customInspect: false
            }));
          }
        }]);
        return BufferList;
      }();
    }, { "../../../../util/util.js": 514, "buffer": 82 }], 406: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          function destroy(err, cb) {
            var _this = this;
            var readableDestroyed = this._readableState && this._readableState.destroyed;
            var writableDestroyed = this._writableState && this._writableState.destroyed;
            if (readableDestroyed || writableDestroyed) {
              if (cb) {
                cb(err);
              } else if (err) {
                if (!this._writableState) {
                  process.nextTick(emitErrorNT, this, err);
                } else if (!this._writableState.errorEmitted) {
                  this._writableState.errorEmitted = true;
                  process.nextTick(emitErrorNT, this, err);
                }
              }
              return this;
            }
            if (this._readableState) {
              this._readableState.destroyed = true;
            }
            if (this._writableState) {
              this._writableState.destroyed = true;
            }
            this._destroy(err || null, function(err2) {
              if (!cb && err2) {
                if (!_this._writableState) {
                  process.nextTick(emitErrorAndCloseNT, _this, err2);
                } else if (!_this._writableState.errorEmitted) {
                  _this._writableState.errorEmitted = true;
                  process.nextTick(emitErrorAndCloseNT, _this, err2);
                } else {
                  process.nextTick(emitCloseNT, _this);
                }
              } else if (cb) {
                process.nextTick(emitCloseNT, _this);
                cb(err2);
              } else {
                process.nextTick(emitCloseNT, _this);
              }
            });
            return this;
          }
          function emitErrorAndCloseNT(self2, err) {
            emitErrorNT(self2, err);
            emitCloseNT(self2);
          }
          function emitCloseNT(self2) {
            if (self2._writableState && !self2._writableState.emitClose)
              return;
            if (self2._readableState && !self2._readableState.emitClose)
              return;
            self2.emit("close");
          }
          function undestroy() {
            if (this._readableState) {
              this._readableState.destroyed = false;
              this._readableState.reading = false;
              this._readableState.ended = false;
              this._readableState.endEmitted = false;
            }
            if (this._writableState) {
              this._writableState.destroyed = false;
              this._writableState.ended = false;
              this._writableState.ending = false;
              this._writableState.finalCalled = false;
              this._writableState.prefinished = false;
              this._writableState.finished = false;
              this._writableState.errorEmitted = false;
            }
          }
          function emitErrorNT(self2, err) {
            self2.emit("error", err);
          }
          function errorOrDestroy(stream, err) {
            var rState = stream._readableState;
            var wState = stream._writableState;
            if (rState && rState.autoDestroy || wState && wState.autoDestroy)
              stream.destroy(err);
            else
              stream.emit("error", err);
          }
          module2.exports = {
            destroy,
            undestroy,
            errorOrDestroy
          };
        }).call(this);
      }).call(this, require2("_process"));
    }, { "_process": 361 }], 407: [function(require2, module2, exports2) {
      var ERR_STREAM_PREMATURE_CLOSE = require2("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
      function once(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once(callback || noop);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend = function onend2() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module2.exports = eos;
    }, { "../../../errors": 398 }], 408: [function(require2, module2, exports2) {
      module2.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }, {}], 409: [function(require2, module2, exports2) {
      var eos;
      function once(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require2("../../../errors").codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require2("./end-of-stream");
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from, to) {
        return from.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop;
        if (typeof streams[streams.length - 1] !== "function")
          return noop;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error)
              error = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error);
          });
        });
        return streams.reduce(pipe);
      }
      module2.exports = pipeline;
    }, { "../../../errors": 398, "./end-of-stream": 407 }], 410: [function(require2, module2, exports2) {
      var ERR_INVALID_OPT_VALUE = require2("../../../errors").codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module2.exports = {
        getHighWaterMark
      };
    }, { "../../../errors": 398 }], 411: [function(require2, module2, exports2) {
      arguments[4][104][0].apply(exports2, arguments);
    }, { "dup": 104, "events": 193 }], 412: [function(require2, module2, exports2) {
      exports2 = module2.exports = require2("./lib/_stream_readable.js");
      exports2.Stream = exports2;
      exports2.Readable = exports2;
      exports2.Writable = require2("./lib/_stream_writable.js");
      exports2.Duplex = require2("./lib/_stream_duplex.js");
      exports2.Transform = require2("./lib/_stream_transform.js");
      exports2.PassThrough = require2("./lib/_stream_passthrough.js");
      exports2.finished = require2("./lib/internal/streams/end-of-stream.js");
      exports2.pipeline = require2("./lib/internal/streams/pipeline.js");
    }, { "./lib/_stream_duplex.js": 399, "./lib/_stream_passthrough.js": 400, "./lib/_stream_readable.js": 401, "./lib/_stream_transform.js": 402, "./lib/_stream_writable.js": 403, "./lib/internal/streams/end-of-stream.js": 407, "./lib/internal/streams/pipeline.js": 409 }], 413: [function(require2, module2, exports2) {
      /*! *****************************************************************************
      	Copyright (c) Microsoft Corporation. All rights reserved.
      	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
      	this file except in compliance with the License. You may obtain a copy of the
      	License at http://www.apache.org/licenses/LICENSE-2.0
      
      	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
      	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
      	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
      	MERCHANTABLITY OR NON-INFRINGEMENT.
      
      	See the Apache Version 2.0 License for specific language governing permissions
      	and limitations under the License.
      	***************************************************************************** */
      var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) {
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
          }
        };
        return _extendStatics(d, b);
      };
      function __extends(d, b) {
        _extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      }
      function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
          return m.call(o);
        return {
          next: function next() {
            if (o && i >= o.length)
              o = void 0;
            return {
              value: o && o[i++],
              done: !o
            };
          }
        };
      }
      function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
            ar.push(r.value);
          }
        } catch (error) {
          e = {
            error
          };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      }
      function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++) {
          ar = ar.concat(__read(arguments[i]));
        }
        return ar;
      }
      var Event = function() {
        function Event2(type, target) {
          this.target = target;
          this.type = type;
        }
        return Event2;
      }();
      var ErrorEvent = function(_super) {
        __extends(ErrorEvent2, _super);
        function ErrorEvent2(error, target) {
          var _this = _super.call(this, "error", target) || this;
          _this.message = error.message;
          _this.error = error;
          return _this;
        }
        return ErrorEvent2;
      }(Event);
      var CloseEvent = function(_super) {
        __extends(CloseEvent2, _super);
        function CloseEvent2(code, reason, target) {
          if (code === void 0) {
            code = 1e3;
          }
          if (reason === void 0) {
            reason = "";
          }
          var _this = _super.call(this, "close", target) || this;
          _this.wasClean = true;
          _this.code = code;
          _this.reason = reason;
          return _this;
        }
        return CloseEvent2;
      }(Event);
      /*!
       * Reconnecting WebSocket
       * by Pedro Ladaria <pedro.ladaria@gmail.com>
       * https://github.com/pladaria/reconnecting-websocket
       * License MIT
       */
      var getGlobalWebSocket = function getGlobalWebSocket2() {
        if (typeof WebSocket !== "undefined") {
          return WebSocket;
        }
      };
      var isWebSocket = function isWebSocket2(w) {
        return typeof w !== "undefined" && !!w && w.CLOSING === 2;
      };
      var DEFAULT = {
        maxReconnectionDelay: 1e4,
        minReconnectionDelay: 1e3 + Math.random() * 4e3,
        minUptime: 5e3,
        reconnectionDelayGrowFactor: 1.3,
        connectionTimeout: 4e3,
        maxRetries: Infinity,
        maxEnqueuedMessages: Infinity,
        startClosed: false,
        debug: false
      };
      var ReconnectingWebSocket = function() {
        function ReconnectingWebSocket2(url, protocols, options) {
          var _this = this;
          if (options === void 0) {
            options = {};
          }
          this._listeners = {
            error: [],
            message: [],
            open: [],
            close: []
          };
          this._retryCount = -1;
          this._shouldReconnect = true;
          this._connectLock = false;
          this._binaryType = "blob";
          this._closeCalled = false;
          this._messageQueue = [];
          this.onclose = null;
          this.onerror = null;
          this.onmessage = null;
          this.onopen = null;
          this._handleOpen = function(event) {
            _this._debug("open event");
            var _a = _this._options.minUptime, minUptime = _a === void 0 ? DEFAULT.minUptime : _a;
            clearTimeout(_this._connectTimeout);
            _this._uptimeTimeout = setTimeout(function() {
              return _this._acceptOpen();
            }, minUptime);
            _this._ws.binaryType = _this._binaryType;
            _this._messageQueue.forEach(function(message) {
              return _this._ws.send(message);
            });
            _this._messageQueue = [];
            if (_this.onopen) {
              _this.onopen(event);
            }
            _this._listeners.open.forEach(function(listener) {
              return _this._callEventListener(event, listener);
            });
          };
          this._handleMessage = function(event) {
            _this._debug("message event");
            if (_this.onmessage) {
              _this.onmessage(event);
            }
            _this._listeners.message.forEach(function(listener) {
              return _this._callEventListener(event, listener);
            });
          };
          this._handleError = function(event) {
            _this._debug("error event", event.message);
            _this._disconnect(void 0, event.message === "TIMEOUT" ? "timeout" : void 0);
            if (_this.onerror) {
              _this.onerror(event);
            }
            _this._debug("exec error listeners");
            _this._listeners.error.forEach(function(listener) {
              return _this._callEventListener(event, listener);
            });
            _this._connect();
          };
          this._handleClose = function(event) {
            _this._debug("close event");
            _this._clearTimeouts();
            if (_this._shouldReconnect) {
              _this._connect();
            }
            if (_this.onclose) {
              _this.onclose(event);
            }
            _this._listeners.close.forEach(function(listener) {
              return _this._callEventListener(event, listener);
            });
          };
          this._url = url;
          this._protocols = protocols;
          this._options = options;
          if (this._options.startClosed) {
            this._shouldReconnect = false;
          }
          this._connect();
        }
        Object.defineProperty(ReconnectingWebSocket2, "CONNECTING", {
          get: function get() {
            return 0;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(ReconnectingWebSocket2, "OPEN", {
          get: function get() {
            return 1;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(ReconnectingWebSocket2, "CLOSING", {
          get: function get() {
            return 2;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(ReconnectingWebSocket2, "CLOSED", {
          get: function get() {
            return 3;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(ReconnectingWebSocket2.prototype, "CONNECTING", {
          get: function get() {
            return ReconnectingWebSocket2.CONNECTING;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(ReconnectingWebSocket2.prototype, "OPEN", {
          get: function get() {
            return ReconnectingWebSocket2.OPEN;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(ReconnectingWebSocket2.prototype, "CLOSING", {
          get: function get() {
            return ReconnectingWebSocket2.CLOSING;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(ReconnectingWebSocket2.prototype, "CLOSED", {
          get: function get() {
            return ReconnectingWebSocket2.CLOSED;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(ReconnectingWebSocket2.prototype, "binaryType", {
          get: function get() {
            return this._ws ? this._ws.binaryType : this._binaryType;
          },
          set: function set(value) {
            this._binaryType = value;
            if (this._ws) {
              this._ws.binaryType = value;
            }
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(ReconnectingWebSocket2.prototype, "retryCount", {
          get: function get() {
            return Math.max(this._retryCount, 0);
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(ReconnectingWebSocket2.prototype, "bufferedAmount", {
          get: function get() {
            var bytes = this._messageQueue.reduce(function(acc, message) {
              if (typeof message === "string") {
                acc += message.length;
              } else if (message instanceof Blob) {
                acc += message.size;
              } else {
                acc += message.byteLength;
              }
              return acc;
            }, 0);
            return bytes + (this._ws ? this._ws.bufferedAmount : 0);
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(ReconnectingWebSocket2.prototype, "extensions", {
          get: function get() {
            return this._ws ? this._ws.extensions : "";
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(ReconnectingWebSocket2.prototype, "protocol", {
          get: function get() {
            return this._ws ? this._ws.protocol : "";
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(ReconnectingWebSocket2.prototype, "readyState", {
          get: function get() {
            if (this._ws) {
              return this._ws.readyState;
            }
            return this._options.startClosed ? ReconnectingWebSocket2.CLOSED : ReconnectingWebSocket2.CONNECTING;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(ReconnectingWebSocket2.prototype, "url", {
          get: function get() {
            return this._ws ? this._ws.url : "";
          },
          enumerable: true,
          configurable: true
        });
        ReconnectingWebSocket2.prototype.close = function(code, reason) {
          if (code === void 0) {
            code = 1e3;
          }
          this._closeCalled = true;
          this._shouldReconnect = false;
          this._clearTimeouts();
          if (!this._ws) {
            this._debug("close enqueued: no ws instance");
            return;
          }
          if (this._ws.readyState === this.CLOSED) {
            this._debug("close: already closed");
            return;
          }
          this._ws.close(code, reason);
        };
        ReconnectingWebSocket2.prototype.reconnect = function(code, reason) {
          this._shouldReconnect = true;
          this._closeCalled = false;
          this._retryCount = -1;
          if (!this._ws || this._ws.readyState === this.CLOSED) {
            this._connect();
          } else {
            this._disconnect(code, reason);
            this._connect();
          }
        };
        ReconnectingWebSocket2.prototype.send = function(data) {
          if (this._ws && this._ws.readyState === this.OPEN) {
            this._debug("send", data);
            this._ws.send(data);
          } else {
            var _a = this._options.maxEnqueuedMessages, maxEnqueuedMessages = _a === void 0 ? DEFAULT.maxEnqueuedMessages : _a;
            if (this._messageQueue.length < maxEnqueuedMessages) {
              this._debug("enqueue", data);
              this._messageQueue.push(data);
            }
          }
        };
        ReconnectingWebSocket2.prototype.addEventListener = function(type, listener) {
          if (this._listeners[type]) {
            this._listeners[type].push(listener);
          }
        };
        ReconnectingWebSocket2.prototype.dispatchEvent = function(event) {
          var e_1, _a;
          var listeners = this._listeners[event.type];
          if (listeners) {
            try {
              for (var listeners_1 = __values(listeners), listeners_1_1 = listeners_1.next(); !listeners_1_1.done; listeners_1_1 = listeners_1.next()) {
                var listener = listeners_1_1.value;
                this._callEventListener(event, listener);
              }
            } catch (e_1_1) {
              e_1 = {
                error: e_1_1
              };
            } finally {
              try {
                if (listeners_1_1 && !listeners_1_1.done && (_a = listeners_1.return))
                  _a.call(listeners_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          }
          return true;
        };
        ReconnectingWebSocket2.prototype.removeEventListener = function(type, listener) {
          if (this._listeners[type]) {
            this._listeners[type] = this._listeners[type].filter(function(l) {
              return l !== listener;
            });
          }
        };
        ReconnectingWebSocket2.prototype._debug = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (this._options.debug) {
            console.log.apply(console, __spread(["RWS>"], args));
          }
        };
        ReconnectingWebSocket2.prototype._getNextDelay = function() {
          var _a = this._options, _b = _a.reconnectionDelayGrowFactor, reconnectionDelayGrowFactor = _b === void 0 ? DEFAULT.reconnectionDelayGrowFactor : _b, _c = _a.minReconnectionDelay, minReconnectionDelay = _c === void 0 ? DEFAULT.minReconnectionDelay : _c, _d = _a.maxReconnectionDelay, maxReconnectionDelay = _d === void 0 ? DEFAULT.maxReconnectionDelay : _d;
          var delay = 0;
          if (this._retryCount > 0) {
            delay = minReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);
            if (delay > maxReconnectionDelay) {
              delay = maxReconnectionDelay;
            }
          }
          this._debug("next delay", delay);
          return delay;
        };
        ReconnectingWebSocket2.prototype._wait = function() {
          var _this = this;
          return new Promise(function(resolve) {
            setTimeout(resolve, _this._getNextDelay());
          });
        };
        ReconnectingWebSocket2.prototype._getNextUrl = function(urlProvider) {
          if (typeof urlProvider === "string") {
            return Promise.resolve(urlProvider);
          }
          if (typeof urlProvider === "function") {
            var url = urlProvider();
            if (typeof url === "string") {
              return Promise.resolve(url);
            }
            if (!!url.then) {
              return url;
            }
          }
          throw Error("Invalid URL");
        };
        ReconnectingWebSocket2.prototype._connect = function() {
          var _this = this;
          if (this._connectLock || !this._shouldReconnect) {
            return;
          }
          this._connectLock = true;
          var _a = this._options, _b = _a.maxRetries, maxRetries = _b === void 0 ? DEFAULT.maxRetries : _b, _c = _a.connectionTimeout, connectionTimeout = _c === void 0 ? DEFAULT.connectionTimeout : _c, _d = _a.WebSocket, WebSocket2 = _d === void 0 ? getGlobalWebSocket() : _d;
          if (this._retryCount >= maxRetries) {
            this._debug("max retries reached", this._retryCount, ">=", maxRetries);
            return;
          }
          this._retryCount++;
          this._debug("connect", this._retryCount);
          this._removeListeners();
          if (!isWebSocket(WebSocket2)) {
            throw Error("No valid WebSocket class provided");
          }
          this._wait().then(function() {
            return _this._getNextUrl(_this._url);
          }).then(function(url) {
            if (_this._closeCalled) {
              return;
            }
            _this._debug("connect", {
              url,
              protocols: _this._protocols
            });
            _this._ws = _this._protocols ? new WebSocket2(url, _this._protocols) : new WebSocket2(url);
            _this._ws.binaryType = _this._binaryType;
            _this._connectLock = false;
            _this._addListeners();
            _this._connectTimeout = setTimeout(function() {
              return _this._handleTimeout();
            }, connectionTimeout);
          });
        };
        ReconnectingWebSocket2.prototype._handleTimeout = function() {
          this._debug("timeout event");
          this._handleError(new ErrorEvent(Error("TIMEOUT"), this));
        };
        ReconnectingWebSocket2.prototype._disconnect = function(code, reason) {
          if (code === void 0) {
            code = 1e3;
          }
          this._clearTimeouts();
          if (!this._ws) {
            return;
          }
          this._removeListeners();
          try {
            this._ws.close(code, reason);
            this._handleClose(new CloseEvent(code, reason, this));
          } catch (error) {
          }
        };
        ReconnectingWebSocket2.prototype._acceptOpen = function() {
          this._debug("accept open");
          this._retryCount = 0;
        };
        ReconnectingWebSocket2.prototype._callEventListener = function(event, listener) {
          if ("handleEvent" in listener) {
            listener.handleEvent(event);
          } else {
            listener(event);
          }
        };
        ReconnectingWebSocket2.prototype._removeListeners = function() {
          if (!this._ws) {
            return;
          }
          this._debug("removeListeners");
          this._ws.removeEventListener("open", this._handleOpen);
          this._ws.removeEventListener("close", this._handleClose);
          this._ws.removeEventListener("message", this._handleMessage);
          this._ws.removeEventListener("error", this._handleError);
        };
        ReconnectingWebSocket2.prototype._addListeners = function() {
          if (!this._ws) {
            return;
          }
          this._debug("addListeners");
          this._ws.addEventListener("open", this._handleOpen);
          this._ws.addEventListener("close", this._handleClose);
          this._ws.addEventListener("message", this._handleMessage);
          this._ws.addEventListener("error", this._handleError);
        };
        ReconnectingWebSocket2.prototype._clearTimeouts = function() {
          clearTimeout(this._connectTimeout);
          clearTimeout(this._uptimeTimeout);
        };
        return ReconnectingWebSocket2;
      }();
      module2.exports = ReconnectingWebSocket;
    }, {}], 414: [function(require2, module2, exports2) {
      var TOS = require2("time-ordered-set");
      class Entry {
        constructor(pool, key, val) {
          this.pool = pool;
          this.prev = null;
          this.next = null;
          this.key = key;
          this.value = val;
          this.refs = 0;
        }
        bump() {
          if (this.refs > 0)
            return;
          this.pool.gcable.add(this);
          this.pool._gcMaybe();
        }
        delete() {
          this.pool.gcable.remove(this);
          this.pool.entries.delete(this.key);
          if (this.pool.close)
            this.pool.close(this.value);
        }
        increment() {
          this.refs++;
          if (this.refs === 1) {
            this.pool.gcable.remove(this);
          }
          this.pool._gcMaybe();
        }
        decrement() {
          this.refs--;
          if (this.refs === 0) {
            this.pool.gcable.add(this);
            this.pool._gcMaybe();
          }
          this.pool._gcMaybe();
        }
      }
      module2.exports = class Pool {
        constructor() {
          var {
            maxSize = Infinity,
            close
          } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          this.maxSize = maxSize;
          this.close = close;
          this.gcable = new TOS();
          this.entries = /* @__PURE__ */ new Map();
        }
        get size() {
          return this.entries.size;
        }
        isFull() {
          return this.entries.size < this.maxSize;
        }
        entry(key) {
          return this.entries.get(key);
        }
        get(key) {
          var bump = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var entry = this.entry(key);
          if (!entry)
            return;
          if (bump)
            entry.bump();
          return entry.value;
        }
        delete(key) {
          var e = this.entry(key);
          if (e)
            e.delete();
        }
        add(val) {
          var forceGC = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          return this.set(val, val, forceGC);
        }
        has(key) {
          return this.entries.has(key);
        }
        set(key, val) {
          var forceGC = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          var existing = this.entries.get(key);
          if (existing) {
            existing.bump();
            existing.value = val;
            return existing;
          }
          var entry = new Entry(this, key, val);
          this.gcable.add(entry);
          this.entries.set(key, entry);
          this._gcMaybe(!forceGC);
          return entry;
        }
        gc() {
          var oldest = this.gcable.oldest;
          if (!oldest)
            return null;
          oldest.delete();
          return oldest.value;
        }
        _gcMaybe() {
          var allowOne = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
          if (this.gcable.length === 1 && allowOne)
            return;
          if (this.entries.size <= this.maxSize && this.close)
            return;
          this.gc();
        }
        increment(key) {
          var e = this.entry(key);
          if (e)
            e.increment();
        }
        decrement(key) {
          var e = this.entry(key);
          if (e)
            e.decrement();
        }
        bump(key) {
          var e = this.entry(key);
          if (e)
            e.bump();
        }
      };
    }, { "time-ordered-set": 504 }], 415: [function(require2, module2, exports2) {
      function reusify(Constructor) {
        var head = new Constructor();
        var tail = head;
        function get() {
          var current = head;
          if (current.next) {
            head = current.next;
          } else {
            head = new Constructor();
            tail = head;
          }
          current.next = null;
          return current;
        }
        function release(obj) {
          tail.next = obj;
          tail = obj;
        }
        return {
          get,
          release
        };
      }
      module2.exports = reusify;
    }, {}], 416: [function(require2, module2, exports2) {
      var Buffer = require2("buffer").Buffer;
      var inherits = require2("inherits");
      var HashBase = require2("hash-base");
      var ARRAY16 = new Array(16);
      var zl = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
      var zr = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
      var sl = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
      var sr = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
      var hl = [0, 1518500249, 1859775393, 2400959708, 2840853838];
      var hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
      function RIPEMD160() {
        HashBase.call(this, 64);
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
        this._e = 3285377520;
      }
      inherits(RIPEMD160, HashBase);
      RIPEMD160.prototype._update = function() {
        var words = ARRAY16;
        for (var j = 0; j < 16; ++j) {
          words[j] = this._block.readInt32LE(j * 4);
        }
        var al = this._a | 0;
        var bl = this._b | 0;
        var cl = this._c | 0;
        var dl = this._d | 0;
        var el = this._e | 0;
        var ar = this._a | 0;
        var br = this._b | 0;
        var cr = this._c | 0;
        var dr = this._d | 0;
        var er = this._e | 0;
        for (var i = 0; i < 80; i += 1) {
          var tl;
          var tr;
          if (i < 16) {
            tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
            tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
          } else if (i < 32) {
            tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
            tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
          } else if (i < 48) {
            tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
            tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
          } else if (i < 64) {
            tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
            tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
          } else {
            tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
            tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
          }
          al = el;
          el = dl;
          dl = rotl(cl, 10);
          cl = bl;
          bl = tl;
          ar = er;
          er = dr;
          dr = rotl(cr, 10);
          cr = br;
          br = tr;
        }
        var t = this._b + cl + dr | 0;
        this._b = this._c + dl + er | 0;
        this._c = this._d + el + ar | 0;
        this._d = this._e + al + br | 0;
        this._e = this._a + bl + cr | 0;
        this._a = t;
      };
      RIPEMD160.prototype._digest = function() {
        this._block[this._blockOffset++] = 128;
        if (this._blockOffset > 56) {
          this._block.fill(0, this._blockOffset, 64);
          this._update();
          this._blockOffset = 0;
        }
        this._block.fill(0, this._blockOffset, 56);
        this._block.writeUInt32LE(this._length[0], 56);
        this._block.writeUInt32LE(this._length[1], 60);
        this._update();
        var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20);
        buffer.writeInt32LE(this._a, 0);
        buffer.writeInt32LE(this._b, 4);
        buffer.writeInt32LE(this._c, 8);
        buffer.writeInt32LE(this._d, 12);
        buffer.writeInt32LE(this._e, 16);
        return buffer;
      };
      function rotl(x, n) {
        return x << n | x >>> 32 - n;
      }
      function fn1(a, b, c, d, e, m, k, s) {
        return rotl(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;
      }
      function fn2(a, b, c, d, e, m, k, s) {
        return rotl(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;
      }
      function fn3(a, b, c, d, e, m, k, s) {
        return rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;
      }
      function fn4(a, b, c, d, e, m, k, s) {
        return rotl(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;
      }
      function fn5(a, b, c, d, e, m, k, s) {
        return rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;
      }
      module2.exports = RIPEMD160;
    }, { "buffer": 82, "hash-base": 210, "inherits": 256 }], 417: [function(require2, module2, exports2) {
      /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
      var buffer = require2("buffer");
      var Buffer = buffer.Buffer;
      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }
      if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
        module2.exports = buffer;
      } else {
        copyProps(buffer, exports2);
        exports2.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer(arg, encodingOrOffset, length);
      }
      SafeBuffer.prototype = Object.create(Buffer.prototype);
      copyProps(Buffer, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer(size);
        if (fill !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer.SlowBuffer(size);
      };
    }, { "buffer": 82 }], 418: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          var buffer = require2("buffer");
          var Buffer = buffer.Buffer;
          var safer = {};
          var key;
          for (key in buffer) {
            if (!buffer.hasOwnProperty(key))
              continue;
            if (key === "SlowBuffer" || key === "Buffer")
              continue;
            safer[key] = buffer[key];
          }
          var Safer = safer.Buffer = {};
          for (key in Buffer) {
            if (!Buffer.hasOwnProperty(key))
              continue;
            if (key === "allocUnsafe" || key === "allocUnsafeSlow")
              continue;
            Safer[key] = Buffer[key];
          }
          safer.Buffer.prototype = Buffer.prototype;
          if (!Safer.from || Safer.from === Uint8Array.from) {
            Safer.from = function(value, encodingOrOffset, length) {
              if (typeof value === "number") {
                throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
              }
              if (value && typeof value.length === "undefined") {
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
              }
              return Buffer(value, encodingOrOffset, length);
            };
          }
          if (!Safer.alloc) {
            Safer.alloc = function(size, fill, encoding) {
              if (typeof size !== "number") {
                throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
              }
              if (size < 0 || size >= 2 * (1 << 30)) {
                throw new RangeError('The value "' + size + '" is invalid for option "size"');
              }
              var buf = Buffer(size);
              if (!fill || fill.length === 0) {
                buf.fill(0);
              } else if (typeof encoding === "string") {
                buf.fill(fill, encoding);
              } else {
                buf.fill(fill);
              }
              return buf;
            };
          }
          if (!safer.kStringMaxLength) {
            try {
              safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
            } catch (e) {
            }
          }
          if (!safer.constants) {
            safer.constants = {
              MAX_LENGTH: safer.kMaxLength
            };
            if (safer.kStringMaxLength) {
              safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
            }
          }
          module2.exports = safer;
        }).call(this);
      }).call(this, require2("_process"));
    }, { "_process": 361, "buffer": 82 }], 419: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      function Hash(blockSize, finalSize) {
        this._block = Buffer.alloc(blockSize);
        this._finalSize = finalSize;
        this._blockSize = blockSize;
        this._len = 0;
      }
      Hash.prototype.update = function(data, enc) {
        if (typeof data === "string") {
          enc = enc || "utf8";
          data = Buffer.from(data, enc);
        }
        var block = this._block;
        var blockSize = this._blockSize;
        var length = data.length;
        var accum = this._len;
        for (var offset = 0; offset < length; ) {
          var assigned = accum % blockSize;
          var remainder = Math.min(length - offset, blockSize - assigned);
          for (var i = 0; i < remainder; i++) {
            block[assigned + i] = data[offset + i];
          }
          accum += remainder;
          offset += remainder;
          if (accum % blockSize === 0) {
            this._update(block);
          }
        }
        this._len += length;
        return this;
      };
      Hash.prototype.digest = function(enc) {
        var rem = this._len % this._blockSize;
        this._block[rem] = 128;
        this._block.fill(0, rem + 1);
        if (rem >= this._finalSize) {
          this._update(this._block);
          this._block.fill(0);
        }
        var bits = this._len * 8;
        if (bits <= 4294967295) {
          this._block.writeUInt32BE(bits, this._blockSize - 4);
        } else {
          var lowBits = (bits & 4294967295) >>> 0;
          var highBits = (bits - lowBits) / 4294967296;
          this._block.writeUInt32BE(highBits, this._blockSize - 8);
          this._block.writeUInt32BE(lowBits, this._blockSize - 4);
        }
        this._update(this._block);
        var hash = this._hash();
        return enc ? hash.toString(enc) : hash;
      };
      Hash.prototype._update = function() {
        throw new Error("_update must be implemented by subclass");
      };
      module2.exports = Hash;
    }, { "safe-buffer": 417 }], 420: [function(require2, module2, exports2) {
      var _exports = module2.exports = function SHA(algorithm) {
        algorithm = algorithm.toLowerCase();
        var Algorithm = _exports[algorithm];
        if (!Algorithm)
          throw new Error(algorithm + " is not supported (we accept pull requests)");
        return new Algorithm();
      };
      _exports.sha = require2("./sha");
      _exports.sha1 = require2("./sha1");
      _exports.sha224 = require2("./sha224");
      _exports.sha256 = require2("./sha256");
      _exports.sha384 = require2("./sha384");
      _exports.sha512 = require2("./sha512");
    }, { "./sha": 421, "./sha1": 422, "./sha224": 423, "./sha256": 424, "./sha384": 425, "./sha512": 426 }], 421: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Hash = require2("./hash");
      var Buffer = require2("safe-buffer").Buffer;
      var K = [1518500249, 1859775393, 2400959708 | 0, 3395469782 | 0];
      var W = new Array(80);
      function Sha() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
      }
      inherits(Sha, Hash);
      Sha.prototype.init = function() {
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
        this._e = 3285377520;
        return this;
      };
      function rotl5(num) {
        return num << 5 | num >>> 27;
      }
      function rotl30(num) {
        return num << 30 | num >>> 2;
      }
      function ft(s, b, c, d) {
        if (s === 0)
          return b & c | ~b & d;
        if (s === 2)
          return b & c | b & d | c & d;
        return b ^ c ^ d;
      }
      Sha.prototype._update = function(M) {
        var W2 = this._w;
        var a = this._a | 0;
        var b = this._b | 0;
        var c = this._c | 0;
        var d = this._d | 0;
        var e = this._e | 0;
        for (var i = 0; i < 16; ++i) {
          W2[i] = M.readInt32BE(i * 4);
        }
        for (; i < 80; ++i) {
          W2[i] = W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16];
        }
        for (var j = 0; j < 80; ++j) {
          var s = ~~(j / 20);
          var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
          e = d;
          d = c;
          c = rotl30(b);
          b = a;
          a = t;
        }
        this._a = a + this._a | 0;
        this._b = b + this._b | 0;
        this._c = c + this._c | 0;
        this._d = d + this._d | 0;
        this._e = e + this._e | 0;
      };
      Sha.prototype._hash = function() {
        var H = Buffer.allocUnsafe(20);
        H.writeInt32BE(this._a | 0, 0);
        H.writeInt32BE(this._b | 0, 4);
        H.writeInt32BE(this._c | 0, 8);
        H.writeInt32BE(this._d | 0, 12);
        H.writeInt32BE(this._e | 0, 16);
        return H;
      };
      module2.exports = Sha;
    }, { "./hash": 419, "inherits": 256, "safe-buffer": 417 }], 422: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Hash = require2("./hash");
      var Buffer = require2("safe-buffer").Buffer;
      var K = [1518500249, 1859775393, 2400959708 | 0, 3395469782 | 0];
      var W = new Array(80);
      function Sha1() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
      }
      inherits(Sha1, Hash);
      Sha1.prototype.init = function() {
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
        this._e = 3285377520;
        return this;
      };
      function rotl1(num) {
        return num << 1 | num >>> 31;
      }
      function rotl5(num) {
        return num << 5 | num >>> 27;
      }
      function rotl30(num) {
        return num << 30 | num >>> 2;
      }
      function ft(s, b, c, d) {
        if (s === 0)
          return b & c | ~b & d;
        if (s === 2)
          return b & c | b & d | c & d;
        return b ^ c ^ d;
      }
      Sha1.prototype._update = function(M) {
        var W2 = this._w;
        var a = this._a | 0;
        var b = this._b | 0;
        var c = this._c | 0;
        var d = this._d | 0;
        var e = this._e | 0;
        for (var i = 0; i < 16; ++i) {
          W2[i] = M.readInt32BE(i * 4);
        }
        for (; i < 80; ++i) {
          W2[i] = rotl1(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16]);
        }
        for (var j = 0; j < 80; ++j) {
          var s = ~~(j / 20);
          var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
          e = d;
          d = c;
          c = rotl30(b);
          b = a;
          a = t;
        }
        this._a = a + this._a | 0;
        this._b = b + this._b | 0;
        this._c = c + this._c | 0;
        this._d = d + this._d | 0;
        this._e = e + this._e | 0;
      };
      Sha1.prototype._hash = function() {
        var H = Buffer.allocUnsafe(20);
        H.writeInt32BE(this._a | 0, 0);
        H.writeInt32BE(this._b | 0, 4);
        H.writeInt32BE(this._c | 0, 8);
        H.writeInt32BE(this._d | 0, 12);
        H.writeInt32BE(this._e | 0, 16);
        return H;
      };
      module2.exports = Sha1;
    }, { "./hash": 419, "inherits": 256, "safe-buffer": 417 }], 423: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Sha256 = require2("./sha256");
      var Hash = require2("./hash");
      var Buffer = require2("safe-buffer").Buffer;
      var W = new Array(64);
      function Sha224() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
      }
      inherits(Sha224, Sha256);
      Sha224.prototype.init = function() {
        this._a = 3238371032;
        this._b = 914150663;
        this._c = 812702999;
        this._d = 4144912697;
        this._e = 4290775857;
        this._f = 1750603025;
        this._g = 1694076839;
        this._h = 3204075428;
        return this;
      };
      Sha224.prototype._hash = function() {
        var H = Buffer.allocUnsafe(28);
        H.writeInt32BE(this._a, 0);
        H.writeInt32BE(this._b, 4);
        H.writeInt32BE(this._c, 8);
        H.writeInt32BE(this._d, 12);
        H.writeInt32BE(this._e, 16);
        H.writeInt32BE(this._f, 20);
        H.writeInt32BE(this._g, 24);
        return H;
      };
      module2.exports = Sha224;
    }, { "./hash": 419, "./sha256": 424, "inherits": 256, "safe-buffer": 417 }], 424: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Hash = require2("./hash");
      var Buffer = require2("safe-buffer").Buffer;
      var K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
      var W = new Array(64);
      function Sha256() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
      }
      inherits(Sha256, Hash);
      Sha256.prototype.init = function() {
        this._a = 1779033703;
        this._b = 3144134277;
        this._c = 1013904242;
        this._d = 2773480762;
        this._e = 1359893119;
        this._f = 2600822924;
        this._g = 528734635;
        this._h = 1541459225;
        return this;
      };
      function ch(x, y, z) {
        return z ^ x & (y ^ z);
      }
      function maj(x, y, z) {
        return x & y | z & (x | y);
      }
      function sigma0(x) {
        return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
      }
      function sigma1(x) {
        return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
      }
      function gamma0(x) {
        return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
      }
      function gamma1(x) {
        return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
      }
      Sha256.prototype._update = function(M) {
        var W2 = this._w;
        var a = this._a | 0;
        var b = this._b | 0;
        var c = this._c | 0;
        var d = this._d | 0;
        var e = this._e | 0;
        var f = this._f | 0;
        var g = this._g | 0;
        var h = this._h | 0;
        for (var i = 0; i < 16; ++i) {
          W2[i] = M.readInt32BE(i * 4);
        }
        for (; i < 64; ++i) {
          W2[i] = gamma1(W2[i - 2]) + W2[i - 7] + gamma0(W2[i - 15]) + W2[i - 16] | 0;
        }
        for (var j = 0; j < 64; ++j) {
          var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W2[j] | 0;
          var T2 = sigma0(a) + maj(a, b, c) | 0;
          h = g;
          g = f;
          f = e;
          e = d + T1 | 0;
          d = c;
          c = b;
          b = a;
          a = T1 + T2 | 0;
        }
        this._a = a + this._a | 0;
        this._b = b + this._b | 0;
        this._c = c + this._c | 0;
        this._d = d + this._d | 0;
        this._e = e + this._e | 0;
        this._f = f + this._f | 0;
        this._g = g + this._g | 0;
        this._h = h + this._h | 0;
      };
      Sha256.prototype._hash = function() {
        var H = Buffer.allocUnsafe(32);
        H.writeInt32BE(this._a, 0);
        H.writeInt32BE(this._b, 4);
        H.writeInt32BE(this._c, 8);
        H.writeInt32BE(this._d, 12);
        H.writeInt32BE(this._e, 16);
        H.writeInt32BE(this._f, 20);
        H.writeInt32BE(this._g, 24);
        H.writeInt32BE(this._h, 28);
        return H;
      };
      module2.exports = Sha256;
    }, { "./hash": 419, "inherits": 256, "safe-buffer": 417 }], 425: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var SHA512 = require2("./sha512");
      var Hash = require2("./hash");
      var Buffer = require2("safe-buffer").Buffer;
      var W = new Array(160);
      function Sha384() {
        this.init();
        this._w = W;
        Hash.call(this, 128, 112);
      }
      inherits(Sha384, SHA512);
      Sha384.prototype.init = function() {
        this._ah = 3418070365;
        this._bh = 1654270250;
        this._ch = 2438529370;
        this._dh = 355462360;
        this._eh = 1731405415;
        this._fh = 2394180231;
        this._gh = 3675008525;
        this._hh = 1203062813;
        this._al = 3238371032;
        this._bl = 914150663;
        this._cl = 812702999;
        this._dl = 4144912697;
        this._el = 4290775857;
        this._fl = 1750603025;
        this._gl = 1694076839;
        this._hl = 3204075428;
        return this;
      };
      Sha384.prototype._hash = function() {
        var H = Buffer.allocUnsafe(48);
        function writeInt64BE(h, l, offset) {
          H.writeInt32BE(h, offset);
          H.writeInt32BE(l, offset + 4);
        }
        writeInt64BE(this._ah, this._al, 0);
        writeInt64BE(this._bh, this._bl, 8);
        writeInt64BE(this._ch, this._cl, 16);
        writeInt64BE(this._dh, this._dl, 24);
        writeInt64BE(this._eh, this._el, 32);
        writeInt64BE(this._fh, this._fl, 40);
        return H;
      };
      module2.exports = Sha384;
    }, { "./hash": 419, "./sha512": 426, "inherits": 256, "safe-buffer": 417 }], 426: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Hash = require2("./hash");
      var Buffer = require2("safe-buffer").Buffer;
      var K = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
      var W = new Array(160);
      function Sha512() {
        this.init();
        this._w = W;
        Hash.call(this, 128, 112);
      }
      inherits(Sha512, Hash);
      Sha512.prototype.init = function() {
        this._ah = 1779033703;
        this._bh = 3144134277;
        this._ch = 1013904242;
        this._dh = 2773480762;
        this._eh = 1359893119;
        this._fh = 2600822924;
        this._gh = 528734635;
        this._hh = 1541459225;
        this._al = 4089235720;
        this._bl = 2227873595;
        this._cl = 4271175723;
        this._dl = 1595750129;
        this._el = 2917565137;
        this._fl = 725511199;
        this._gl = 4215389547;
        this._hl = 327033209;
        return this;
      };
      function Ch(x, y, z) {
        return z ^ x & (y ^ z);
      }
      function maj(x, y, z) {
        return x & y | z & (x | y);
      }
      function sigma0(x, xl) {
        return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
      }
      function sigma1(x, xl) {
        return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
      }
      function Gamma0(x, xl) {
        return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
      }
      function Gamma0l(x, xl) {
        return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
      }
      function Gamma1(x, xl) {
        return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
      }
      function Gamma1l(x, xl) {
        return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
      }
      function getCarry(a, b) {
        return a >>> 0 < b >>> 0 ? 1 : 0;
      }
      Sha512.prototype._update = function(M) {
        var W2 = this._w;
        var ah = this._ah | 0;
        var bh = this._bh | 0;
        var ch = this._ch | 0;
        var dh = this._dh | 0;
        var eh = this._eh | 0;
        var fh = this._fh | 0;
        var gh = this._gh | 0;
        var hh = this._hh | 0;
        var al = this._al | 0;
        var bl = this._bl | 0;
        var cl = this._cl | 0;
        var dl = this._dl | 0;
        var el = this._el | 0;
        var fl = this._fl | 0;
        var gl = this._gl | 0;
        var hl = this._hl | 0;
        for (var i = 0; i < 32; i += 2) {
          W2[i] = M.readInt32BE(i * 4);
          W2[i + 1] = M.readInt32BE(i * 4 + 4);
        }
        for (; i < 160; i += 2) {
          var xh = W2[i - 15 * 2];
          var xl = W2[i - 15 * 2 + 1];
          var gamma0 = Gamma0(xh, xl);
          var gamma0l = Gamma0l(xl, xh);
          xh = W2[i - 2 * 2];
          xl = W2[i - 2 * 2 + 1];
          var gamma1 = Gamma1(xh, xl);
          var gamma1l = Gamma1l(xl, xh);
          var Wi7h = W2[i - 7 * 2];
          var Wi7l = W2[i - 7 * 2 + 1];
          var Wi16h = W2[i - 16 * 2];
          var Wi16l = W2[i - 16 * 2 + 1];
          var Wil = gamma0l + Wi7l | 0;
          var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
          Wil = Wil + gamma1l | 0;
          Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
          Wil = Wil + Wi16l | 0;
          Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
          W2[i] = Wih;
          W2[i + 1] = Wil;
        }
        for (var j = 0; j < 160; j += 2) {
          Wih = W2[j];
          Wil = W2[j + 1];
          var majh = maj(ah, bh, ch);
          var majl = maj(al, bl, cl);
          var sigma0h = sigma0(ah, al);
          var sigma0l = sigma0(al, ah);
          var sigma1h = sigma1(eh, el);
          var sigma1l = sigma1(el, eh);
          var Kih = K[j];
          var Kil = K[j + 1];
          var chh = Ch(eh, fh, gh);
          var chl = Ch(el, fl, gl);
          var t1l = hl + sigma1l | 0;
          var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
          t1l = t1l + chl | 0;
          t1h = t1h + chh + getCarry(t1l, chl) | 0;
          t1l = t1l + Kil | 0;
          t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
          t1l = t1l + Wil | 0;
          t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
          var t2l = sigma0l + majl | 0;
          var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
          hh = gh;
          hl = gl;
          gh = fh;
          gl = fl;
          fh = eh;
          fl = el;
          el = dl + t1l | 0;
          eh = dh + t1h + getCarry(el, dl) | 0;
          dh = ch;
          dl = cl;
          ch = bh;
          cl = bl;
          bh = ah;
          bl = al;
          al = t1l + t2l | 0;
          ah = t1h + t2h + getCarry(al, t1l) | 0;
        }
        this._al = this._al + al | 0;
        this._bl = this._bl + bl | 0;
        this._cl = this._cl + cl | 0;
        this._dl = this._dl + dl | 0;
        this._el = this._el + el | 0;
        this._fl = this._fl + fl | 0;
        this._gl = this._gl + gl | 0;
        this._hl = this._hl + hl | 0;
        this._ah = this._ah + ah + getCarry(this._al, al) | 0;
        this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
        this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
        this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
        this._eh = this._eh + eh + getCarry(this._el, el) | 0;
        this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
        this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
        this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
      };
      Sha512.prototype._hash = function() {
        var H = Buffer.allocUnsafe(64);
        function writeInt64BE(h, l, offset) {
          H.writeInt32BE(h, offset);
          H.writeInt32BE(l, offset + 4);
        }
        writeInt64BE(this._ah, this._al, 0);
        writeInt64BE(this._bh, this._bl, 8);
        writeInt64BE(this._ch, this._cl, 16);
        writeInt64BE(this._dh, this._dl, 24);
        writeInt64BE(this._eh, this._el, 32);
        writeInt64BE(this._fh, this._fl, 40);
        writeInt64BE(this._gh, this._gl, 48);
        writeInt64BE(this._hh, this._hl, 56);
        return H;
      };
      module2.exports = Sha512;
    }, { "./hash": 419, "inherits": 256, "safe-buffer": 417 }], 427: [function(require2, module2, exports2) {
      var js = require2("./sha256.js");
      var wasm = require2("sha256-wasm");
      var Proto = js;
      module2.exports = function() {
        return new Proto();
      };
      module2.exports.ready = function(cb) {
        wasm.ready(function() {
          cb();
        });
      };
      module2.exports.WASM_SUPPORTED = wasm.WASM_SUPPORTED;
      module2.exports.WASM_LOADED = false;
      module2.exports.SHA256_BYTES = 32;
      wasm.ready(function(err) {
        if (!err) {
          module2.exports.WASM_LOADED = true;
          module2.exports = Proto = wasm;
        }
      });
    }, { "./sha256.js": 428, "sha256-wasm": 429 }], 428: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          if (btoa == null)
            var btoa = (buf) => require2("buffer")["Buffer"].from(buf).toString("base64");
          if (atob2 == null)
            var atob2 = (buf) => new Uint8Array(require2("buffer")["Buffer"].from(buf, "base64"));
          var assert = require2("nanoassert");
          module2.exports = Sha256;
          var SHA256_BYTES = module2.exports.SHA256_BYTES = 32;
          var BLOCKSIZE = 64;
          var K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
          function expand(a, b, c, d) {
            var b_ = ((a >>> 17 | a << 15) ^ (a >>> 19 | a << 13) ^ a >>> 10) + b;
            var d_ = ((c >>> 7 | c << 25) ^ (c >>> 18 | c << 14) ^ c >>> 3) + d;
            return b_ + d_ << 0;
          }
          function compress(state, words) {
            var ch, maj, s0, s1, T1, T2;
            var [a, b, c, d, e, f, g, h] = state;
            var w = new Uint32Array(64);
            for (var i = 0; i < 16; i++) {
              w[i] = bswap(words[i]);
            }
            for (var _i = 16; _i < 64; _i++) {
              w[_i] = expand(w[_i - 2], w[_i - 7], w[_i - 15], w[_i - 16]);
            }
            for (var _i2 = 0; _i2 < 64; _i2 += 4) {
              round(_i2);
            }
            state[0] = state[0] + a;
            state[1] = state[1] + b;
            state[2] = state[2] + c;
            state[3] = state[3] + d;
            state[4] = state[4] + e;
            state[5] = state[5] + f;
            state[6] = state[6] + g;
            state[7] = state[7] + h;
            function round(n) {
              ch = e & f ^ ~e & g;
              maj = a & b ^ a & c ^ b & c;
              s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
              s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
              T1 = h + ch + s1 + w[n] + K[n];
              T2 = s0 + maj;
              h = d + T1;
              d = T1 + T2;
              ch = h & e ^ ~h & f;
              maj = d & a ^ d & b ^ a & b;
              s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
              s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
              T1 = g + ch + s1 + w[n + 1] + K[n + 1];
              T2 = s0 + maj;
              g = c + T1;
              c = T1 + T2;
              ch = g & h ^ ~g & e;
              maj = c & d ^ c & a ^ d & a;
              s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
              s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
              T1 = f + ch + s1 + w[n + 2] + K[n + 2];
              T2 = s0 + maj;
              f = b + T1;
              b = T1 + T2;
              ch = f & g ^ ~f & h;
              maj = b & c ^ b & d ^ c & d;
              s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
              s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7);
              T1 = e + ch + s1 + w[n + 3] + K[n + 3];
              T2 = s0 + maj;
              e = a + T1;
              a = T1 + T2;
            }
          }
          function Sha256() {
            if (!(this instanceof Sha256))
              return new Sha256();
            this.buffer = new ArrayBuffer(64);
            this.bytesRead = 0;
            this.pos = 0;
            this.digestLength = SHA256_BYTES;
            this.finalised = false;
            this.load = new Uint8Array(this.buffer);
            this.words = new Uint32Array(this.buffer);
            this.state = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
            return this;
          }
          Sha256.prototype.update = function(input, enc) {
            assert(this.finalised === false, "Hash instance finalised");
            var [inputBuf, len] = formatInput(input, enc);
            var i = 0;
            this.bytesRead += len;
            while (len > 0) {
              this.load.set(inputBuf.subarray(i, i + BLOCKSIZE - this.pos), this.pos);
              i += BLOCKSIZE - this.pos;
              len -= BLOCKSIZE - this.pos;
              if (len < 0)
                break;
              this.pos = 0;
              compress(this.state, this.words);
            }
            this.pos = this.bytesRead & 63;
            this.load.fill(0, this.pos);
            return this;
          };
          Sha256.prototype.digest = function(enc) {
            var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            assert(this.finalised === false, "Hash instance finalised");
            this.finalised = true;
            this.load.fill(0, this.pos);
            this.load[this.pos] = 128;
            if (this.pos > 55) {
              compress(this.state, this.words);
              this.words.fill(0);
              this.pos = 0;
            }
            var view = new DataView(this.buffer);
            view.setUint32(56, this.bytesRead / 2 ** 29);
            view.setUint32(60, this.bytesRead << 3);
            compress(this.state, this.words);
            var resultBuf = new Uint8Array(this.state.map(bswap).buffer);
            if (!enc) {
              return new Uint8Array(resultBuf);
            }
            if (typeof enc === "string") {
              if (enc === "hex")
                return hexSlice(resultBuf, 0, resultBuf.length);
              if (enc === "utf8" || enc === "utf-8")
                return new TextEncoder().encode(resultBuf);
              if (enc === "base64")
                return btoa(resultBuf);
              throw new Error("Encoding: " + enc + " not supported");
            }
            assert(enc instanceof Uint8Array, "input must be Uint8Array or Buffer");
            assert(enc.byteLength >= this.digestLength + offset, "input not large enough for digest");
            for (var i = 0; i < this.digestLength; i++) {
              enc[i + offset] = resultBuf[i];
            }
            return enc;
          };
          function HMAC(key) {
            if (!(this instanceof HMAC))
              return new HMAC(key);
            this.pad = Buffer.alloc(64);
            this.inner = Sha256();
            this.outer = Sha256();
            var keyhash = Buffer.alloc(32);
            if (key.byteLength > 64) {
              Sha256().update(key).digest(keyhash);
              key = keyhash;
            }
            this.pad.fill(54);
            for (var i = 0; i < key.byteLength; i++) {
              this.pad[i] ^= key[i];
            }
            this.inner.update(this.pad);
            this.pad.fill(92);
            for (var _i3 = 0; _i3 < key.byteLength; _i3++) {
              this.pad[_i3] ^= key[_i3];
            }
            this.outer.update(this.pad);
            this.pad.fill(0);
            keyhash.fill(0);
          }
          HMAC.prototype.update = function(input, enc) {
            this.inner.update(input, enc);
            return this;
          };
          HMAC.prototype.digest = function(enc) {
            var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            this.outer.update(this.inner.digest());
            return this.outer.digest(enc, offset);
          };
          Sha256.HMAC = HMAC;
          function hexSlice(buf) {
            var start = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            var len = arguments.length > 2 ? arguments[2] : void 0;
            if (!len)
              len = buf.byteLength;
            var str = "";
            for (var i = 0; i < len; i++) {
              str += toHex(buf[start + i]);
            }
            return str;
          }
          function toHex(n) {
            if (n < 16)
              return "0" + n.toString(16);
            return n.toString(16);
          }
          function formatInput(input, enc) {
            var result = input instanceof Uint8Array ? input : strToBuf(input, enc);
            return [result, result.byteLength];
          }
          function strToBuf(input, enc) {
            if (enc === "hex")
              return hex2bin(input);
            else if (enc === "utf8" || enc === "utf-8")
              return new TextDecoder().decode(input);
            else if (enc === "base64")
              return atob2(input);
            else
              throw new Error("Encoding: " + enc + " not supported");
          }
          function hex2bin(str) {
            if (str.length % 2 !== 0)
              return hex2bin("0" + str);
            var ret = new Uint8Array(str.length / 2);
            for (var i = 0; i < ret.length; i++) {
              ret[i] = Number("0x" + str.substring(2 * i, 2 * i + 2));
            }
            return ret;
          }
          function bswap(a) {
            var r = (a & 16711935) >>> 8 | (a & 16711935) << 24;
            var l = (a & 4278255360) << 8 | (a & 4278255360) >>> 24;
            return r | l;
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82, "nanoassert": 308 }], 429: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          if (btoa == null)
            var btoa = (buf) => require2("buffer")["Buffer"].from(buf).toString("base64");
          if (atob2 == null)
            var atob2 = (buf) => new Uint8Array(require2("buffer")["Buffer"].from(buf, "base64"));
          var assert = require2("nanoassert");
          var wasm = require2("./sha256.js")({
            imports: {
              debug: {
                log() {
                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                  }
                  console.log(...args.map((int) => (int >>> 0).toString(16).padStart(8, "0")));
                },
                log_tee(arg) {
                  console.log((arg >>> 0).toString(16).padStart(8, "0"));
                  return arg;
                }
              }
            }
          });
          var head = 0;
          var freeList = [];
          module2.exports = Sha256;
          var SHA256_BYTES = module2.exports.SHA256_BYTES = 32;
          var INPUT_OFFSET = 40;
          var STATEBYTES = 108;
          var BLOCKSIZE = 64;
          function Sha256() {
            if (!(this instanceof Sha256))
              return new Sha256();
            if (!(wasm && wasm.exports))
              throw new Error("WASM not loaded. Wait for Sha256.ready(cb)");
            if (!freeList.length) {
              freeList.push(head);
              head += STATEBYTES;
            }
            this.finalized = false;
            this.digestLength = SHA256_BYTES;
            this.pointer = freeList.pop();
            this.pos = 0;
            wasm.memory.fill(0, this.pointer, this.pointer + STATEBYTES);
            if (this.pointer + this.digestLength > wasm.memory.length)
              wasm.realloc(this.pointer + STATEBYTES);
          }
          Sha256.prototype.update = function(input, enc) {
            assert(this.finalized === false, "Hash instance finalized");
            if (head % 4 !== 0)
              head += 4 - head % 4;
            assert(head % 4 === 0, "input shoud be aligned for int32");
            var [inputBuf, length] = formatInput(input, enc);
            assert(inputBuf instanceof Uint8Array, "input must be Uint8Array or Buffer");
            if (head + length > wasm.memory.length)
              wasm.realloc(head + input.length);
            wasm.memory.fill(0, head, head + roundUp(length, BLOCKSIZE) - BLOCKSIZE);
            wasm.memory.set(inputBuf.subarray(0, BLOCKSIZE - this.pos), this.pointer + INPUT_OFFSET + this.pos);
            wasm.memory.set(inputBuf.subarray(BLOCKSIZE - this.pos), head);
            this.pos = this.pos + length & 63;
            wasm.exports.sha256(this.pointer, head, length, 0);
            return this;
          };
          Sha256.prototype.digest = function(enc) {
            var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            assert(this.finalized === false, "Hash instance finalized");
            this.finalized = true;
            freeList.push(this.pointer);
            var paddingStart = this.pointer + INPUT_OFFSET + this.pos;
            wasm.memory.fill(0, paddingStart, this.pointer + INPUT_OFFSET + BLOCKSIZE);
            wasm.exports.sha256(this.pointer, head, 0, 1);
            var resultBuf = wasm.memory.subarray(this.pointer, this.pointer + this.digestLength);
            if (!enc) {
              return resultBuf;
            }
            if (typeof enc === "string") {
              if (enc === "hex")
                return hexSlice(resultBuf, 0, resultBuf.length);
              if (enc === "utf8" || enc === "utf-8")
                return new TextEncoder().encode(resultBuf);
              if (enc === "base64")
                return btoa(resultBuf);
              throw new Error("Encoding: " + enc + " not supported");
            }
            assert(enc instanceof Uint8Array, "input must be Uint8Array or Buffer");
            assert(enc.byteLength >= this.digestLength + offset, "input not large enough for digest");
            for (var i = 0; i < this.digestLength; i++) {
              enc[i + offset] = resultBuf[i];
            }
            return enc;
          };
          Sha256.WASM = wasm && wasm.buffer;
          Sha256.WASM_SUPPORTED = typeof WebAssembly !== "undefined";
          Sha256.ready = function(cb) {
            if (!cb)
              cb = noop;
            if (!wasm)
              return cb(new Error("WebAssembly not supported"));
            var p = new Promise(function(reject, resolve) {
              wasm.onload(function(err) {
                if (err)
                  resolve(err);
                else
                  reject();
                cb(err);
              });
            });
            return p;
          };
          Sha256.prototype.ready = Sha256.ready;
          function HMAC(key) {
            if (!(this instanceof HMAC))
              return new HMAC(key);
            this.pad = Buffer.alloc(64);
            this.inner = Sha256();
            this.outer = Sha256();
            var keyhash = Buffer.alloc(32);
            if (key.byteLength > 64) {
              Sha256().update(key).digest(keyhash);
              key = keyhash;
            }
            this.pad.fill(54);
            for (var i = 0; i < key.byteLength; i++) {
              this.pad[i] ^= key[i];
            }
            this.inner.update(this.pad);
            this.pad.fill(92);
            for (var _i = 0; _i < key.byteLength; _i++) {
              this.pad[_i] ^= key[_i];
            }
            this.outer.update(this.pad);
            this.pad.fill(0);
            keyhash.fill(0);
          }
          HMAC.prototype.update = function(input, enc) {
            this.inner.update(input, enc);
            return this;
          };
          HMAC.prototype.digest = function(enc) {
            var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            this.outer.update(this.inner.digest());
            return this.outer.digest(enc, offset);
          };
          Sha256.HMAC = HMAC;
          function noop() {
          }
          function formatInput(input, enc) {
            var result = input instanceof Uint8Array ? input : strToBuf(input, enc);
            return [result, result.byteLength];
          }
          function strToBuf(input, enc) {
            if (enc === "hex")
              return hex2bin(input);
            else if (enc === "utf8" || enc === "utf-8")
              return new TextDecoder().decode(input);
            else if (enc === "base64")
              return atob2(input);
            else
              throw new Error("Encoding: " + enc + " not supported");
          }
          function hex2bin(str) {
            if (str.length % 2 !== 0)
              return hex2bin("0" + str);
            var ret = new Uint8Array(str.length / 2);
            for (var i = 0; i < ret.length; i++) {
              ret[i] = Number("0x" + str.substring(2 * i, 2 * i + 2));
            }
            return ret;
          }
          function hexSlice(buf) {
            var start = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            var len = arguments.length > 2 ? arguments[2] : void 0;
            if (!len)
              len = buf.byteLength;
            var str = "";
            for (var i = 0; i < len; i++) {
              str += toHex(buf[start + i]);
            }
            return str;
          }
          function toHex(n) {
            if (n < 16)
              return "0" + n.toString(16);
            return n.toString(16);
          }
          function roundUp(n, base) {
            return n + base - 1 & -base;
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "./sha256.js": 430, "buffer": 82, "nanoassert": 308 }], 430: [function(require2, module2, exports2) {
      module2.exports = loadWebAssembly;
      loadWebAssembly.supported = typeof WebAssembly !== "undefined";
      function loadWebAssembly(opts) {
        if (!loadWebAssembly.supported)
          return null;
        var imp = opts && opts.imports;
        var wasm = toUint8Array("AGFzbQEAAAABNAVgAX8Bf2AIf39/f39/f38AYAR/f39/AX9gEX9/f39/f39/f39/f39/f39/AGAEf39/fwADBgUAAQIDBAUDAQABBikIfwFBAAt/AUEAC38BQQALfwFBAAt/AUEAC38BQQALfwFBAAt/AUEACwcTAgZtZW1vcnkCAAZzaGEyNTYABArgFwUZACAAQf+B/AdxQQh4IABBgP6DeHFBCHdyC7wDAQZ/IwQjBXEjBEF/cyMGcXMhCiMAIwFxIwAjAnFzIwEjAnFzIQsjAEECeCMAQQ14cyMAQRZ4cyEMIwRBBngjBEELeHMjBEEZeHMhDSMHIApqIA1qIABqIARqIQggDCALaiEJIwMgCGokByAIIAlqJAMjByMEcSMHQX9zIwVxcyEKIwMjAHEjAyMBcXMjACMBcXMhCyMDQQJ4IwNBDXhzIwNBFnhzIQwjB0EGeCMHQQt4cyMHQRl4cyENIwYgCmogDWogAWogBWohCCAMIAtqIQkjAiAIaiQGIAggCWokAiMGIwdxIwZBf3MjBHFzIQojAiMDcSMCIwBxcyMDIwBxcyELIwJBAngjAkENeHMjAkEWeHMhDCMGQQZ4IwZBC3hzIwZBGXhzIQ0jBSAKaiANaiACaiAGaiEIIAwgC2ohCSMBIAhqJAUgCCAJaiQBIwUjBnEjBUF/cyMHcXMhCiMBIwJxIwEjA3FzIwIjA3FzIQsjAUECeCMBQQ14cyMBQRZ4cyEMIwVBBngjBUELeHMjBUEZeHMhDSMEIApqIA1qIANqIAdqIQggDCALaiEJIwAgCGokBCAIIAlqJAALKwAgAEEReCAAQRN4cyAAQQp2cyABaiACQQd4IAJBEnhzIAJBA3ZzIANqagvNCwEwfyAAKAJoQQBGBEAgAEHnzKfQBjYCACAAQYXdntt7NgIEIABB8ua74wM2AgggAEG66r+qejYCDCAAQf+kuYgFNgIQIABBjNGV2Hk2AhQgAEGrs4/8ATYCGCAAQZmag98FNgIcIABBATYCaAsgACgCACQAIAAoAgQkASAAKAIIJAIgACgCDCQDIAAoAhAkBCAAKAIUJAUgACgCGCQGIAAoAhwkByABEAAhASACEAAhAiADEAAhAyAEEAAhBCAFEAAhBSAGEAAhBiAHEAAhByAIEAAhCCAJEAAhCSAKEAAhCiALEAAhCyAMEAAhDCANEAAhDSAOEAAhDiAPEAAhDyAQEAAhECAPIAogAiABEAIhESAQIAsgAyACEAIhEiARIAwgBCADEAIhEyASIA0gBSAEEAIhFCATIA4gBiAFEAIhFSAUIA8gByAGEAIhFiAVIBAgCCAHEAIhFyAWIBEgCSAIEAIhGCAXIBIgCiAJEAIhGSAYIBMgCyAKEAIhGiAZIBQgDCALEAIhGyAaIBUgDSAMEAIhHCAbIBYgDiANEAIhHSAcIBcgDyAOEAIhHiAdIBggECAPEAIhHyAeIBkgESAQEAIhICAfIBogEiAREAIhISAgIBsgEyASEAIhIiAhIBwgFCATEAIhIyAiIB0gFSAUEAIhJCAjIB4gFiAVEAIhJSAkIB8gFyAWEAIhJiAlICAgGCAXEAIhJyAmICEgGSAYEAIhKCAnICIgGiAZEAIhKSAoICMgGyAaEAIhKiApICQgHCAbEAIhKyAqICUgHSAcEAIhLCArICYgHiAdEAIhLSAsICcgHyAeEAIhLiAtICggICAfEAIhLyAuICkgISAgEAIhMCAvICogIiAhEAIhMSAwICsgIyAiEAIhMiAxICwgJCAjEAIhMyAyIC0gJSAkEAIhNCAzIC4gJiAlEAIhNSA0IC8gJyAmEAIhNiA1IDAgKCAnEAIhNyA2IDEgKSAoEAIhOCA3IDIgKiApEAIhOSA4IDMgKyAqEAIhOiA5IDQgLCArEAIhOyA6IDUgLSAsEAIhPCA7IDYgLiAtEAIhPSA8IDcgLyAuEAIhPiA9IDggMCAvEAIhPyA+IDkgMSAwEAIhQCABIAIgAyAEQZjfqJQEQZGJ3YkHQc/3g657QaW3181+EAEgBSAGIAcgCEHbhNvKA0Hxo8TPBUGkhf6ReUHVvfHYehABIAkgCiALIAxBmNWewH1BgbaNlAFBvovGoQJBw/uxqAUQASANIA4gDyAQQfS6+ZUHQf7j+oZ4QaeN8N55QfTi74x8EAEgESASIBMgFEHB0+2kfkGGj/n9fkHGu4b+AEHMw7KgAhABIBUgFiAXIBhB79ik7wJBqonS0wRB3NPC5QVB2pHmtwcQASAZIBogGyAcQdKi+cF5Qe2Mx8F6QcjPjIB7Qcf/5fp7EAEgHSAeIB8gIEHzl4C3fEHHop6tfUHRxqk2QefSpKEBEAEgISAiICMgJEGFldy9AkG4wuzwAkH827HpBEGTmuCZBRABICUgJiAnIChB1OapqAZBu5WoswdBrpKLjnhBhdnIk3kQASApICogKyAsQaHR/5V6QcvM6cB6QfCWrpJ8QaOjsbt8EAEgLSAuIC8gMEGZ0MuMfUGkjOS0fUGF67igf0HwwKqDARABIDEgMiAzIDRBloKTzQFBiNjd8QFBzO6hugJBtfnCpQMQASA1IDYgNyA4QbOZ8MgDQcrU4vYEQc+U89wFQfPfucEGEAEgOSA6IDsgPEHuhb6kB0HvxpXFB0GU8KGmeEGIhJzmeBABID0gPiA/IEBB+v/7hXlB69nBonpB98fm93tB8vHFs3wQASAAIAAoAgAjAGo2AgAgACAAKAIEIwFqNgIEIAAgACgCCCMCajYCCCAAIAAoAgwjA2o2AgwgACAAKAIQIwRqNgIQIAAgACgCFCMFajYCFCAAIAAoAhgjBmo2AhggACAAKAIcIwdqNgIcC4oIAgF+En8gACkDICEEIASnQT9xIAJqIQYgBCACrXwhBCAAIAQ3AyACQCAAKAIoIQcgACgCLCEIIAAoAjAhCSAAKAI0IQogACgCOCELIAAoAjwhDCAAKAJAIQ0gACgCRCEOIAAoAkghDyAAKAJMIRAgACgCUCERIAAoAlQhEiAAKAJYIRMgACgCXCEUIAAoAmAhFSAAKAJkIRYgBkHAAGsiBkEASA0AIAAgByAIIAkgCiALIAwgDSAOIA8gECARIBIgEyAUIBUgFhADA0AgASgCACEHIAEoAgQhCCABKAIIIQkgASgCDCEKIAEoAhAhCyABKAIUIQwgASgCGCENIAEoAhwhDiABKAIgIQ8gASgCJCEQIAEoAighESABKAIsIRIgASgCMCETIAEoAjQhFCABKAI4IRUgASgCPCEWIAFBwABqIQEgBkHAAGsiBkEASARAIAAgBzYCKCAAIAg2AiwgACAJNgIwIAAgCjYCNCAAIAs2AjggACAMNgI8IAAgDTYCQCAAIA42AkQgACAPNgJIIAAgEDYCTCAAIBE2AlAgACASNgJUIAAgEzYCWCAAIBQ2AlwgACAVNgJgIAAgFjYCZAwCCyAAIAcgCCAJIAogCyAMIA0gDiAPIBAgESASIBMgFCAVIBYQAwwACwsgA0EBRgRAIASnQT9xIQZBgAEgBkEDcUEDdHQhBQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAGQQJ2Dg8DBAUGBwgJCgsMDQ4PEAECCwsgBSAVciEVQQAhBQsgBSAWciEWQQAhBSAAIAcgCCAJIAogCyAMIA0gDiAPIBAgESASIBMgFCAVIBYQAyAAIAQ3AyBBACEHQQAhCEEAIQlBACEKQQAhC0EAIQxBACENQQAhDkEAIQ9BACEQQQAhEUEAIRJBACETQQAhFEEAIRVBACEWCyAFIAdyIQdBACEFCyAFIAhyIQhBACEFCyAFIAlyIQlBACEFCyAFIApyIQpBACEFCyAFIAtyIQtBACEFCyAFIAxyIQxBACEFCyAFIA1yIQ1BACEFCyAFIA5yIQ5BACEFCyAFIA9yIQ9BACEFCyAFIBByIRBBACEFCyAFIBFyIRFBACEFCyAFIBJyIRJBACEFCyAFIBNyIRNBACEFCyAFIBRyIRRBACEFCyAEQh2IpxAAIRUgBEIDhqcQACEWIAAgByAIIAkgCiALIAwgDSAOIA8gECARIBIgEyAUIBUgFhADIAAgACgCABAANgIAIAAgACgCBBAANgIEIAAgACgCCBAANgIIIAAgACgCDBAANgIMIAAgACgCEBAANgIQIAAgACgCFBAANgIUIAAgACgCGBAANgIYIAAgACgCHBAANgIcCws=");
        var ready = null;
        var mod = {
          buffer: wasm,
          memory: null,
          exports: null,
          realloc,
          onload
        };
        onload(function() {
        });
        return mod;
        function realloc(size) {
          mod.exports.memory.grow(Math.max(0, Math.ceil(Math.abs(size - mod.memory.length) / 65536)));
          mod.memory = new Uint8Array(mod.exports.memory.buffer);
        }
        function onload(cb) {
          if (mod.exports)
            return cb();
          if (ready) {
            ready.then(cb.bind(null, null)).catch(cb);
            return;
          }
          try {
            if (opts && opts.async)
              throw new Error("async");
            setup({
              instance: new WebAssembly.Instance(new WebAssembly.Module(wasm), imp)
            });
          } catch (err) {
            ready = WebAssembly.instantiate(wasm, imp).then(setup);
          }
          onload(cb);
        }
        function setup(w) {
          mod.exports = w.instance.exports;
          mod.memory = mod.exports.memory && mod.exports.memory.buffer && new Uint8Array(mod.exports.memory.buffer);
        }
      }
      function toUint8Array(s) {
        if (typeof atob === "function")
          return new Uint8Array(atob(s).split("").map(charCodeAt));
        return require2("buffer").Buffer.from(s, "base64");
      }
      function charCodeAt(c) {
        return c.charCodeAt(0);
      }
    }, {}], 431: [function(require2, module2, exports2) {
      var js = require2("./sha512.js");
      var wasm = require2("sha512-wasm");
      var Proto = js;
      module2.exports = function() {
        return new Proto();
      };
      module2.exports.ready = function(cb) {
        wasm.ready(function() {
          cb();
        });
      };
      module2.exports.WASM_SUPPORTED = wasm.SUPPORTED;
      module2.exports.WASM_LOADED = false;
      module2.exports.SHA512_BYTES = 64;
      wasm.ready(function(err) {
        if (!err) {
          module2.exports.WASM_LOADED = true;
          module2.exports = Proto = wasm;
        }
      });
    }, { "./sha512.js": 432, "sha512-wasm": 433 }], 432: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          if (btoa == null)
            var btoa = (buf) => require2("buffer")["Buffer"].from(buf).toString("base64");
          if (atob2 == null)
            var atob2 = (buf) => new Uint8Array(require2("buffer")["Buffer"].from(buf, "base64"));
          var assert = require2("nanoassert");
          module2.exports = Sha512;
          var BLOCKSIZE = 128;
          var K = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
          function Sha512() {
            if (!(this instanceof Sha512))
              return new Sha512();
            this.hh = new Int32Array(8);
            this.hl = new Int32Array(8);
            this.buffer = new Uint8Array(128);
            this.finalised = false;
            this.bytesRead = 0;
            this.pos = 0;
            this.hh[0] = 1779033703;
            this.hh[1] = 3144134277;
            this.hh[2] = 1013904242;
            this.hh[3] = 2773480762;
            this.hh[4] = 1359893119;
            this.hh[5] = 2600822924;
            this.hh[6] = 528734635;
            this.hh[7] = 1541459225;
            this.hl[0] = 4089235720;
            this.hl[1] = 2227873595;
            this.hl[2] = 4271175723;
            this.hl[3] = 1595750129;
            this.hl[4] = 2917565137;
            this.hl[5] = 725511199;
            this.hl[6] = 4215389547;
            this.hl[7] = 327033209;
            return this;
          }
          Sha512.prototype.update = function(input, enc) {
            assert(this.finalised === false, "Hash instance finalised");
            var [inputBuf, len] = formatInput(input, enc);
            this.bytesRead += len;
            var full = len + this.pos & -128;
            this.buffer.set(inputBuf.subarray(0, BLOCKSIZE - this.pos), this.pos);
            var pos = this.pos;
            len -= BLOCKSIZE - this.pos;
            if (len >= 0) {
              compress(this.hh, this.hl, this.buffer, 128);
              this.pos = 0;
            }
            if (len > 127) {
              compress(this.hh, this.hl, inputBuf.subarray(BLOCKSIZE - pos, full - pos), full - BLOCKSIZE);
              len %= 128;
            }
            this.buffer.set(inputBuf.subarray(inputBuf.byteLength - len));
            this.pos = this.bytesRead & 127;
            this.buffer.fill(0, this.pos);
            return this;
          };
          Sha512.prototype.digest = function(enc) {
            var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            assert(this.finalised === false, "Hash instance finalised");
            this.finalised = true;
            this.buffer.fill(0, this.pos);
            this.buffer[this.pos] = 128;
            if (this.pos > 111) {
              compress(this.hh, this.hl, this.buffer, 128);
              this.buffer.fill(0);
              this.pos = 0;
            }
            ts64(this.buffer, 120, this.bytesRead / 536870912 | 0, this.bytesRead << 3);
            compress(this.hh, this.hl, this.buffer, 128);
            if (enc instanceof Uint8Array && enc.byteLength > 63) {
              for (var i = 0; i < 8; i++) {
                ts64(enc, 8 * i + offset, this.hh[i], this.hl[i]);
              }
              return enc;
            }
            var resultBuf = new Uint8Array(64);
            for (var _i = 0; _i < 8; _i++) {
              ts64(resultBuf, 8 * _i, this.hh[_i], this.hl[_i]);
            }
            if (typeof enc === "string") {
              if (enc === "hex")
                return hexSlice(resultBuf, 0, resultBuf.length);
              if (enc === "utf8" || enc === "utf-8")
                return new TextEncoder().encode(resultBuf);
              if (enc === "base64")
                return btoa(resultBuf);
              throw new Error("Encoding: " + enc + " not supported");
            }
            return resultBuf;
          };
          function ts64(x, i, h, l) {
            x[i] = h >> 24 & 255;
            x[i + 1] = h >> 16 & 255;
            x[i + 2] = h >> 8 & 255;
            x[i + 3] = h & 255;
            x[i + 4] = l >> 24 & 255;
            x[i + 5] = l >> 16 & 255;
            x[i + 6] = l >> 8 & 255;
            x[i + 7] = l & 255;
          }
          function hexSlice(buf) {
            var start = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            var len = arguments.length > 2 ? arguments[2] : void 0;
            if (!len)
              len = buf.byteLength;
            var str = "";
            for (var i = 0; i < len; i++) {
              str += toHex(buf[start + i]);
            }
            return str;
          }
          function toHex(n) {
            if (n < 16)
              return "0" + n.toString(16);
            return n.toString(16);
          }
          function formatInput(input, enc) {
            var result = input instanceof Uint8Array ? input : strToBuf(input, enc);
            return [result, result.byteLength];
          }
          function strToBuf(input, enc) {
            if (enc === "hex")
              return hex2bin(input);
            else if (enc === "utf8" || enc === "utf-8")
              return new TextDecoder().decode(input);
            else if (enc === "base64")
              return atob2(input);
            else
              throw new Error("Encoding: " + enc + " not supported");
          }
          function hex2bin(str) {
            if (str.length % 2 !== 0)
              return hex2bin("0" + str);
            var ret = new Uint8Array(str.length / 2);
            for (var i = 0; i < ret.length; i++) {
              ret[i] = Number("0x" + str.substring(2 * i, 2 * i + 2));
            }
            return ret;
          }
          function compress(hh, hl, m, n) {
            var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
            var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
            var pos = 0;
            while (n >= 128) {
              for (i = 0; i < 16; i++) {
                j = 8 * i + pos;
                wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
                wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
              }
              for (i = 0; i < 80; i++) {
                bh0 = ah0;
                bh1 = ah1;
                bh2 = ah2;
                bh3 = ah3;
                bh4 = ah4;
                bh5 = ah5;
                bh6 = ah6;
                bh7 = ah7;
                bl0 = al0;
                bl1 = al1;
                bl2 = al2;
                bl3 = al3;
                bl4 = al4;
                bl5 = al5;
                bl6 = al6;
                bl7 = al7;
                h = ah7;
                l = al7;
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
                l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                h = ah4 & ah5 ^ ~ah4 & ah6;
                l = al4 & al5 ^ ~al4 & al6;
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                h = K[i * 2];
                l = K[i * 2 + 1];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                h = wh[i % 16];
                l = wl[i % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                th = c & 65535 | d << 16;
                tl = a & 65535 | b << 16;
                h = th;
                l = tl;
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
                l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
                l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                bh7 = c & 65535 | d << 16;
                bl7 = a & 65535 | b << 16;
                h = bh3;
                l = bl3;
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = th;
                l = tl;
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                bh3 = c & 65535 | d << 16;
                bl3 = a & 65535 | b << 16;
                ah1 = bh0;
                ah2 = bh1;
                ah3 = bh2;
                ah4 = bh3;
                ah5 = bh4;
                ah6 = bh5;
                ah7 = bh6;
                ah0 = bh7;
                al1 = bl0;
                al2 = bl1;
                al3 = bl2;
                al4 = bl3;
                al5 = bl4;
                al6 = bl5;
                al7 = bl6;
                al0 = bl7;
                if (i % 16 === 15) {
                  for (j = 0; j < 16; j++) {
                    h = wh[j];
                    l = wl[j];
                    a = l & 65535;
                    b = l >>> 16;
                    c = h & 65535;
                    d = h >>> 16;
                    h = wh[(j + 9) % 16];
                    l = wl[(j + 9) % 16];
                    a += l & 65535;
                    b += l >>> 16;
                    c += h & 65535;
                    d += h >>> 16;
                    th = wh[(j + 1) % 16];
                    tl = wl[(j + 1) % 16];
                    h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                    l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                    a += l & 65535;
                    b += l >>> 16;
                    c += h & 65535;
                    d += h >>> 16;
                    th = wh[(j + 14) % 16];
                    tl = wl[(j + 14) % 16];
                    h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                    l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                    a += l & 65535;
                    b += l >>> 16;
                    c += h & 65535;
                    d += h >>> 16;
                    b += a >>> 16;
                    c += b >>> 16;
                    d += c >>> 16;
                    wh[j] = c & 65535 | d << 16;
                    wl[j] = a & 65535 | b << 16;
                  }
                }
              }
              h = ah0;
              l = al0;
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = hh[0];
              l = hl[0];
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              hh[0] = ah0 = c & 65535 | d << 16;
              hl[0] = al0 = a & 65535 | b << 16;
              h = ah1;
              l = al1;
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = hh[1];
              l = hl[1];
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              hh[1] = ah1 = c & 65535 | d << 16;
              hl[1] = al1 = a & 65535 | b << 16;
              h = ah2;
              l = al2;
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = hh[2];
              l = hl[2];
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              hh[2] = ah2 = c & 65535 | d << 16;
              hl[2] = al2 = a & 65535 | b << 16;
              h = ah3;
              l = al3;
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = hh[3];
              l = hl[3];
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              hh[3] = ah3 = c & 65535 | d << 16;
              hl[3] = al3 = a & 65535 | b << 16;
              h = ah4;
              l = al4;
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = hh[4];
              l = hl[4];
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              hh[4] = ah4 = c & 65535 | d << 16;
              hl[4] = al4 = a & 65535 | b << 16;
              h = ah5;
              l = al5;
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = hh[5];
              l = hl[5];
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              hh[5] = ah5 = c & 65535 | d << 16;
              hl[5] = al5 = a & 65535 | b << 16;
              h = ah6;
              l = al6;
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = hh[6];
              l = hl[6];
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              hh[6] = ah6 = c & 65535 | d << 16;
              hl[6] = al6 = a & 65535 | b << 16;
              h = ah7;
              l = al7;
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = hh[7];
              l = hl[7];
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              hh[7] = ah7 = c & 65535 | d << 16;
              hl[7] = al7 = a & 65535 | b << 16;
              pos += 128;
              n -= 128;
            }
          }
          function HMAC(key) {
            if (!(this instanceof HMAC))
              return new HMAC(key);
            this.pad = Buffer.alloc(128);
            this.inner = Sha512();
            this.outer = Sha512();
            var keyhash = Buffer.alloc(64);
            if (key.byteLength > 128) {
              Sha512().update(key).digest(keyhash);
              key = keyhash;
            }
            this.pad.fill(54);
            for (var i = 0; i < key.byteLength; i++) {
              this.pad[i] ^= key[i];
            }
            this.inner.update(this.pad);
            this.pad.fill(92);
            for (var _i2 = 0; _i2 < key.byteLength; _i2++) {
              this.pad[_i2] ^= key[_i2];
            }
            this.outer.update(this.pad);
            this.pad.fill(0);
            keyhash.fill(0);
          }
          HMAC.prototype.update = function(input, enc) {
            this.inner.update(input, enc);
            return this;
          };
          HMAC.prototype.digest = function(enc) {
            var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            this.outer.update(this.inner.digest());
            return this.outer.digest(enc, offset);
          };
          Sha512.HMAC = HMAC;
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82, "nanoassert": 308 }], 433: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          if (btoa == null)
            var btoa = (buf) => require2("buffer")["Buffer"].from(buf).toString("base64");
          if (atob2 == null)
            var atob2 = (buf) => new Uint8Array(require2("buffer")["Buffer"].from(buf, "base64"));
          var assert = require2("nanoassert");
          var wasm = require2("./sha512.js")({
            imports: {
              debug: {
                log() {
                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                  }
                  console.log(...args.map((int) => (int >>> 0).toString(16).padStart(8, "0")));
                },
                log_tee(arg) {
                  console.log((arg >>> 0).toString(16).padStart(8, "0"));
                  return arg;
                }
              }
            }
          });
          var head = 0;
          var freeList = [];
          module2.exports = Sha512;
          var SHA512_BYTES = module2.exports.SHA512_BYTES = 64;
          var INPUT_OFFSET = 80;
          var STATEBYTES = 216;
          var BLOCKSIZE = 128;
          function Sha512() {
            if (!(this instanceof Sha512))
              return new Sha512();
            if (!(wasm && wasm.exports))
              throw new Error("WASM not loaded. Wait for Sha512.ready(cb)");
            if (!freeList.length) {
              freeList.push(head);
              head += STATEBYTES;
            }
            this.finalized = false;
            this.digestLength = SHA512_BYTES;
            this.pointer = freeList.pop();
            this.pos = 0;
            this.wasm = wasm;
            wasm.memory.fill(0, this.pointer, this.pointer + STATEBYTES);
            if (this.pointer + this.digestLength > wasm.memory.length)
              wasm.realloc(this.pointer + STATEBYTES);
          }
          Sha512.prototype.update = function(input, enc) {
            assert(this.finalized === false, "Hash instance finalized");
            if (head % 8 !== 0)
              head += 8 - head % 8;
            assert(head % 8 === 0, "input should be aligned for int64");
            var [inputBuf, length] = formatInput(input, enc);
            assert(inputBuf instanceof Uint8Array, "input must be Uint8Array or Buffer");
            if (head + input.length > wasm.memory.length)
              wasm.realloc(head + input.length);
            wasm.memory.fill(0, head, head + roundUp(length, BLOCKSIZE) - BLOCKSIZE);
            wasm.memory.set(inputBuf.subarray(0, BLOCKSIZE - this.pos), this.pointer + INPUT_OFFSET + this.pos);
            wasm.memory.set(inputBuf.subarray(BLOCKSIZE - this.pos), head);
            this.pos = this.pos + length & 127;
            wasm.exports.sha512(this.pointer, head, length, 0);
            return this;
          };
          Sha512.prototype.digest = function(enc) {
            var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            assert(this.finalized === false, "Hash instance finalized");
            this.finalized = true;
            freeList.push(this.pointer);
            var paddingStart = this.pointer + INPUT_OFFSET + this.pos;
            wasm.memory.fill(0, paddingStart, this.pointer + INPUT_OFFSET + BLOCKSIZE);
            wasm.exports.sha512(this.pointer, head, 0, 1);
            var resultBuf = wasm.memory.subarray(this.pointer, this.pointer + this.digestLength);
            if (!enc) {
              return resultBuf;
            }
            if (typeof enc === "string") {
              if (enc === "hex")
                return hexSlice(resultBuf, 0, resultBuf.length);
              if (enc === "utf8" || enc === "utf-8")
                return new TextEncoder().encode(resultBuf);
              if (enc === "base64")
                return btoa(resultBuf);
              throw new Error("Encoding: " + enc + " not supported");
            }
            assert(enc instanceof Uint8Array, "output must be Uint8Array or Buffer");
            assert(enc.byteLength >= this.digestLength + offset, "output must have at least 'SHA512_BYTES' bytes remaining");
            for (var i = 0; i < this.digestLength; i++) {
              enc[i + offset] = resultBuf[i];
            }
            return enc;
          };
          Sha512.WASM = wasm && wasm.buffer;
          Sha512.WASM_SUPPORTED = typeof WebAssembly !== "undefined";
          Sha512.ready = function(cb) {
            if (!cb)
              cb = noop;
            if (!wasm)
              return cb(new Error("WebAssembly not supported"));
            var p = new Promise(function(reject, resolve) {
              wasm.onload(function(err) {
                if (err)
                  resolve(err);
                else
                  reject();
                cb(err);
              });
            });
            return p;
          };
          Sha512.prototype.ready = Sha512.ready;
          function HMAC(key) {
            if (!(this instanceof HMAC))
              return new HMAC(key);
            this.pad = Buffer.alloc(128);
            this.inner = Sha512();
            this.outer = Sha512();
            var keyhash = Buffer.alloc(64);
            if (key.byteLength > 128) {
              Sha512().update(key).digest(keyhash);
              key = keyhash;
            }
            this.pad.fill(54);
            for (var i = 0; i < key.byteLength; i++) {
              this.pad[i] ^= key[i];
            }
            this.inner.update(this.pad);
            this.pad.fill(92);
            for (var _i = 0; _i < key.byteLength; _i++) {
              this.pad[_i] ^= key[_i];
            }
            this.outer.update(this.pad);
            this.pad.fill(0);
            keyhash.fill(0);
          }
          HMAC.prototype.update = function(input, enc) {
            this.inner.update(input, enc);
            return this;
          };
          HMAC.prototype.digest = function(enc) {
            var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            this.outer.update(this.inner.digest());
            return this.outer.digest(enc, offset);
          };
          Sha512.HMAC = HMAC;
          function noop() {
          }
          function formatInput(input, enc) {
            var result = input instanceof Uint8Array ? input : strToBuf(input, enc);
            return [result, result.byteLength];
          }
          function strToBuf(input, enc) {
            if (enc === "hex")
              return hex2bin(input);
            else if (enc === "utf8" || enc === "utf-8")
              return new TextEncoder().encode(input);
            else if (enc === "base64")
              return atob2(input);
            else
              throw new Error("Encoding: " + enc + " not supported");
          }
          function hex2bin(str) {
            if (str.length % 2 !== 0)
              return hex2bin("0" + str);
            var ret = new Uint8Array(str.length / 2);
            for (var i = 0; i < ret.length; i++) {
              ret[i] = Number("0x" + str.substring(2 * i, 2 * i + 2));
            }
            return ret;
          }
          function hexSlice(buf, start, len) {
            var str = "";
            for (var i = 0; i < len; i++) {
              str += toHex(buf[start + i]);
            }
            return str;
          }
          function toHex(n) {
            if (n < 16)
              return "0" + n.toString(16);
            return n.toString(16);
          }
          function roundUp(n, base) {
            return n + base - 1 & -base;
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "./sha512.js": 434, "buffer": 82, "nanoassert": 308 }], 434: [function(require2, module2, exports2) {
      module2.exports = loadWebAssembly;
      loadWebAssembly.supported = typeof WebAssembly !== "undefined";
      function loadWebAssembly(opts) {
        if (!loadWebAssembly.supported)
          return null;
        var imp = opts && opts.imports;
        var wasm = toUint8Array("AGFzbQEAAAABNAVgAX4BfmAIfn5+fn5+fn4AYAR+fn5+AX5gEX9+fn5+fn5+fn5+fn5+fn5+AGAEf39/fwADBgUAAQIDBAUDAQAABikIfgFCAAt+AUIAC34BQgALfgFCAAt+AUIAC34BQgALfgFCAAt+AUIACwcTAgZtZW1vcnkCAAZzaGE1MTIABAqZHgVCACAAQoCA/P+PgECDQhCJIABC//+DgPD/P4NCEIqEIQAgAEL/gfyH8J/A/wCDQgiJIABCgP6D+I/gv4B/g0IIioQLvAMBBn4jBCMFgyMEQn+FIwaDhSEKIwAjAYMjACMCg4UjASMCg4UhCyMAQhyKIwBCIoqFIwBCJ4qFIQwjBEIOiiMEQhKKhSMEQimKhSENIwcgCnwgDXwgAHwgBHwhCCAMIAt8IQkjAyAIfCQHIAggCXwkAyMHIwSDIwdCf4UjBYOFIQojAyMAgyMDIwGDhSMAIwGDhSELIwNCHIojA0IiioUjA0InioUhDCMHQg6KIwdCEoqFIwdCKYqFIQ0jBiAKfCANfCABfCAFfCEIIAwgC3whCSMCIAh8JAYgCCAJfCQCIwYjB4MjBkJ/hSMEg4UhCiMCIwODIwIjAIOFIwMjAIOFIQsjAkIciiMCQiKKhSMCQieKhSEMIwZCDoojBkISioUjBkIpioUhDSMFIAp8IA18IAJ8IAZ8IQggDCALfCEJIwEgCHwkBSAIIAl8JAEjBSMGgyMFQn+FIweDhSEKIwEjAoMjASMDg4UjAyMCg4UhCyMBQhyKIwFCIoqFIwFCJ4qFIQwjBUIOiiMFQhKKhSMFQimKhSENIwQgCnwgDXwgA3wgB3whCCAMIAt8IQkjACAIfCQEIAggCXwkAAsrACAAQhOKIABCPYqFIABCBoiFIAF8IAJCAYogAkIIioUgAkIHiIUgA3x8C6QRACAAKQPQAUIAUQRAIABCiJLznf/M+YTqADcDACAAQrvOqqbY0Ouzu383AwggAEKr8NP0r+68tzw3AxAgAELx7fT4paf9p6V/NwMYIABC0YWa7/rPlIfRADcDICAAQp/Y+dnCkdqCm383AyggAELr+obav7X2wR83AzAgAEL5wvibkaOz8NsANwM4IABCATcD0AELIAApAwAkACAAKQMIJAEgACkDECQCIAApAxgkAyAAKQMgJAQgACkDKCQFIAApAzAkBiAAKQM4JAcgARAAIQEgAhAAIQIgAxAAIQMgBBAAIQQgBRAAIQUgBhAAIQYgBxAAIQcgCBAAIQggCRAAIQkgChAAIQogCxAAIQsgDBAAIQwgDRAAIQ0gDhAAIQ4gDxAAIQ8gEBAAIRAgASACIAMgBEKi3KK5jfOLxcIAQs3LvZ+SktGb8QBCr/a04v75vuC1f0K8t6eM2PT22mkQASAFIAYgByAIQrjqopq/y7CrOUKZoJewm77E+NkAQpuf5fjK1OCfkn9CmIK2093al46rfxABIAkgCiALIAxCwoSMmIrT6oNYQr7fwauU4NbBEkKM5ZL35LfhmCRC4un+r724n4bVABABIA0gDiAPIBBC75Luk8+ul9/yAEKxrdrY47+s74B/QrWknK7y1IHum39ClM2k+8yu/M1BEAEgDyAKIAIgARACIQEgECALIAMgAhACIQIgASAMIAQgAxACIQMgAiANIAUgBBACIQQgAyAOIAYgBRACIQUgBCAPIAcgBhACIQYgBSAQIAggBxACIQcgBiABIAkgCBACIQggByACIAogCRACIQkgCCADIAsgChACIQogCSAEIAwgCxACIQsgCiAFIA0gDBACIQwgCyAGIA4gDRACIQ0gDCAHIA8gDhACIQ4gDSAIIBAgDxACIQ8gDiAJIAEgEBACIRAgASACIAMgBELSlcX3mbjazWRC48u8wuPwkd9vQrWrs9zouOfgD0LluLK9x7mohiQQASAFIAYgByAIQvWErMn1jcv0LUKDyZv1ppWhusoAQtT3h+rLu6rY3ABCtafFmKib4vz2ABABIAkgCiALIAxCq7+b866qlJ+Yf0KQ5NDt0s3xmKh/Qr/C7MeJ+cmBsH9C5J289/v436y/fxABIA0gDiAPIBBCwp+i7bP+gvBGQqXOqpj5qOTTVULvhI6AnuqY5QZC8Ny50PCsypQUEAEgDyAKIAIgARACIQEgECALIAMgAhACIQIgASAMIAQgAxACIQMgAiANIAUgBBACIQQgAyAOIAYgBRACIQUgBCAPIAcgBhACIQYgBSAQIAggBxACIQcgBiABIAkgCBACIQggByACIAogCRACIQkgCCADIAsgChACIQogCSAEIAwgCxACIQsgCiAFIA0gDBACIQwgCyAGIA4gDRACIQ0gDCAHIA8gDhACIQ4gDSAIIBAgDxACIQ8gDiAJIAEgEBACIRAgASACIAMgBEL838i21NDC2ydCppKb4YWnyI0uQu3VkNbFv5uWzQBC3+fW7Lmig5zTABABIAUgBiAHIAhC3se93cjqnIXlAEKo5d7js9eCtfYAQubdtr/kpbLhgX9Cu+qIpNGQi7mSfxABIAkgCiALIAxC5IbE55SU+t+if0KB4Ijiu8mZjah/QpGv4oeN7uKlQkKw/NKysLSUtkcQASANIA4gDyAQQpikvbedg7rJUUKQ0parxcTBzFZCqsDEu9WwjYd0Qrij75WDjqi1EBABIA8gCiACIAEQAiEBIBAgCyADIAIQAiECIAEgDCAEIAMQAiEDIAIgDSAFIAQQAiEEIAMgDiAGIAUQAiEFIAQgDyAHIAYQAiEGIAUgECAIIAcQAiEHIAYgASAJIAgQAiEIIAcgAiAKIAkQAiEJIAggAyALIAoQAiEKIAkgBCAMIAsQAiELIAogBSANIAwQAiEMIAsgBiAOIA0QAiENIAwgByAPIA4QAiEOIA0gCCAQIA8QAiEPIA4gCSABIBAQAiEQIAEgAiADIARCyKHLxuuisNIZQtPWhoqFgdubHkKZ17v8zemdpCdCqJHtjN6Wr9g0EAEgBSAGIAcgCELjtKWuvJaDjjlCy5WGmq7JquzOAELzxo+798myztsAQqPxyrW9/puX6AAQASAJIAogCyAMQvzlvu/l3eDH9ABC4N7cmPTt2NL4AELy1sKPyoKe5IR/QuzzkNOBwcDjjH8QASANIA4gDyAQQqi8jJui/7/fkH9C6fuK9L2dm6ikf0KV8pmW+/7o/L5/QqumyZuunt64RhABIA8gCiACIAEQAiEBIBAgCyADIAIQAiECIAEgDCAEIAMQAiEDIAIgDSAFIAQQAiEEIAMgDiAGIAUQAiEFIAQgDyAHIAYQAiEGIAUgECAIIAcQAiEHIAYgASAJIAgQAiEIIAcgAiAKIAkQAiEJIAggAyALIAoQAiEKIAkgBCAMIAsQAiELIAogBSANIAwQAiEMIAsgBiAOIA0QAiENIAwgByAPIA4QAiEOIA0gCCAQIA8QAiEPIA4gCSABIBAQAiEQIAEgAiADIARCnMOZ0e7Zz5NKQoeEg47ymK7DUUKe1oPv7Lqf7WpC+KK78/7v0751EAEgBSAGIAcgCEK6392Qp/WZ+AZCprGiltq437EKQq6b5PfLgOafEUKbjvGY0ebCuBsQASAJIAogCyAMQoT7kZjS/t3tKEKTyZyGtO+q5TJCvP2mrqHBr888QsyawODJ+NmOwwAQASANIA4gDyAQQraF+dnsl/XizABCqvyV48+zyr/ZAELs9dvWs/Xb5d8AQpewndLEsYai7AAQASAAIAApAwAjAHw3AwAgACAAKQMIIwF8NwMIIAAgACkDECMCfDcDECAAIAApAxgjA3w3AxggACAAKQMgIwR8NwMgIAAgACkDKCMFfDcDKCAAIAApAzAjBnw3AzAgACAAKQM4Iwd8NwM4C8MIARV+IAApA0AhBCAAKQNIIQUgBEL/AIMgAq18IQggBCEGIAQgAq18IQQgACAENwNAIAQgBlQEQCAFQgF8IQUgACAFNwNICwJAIAApA1AhCSAAKQNYIQogACkDYCELIAApA2ghDCAAKQNwIQ0gACkDeCEOIAApA4ABIQ8gACkDiAEhECAAKQOQASERIAApA5gBIRIgACkDoAEhEyAAKQOoASEUIAApA7ABIRUgACkDuAEhFiAAKQPAASEXIAApA8gBIRggCEKAAX0iCEIAUw0AIAAgCSAKIAsgDCANIA4gDyAQIBEgEiATIBQgFSAWIBcgGBADA0AgASkDACEJIAEpAwghCiABKQMQIQsgASkDGCEMIAEpAyAhDSABKQMoIQ4gASkDMCEPIAEpAzghECABKQNAIREgASkDSCESIAEpA1AhEyABKQNYIRQgASkDYCEVIAEpA2ghFiABKQNwIRcgASkDeCEYIAFBgAFqIQEgCEKAAX0iCEIAUwRAIAAgCTcDUCAAIAo3A1ggACALNwNgIAAgDDcDaCAAIA03A3AgACAONwN4IAAgDzcDgAEgACAQNwOIASAAIBE3A5ABIAAgEjcDmAEgACATNwOgASAAIBQ3A6gBIAAgFTcDsAEgACAWNwO4ASAAIBc3A8ABIAAgGDcDyAEMAgsgACAJIAogCyAMIA0gDiAPIBAgESASIBMgFCAVIBYgFyAYEAMMAAsLIANBAUYEQCAEQv8AgyEIQoABIAhCB4NCA4aGIQcCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgCKdBA3YODwMEBQYHCAkKCwwNDg8QAQILCyAHIBeEIRdCACEHCyAHIBiEIRhCACEHIAAgCSAKIAsgDCANIA4gDyAQIBEgEiATIBQgFSAWIBcgGBADIAAgBDcDQEIAIQlCACEKQgAhC0IAIQxCACENQgAhDkIAIQ9CACEQQgAhEUIAIRJCACETQgAhFEIAIRVCACEWQgAhF0IAIRgLIAcgCYQhCUIAIQcLIAcgCoQhCkIAIQcLIAcgC4QhC0IAIQcLIAcgDIQhDEIAIQcLIAcgDYQhDUIAIQcLIAcgDoQhDkIAIQcLIAcgD4QhD0IAIQcLIAcgEIQhEEIAIQcLIAcgEYQhEUIAIQcLIAcgEoQhEkIAIQcLIAcgE4QhE0IAIQcLIAcgFIQhFEIAIQcLIAcgFYQhFUIAIQcLIAcgFoQhFkIAIQcLIARCPYggBUIDiHwQACEXIARCCH4QACEYIAAgCSAKIAsgDCANIA4gDyAQIBEgEiATIBQgFSAWIBcgGBADIAAgACkDABAANwMAIAAgACkDCBAANwMIIAAgACkDEBAANwMQIAAgACkDGBAANwMYIAAgACkDIBAANwMgIAAgACkDKBAANwMoIAAgACkDMBAANwMwIAAgACkDOBAANwM4Cws=");
        var ready = null;
        var mod = {
          buffer: wasm,
          memory: null,
          exports: null,
          realloc,
          onload
        };
        onload(function() {
        });
        return mod;
        function realloc(size) {
          mod.exports.memory.grow(Math.max(0, Math.ceil(Math.abs(size - mod.memory.length) / 65536)));
          mod.memory = new Uint8Array(mod.exports.memory.buffer);
        }
        function onload(cb) {
          if (mod.exports)
            return cb();
          if (ready) {
            ready.then(cb.bind(null, null)).catch(cb);
            return;
          }
          try {
            if (opts && opts.async)
              throw new Error("async");
            setup({
              instance: new WebAssembly.Instance(new WebAssembly.Module(wasm), imp)
            });
          } catch (err) {
            ready = WebAssembly.instantiate(wasm, imp).then(setup);
          }
          onload(cb);
        }
        function setup(w) {
          mod.exports = w.instance.exports;
          mod.memory = mod.exports.memory && mod.exports.memory.buffer && new Uint8Array(mod.exports.memory.buffer);
        }
      }
      function toUint8Array(s) {
        if (typeof atob === "function")
          return new Uint8Array(atob(s).split("").map(charCodeAt));
        return require2("buffer").Buffer.from(s, "base64");
      }
      function charCodeAt(c) {
        return c.charCodeAt(0);
      }
    }, {}], 435: [function(require2, module2, exports2) {
      var varint = require2("varint");
      exports2.encode = function encode(v, b, o) {
        v = v >= 0 ? v * 2 : v * -2 - 1;
        var r = varint.encode(v, b, o);
        encode.bytes = varint.encode.bytes;
        return r;
      };
      exports2.decode = function decode(b, o) {
        var v = varint.decode(b, o);
        decode.bytes = varint.decode.bytes;
        return v & 1 ? (v + 1) / -2 : v / 2;
      };
      exports2.encodingLength = function(v) {
        return varint.encodingLength(v >= 0 ? v * 2 : v * -2 - 1);
      };
    }, { "varint": 517 }], 436: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var noise = require2("noise-protocol");
          var NoiseSymmetricState = require2("noise-protocol/symmetric-state");
          var NoiseHash = require2("noise-protocol/hash");
          var assert = require2("nanoassert");
          var EMPTY = Buffer.alloc(0);
          function SimpleHandshake(isInitiator, opts) {
            if (!(this instanceof SimpleHandshake))
              return new SimpleHandshake(isInitiator, opts);
            opts = opts || {};
            var pattern = opts.pattern || "NN";
            var prolouge = opts.prolouge || EMPTY;
            this.handshakeHash = null;
            this.onstatickey = opts.onstatickey || function(_, cb) {
              cb();
            };
            this.onephemeralkey = opts.onephemeralkey || function(_, cb) {
              cb();
            };
            this.onhandshake = opts.onhandshake || function(_, cb) {
              cb();
            };
            this.state = noise.initialize(pattern, isInitiator, prolouge, opts.staticKeyPair, opts.ephemeralKeyPair, opts.remoteStaticKey, opts.remoteEphemeralKey);
            this.waiting = isInitiator === false;
            this.finished = false;
            this.split = null;
            this._tx = Buffer.alloc(65535);
            this._rx = Buffer.alloc(65535);
          }
          SimpleHandshake.prototype.recv = function recv(data, cb) {
            var self2 = this;
            assert(self2.finished === false, "Should not call recv if finished");
            assert(data != null, "must have data");
            assert(data.byteLength <= self2._rx.byteLength, "too much data received");
            assert(self2.waiting === true, "Wrong state, not ready to receive data");
            assert(self2.split == null, "split should be null");
            var hasREBefore = self2.state.re != null;
            var hasRSBefore = self2.state.rs != null;
            try {
              self2.split = noise.readMessage(self2.state, data, self2._rx);
            } catch (ex) {
              return self2._finish(ex, null, cb);
            }
            self2.waiting = false;
            var hasREAfter = self2.state.re != null;
            var hasRSAfter = self2.state.rs != null;
            if (hasREBefore === false && hasREAfter === true) {
              return self2.onephemeralkey(self2.state.re, checkStatic);
            }
            return checkStatic();
            function checkStatic(err) {
              if (err)
                return ondone(err);
              if (hasRSBefore === false && hasRSAfter === true) {
                return self2.onstatickey(self2.state.rs, ondone);
              }
              return ondone();
            }
            function ondone(err) {
              if (err)
                return self2._finish(err, null, cb);
              var msg = self2._rx.subarray(0, noise.readMessage.bytes);
              if (self2.split)
                return self2._finish(null, msg, cb);
              cb(null, msg);
            }
          };
          SimpleHandshake.prototype.send = function send(data, cb) {
            assert(this.finished === false, "Should not call send if finished");
            assert(this.waiting === false, "Wrong state, not ready to send data");
            assert(this.split == null, "split should be null");
            data = data || EMPTY;
            try {
              this.split = noise.writeMessage(this.state, data, this._tx);
            } catch (ex) {
              return this._finish(ex, null, cb);
            }
            this.waiting = true;
            var buf = this._tx.subarray(0, noise.writeMessage.bytes);
            if (this.split != null)
              return this._finish(null, buf, cb);
            return cb(null, buf);
          };
          SimpleHandshake.prototype.destroy = function() {
            this._finish(null, null, function() {
            });
          };
          SimpleHandshake.prototype._finish = function _finish(err, msg, cb) {
            assert(this.finished === false, "Already finished");
            var self2 = this;
            self2.finished = true;
            self2.waiting = false;
            if (self2.split) {
              self2.handshakeHash = Buffer.alloc(NoiseHash.HASHLEN);
              NoiseSymmetricState.getHandshakeHash(self2.state.symmetricState, self2.handshakeHash);
            }
            if (err)
              return ondone(err);
            self2.onhandshake(self2.state, ondone);
            function ondone(err2) {
              noise.destroy(self2.state);
              cb(err2, msg, self2.split);
              self2._rx.fill(0);
              self2._tx.fill(0);
            }
          };
          SimpleHandshake.keygen = noise.keygen;
          SimpleHandshake.seedKeygen = noise.seedKeygen;
          module2.exports = SimpleHandshake;
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82, "nanoassert": 308, "noise-protocol": 336, "noise-protocol/hash": 335, "noise-protocol/symmetric-state": 337 }], 437: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var Handshake = require2("./lib/handshake");
          var messages = require2("./messages");
          var XOR = require2("./lib/xor");
          var SMC = require2("simple-message-channels");
          var crypto = require2("hypercore-crypto");
          var varint = require2("varint");
          module2.exports = class SimpleProtocol {
            constructor(initiator, handlers) {
              var payload = {
                nonce: XOR.nonce()
              };
              this.handlers = handlers || {};
              this.remotePayload = null;
              this.remotePublicKey = null;
              this.publicKey = null;
              this.handshakeHash = null;
              this.destroyed = false;
              this._initiator = initiator;
              this._payload = payload;
              this._pending = [];
              this._handshake = null;
              this._split = null;
              this._encryption = null;
              this._noise = !(handlers.encrypted === false && handlers.noise === false);
              this._buffering = null;
              this._handshaking = false;
              this._messages = new SMC({
                onmessage,
                onmissing,
                context: this,
                types: [{
                  context: this,
                  onmessage: onopen,
                  encoding: messages.Open
                }, {
                  context: this,
                  onmessage: onoptions,
                  encoding: messages.Options
                }, {
                  context: this,
                  onmessage: onstatus,
                  encoding: messages.Status
                }, {
                  context: this,
                  onmessage: onhave,
                  encoding: messages.Have
                }, {
                  context: this,
                  onmessage: onunhave,
                  encoding: messages.Unhave
                }, {
                  context: this,
                  onmessage: onwant,
                  encoding: messages.Want
                }, {
                  context: this,
                  onmessage: onunwant,
                  encoding: messages.Unwant
                }, {
                  context: this,
                  onmessage: onrequest,
                  encoding: messages.Request
                }, {
                  context: this,
                  onmessage: oncancel,
                  encoding: messages.Cancel
                }, {
                  context: this,
                  onmessage: ondata,
                  encoding: messages.Data
                }, {
                  context: this,
                  onmessage: onclose,
                  encoding: messages.Close
                }]
              });
              if (handlers.encrypted !== false || handlers.noise !== false) {
                this._handshaking = true;
                if (typeof this.handlers.keyPair !== "function") {
                  this._onkeypair(null, this.handlers.keyPair || null);
                } else {
                  this._buffering = [];
                  this.handlers.keyPair(this._onkeypair.bind(this));
                }
              }
            }
            _onkeypair(err, keyPair) {
              if (err)
                return this.destroy(err);
              if (this._handshake !== null)
                return;
              this.handlers.keyPair = keyPair;
              var handshake = new Handshake(this._initiator, messages.NoisePayload.encode(this._payload), this.handlers, this._onhandshake.bind(this));
              this.publicKey = handshake.keyPair.publicKey;
              this._handshake = handshake;
              if (this._buffering) {
                while (this._buffering.length) {
                  this._recv(this._buffering.shift());
                }
              }
              this._buffering = null;
            }
            open(ch, message) {
              return this._send(ch, 0, message);
            }
            options(ch, message) {
              return this._send(ch, 1, message);
            }
            status(ch, message) {
              return this._send(ch, 2, message);
            }
            have(ch, message) {
              return this._send(ch, 3, message);
            }
            unhave(ch, message) {
              return this._send(ch, 4, message);
            }
            want(ch, message) {
              return this._send(ch, 5, message);
            }
            unwant(ch, message) {
              return this._send(ch, 6, message);
            }
            request(ch, message) {
              return this._send(ch, 7, message);
            }
            cancel(ch, message) {
              return this._send(ch, 8, message);
            }
            data(ch, message) {
              return this._send(ch, 9, message);
            }
            close(ch, message) {
              return this._send(ch, 10, message || {});
            }
            extension(ch, id, message) {
              var buf = Buffer.allocUnsafe(varint.encodingLength(id) + message.length);
              varint.encode(id, buf, 0);
              message.copy(buf, varint.encode.bytes);
              return this._send(ch, 15, buf);
            }
            ping() {
              if (this._handshaking || this._pending.length)
                return;
              var ping = Buffer.from([0]);
              if (this._encryption !== null) {
                ping = this._encryption.encrypt(ping);
              }
              return this.handlers.send(ping);
            }
            _onhandshake(err, remotePayload, split, overflow, remotePublicKey, handshakeHash) {
              if (err)
                return this.destroy(new Error("Noise handshake error"));
              if (!remotePayload)
                return this.destroy(new Error("Remote did not include a handshake payload"));
              this.remotePublicKey = remotePublicKey;
              this.handshakeHash = handshakeHash;
              try {
                remotePayload = messages.NoisePayload.decode(remotePayload);
              } catch (_) {
                return this.destroy(new Error("Could not parse remote payload"));
              }
              this._handshake = null;
              this._handshaking = false;
              this._split = split;
              this._encryption = this.handlers.encrypted === false ? null : new XOR({
                rnonce: remotePayload.nonce,
                tnonce: this._payload.nonce
              }, split);
              this.remotePayload = remotePayload;
              if (this.handlers.onhandshake)
                this.handlers.onhandshake();
              if (this.destroyed)
                return;
              if (overflow)
                this.recv(overflow);
              while (this._pending.length && !this.destroyed) {
                this._sendNow(...this._pending.shift());
              }
            }
            _send(channel, type, message) {
              if (this._handshaking || this._pending.length) {
                this._pending.push([channel, type, message]);
                return false;
              }
              return this._sendNow(channel, type, message);
            }
            _sendNow(channel, type, message) {
              if (type === 0 && message.key && !message.capability) {
                message.capability = this.capability(message.key);
                message.key = null;
              }
              var data = this._messages.send(channel, type, message);
              if (this._encryption !== null) {
                data = this._encryption.encrypt(data);
              }
              return this.handlers.send(data);
            }
            capability(key) {
              return crypto.capability(key, this._split);
            }
            remoteCapability(key) {
              return crypto.remoteCapability(key, this._split);
            }
            recv(data) {
              if (this._buffering !== null)
                this._buffering.push(data);
              else
                this._recv(data);
            }
            _recv(data) {
              if (this.destroyed)
                return;
              if (this._handshaking) {
                this._handshake.recv(data);
                return;
              }
              if (this._encryption !== null) {
                data = this._encryption.decrypt(data);
              }
              if (!this._messages.recv(data)) {
                this.destroy(this._messages.error);
              }
            }
            destroy(err) {
              if (this.destroyed)
                return;
              this.destroyed = true;
              if (this._handshake)
                this._handshake.destroy();
              if (this._encryption)
                this._encryption.destroy();
              if (this.handlers.destroy)
                this.handlers.destroy(err);
            }
            static keyPair(seed) {
              return Handshake.keyPair(seed);
            }
          };
          function onopen(ch, message, self2) {
            if (self2.handlers.onopen)
              self2.handlers.onopen(ch, message);
          }
          function onoptions(ch, message, self2) {
            if (self2.handlers.onoptions)
              self2.handlers.onoptions(ch, message);
          }
          function onstatus(ch, message, self2) {
            if (self2.handlers.onstatus)
              self2.handlers.onstatus(ch, message);
          }
          function onhave(ch, message, self2) {
            if (self2.handlers.onhave)
              self2.handlers.onhave(ch, message);
          }
          function onunhave(ch, message, self2) {
            if (self2.handlers.onunhave)
              self2.handlers.onunhave(ch, message);
          }
          function onwant(ch, message, self2) {
            if (self2.handlers.onwant)
              self2.handlers.onwant(ch, message);
          }
          function onunwant(ch, message, self2) {
            if (self2.handlers.onunwant)
              self2.handlers.onunwant(ch, message);
          }
          function onrequest(ch, message, self2) {
            if (self2.handlers.onrequest)
              self2.handlers.onrequest(ch, message);
          }
          function oncancel(ch, message, self2) {
            if (self2.handlers.oncancel)
              self2.handlers.oncancel(ch, message);
          }
          function ondata(ch, message, self2) {
            if (self2.handlers.ondata)
              self2.handlers.ondata(ch, message);
          }
          function onclose(ch, message, self2) {
            if (self2.handlers.onclose)
              self2.handlers.onclose(ch, message);
          }
          function onmessage(ch, type, message, self2) {
            if (type !== 15)
              return;
            var id = varint.decode(message);
            var m = message.slice(varint.decode.bytes);
            if (self2.handlers.onextension)
              self2.handlers.onextension(ch, id, m);
          }
          function onmissing(bytes, self2) {
            if (self2.handlers.onmissing)
              self2.handlers.onmissing(bytes);
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "./lib/handshake": 438, "./lib/xor": 439, "./messages": 440, "buffer": 82, "hypercore-crypto": 227, "simple-message-channels": 441, "varint": 517 }], 438: [function(require2, module2, exports2) {
      (function(process, Buffer) {
        (function() {
          var SH = require2("simple-handshake");
          var DH = require2("noise-protocol/dh");
          var crypto = require2("hypercore-crypto");
          var varint = require2("varint");
          module2.exports = class ProtocolHandshake {
            constructor(initiator, payload, opts, done) {
              this.options = opts;
              this.ondone = done;
              this.buffer = null;
              this.length = 0;
              this.remotePayload = null;
              this.payload = payload;
              this.keyPair = opts.keyPair || ProtocolHandshake.keyPair();
              this.remotePublicKey = null;
              this.onrecv = onrecv.bind(this);
              this.onsend = onsend.bind(this);
              this.destroyed = false;
              this.noise = SH(initiator, {
                pattern: "XX",
                onhandshake,
                staticKeyPair: this.keyPair,
                onstatickey: onstatickey.bind(this)
              });
              var self2 = this;
              if (this.noise.waiting === false)
                process.nextTick(start, this);
              function onhandshake(state, cb) {
                process.nextTick(finish, self2);
                cb(null);
              }
            }
            recv(data) {
              if (this.destroyed)
                return;
              if (this.buffer)
                this.buffer = Buffer.concat([this.buffer, data]);
              else
                this.buffer = data;
              while (!this.destroyed && !this.noise.finished) {
                if (!this.buffer || this.buffer.length < 3)
                  return;
                if (this.length) {
                  if (this.buffer.length < this.length)
                    return;
                  var message = this.buffer.slice(0, this.length);
                  this.buffer = this.length < this.buffer.length ? this.buffer.slice(this.length) : null;
                  this.length = 0;
                  this.noise.recv(message, this.onrecv);
                } else {
                  this.length = varint.decode(this.buffer, 0);
                  this.buffer = this.buffer.slice(varint.decode.bytes);
                }
              }
            }
            destroy(err) {
              if (this.destroyed)
                return;
              this.destroyed = true;
              if (!this.noise.finished)
                this.noise.destroy();
              this.ondone(err);
            }
            static keyPair(seed) {
              var obj = {
                publicKey: Buffer.alloc(DH.PKLEN),
                secretKey: Buffer.alloc(DH.SKLEN)
              };
              if (seed)
                DH.generateSeedKeypair(obj.publicKey, obj.secretKey, seed);
              else
                DH.generateKeypair(obj.publicKey, obj.secretKey);
              return obj;
            }
          };
          function finish(self2) {
            if (self2.destroyed)
              return;
            self2.destroyed = true;
            var split = {
              rx: Buffer.from(self2.noise.split.rx),
              tx: Buffer.from(self2.noise.split.tx)
            };
            crypto.free(self2.noise.split.rx);
            crypto.free(self2.noise.split.tx);
            self2.ondone(null, self2.remotePayload, split, self2.buffer, self2.remotePublicKey, self2.noise.handshakeHash);
          }
          function start(self2) {
            if (self2.destroyed)
              return;
            self2.noise.send(self2.payload, self2.onsend);
          }
          function onsend(err, data) {
            if (err)
              return this.destroy(err);
            var buf = Buffer.allocUnsafe(varint.encodingLength(data.length) + data.length);
            varint.encode(data.length, buf, 0);
            data.copy(buf, varint.encode.bytes);
            this.options.send(buf);
          }
          function onrecv(err, data) {
            if (err)
              return this.destroy(err);
            if (data && data.length)
              this.remotePayload = Buffer.concat([data]);
            if (this.destroyed || this.noise.finished)
              return;
            if (this.noise.waiting === false) {
              this.noise.send(this.payload, this.onsend);
            }
          }
          function onstatickey(remoteKey, done) {
            this.remotePublicKey = Buffer.concat([remoteKey]);
            if (this.options.onauthenticate)
              this.options.onauthenticate(this.remotePublicKey, done);
            else
              done(null);
          }
        }).call(this);
      }).call(this, require2("_process"), require2("buffer").Buffer);
    }, { "_process": 361, "buffer": 82, "hypercore-crypto": 227, "noise-protocol/dh": 333, "simple-handshake": 436, "varint": 517 }], 439: [function(require2, module2, exports2) {
      var XSalsa20 = require2("xsalsa20-universal");
      var crypto = require2("hypercore-crypto");
      module2.exports = class XOR {
        constructor(nonces, split) {
          this.rnonce = nonces.rnonce;
          this.tnonce = nonces.tnonce;
          this.rx = new XSalsa20(this.rnonce, split.rx.slice(0, 32));
          this.tx = new XSalsa20(this.tnonce, split.tx.slice(0, 32));
        }
        encrypt(data) {
          this.tx.update(data, data);
          return data;
        }
        decrypt(data) {
          this.rx.update(data, data);
          return data;
        }
        destroy() {
          this.tx.final();
          this.rx.final();
        }
        static nonce() {
          return crypto.randomBytes(24);
        }
      };
    }, { "hypercore-crypto": 227, "xsalsa20-universal": 536 }], 440: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var encodings = require2("protocol-buffers-encodings");
          var varint = encodings.varint;
          var skip = encodings.skip;
          var NoisePayload = exports2.NoisePayload = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          };
          var Open = exports2.Open = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          };
          var Options = exports2.Options = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          };
          var Status = exports2.Status = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          };
          var Have = exports2.Have = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          };
          var Unhave = exports2.Unhave = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          };
          var Want = exports2.Want = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          };
          var Unwant = exports2.Unwant = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          };
          var Request = exports2.Request = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          };
          var Cancel = exports2.Cancel = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          };
          var Data = exports2.Data = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          };
          var Close = exports2.Close = {
            buffer: true,
            encodingLength: null,
            encode: null,
            decode: null
          };
          defineNoisePayload();
          defineOpen();
          defineOptions();
          defineStatus();
          defineHave();
          defineUnhave();
          defineWant();
          defineUnwant();
          defineRequest();
          defineCancel();
          defineData();
          defineClose();
          function defineNoisePayload() {
            var enc = [encodings.bytes];
            NoisePayload.encodingLength = encodingLength;
            NoisePayload.encode = encode;
            NoisePayload.decode = decode;
            function encodingLength(obj) {
              var length = 0;
              if (!defined(obj.nonce))
                throw new Error("nonce is required");
              var len = enc[0].encodingLength(obj.nonce);
              length += 1 + len;
              return length;
            }
            function encode(obj, buf, offset) {
              if (!offset)
                offset = 0;
              if (!buf)
                buf = Buffer.allocUnsafe(encodingLength(obj));
              var oldOffset = offset;
              if (!defined(obj.nonce))
                throw new Error("nonce is required");
              buf[offset++] = 10;
              enc[0].encode(obj.nonce, buf, offset);
              offset += enc[0].encode.bytes;
              encode.bytes = offset - oldOffset;
              return buf;
            }
            function decode(buf, offset, end) {
              if (!offset)
                offset = 0;
              if (!end)
                end = buf.length;
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid");
              var oldOffset = offset;
              var obj = {
                nonce: null
              };
              var found0 = false;
              while (true) {
                if (end <= offset) {
                  if (!found0)
                    throw new Error("Decoded message is not valid");
                  decode.bytes = offset - oldOffset;
                  return obj;
                }
                var prefix = varint.decode(buf, offset);
                offset += varint.decode.bytes;
                var tag = prefix >> 3;
                switch (tag) {
                  case 1:
                    obj.nonce = enc[0].decode(buf, offset);
                    offset += enc[0].decode.bytes;
                    found0 = true;
                    break;
                  default:
                    offset = skip(prefix & 7, buf, offset);
                }
              }
            }
          }
          function defineOpen() {
            var enc = [encodings.bytes];
            Open.encodingLength = encodingLength;
            Open.encode = encode;
            Open.decode = decode;
            function encodingLength(obj) {
              var length = 0;
              if (!defined(obj.discoveryKey))
                throw new Error("discoveryKey is required");
              var len = enc[0].encodingLength(obj.discoveryKey);
              length += 1 + len;
              if (defined(obj.capability)) {
                var len = enc[0].encodingLength(obj.capability);
                length += 1 + len;
              }
              return length;
            }
            function encode(obj, buf, offset) {
              if (!offset)
                offset = 0;
              if (!buf)
                buf = Buffer.allocUnsafe(encodingLength(obj));
              var oldOffset = offset;
              if (!defined(obj.discoveryKey))
                throw new Error("discoveryKey is required");
              buf[offset++] = 10;
              enc[0].encode(obj.discoveryKey, buf, offset);
              offset += enc[0].encode.bytes;
              if (defined(obj.capability)) {
                buf[offset++] = 18;
                enc[0].encode(obj.capability, buf, offset);
                offset += enc[0].encode.bytes;
              }
              encode.bytes = offset - oldOffset;
              return buf;
            }
            function decode(buf, offset, end) {
              if (!offset)
                offset = 0;
              if (!end)
                end = buf.length;
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid");
              var oldOffset = offset;
              var obj = {
                discoveryKey: null,
                capability: null
              };
              var found0 = false;
              while (true) {
                if (end <= offset) {
                  if (!found0)
                    throw new Error("Decoded message is not valid");
                  decode.bytes = offset - oldOffset;
                  return obj;
                }
                var prefix = varint.decode(buf, offset);
                offset += varint.decode.bytes;
                var tag = prefix >> 3;
                switch (tag) {
                  case 1:
                    obj.discoveryKey = enc[0].decode(buf, offset);
                    offset += enc[0].decode.bytes;
                    found0 = true;
                    break;
                  case 2:
                    obj.capability = enc[0].decode(buf, offset);
                    offset += enc[0].decode.bytes;
                    break;
                  default:
                    offset = skip(prefix & 7, buf, offset);
                }
              }
            }
          }
          function defineOptions() {
            var enc = [encodings.string, encodings.bool];
            Options.encodingLength = encodingLength;
            Options.encode = encode;
            Options.decode = decode;
            function encodingLength(obj) {
              var length = 0;
              if (defined(obj.extensions)) {
                for (var i = 0; i < obj.extensions.length; i++) {
                  if (!defined(obj.extensions[i]))
                    continue;
                  var len = enc[0].encodingLength(obj.extensions[i]);
                  length += 1 + len;
                }
              }
              if (defined(obj.ack)) {
                var len = enc[1].encodingLength(obj.ack);
                length += 1 + len;
              }
              return length;
            }
            function encode(obj, buf, offset) {
              if (!offset)
                offset = 0;
              if (!buf)
                buf = Buffer.allocUnsafe(encodingLength(obj));
              var oldOffset = offset;
              if (defined(obj.extensions)) {
                for (var i = 0; i < obj.extensions.length; i++) {
                  if (!defined(obj.extensions[i]))
                    continue;
                  buf[offset++] = 10;
                  enc[0].encode(obj.extensions[i], buf, offset);
                  offset += enc[0].encode.bytes;
                }
              }
              if (defined(obj.ack)) {
                buf[offset++] = 16;
                enc[1].encode(obj.ack, buf, offset);
                offset += enc[1].encode.bytes;
              }
              encode.bytes = offset - oldOffset;
              return buf;
            }
            function decode(buf, offset, end) {
              if (!offset)
                offset = 0;
              if (!end)
                end = buf.length;
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid");
              var oldOffset = offset;
              var obj = {
                extensions: [],
                ack: false
              };
              while (true) {
                if (end <= offset) {
                  decode.bytes = offset - oldOffset;
                  return obj;
                }
                var prefix = varint.decode(buf, offset);
                offset += varint.decode.bytes;
                var tag = prefix >> 3;
                switch (tag) {
                  case 1:
                    obj.extensions.push(enc[0].decode(buf, offset));
                    offset += enc[0].decode.bytes;
                    break;
                  case 2:
                    obj.ack = enc[1].decode(buf, offset);
                    offset += enc[1].decode.bytes;
                    break;
                  default:
                    offset = skip(prefix & 7, buf, offset);
                }
              }
            }
          }
          function defineStatus() {
            var enc = [encodings.bool];
            Status.encodingLength = encodingLength;
            Status.encode = encode;
            Status.decode = decode;
            function encodingLength(obj) {
              var length = 0;
              if (defined(obj.uploading)) {
                var len = enc[0].encodingLength(obj.uploading);
                length += 1 + len;
              }
              if (defined(obj.downloading)) {
                var len = enc[0].encodingLength(obj.downloading);
                length += 1 + len;
              }
              return length;
            }
            function encode(obj, buf, offset) {
              if (!offset)
                offset = 0;
              if (!buf)
                buf = Buffer.allocUnsafe(encodingLength(obj));
              var oldOffset = offset;
              if (defined(obj.uploading)) {
                buf[offset++] = 8;
                enc[0].encode(obj.uploading, buf, offset);
                offset += enc[0].encode.bytes;
              }
              if (defined(obj.downloading)) {
                buf[offset++] = 16;
                enc[0].encode(obj.downloading, buf, offset);
                offset += enc[0].encode.bytes;
              }
              encode.bytes = offset - oldOffset;
              return buf;
            }
            function decode(buf, offset, end) {
              if (!offset)
                offset = 0;
              if (!end)
                end = buf.length;
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid");
              var oldOffset = offset;
              var obj = {
                uploading: false,
                downloading: false
              };
              while (true) {
                if (end <= offset) {
                  decode.bytes = offset - oldOffset;
                  return obj;
                }
                var prefix = varint.decode(buf, offset);
                offset += varint.decode.bytes;
                var tag = prefix >> 3;
                switch (tag) {
                  case 1:
                    obj.uploading = enc[0].decode(buf, offset);
                    offset += enc[0].decode.bytes;
                    break;
                  case 2:
                    obj.downloading = enc[0].decode(buf, offset);
                    offset += enc[0].decode.bytes;
                    break;
                  default:
                    offset = skip(prefix & 7, buf, offset);
                }
              }
            }
          }
          function defineHave() {
            var enc = [encodings.varint, encodings.bytes, encodings.bool];
            Have.encodingLength = encodingLength;
            Have.encode = encode;
            Have.decode = decode;
            function encodingLength(obj) {
              var length = 0;
              if (!defined(obj.start))
                throw new Error("start is required");
              var len = enc[0].encodingLength(obj.start);
              length += 1 + len;
              if (defined(obj.length)) {
                var len = enc[0].encodingLength(obj.length);
                length += 1 + len;
              }
              if (defined(obj.bitfield)) {
                var len = enc[1].encodingLength(obj.bitfield);
                length += 1 + len;
              }
              if (defined(obj.ack)) {
                var len = enc[2].encodingLength(obj.ack);
                length += 1 + len;
              }
              return length;
            }
            function encode(obj, buf, offset) {
              if (!offset)
                offset = 0;
              if (!buf)
                buf = Buffer.allocUnsafe(encodingLength(obj));
              var oldOffset = offset;
              if (!defined(obj.start))
                throw new Error("start is required");
              buf[offset++] = 8;
              enc[0].encode(obj.start, buf, offset);
              offset += enc[0].encode.bytes;
              if (defined(obj.length)) {
                buf[offset++] = 16;
                enc[0].encode(obj.length, buf, offset);
                offset += enc[0].encode.bytes;
              }
              if (defined(obj.bitfield)) {
                buf[offset++] = 26;
                enc[1].encode(obj.bitfield, buf, offset);
                offset += enc[1].encode.bytes;
              }
              if (defined(obj.ack)) {
                buf[offset++] = 32;
                enc[2].encode(obj.ack, buf, offset);
                offset += enc[2].encode.bytes;
              }
              encode.bytes = offset - oldOffset;
              return buf;
            }
            function decode(buf, offset, end) {
              if (!offset)
                offset = 0;
              if (!end)
                end = buf.length;
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid");
              var oldOffset = offset;
              var obj = {
                start: 0,
                length: 1,
                bitfield: null,
                ack: false
              };
              var found0 = false;
              while (true) {
                if (end <= offset) {
                  if (!found0)
                    throw new Error("Decoded message is not valid");
                  decode.bytes = offset - oldOffset;
                  return obj;
                }
                var prefix = varint.decode(buf, offset);
                offset += varint.decode.bytes;
                var tag = prefix >> 3;
                switch (tag) {
                  case 1:
                    obj.start = enc[0].decode(buf, offset);
                    offset += enc[0].decode.bytes;
                    found0 = true;
                    break;
                  case 2:
                    obj.length = enc[0].decode(buf, offset);
                    offset += enc[0].decode.bytes;
                    break;
                  case 3:
                    obj.bitfield = enc[1].decode(buf, offset);
                    offset += enc[1].decode.bytes;
                    break;
                  case 4:
                    obj.ack = enc[2].decode(buf, offset);
                    offset += enc[2].decode.bytes;
                    break;
                  default:
                    offset = skip(prefix & 7, buf, offset);
                }
              }
            }
          }
          function defineUnhave() {
            var enc = [encodings.varint];
            Unhave.encodingLength = encodingLength;
            Unhave.encode = encode;
            Unhave.decode = decode;
            function encodingLength(obj) {
              var length = 0;
              if (!defined(obj.start))
                throw new Error("start is required");
              var len = enc[0].encodingLength(obj.start);
              length += 1 + len;
              if (defined(obj.length)) {
                var len = enc[0].encodingLength(obj.length);
                length += 1 + len;
              }
              return length;
            }
            function encode(obj, buf, offset) {
              if (!offset)
                offset = 0;
              if (!buf)
                buf = Buffer.allocUnsafe(encodingLength(obj));
              var oldOffset = offset;
              if (!defined(obj.start))
                throw new Error("start is required");
              buf[offset++] = 8;
              enc[0].encode(obj.start, buf, offset);
              offset += enc[0].encode.bytes;
              if (defined(obj.length)) {
                buf[offset++] = 16;
                enc[0].encode(obj.length, buf, offset);
                offset += enc[0].encode.bytes;
              }
              encode.bytes = offset - oldOffset;
              return buf;
            }
            function decode(buf, offset, end) {
              if (!offset)
                offset = 0;
              if (!end)
                end = buf.length;
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid");
              var oldOffset = offset;
              var obj = {
                start: 0,
                length: 1
              };
              var found0 = false;
              while (true) {
                if (end <= offset) {
                  if (!found0)
                    throw new Error("Decoded message is not valid");
                  decode.bytes = offset - oldOffset;
                  return obj;
                }
                var prefix = varint.decode(buf, offset);
                offset += varint.decode.bytes;
                var tag = prefix >> 3;
                switch (tag) {
                  case 1:
                    obj.start = enc[0].decode(buf, offset);
                    offset += enc[0].decode.bytes;
                    found0 = true;
                    break;
                  case 2:
                    obj.length = enc[0].decode(buf, offset);
                    offset += enc[0].decode.bytes;
                    break;
                  default:
                    offset = skip(prefix & 7, buf, offset);
                }
              }
            }
          }
          function defineWant() {
            var enc = [encodings.varint];
            Want.encodingLength = encodingLength;
            Want.encode = encode;
            Want.decode = decode;
            function encodingLength(obj) {
              var length = 0;
              if (!defined(obj.start))
                throw new Error("start is required");
              var len = enc[0].encodingLength(obj.start);
              length += 1 + len;
              if (defined(obj.length)) {
                var len = enc[0].encodingLength(obj.length);
                length += 1 + len;
              }
              return length;
            }
            function encode(obj, buf, offset) {
              if (!offset)
                offset = 0;
              if (!buf)
                buf = Buffer.allocUnsafe(encodingLength(obj));
              var oldOffset = offset;
              if (!defined(obj.start))
                throw new Error("start is required");
              buf[offset++] = 8;
              enc[0].encode(obj.start, buf, offset);
              offset += enc[0].encode.bytes;
              if (defined(obj.length)) {
                buf[offset++] = 16;
                enc[0].encode(obj.length, buf, offset);
                offset += enc[0].encode.bytes;
              }
              encode.bytes = offset - oldOffset;
              return buf;
            }
            function decode(buf, offset, end) {
              if (!offset)
                offset = 0;
              if (!end)
                end = buf.length;
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid");
              var oldOffset = offset;
              var obj = {
                start: 0,
                length: 0
              };
              var found0 = false;
              while (true) {
                if (end <= offset) {
                  if (!found0)
                    throw new Error("Decoded message is not valid");
                  decode.bytes = offset - oldOffset;
                  return obj;
                }
                var prefix = varint.decode(buf, offset);
                offset += varint.decode.bytes;
                var tag = prefix >> 3;
                switch (tag) {
                  case 1:
                    obj.start = enc[0].decode(buf, offset);
                    offset += enc[0].decode.bytes;
                    found0 = true;
                    break;
                  case 2:
                    obj.length = enc[0].decode(buf, offset);
                    offset += enc[0].decode.bytes;
                    break;
                  default:
                    offset = skip(prefix & 7, buf, offset);
                }
              }
            }
          }
          function defineUnwant() {
            var enc = [encodings.varint];
            Unwant.encodingLength = encodingLength;
            Unwant.encode = encode;
            Unwant.decode = decode;
            function encodingLength(obj) {
              var length = 0;
              if (!defined(obj.start))
                throw new Error("start is required");
              var len = enc[0].encodingLength(obj.start);
              length += 1 + len;
              if (defined(obj.length)) {
                var len = enc[0].encodingLength(obj.length);
                length += 1 + len;
              }
              return length;
            }
            function encode(obj, buf, offset) {
              if (!offset)
                offset = 0;
              if (!buf)
                buf = Buffer.allocUnsafe(encodingLength(obj));
              var oldOffset = offset;
              if (!defined(obj.start))
                throw new Error("start is required");
              buf[offset++] = 8;
              enc[0].encode(obj.start, buf, offset);
              offset += enc[0].encode.bytes;
              if (defined(obj.length)) {
                buf[offset++] = 16;
                enc[0].encode(obj.length, buf, offset);
                offset += enc[0].encode.bytes;
              }
              encode.bytes = offset - oldOffset;
              return buf;
            }
            function decode(buf, offset, end) {
              if (!offset)
                offset = 0;
              if (!end)
                end = buf.length;
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid");
              var oldOffset = offset;
              var obj = {
                start: 0,
                length: 0
              };
              var found0 = false;
              while (true) {
                if (end <= offset) {
                  if (!found0)
                    throw new Error("Decoded message is not valid");
                  decode.bytes = offset - oldOffset;
                  return obj;
                }
                var prefix = varint.decode(buf, offset);
                offset += varint.decode.bytes;
                var tag = prefix >> 3;
                switch (tag) {
                  case 1:
                    obj.start = enc[0].decode(buf, offset);
                    offset += enc[0].decode.bytes;
                    found0 = true;
                    break;
                  case 2:
                    obj.length = enc[0].decode(buf, offset);
                    offset += enc[0].decode.bytes;
                    break;
                  default:
                    offset = skip(prefix & 7, buf, offset);
                }
              }
            }
          }
          function defineRequest() {
            var enc = [encodings.varint, encodings.bool];
            Request.encodingLength = encodingLength;
            Request.encode = encode;
            Request.decode = decode;
            function encodingLength(obj) {
              var length = 0;
              if (!defined(obj.index))
                throw new Error("index is required");
              var len = enc[0].encodingLength(obj.index);
              length += 1 + len;
              if (defined(obj.bytes)) {
                var len = enc[0].encodingLength(obj.bytes);
                length += 1 + len;
              }
              if (defined(obj.hash)) {
                var len = enc[1].encodingLength(obj.hash);
                length += 1 + len;
              }
              if (defined(obj.nodes)) {
                var len = enc[0].encodingLength(obj.nodes);
                length += 1 + len;
              }
              return length;
            }
            function encode(obj, buf, offset) {
              if (!offset)
                offset = 0;
              if (!buf)
                buf = Buffer.allocUnsafe(encodingLength(obj));
              var oldOffset = offset;
              if (!defined(obj.index))
                throw new Error("index is required");
              buf[offset++] = 8;
              enc[0].encode(obj.index, buf, offset);
              offset += enc[0].encode.bytes;
              if (defined(obj.bytes)) {
                buf[offset++] = 16;
                enc[0].encode(obj.bytes, buf, offset);
                offset += enc[0].encode.bytes;
              }
              if (defined(obj.hash)) {
                buf[offset++] = 24;
                enc[1].encode(obj.hash, buf, offset);
                offset += enc[1].encode.bytes;
              }
              if (defined(obj.nodes)) {
                buf[offset++] = 32;
                enc[0].encode(obj.nodes, buf, offset);
                offset += enc[0].encode.bytes;
              }
              encode.bytes = offset - oldOffset;
              return buf;
            }
            function decode(buf, offset, end) {
              if (!offset)
                offset = 0;
              if (!end)
                end = buf.length;
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid");
              var oldOffset = offset;
              var obj = {
                index: 0,
                bytes: 0,
                hash: false,
                nodes: 0
              };
              var found0 = false;
              while (true) {
                if (end <= offset) {
                  if (!found0)
                    throw new Error("Decoded message is not valid");
                  decode.bytes = offset - oldOffset;
                  return obj;
                }
                var prefix = varint.decode(buf, offset);
                offset += varint.decode.bytes;
                var tag = prefix >> 3;
                switch (tag) {
                  case 1:
                    obj.index = enc[0].decode(buf, offset);
                    offset += enc[0].decode.bytes;
                    found0 = true;
                    break;
                  case 2:
                    obj.bytes = enc[0].decode(buf, offset);
                    offset += enc[0].decode.bytes;
                    break;
                  case 3:
                    obj.hash = enc[1].decode(buf, offset);
                    offset += enc[1].decode.bytes;
                    break;
                  case 4:
                    obj.nodes = enc[0].decode(buf, offset);
                    offset += enc[0].decode.bytes;
                    break;
                  default:
                    offset = skip(prefix & 7, buf, offset);
                }
              }
            }
          }
          function defineCancel() {
            var enc = [encodings.varint, encodings.bool];
            Cancel.encodingLength = encodingLength;
            Cancel.encode = encode;
            Cancel.decode = decode;
            function encodingLength(obj) {
              var length = 0;
              if (!defined(obj.index))
                throw new Error("index is required");
              var len = enc[0].encodingLength(obj.index);
              length += 1 + len;
              if (defined(obj.bytes)) {
                var len = enc[0].encodingLength(obj.bytes);
                length += 1 + len;
              }
              if (defined(obj.hash)) {
                var len = enc[1].encodingLength(obj.hash);
                length += 1 + len;
              }
              return length;
            }
            function encode(obj, buf, offset) {
              if (!offset)
                offset = 0;
              if (!buf)
                buf = Buffer.allocUnsafe(encodingLength(obj));
              var oldOffset = offset;
              if (!defined(obj.index))
                throw new Error("index is required");
              buf[offset++] = 8;
              enc[0].encode(obj.index, buf, offset);
              offset += enc[0].encode.bytes;
              if (defined(obj.bytes)) {
                buf[offset++] = 16;
                enc[0].encode(obj.bytes, buf, offset);
                offset += enc[0].encode.bytes;
              }
              if (defined(obj.hash)) {
                buf[offset++] = 24;
                enc[1].encode(obj.hash, buf, offset);
                offset += enc[1].encode.bytes;
              }
              encode.bytes = offset - oldOffset;
              return buf;
            }
            function decode(buf, offset, end) {
              if (!offset)
                offset = 0;
              if (!end)
                end = buf.length;
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid");
              var oldOffset = offset;
              var obj = {
                index: 0,
                bytes: 0,
                hash: false
              };
              var found0 = false;
              while (true) {
                if (end <= offset) {
                  if (!found0)
                    throw new Error("Decoded message is not valid");
                  decode.bytes = offset - oldOffset;
                  return obj;
                }
                var prefix = varint.decode(buf, offset);
                offset += varint.decode.bytes;
                var tag = prefix >> 3;
                switch (tag) {
                  case 1:
                    obj.index = enc[0].decode(buf, offset);
                    offset += enc[0].decode.bytes;
                    found0 = true;
                    break;
                  case 2:
                    obj.bytes = enc[0].decode(buf, offset);
                    offset += enc[0].decode.bytes;
                    break;
                  case 3:
                    obj.hash = enc[1].decode(buf, offset);
                    offset += enc[1].decode.bytes;
                    break;
                  default:
                    offset = skip(prefix & 7, buf, offset);
                }
              }
            }
          }
          function defineData() {
            var Node = Data.Node = {
              buffer: true,
              encodingLength: null,
              encode: null,
              decode: null
            };
            defineNode();
            function defineNode() {
              var enc2 = [encodings.varint, encodings.bytes];
              Node.encodingLength = encodingLength2;
              Node.encode = encode2;
              Node.decode = decode2;
              function encodingLength2(obj) {
                var length = 0;
                if (!defined(obj.index))
                  throw new Error("index is required");
                var len = enc2[0].encodingLength(obj.index);
                length += 1 + len;
                if (!defined(obj.hash))
                  throw new Error("hash is required");
                var len = enc2[1].encodingLength(obj.hash);
                length += 1 + len;
                if (!defined(obj.size))
                  throw new Error("size is required");
                var len = enc2[0].encodingLength(obj.size);
                length += 1 + len;
                return length;
              }
              function encode2(obj, buf, offset) {
                if (!offset)
                  offset = 0;
                if (!buf)
                  buf = Buffer.allocUnsafe(encodingLength2(obj));
                var oldOffset = offset;
                if (!defined(obj.index))
                  throw new Error("index is required");
                buf[offset++] = 8;
                enc2[0].encode(obj.index, buf, offset);
                offset += enc2[0].encode.bytes;
                if (!defined(obj.hash))
                  throw new Error("hash is required");
                buf[offset++] = 18;
                enc2[1].encode(obj.hash, buf, offset);
                offset += enc2[1].encode.bytes;
                if (!defined(obj.size))
                  throw new Error("size is required");
                buf[offset++] = 24;
                enc2[0].encode(obj.size, buf, offset);
                offset += enc2[0].encode.bytes;
                encode2.bytes = offset - oldOffset;
                return buf;
              }
              function decode2(buf, offset, end) {
                if (!offset)
                  offset = 0;
                if (!end)
                  end = buf.length;
                if (!(end <= buf.length && offset <= buf.length))
                  throw new Error("Decoded message is not valid");
                var oldOffset = offset;
                var obj = {
                  index: 0,
                  hash: null,
                  size: 0
                };
                var found0 = false;
                var found1 = false;
                var found2 = false;
                while (true) {
                  if (end <= offset) {
                    if (!found0 || !found1 || !found2)
                      throw new Error("Decoded message is not valid");
                    decode2.bytes = offset - oldOffset;
                    return obj;
                  }
                  var prefix = varint.decode(buf, offset);
                  offset += varint.decode.bytes;
                  var tag = prefix >> 3;
                  switch (tag) {
                    case 1:
                      obj.index = enc2[0].decode(buf, offset);
                      offset += enc2[0].decode.bytes;
                      found0 = true;
                      break;
                    case 2:
                      obj.hash = enc2[1].decode(buf, offset);
                      offset += enc2[1].decode.bytes;
                      found1 = true;
                      break;
                    case 3:
                      obj.size = enc2[0].decode(buf, offset);
                      offset += enc2[0].decode.bytes;
                      found2 = true;
                      break;
                    default:
                      offset = skip(prefix & 7, buf, offset);
                  }
                }
              }
            }
            var enc = [encodings.varint, encodings.bytes, Node];
            Data.encodingLength = encodingLength;
            Data.encode = encode;
            Data.decode = decode;
            function encodingLength(obj) {
              var length = 0;
              if (!defined(obj.index))
                throw new Error("index is required");
              var len = enc[0].encodingLength(obj.index);
              length += 1 + len;
              if (defined(obj.value)) {
                var len = enc[1].encodingLength(obj.value);
                length += 1 + len;
              }
              if (defined(obj.nodes)) {
                for (var i = 0; i < obj.nodes.length; i++) {
                  if (!defined(obj.nodes[i]))
                    continue;
                  var len = enc[2].encodingLength(obj.nodes[i]);
                  length += varint.encodingLength(len);
                  length += 1 + len;
                }
              }
              if (defined(obj.signature)) {
                var len = enc[1].encodingLength(obj.signature);
                length += 1 + len;
              }
              return length;
            }
            function encode(obj, buf, offset) {
              if (!offset)
                offset = 0;
              if (!buf)
                buf = Buffer.allocUnsafe(encodingLength(obj));
              var oldOffset = offset;
              if (!defined(obj.index))
                throw new Error("index is required");
              buf[offset++] = 8;
              enc[0].encode(obj.index, buf, offset);
              offset += enc[0].encode.bytes;
              if (defined(obj.value)) {
                buf[offset++] = 18;
                enc[1].encode(obj.value, buf, offset);
                offset += enc[1].encode.bytes;
              }
              if (defined(obj.nodes)) {
                for (var i = 0; i < obj.nodes.length; i++) {
                  if (!defined(obj.nodes[i]))
                    continue;
                  buf[offset++] = 26;
                  varint.encode(enc[2].encodingLength(obj.nodes[i]), buf, offset);
                  offset += varint.encode.bytes;
                  enc[2].encode(obj.nodes[i], buf, offset);
                  offset += enc[2].encode.bytes;
                }
              }
              if (defined(obj.signature)) {
                buf[offset++] = 34;
                enc[1].encode(obj.signature, buf, offset);
                offset += enc[1].encode.bytes;
              }
              encode.bytes = offset - oldOffset;
              return buf;
            }
            function decode(buf, offset, end) {
              if (!offset)
                offset = 0;
              if (!end)
                end = buf.length;
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid");
              var oldOffset = offset;
              var obj = {
                index: 0,
                value: null,
                nodes: [],
                signature: null
              };
              var found0 = false;
              while (true) {
                if (end <= offset) {
                  if (!found0)
                    throw new Error("Decoded message is not valid");
                  decode.bytes = offset - oldOffset;
                  return obj;
                }
                var prefix = varint.decode(buf, offset);
                offset += varint.decode.bytes;
                var tag = prefix >> 3;
                switch (tag) {
                  case 1:
                    obj.index = enc[0].decode(buf, offset);
                    offset += enc[0].decode.bytes;
                    found0 = true;
                    break;
                  case 2:
                    obj.value = enc[1].decode(buf, offset);
                    offset += enc[1].decode.bytes;
                    break;
                  case 3:
                    var len = varint.decode(buf, offset);
                    offset += varint.decode.bytes;
                    obj.nodes.push(enc[2].decode(buf, offset, offset + len));
                    offset += enc[2].decode.bytes;
                    break;
                  case 4:
                    obj.signature = enc[1].decode(buf, offset);
                    offset += enc[1].decode.bytes;
                    break;
                  default:
                    offset = skip(prefix & 7, buf, offset);
                }
              }
            }
          }
          function defineClose() {
            var enc = [encodings.bytes];
            Close.encodingLength = encodingLength;
            Close.encode = encode;
            Close.decode = decode;
            function encodingLength(obj) {
              var length = 0;
              if (defined(obj.discoveryKey)) {
                var len = enc[0].encodingLength(obj.discoveryKey);
                length += 1 + len;
              }
              return length;
            }
            function encode(obj, buf, offset) {
              if (!offset)
                offset = 0;
              if (!buf)
                buf = Buffer.allocUnsafe(encodingLength(obj));
              var oldOffset = offset;
              if (defined(obj.discoveryKey)) {
                buf[offset++] = 10;
                enc[0].encode(obj.discoveryKey, buf, offset);
                offset += enc[0].encode.bytes;
              }
              encode.bytes = offset - oldOffset;
              return buf;
            }
            function decode(buf, offset, end) {
              if (!offset)
                offset = 0;
              if (!end)
                end = buf.length;
              if (!(end <= buf.length && offset <= buf.length))
                throw new Error("Decoded message is not valid");
              var oldOffset = offset;
              var obj = {
                discoveryKey: null
              };
              while (true) {
                if (end <= offset) {
                  decode.bytes = offset - oldOffset;
                  return obj;
                }
                var prefix = varint.decode(buf, offset);
                offset += varint.decode.bytes;
                var tag = prefix >> 3;
                switch (tag) {
                  case 1:
                    obj.discoveryKey = enc[0].decode(buf, offset);
                    offset += enc[0].decode.bytes;
                    break;
                  default:
                    offset = skip(prefix & 7, buf, offset);
                }
              }
            }
          }
          function defined(val) {
            return val !== null && val !== void 0 && (typeof val !== "number" || !isNaN(val));
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82, "protocol-buffers-encodings": 363 }], 441: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var varint = require2("varint");
          module2.exports = class SimpleMessageChannels {
            constructor() {
              var {
                maxSize = 8 * 1024 * 1024,
                context = null,
                onmessage = null,
                onmissing = null,
                types = null
              } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              this._message = null;
              this._ptr = 0;
              this._varint = 0;
              this._factor = 1;
              this._length = 0;
              this._header = 0;
              this._state = 0;
              this._consumed = 0;
              this._maxSize = maxSize;
              this._types = types || [];
              this.receiving = false;
              this.destroyed = false;
              this.error = null;
              this.context = context;
              this.onmessage = onmessage;
              this.onmissing = onmissing;
            }
            destroy(err) {
              if (err)
                this.error = err;
              this.destroyed = true;
            }
            recv(data) {
              if (this.receiving === true)
                throw new Error("Cannot recursively receive data");
              this.receiving = true;
              var offset = 0;
              while (offset < data.length) {
                if (this._state === 2)
                  offset = this._readMessage(data, offset);
                else
                  offset = this._readVarint(data, offset);
              }
              if (this._state === 2 && this._length === 0) {
                this._readMessage(data, offset);
              }
              this.receiving = false;
              return !this.destroyed;
            }
            _readMessage(data, offset) {
              var free = data.length - offset;
              if (free >= this._length) {
                if (this._message) {
                  data.copy(this._message, this._message.length - this._length, offset);
                } else {
                  this._message = data.slice(offset, offset + this._length);
                }
                return this._nextState(data, offset += this._length) ? offset : data.length;
              }
              if (!this._message)
                this._message = Buffer.allocUnsafe(this._length);
              data.copy(this._message, this._message.length - this._length, offset);
              this._length -= free;
              return data.length;
            }
            _readVarint(data, offset) {
              for (; offset < data.length; offset++) {
                this._varint += (data[offset] & 127) * this._factor;
                this._consumed++;
                if (data[offset] < 128)
                  return this._nextState(data, ++offset) ? offset : data.length;
                this._factor *= 128;
              }
              if (this._consumed >= 8)
                this.destroy(new Error("Incoming varint is invalid"));
              return data.length;
            }
            _nextState(data, offset) {
              switch (this._state) {
                case 0:
                  this._state = 1;
                  this._factor = 1;
                  this._length = this._varint;
                  this._consumed = this._varint = 0;
                  if (this._length === 0)
                    this._state = 0;
                  return true;
                case 1:
                  this._state = 2;
                  this._factor = 1;
                  this._header = this._varint;
                  this._length -= this._consumed;
                  this._consumed = this._varint = 0;
                  if (this._length < 0 || this._length > this._maxSize) {
                    this.destroy(new Error("Incoming message is larger than max size"));
                    return false;
                  }
                  if (this.onmissing) {
                    var extra = data.length - offset;
                    if (this._length > extra)
                      this.onmissing(this._length - extra, this.context);
                  }
                  return true;
                case 2:
                  this._state = 0;
                  this._onmessage(this._header >> 4, this._header & 15, this._message, data, offset);
                  this._message = null;
                  return !this.destroyed;
                default:
                  return false;
              }
            }
            _onmessage(channel, type, message, data, offset) {
              if (type >= this._types.length) {
                if (this.onmessage === null)
                  return;
                return this.onmessage(channel, type, message, this.context, data, offset);
              }
              var m = null;
              var {
                onmessage,
                encoding,
                context
              } = this._types[type];
              try {
                m = encoding.decode(message);
              } catch (err) {
                this.destroy(err);
                return;
              }
              onmessage(channel, m, context, data, offset);
            }
            send(channel, type, message) {
              var header = channel << 4 | type;
              var length = this._encodingLength(type, message) + varint.encodingLength(header);
              var payload = Buffer.allocUnsafe(varint.encodingLength(length) + length);
              varint.encode(length, payload, 0);
              var offset = varint.encode.bytes;
              varint.encode(header, payload, offset);
              this._encode(type, message, payload, offset + varint.encode.bytes);
              return payload;
            }
            sendBatch(messages) {
              var length = 0;
              var offset = 0;
              for (var {
                type,
                message
              } of messages) {
                length += 16 + this._encodingLength(type, message);
              }
              var payload = Buffer.allocUnsafe(length);
              for (var {
                channel,
                type: _type,
                message: _message
              } of messages) {
                var header = channel << 4 | _type;
                var _length = this._encodingLength(_type, _message) + varint.encodingLength(header);
                varint.encode(_length, payload, offset);
                offset += varint.encode.bytes;
                varint.encode(header, payload, offset);
                offset += varint.encode.bytes;
                offset += this._encode(_type, _message, payload, offset);
              }
              return payload.slice(0, offset);
            }
            _encodingLength(type, message) {
              if (type >= this._types.length)
                return message.length;
              return this._types[type].encoding.encodingLength(message);
            }
            _encode(type, message, buf, offset) {
              if (type >= this._types.length) {
                message.copy(buf, offset);
                return message.length;
              }
              var enc = this._types[type].encoding;
              enc.encode(message, buf, offset);
              return enc.encode.bytes;
            }
          };
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82, "varint": 517 }], 442: [function(require2, module2, exports2) {
      /*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
      var debug = require2("debug")("simple-peer");
      var getBrowserRTC = require2("get-browser-rtc");
      var randombytes = require2("randombytes");
      var stream = require2("readable-stream");
      var queueMicrotask2 = require2("queue-microtask");
      var errCode = require2("err-code");
      var {
        Buffer
      } = require2("buffer");
      var MAX_BUFFERED_AMOUNT = 64 * 1024;
      var ICECOMPLETE_TIMEOUT = 5 * 1e3;
      var CHANNEL_CLOSING_TIMEOUT = 5 * 1e3;
      function filterTrickle(sdp) {
        return sdp.replace(/a=ice-options:trickle\s\n/g, "");
      }
      function warn(message) {
        console.warn(message);
      }
      class Peer extends stream.Duplex {
        constructor(opts) {
          opts = Object.assign({
            allowHalfOpen: false
          }, opts);
          super(opts);
          this._id = randombytes(4).toString("hex").slice(0, 7);
          this._debug("new peer %o", opts);
          this.channelName = opts.initiator ? opts.channelName || randombytes(20).toString("hex") : null;
          this.initiator = opts.initiator || false;
          this.channelConfig = opts.channelConfig || Peer.channelConfig;
          this.channelNegotiated = this.channelConfig.negotiated;
          this.config = Object.assign({}, Peer.config, opts.config);
          this.offerOptions = opts.offerOptions || {};
          this.answerOptions = opts.answerOptions || {};
          this.sdpTransform = opts.sdpTransform || ((sdp) => sdp);
          this.streams = opts.streams || (opts.stream ? [opts.stream] : []);
          this.trickle = opts.trickle !== void 0 ? opts.trickle : true;
          this.allowHalfTrickle = opts.allowHalfTrickle !== void 0 ? opts.allowHalfTrickle : false;
          this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT;
          this.destroyed = false;
          this.destroying = false;
          this._connected = false;
          this.remoteAddress = void 0;
          this.remoteFamily = void 0;
          this.remotePort = void 0;
          this.localAddress = void 0;
          this.localFamily = void 0;
          this.localPort = void 0;
          this._wrtc = opts.wrtc && typeof opts.wrtc === "object" ? opts.wrtc : getBrowserRTC();
          if (!this._wrtc) {
            if (typeof window === "undefined") {
              throw errCode(new Error("No WebRTC support: Specify `opts.wrtc` option in this environment"), "ERR_WEBRTC_SUPPORT");
            } else {
              throw errCode(new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT");
            }
          }
          this._pcReady = false;
          this._channelReady = false;
          this._iceComplete = false;
          this._iceCompleteTimer = null;
          this._channel = null;
          this._pendingCandidates = [];
          this._isNegotiating = false;
          this._firstNegotiation = true;
          this._batchedNegotiation = false;
          this._queuedNegotiation = false;
          this._sendersAwaitingStable = [];
          this._senderMap = /* @__PURE__ */ new Map();
          this._closingInterval = null;
          this._remoteTracks = [];
          this._remoteStreams = [];
          this._chunk = null;
          this._cb = null;
          this._interval = null;
          try {
            this._pc = new this._wrtc.RTCPeerConnection(this.config);
          } catch (err) {
            queueMicrotask2(() => this.destroy(errCode(err, "ERR_PC_CONSTRUCTOR")));
            return;
          }
          this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === "number";
          this._pc.oniceconnectionstatechange = () => {
            this._onIceStateChange();
          };
          this._pc.onicegatheringstatechange = () => {
            this._onIceStateChange();
          };
          this._pc.onconnectionstatechange = () => {
            this._onConnectionStateChange();
          };
          this._pc.onsignalingstatechange = () => {
            this._onSignalingStateChange();
          };
          this._pc.onicecandidate = (event) => {
            this._onIceCandidate(event);
          };
          if (this.initiator || this.channelNegotiated) {
            this._setupData({
              channel: this._pc.createDataChannel(this.channelName, this.channelConfig)
            });
          } else {
            this._pc.ondatachannel = (event) => {
              this._setupData(event);
            };
          }
          if (this.streams) {
            this.streams.forEach((stream2) => {
              this.addStream(stream2);
            });
          }
          this._pc.ontrack = (event) => {
            this._onTrack(event);
          };
          this._debug("initial negotiation");
          this._needsNegotiation();
          this._onFinishBound = () => {
            this._onFinish();
          };
          this.once("finish", this._onFinishBound);
        }
        get bufferSize() {
          return this._channel && this._channel.bufferedAmount || 0;
        }
        get connected() {
          return this._connected && this._channel.readyState === "open";
        }
        address() {
          return {
            port: this.localPort,
            family: this.localFamily,
            address: this.localAddress
          };
        }
        signal(data) {
          if (this.destroyed)
            throw errCode(new Error("cannot signal after peer is destroyed"), "ERR_SIGNALING");
          if (typeof data === "string") {
            try {
              data = JSON.parse(data);
            } catch (err) {
              data = {};
            }
          }
          this._debug("signal()");
          if (data.renegotiate && this.initiator) {
            this._debug("got request to renegotiate");
            this._needsNegotiation();
          }
          if (data.transceiverRequest && this.initiator) {
            this._debug("got request for transceiver");
            this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init);
          }
          if (data.candidate) {
            if (this._pc.remoteDescription && this._pc.remoteDescription.type) {
              this._addIceCandidate(data.candidate);
            } else {
              this._pendingCandidates.push(data.candidate);
            }
          }
          if (data.sdp) {
            this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(data)).then(() => {
              if (this.destroyed)
                return;
              this._pendingCandidates.forEach((candidate) => {
                this._addIceCandidate(candidate);
              });
              this._pendingCandidates = [];
              if (this._pc.remoteDescription.type === "offer")
                this._createAnswer();
            }).catch((err) => {
              this.destroy(errCode(err, "ERR_SET_REMOTE_DESCRIPTION"));
            });
          }
          if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {
            this.destroy(errCode(new Error("signal() called with invalid signal data"), "ERR_SIGNALING"));
          }
        }
        _addIceCandidate(candidate) {
          var iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate);
          this._pc.addIceCandidate(iceCandidateObj).catch((err) => {
            if (!iceCandidateObj.address || iceCandidateObj.address.endsWith(".local")) {
              warn("Ignoring unsupported ICE candidate.");
            } else {
              this.destroy(errCode(err, "ERR_ADD_ICE_CANDIDATE"));
            }
          });
        }
        send(chunk) {
          this._channel.send(chunk);
        }
        addTransceiver(kind, init) {
          this._debug("addTransceiver()");
          if (this.initiator) {
            try {
              this._pc.addTransceiver(kind, init);
              this._needsNegotiation();
            } catch (err) {
              this.destroy(errCode(err, "ERR_ADD_TRANSCEIVER"));
            }
          } else {
            this.emit("signal", {
              type: "transceiverRequest",
              transceiverRequest: {
                kind,
                init
              }
            });
          }
        }
        addStream(stream2) {
          this._debug("addStream()");
          stream2.getTracks().forEach((track) => {
            this.addTrack(track, stream2);
          });
        }
        addTrack(track, stream2) {
          this._debug("addTrack()");
          var submap = this._senderMap.get(track) || /* @__PURE__ */ new Map();
          var sender = submap.get(stream2);
          if (!sender) {
            sender = this._pc.addTrack(track, stream2);
            submap.set(stream2, sender);
            this._senderMap.set(track, submap);
            this._needsNegotiation();
          } else if (sender.removed) {
            throw errCode(new Error("Track has been removed. You should enable/disable tracks that you want to re-add."), "ERR_SENDER_REMOVED");
          } else {
            throw errCode(new Error("Track has already been added to that stream."), "ERR_SENDER_ALREADY_ADDED");
          }
        }
        replaceTrack(oldTrack, newTrack, stream2) {
          this._debug("replaceTrack()");
          var submap = this._senderMap.get(oldTrack);
          var sender = submap ? submap.get(stream2) : null;
          if (!sender) {
            throw errCode(new Error("Cannot replace track that was never added."), "ERR_TRACK_NOT_ADDED");
          }
          if (newTrack)
            this._senderMap.set(newTrack, submap);
          if (sender.replaceTrack != null) {
            sender.replaceTrack(newTrack);
          } else {
            this.destroy(errCode(new Error("replaceTrack is not supported in this browser"), "ERR_UNSUPPORTED_REPLACETRACK"));
          }
        }
        removeTrack(track, stream2) {
          this._debug("removeSender()");
          var submap = this._senderMap.get(track);
          var sender = submap ? submap.get(stream2) : null;
          if (!sender) {
            throw errCode(new Error("Cannot remove track that was never added."), "ERR_TRACK_NOT_ADDED");
          }
          try {
            sender.removed = true;
            this._pc.removeTrack(sender);
          } catch (err) {
            if (err.name === "NS_ERROR_UNEXPECTED") {
              this._sendersAwaitingStable.push(sender);
            } else {
              this.destroy(errCode(err, "ERR_REMOVE_TRACK"));
            }
          }
          this._needsNegotiation();
        }
        removeStream(stream2) {
          this._debug("removeSenders()");
          stream2.getTracks().forEach((track) => {
            this.removeTrack(track, stream2);
          });
        }
        _needsNegotiation() {
          this._debug("_needsNegotiation");
          if (this._batchedNegotiation)
            return;
          this._batchedNegotiation = true;
          queueMicrotask2(() => {
            this._batchedNegotiation = false;
            if (this.initiator || !this._firstNegotiation) {
              this._debug("starting batched negotiation");
              this.negotiate();
            } else {
              this._debug("non-initiator initial negotiation request discarded");
            }
            this._firstNegotiation = false;
          });
        }
        negotiate() {
          if (this.initiator) {
            if (this._isNegotiating) {
              this._queuedNegotiation = true;
              this._debug("already negotiating, queueing");
            } else {
              this._debug("start negotiation");
              setTimeout(() => {
                this._createOffer();
              }, 0);
            }
          } else {
            if (this._isNegotiating) {
              this._queuedNegotiation = true;
              this._debug("already negotiating, queueing");
            } else {
              this._debug("requesting negotiation from initiator");
              this.emit("signal", {
                type: "renegotiate",
                renegotiate: true
              });
            }
          }
          this._isNegotiating = true;
        }
        destroy(err) {
          this._destroy(err, () => {
          });
        }
        _destroy(err, cb) {
          if (this.destroyed || this.destroying)
            return;
          this.destroying = true;
          this._debug("destroying (error: %s)", err && (err.message || err));
          queueMicrotask2(() => {
            this.destroyed = true;
            this.destroying = false;
            this._debug("destroy (error: %s)", err && (err.message || err));
            this.readable = this.writable = false;
            if (!this._readableState.ended)
              this.push(null);
            if (!this._writableState.finished)
              this.end();
            this._connected = false;
            this._pcReady = false;
            this._channelReady = false;
            this._remoteTracks = null;
            this._remoteStreams = null;
            this._senderMap = null;
            clearInterval(this._closingInterval);
            this._closingInterval = null;
            clearInterval(this._interval);
            this._interval = null;
            this._chunk = null;
            this._cb = null;
            if (this._onFinishBound)
              this.removeListener("finish", this._onFinishBound);
            this._onFinishBound = null;
            if (this._channel) {
              try {
                this._channel.close();
              } catch (err2) {
              }
              this._channel.onmessage = null;
              this._channel.onopen = null;
              this._channel.onclose = null;
              this._channel.onerror = null;
            }
            if (this._pc) {
              try {
                this._pc.close();
              } catch (err2) {
              }
              this._pc.oniceconnectionstatechange = null;
              this._pc.onicegatheringstatechange = null;
              this._pc.onsignalingstatechange = null;
              this._pc.onicecandidate = null;
              this._pc.ontrack = null;
              this._pc.ondatachannel = null;
            }
            this._pc = null;
            this._channel = null;
            if (err)
              this.emit("error", err);
            this.emit("close");
            cb();
          });
        }
        _setupData(event) {
          if (!event.channel) {
            return this.destroy(errCode(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL"));
          }
          this._channel = event.channel;
          this._channel.binaryType = "arraybuffer";
          if (typeof this._channel.bufferedAmountLowThreshold === "number") {
            this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT;
          }
          this.channelName = this._channel.label;
          this._channel.onmessage = (event2) => {
            this._onChannelMessage(event2);
          };
          this._channel.onbufferedamountlow = () => {
            this._onChannelBufferedAmountLow();
          };
          this._channel.onopen = () => {
            this._onChannelOpen();
          };
          this._channel.onclose = () => {
            this._onChannelClose();
          };
          this._channel.onerror = (err) => {
            this.destroy(errCode(err, "ERR_DATA_CHANNEL"));
          };
          var isClosing = false;
          this._closingInterval = setInterval(() => {
            if (this._channel && this._channel.readyState === "closing") {
              if (isClosing)
                this._onChannelClose();
              isClosing = true;
            } else {
              isClosing = false;
            }
          }, CHANNEL_CLOSING_TIMEOUT);
        }
        _read() {
        }
        _write(chunk, encoding, cb) {
          if (this.destroyed)
            return cb(errCode(new Error("cannot write after peer is destroyed"), "ERR_DATA_CHANNEL"));
          if (this._connected) {
            try {
              this.send(chunk);
            } catch (err) {
              return this.destroy(errCode(err, "ERR_DATA_CHANNEL"));
            }
            if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
              this._debug("start backpressure: bufferedAmount %d", this._channel.bufferedAmount);
              this._cb = cb;
            } else {
              cb(null);
            }
          } else {
            this._debug("write before connect");
            this._chunk = chunk;
            this._cb = cb;
          }
        }
        _onFinish() {
          if (this.destroyed)
            return;
          var destroySoon = () => {
            setTimeout(() => this.destroy(), 1e3);
          };
          if (this._connected) {
            destroySoon();
          } else {
            this.once("connect", destroySoon);
          }
        }
        _startIceCompleteTimeout() {
          if (this.destroyed)
            return;
          if (this._iceCompleteTimer)
            return;
          this._debug("started iceComplete timeout");
          this._iceCompleteTimer = setTimeout(() => {
            if (!this._iceComplete) {
              this._iceComplete = true;
              this._debug("iceComplete timeout completed");
              this.emit("iceTimeout");
              this.emit("_iceComplete");
            }
          }, this.iceCompleteTimeout);
        }
        _createOffer() {
          if (this.destroyed)
            return;
          this._pc.createOffer(this.offerOptions).then((offer) => {
            if (this.destroyed)
              return;
            if (!this.trickle && !this.allowHalfTrickle)
              offer.sdp = filterTrickle(offer.sdp);
            offer.sdp = this.sdpTransform(offer.sdp);
            var sendOffer = () => {
              if (this.destroyed)
                return;
              var signal = this._pc.localDescription || offer;
              this._debug("signal");
              this.emit("signal", {
                type: signal.type,
                sdp: signal.sdp
              });
            };
            var onSuccess = () => {
              this._debug("createOffer success");
              if (this.destroyed)
                return;
              if (this.trickle || this._iceComplete)
                sendOffer();
              else
                this.once("_iceComplete", sendOffer);
            };
            var onError = (err) => {
              this.destroy(errCode(err, "ERR_SET_LOCAL_DESCRIPTION"));
            };
            this._pc.setLocalDescription(offer).then(onSuccess).catch(onError);
          }).catch((err) => {
            this.destroy(errCode(err, "ERR_CREATE_OFFER"));
          });
        }
        _requestMissingTransceivers() {
          if (this._pc.getTransceivers) {
            this._pc.getTransceivers().forEach((transceiver) => {
              if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {
                transceiver.requested = true;
                this.addTransceiver(transceiver.sender.track.kind);
              }
            });
          }
        }
        _createAnswer() {
          if (this.destroyed)
            return;
          this._pc.createAnswer(this.answerOptions).then((answer) => {
            if (this.destroyed)
              return;
            if (!this.trickle && !this.allowHalfTrickle)
              answer.sdp = filterTrickle(answer.sdp);
            answer.sdp = this.sdpTransform(answer.sdp);
            var sendAnswer = () => {
              if (this.destroyed)
                return;
              var signal = this._pc.localDescription || answer;
              this._debug("signal");
              this.emit("signal", {
                type: signal.type,
                sdp: signal.sdp
              });
              if (!this.initiator)
                this._requestMissingTransceivers();
            };
            var onSuccess = () => {
              if (this.destroyed)
                return;
              if (this.trickle || this._iceComplete)
                sendAnswer();
              else
                this.once("_iceComplete", sendAnswer);
            };
            var onError = (err) => {
              this.destroy(errCode(err, "ERR_SET_LOCAL_DESCRIPTION"));
            };
            this._pc.setLocalDescription(answer).then(onSuccess).catch(onError);
          }).catch((err) => {
            this.destroy(errCode(err, "ERR_CREATE_ANSWER"));
          });
        }
        _onConnectionStateChange() {
          if (this.destroyed)
            return;
          if (this._pc.connectionState === "failed") {
            this.destroy(errCode(new Error("Connection failed."), "ERR_CONNECTION_FAILURE"));
          }
        }
        _onIceStateChange() {
          if (this.destroyed)
            return;
          var iceConnectionState = this._pc.iceConnectionState;
          var iceGatheringState = this._pc.iceGatheringState;
          this._debug("iceStateChange (connection: %s) (gathering: %s)", iceConnectionState, iceGatheringState);
          this.emit("iceStateChange", iceConnectionState, iceGatheringState);
          if (iceConnectionState === "connected" || iceConnectionState === "completed") {
            this._pcReady = true;
            this._maybeReady();
          }
          if (iceConnectionState === "failed") {
            this.destroy(errCode(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE"));
          }
          if (iceConnectionState === "closed") {
            this.destroy(errCode(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"));
          }
        }
        getStats(cb) {
          var flattenValues = (report) => {
            if (Object.prototype.toString.call(report.values) === "[object Array]") {
              report.values.forEach((value) => {
                Object.assign(report, value);
              });
            }
            return report;
          };
          if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {
            this._pc.getStats().then((res) => {
              var reports = [];
              res.forEach((report) => {
                reports.push(flattenValues(report));
              });
              cb(null, reports);
            }, (err) => cb(err));
          } else if (this._pc.getStats.length > 0) {
            this._pc.getStats((res) => {
              if (this.destroyed)
                return;
              var reports = [];
              res.result().forEach((result) => {
                var report = {};
                result.names().forEach((name) => {
                  report[name] = result.stat(name);
                });
                report.id = result.id;
                report.type = result.type;
                report.timestamp = result.timestamp;
                reports.push(flattenValues(report));
              });
              cb(null, reports);
            }, (err) => cb(err));
          } else {
            cb(null, []);
          }
        }
        _maybeReady() {
          this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady);
          if (this._connected || this._connecting || !this._pcReady || !this._channelReady)
            return;
          this._connecting = true;
          var findCandidatePair = () => {
            if (this.destroyed)
              return;
            this.getStats((err, items) => {
              if (this.destroyed)
                return;
              if (err)
                items = [];
              var remoteCandidates = {};
              var localCandidates = {};
              var candidatePairs = {};
              var foundSelectedCandidatePair = false;
              items.forEach((item) => {
                if (item.type === "remotecandidate" || item.type === "remote-candidate") {
                  remoteCandidates[item.id] = item;
                }
                if (item.type === "localcandidate" || item.type === "local-candidate") {
                  localCandidates[item.id] = item;
                }
                if (item.type === "candidatepair" || item.type === "candidate-pair") {
                  candidatePairs[item.id] = item;
                }
              });
              var setSelectedCandidatePair = (selectedCandidatePair) => {
                foundSelectedCandidatePair = true;
                var local = localCandidates[selectedCandidatePair.localCandidateId];
                if (local && (local.ip || local.address)) {
                  this.localAddress = local.ip || local.address;
                  this.localPort = Number(local.port);
                } else if (local && local.ipAddress) {
                  this.localAddress = local.ipAddress;
                  this.localPort = Number(local.portNumber);
                } else if (typeof selectedCandidatePair.googLocalAddress === "string") {
                  local = selectedCandidatePair.googLocalAddress.split(":");
                  this.localAddress = local[0];
                  this.localPort = Number(local[1]);
                }
                if (this.localAddress) {
                  this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4";
                }
                var remote = remoteCandidates[selectedCandidatePair.remoteCandidateId];
                if (remote && (remote.ip || remote.address)) {
                  this.remoteAddress = remote.ip || remote.address;
                  this.remotePort = Number(remote.port);
                } else if (remote && remote.ipAddress) {
                  this.remoteAddress = remote.ipAddress;
                  this.remotePort = Number(remote.portNumber);
                } else if (typeof selectedCandidatePair.googRemoteAddress === "string") {
                  remote = selectedCandidatePair.googRemoteAddress.split(":");
                  this.remoteAddress = remote[0];
                  this.remotePort = Number(remote[1]);
                }
                if (this.remoteAddress) {
                  this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4";
                }
                this._debug("connect local: %s:%s remote: %s:%s", this.localAddress, this.localPort, this.remoteAddress, this.remotePort);
              };
              items.forEach((item) => {
                if (item.type === "transport" && item.selectedCandidatePairId) {
                  setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId]);
                }
                if (item.type === "googCandidatePair" && item.googActiveConnection === "true" || (item.type === "candidatepair" || item.type === "candidate-pair") && item.selected) {
                  setSelectedCandidatePair(item);
                }
              });
              if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {
                setTimeout(findCandidatePair, 100);
                return;
              } else {
                this._connecting = false;
                this._connected = true;
              }
              if (this._chunk) {
                try {
                  this.send(this._chunk);
                } catch (err2) {
                  return this.destroy(errCode(err2, "ERR_DATA_CHANNEL"));
                }
                this._chunk = null;
                this._debug('sent chunk from "write before connect"');
                var cb = this._cb;
                this._cb = null;
                cb(null);
              }
              if (typeof this._channel.bufferedAmountLowThreshold !== "number") {
                this._interval = setInterval(() => this._onInterval(), 150);
                if (this._interval.unref)
                  this._interval.unref();
              }
              this._debug("connect");
              this.emit("connect");
            });
          };
          findCandidatePair();
        }
        _onInterval() {
          if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
            return;
          }
          this._onChannelBufferedAmountLow();
        }
        _onSignalingStateChange() {
          if (this.destroyed)
            return;
          if (this._pc.signalingState === "stable") {
            this._isNegotiating = false;
            this._debug("flushing sender queue", this._sendersAwaitingStable);
            this._sendersAwaitingStable.forEach((sender) => {
              this._pc.removeTrack(sender);
              this._queuedNegotiation = true;
            });
            this._sendersAwaitingStable = [];
            if (this._queuedNegotiation) {
              this._debug("flushing negotiation queue");
              this._queuedNegotiation = false;
              this._needsNegotiation();
            } else {
              this._debug("negotiated");
              this.emit("negotiated");
            }
          }
          this._debug("signalingStateChange %s", this._pc.signalingState);
          this.emit("signalingStateChange", this._pc.signalingState);
        }
        _onIceCandidate(event) {
          if (this.destroyed)
            return;
          if (event.candidate && this.trickle) {
            this.emit("signal", {
              type: "candidate",
              candidate: {
                candidate: event.candidate.candidate,
                sdpMLineIndex: event.candidate.sdpMLineIndex,
                sdpMid: event.candidate.sdpMid
              }
            });
          } else if (!event.candidate && !this._iceComplete) {
            this._iceComplete = true;
            this.emit("_iceComplete");
          }
          if (event.candidate) {
            this._startIceCompleteTimeout();
          }
        }
        _onChannelMessage(event) {
          if (this.destroyed)
            return;
          var data = event.data;
          if (data instanceof ArrayBuffer)
            data = Buffer.from(data);
          this.push(data);
        }
        _onChannelBufferedAmountLow() {
          if (this.destroyed || !this._cb)
            return;
          this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
          var cb = this._cb;
          this._cb = null;
          cb(null);
        }
        _onChannelOpen() {
          if (this._connected || this.destroyed)
            return;
          this._debug("on channel open");
          this._channelReady = true;
          this._maybeReady();
        }
        _onChannelClose() {
          if (this.destroyed)
            return;
          this._debug("on channel close");
          this.destroy();
        }
        _onTrack(event) {
          if (this.destroyed)
            return;
          event.streams.forEach((eventStream) => {
            this._debug("on track");
            this.emit("track", event.track, eventStream);
            this._remoteTracks.push({
              track: event.track,
              stream: eventStream
            });
            if (this._remoteStreams.some((remoteStream) => {
              return remoteStream.id === eventStream.id;
            }))
              return;
            this._remoteStreams.push(eventStream);
            queueMicrotask2(() => {
              this._debug("on stream");
              this.emit("stream", eventStream);
            });
          });
        }
        _debug() {
          var args = [].slice.call(arguments);
          args[0] = "[" + this._id + "] " + args[0];
          debug.apply(null, args);
        }
      }
      Peer.WEBRTC_SUPPORT = !!getBrowserRTC();
      Peer.config = {
        iceServers: [{
          urls: ["stun:stun.l.google.com:19302", "stun:global.stun.twilio.com:3478"]
        }],
        sdpSemantics: "unified-plan"
      };
      Peer.channelConfig = {};
      module2.exports = Peer;
    }, { "buffer": 82, "debug": 119, "err-code": 188, "get-browser-rtc": 205, "queue-microtask": 377, "randombytes": 382, "readable-stream": 412 }], 443: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              if (enumerableOnly)
                symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
              keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              if (i % 2) {
                ownKeys(Object(source), true).forEach(function(key) {
                  _defineProperty(target, key, source[key]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys(Object(source)).forEach(function(key) {
                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
              }
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          /*! simple-websocket. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
          var debug = require2("debug")("simple-websocket");
          var randombytes = require2("randombytes");
          var stream = require2("readable-stream");
          var queueMicrotask2 = require2("queue-microtask");
          var ws = require2("ws");
          var _WebSocket = typeof ws !== "function" ? WebSocket : ws;
          var MAX_BUFFERED_AMOUNT = 64 * 1024;
          class Socket extends stream.Duplex {
            constructor() {
              var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              if (typeof opts === "string") {
                opts = {
                  url: opts
                };
              }
              opts = Object.assign({
                allowHalfOpen: false
              }, opts);
              super(opts);
              if (opts.url == null && opts.socket == null) {
                throw new Error("Missing required `url` or `socket` option");
              }
              if (opts.url != null && opts.socket != null) {
                throw new Error("Must specify either `url` or `socket` option, not both");
              }
              this._id = randombytes(4).toString("hex").slice(0, 7);
              this._debug("new websocket: %o", opts);
              this.connected = false;
              this.destroyed = false;
              this._chunk = null;
              this._cb = null;
              this._interval = null;
              if (opts.socket) {
                this.url = opts.socket.url;
                this._ws = opts.socket;
                this.connected = opts.socket.readyState === _WebSocket.OPEN;
              } else {
                this.url = opts.url;
                try {
                  if (typeof ws === "function") {
                    this._ws = new _WebSocket(opts.url, null, _objectSpread(_objectSpread({}, opts), {}, {
                      encoding: void 0
                    }));
                  } else {
                    this._ws = new _WebSocket(opts.url);
                  }
                } catch (err) {
                  queueMicrotask2(() => this.destroy(err));
                  return;
                }
              }
              this._ws.binaryType = "arraybuffer";
              if (opts.socket && this.connected) {
                queueMicrotask2(() => this._handleOpen());
              } else {
                this._ws.onopen = () => this._handleOpen();
              }
              this._ws.onmessage = (event) => this._handleMessage(event);
              this._ws.onclose = () => this._handleClose();
              this._ws.onerror = (err) => this._handleError(err);
              this._handleFinishBound = () => this._handleFinish();
              this.once("finish", this._handleFinishBound);
            }
            send(chunk) {
              this._ws.send(chunk);
            }
            destroy(err) {
              this._destroy(err, () => {
              });
            }
            _destroy(err, cb) {
              if (this.destroyed)
                return;
              this._debug("destroy (error: %s)", err && (err.message || err));
              this.readable = this.writable = false;
              if (!this._readableState.ended)
                this.push(null);
              if (!this._writableState.finished)
                this.end();
              this.connected = false;
              this.destroyed = true;
              clearInterval(this._interval);
              this._interval = null;
              this._chunk = null;
              this._cb = null;
              if (this._handleFinishBound) {
                this.removeListener("finish", this._handleFinishBound);
              }
              this._handleFinishBound = null;
              if (this._ws) {
                var _ws = this._ws;
                var onClose = () => {
                  _ws.onclose = null;
                };
                if (_ws.readyState === _WebSocket.CLOSED) {
                  onClose();
                } else {
                  try {
                    _ws.onclose = onClose;
                    _ws.close();
                  } catch (err2) {
                    onClose();
                  }
                }
                _ws.onopen = null;
                _ws.onmessage = null;
                _ws.onerror = () => {
                };
              }
              this._ws = null;
              if (err)
                this.emit("error", err);
              this.emit("close");
              cb();
            }
            _read() {
            }
            _write(chunk, encoding, cb) {
              if (this.destroyed)
                return cb(new Error("cannot write after socket is destroyed"));
              if (this.connected) {
                try {
                  this.send(chunk);
                } catch (err) {
                  return this.destroy(err);
                }
                if (typeof ws !== "function" && this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT) {
                  this._debug("start backpressure: bufferedAmount %d", this._ws.bufferedAmount);
                  this._cb = cb;
                } else {
                  cb(null);
                }
              } else {
                this._debug("write before connect");
                this._chunk = chunk;
                this._cb = cb;
              }
            }
            _handleOpen() {
              if (this.connected || this.destroyed)
                return;
              this.connected = true;
              if (this._chunk) {
                try {
                  this.send(this._chunk);
                } catch (err) {
                  return this.destroy(err);
                }
                this._chunk = null;
                this._debug('sent chunk from "write before connect"');
                var cb = this._cb;
                this._cb = null;
                cb(null);
              }
              if (typeof ws !== "function") {
                this._interval = setInterval(() => this._onInterval(), 150);
                if (this._interval.unref)
                  this._interval.unref();
              }
              this._debug("connect");
              this.emit("connect");
            }
            _handleMessage(event) {
              if (this.destroyed)
                return;
              var data = event.data;
              if (data instanceof ArrayBuffer)
                data = Buffer.from(data);
              this.push(data);
            }
            _handleClose() {
              if (this.destroyed)
                return;
              this._debug("on close");
              this.destroy();
            }
            _handleError(err) {
              this.destroy(new Error("Error connecting to ".concat(this.url, " (").concat(err, ")")));
            }
            _handleFinish() {
              if (this.destroyed)
                return;
              var destroySoon = () => {
                setTimeout(() => this.destroy(), 1e3);
              };
              if (this.connected) {
                destroySoon();
              } else {
                this.once("connect", destroySoon);
              }
            }
            _onInterval() {
              if (!this._cb || !this._ws || this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT) {
                return;
              }
              this._debug("ending backpressure: bufferedAmount %d", this._ws.bufferedAmount);
              var cb = this._cb;
              this._cb = null;
              cb(null);
            }
            _debug() {
              var args = [].slice.call(arguments);
              args[0] = "[" + this._id + "] " + args[0];
              debug.apply(null, args);
            }
          }
          Socket.WEBSOCKET_SUPPORT = !!_WebSocket;
          module2.exports = Socket;
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82, "debug": 119, "queue-microtask": 377, "randombytes": 382, "readable-stream": 412, "ws": 53 }], 444: [function(require2, module2, exports2) {
      module2.exports = fallback;
      function _add(a, b) {
        var rl = a.l + b.l;
        var a2 = {
          h: a.h + b.h + (rl / 2 >>> 31) >>> 0,
          l: rl >>> 0
        };
        a.h = a2.h;
        a.l = a2.l;
      }
      function _xor(a, b) {
        a.h ^= b.h;
        a.h >>>= 0;
        a.l ^= b.l;
        a.l >>>= 0;
      }
      function _rotl(a, n) {
        var a2 = {
          h: a.h << n | a.l >>> 32 - n,
          l: a.l << n | a.h >>> 32 - n
        };
        a.h = a2.h;
        a.l = a2.l;
      }
      function _rotl32(a) {
        var al = a.l;
        a.l = a.h;
        a.h = al;
      }
      function _compress(v0, v1, v2, v3) {
        _add(v0, v1);
        _add(v2, v3);
        _rotl(v1, 13);
        _rotl(v3, 16);
        _xor(v1, v0);
        _xor(v3, v2);
        _rotl32(v0);
        _add(v2, v1);
        _add(v0, v3);
        _rotl(v1, 17);
        _rotl(v3, 21);
        _xor(v1, v2);
        _xor(v3, v0);
        _rotl32(v2);
      }
      function _get_int(a, offset) {
        return a[offset + 3] << 24 | a[offset + 2] << 16 | a[offset + 1] << 8 | a[offset];
      }
      function fallback(out, m, key) {
        var k0 = {
          h: _get_int(key, 4),
          l: _get_int(key, 0)
        };
        var k1 = {
          h: _get_int(key, 12),
          l: _get_int(key, 8)
        };
        var v0 = {
          h: k0.h,
          l: k0.l
        };
        var v2 = k0;
        var v1 = {
          h: k1.h,
          l: k1.l
        };
        var v3 = k1;
        var mi;
        var mp = 0;
        var ml = m.length;
        var ml7 = ml - 7;
        var buf = new Uint8Array(new ArrayBuffer(8));
        _xor(v0, {
          h: 1936682341,
          l: 1886610805
        });
        _xor(v1, {
          h: 1685025377,
          l: 1852075885
        });
        _xor(v2, {
          h: 1819895653,
          l: 1852142177
        });
        _xor(v3, {
          h: 1952801890,
          l: 2037671283
        });
        while (mp < ml7) {
          mi = {
            h: _get_int(m, mp + 4),
            l: _get_int(m, mp)
          };
          _xor(v3, mi);
          _compress(v0, v1, v2, v3);
          _compress(v0, v1, v2, v3);
          _xor(v0, mi);
          mp += 8;
        }
        buf[7] = ml;
        var ic = 0;
        while (mp < ml) {
          buf[ic++] = m[mp++];
        }
        while (ic < 7) {
          buf[ic++] = 0;
        }
        mi = {
          h: buf[7] << 24 | buf[6] << 16 | buf[5] << 8 | buf[4],
          l: buf[3] << 24 | buf[2] << 16 | buf[1] << 8 | buf[0]
        };
        _xor(v3, mi);
        _compress(v0, v1, v2, v3);
        _compress(v0, v1, v2, v3);
        _xor(v0, mi);
        _xor(v2, {
          h: 0,
          l: 255
        });
        _compress(v0, v1, v2, v3);
        _compress(v0, v1, v2, v3);
        _compress(v0, v1, v2, v3);
        _compress(v0, v1, v2, v3);
        var h = v0;
        _xor(h, v1);
        _xor(h, v2);
        _xor(h, v3);
        out[0] = h.l & 255;
        out[1] = h.l >> 8 & 255;
        out[2] = h.l >> 16 & 255;
        out[3] = h.l >> 24 & 255;
        out[4] = h.h & 255;
        out[5] = h.h >> 8 & 255;
        out[6] = h.h >> 16 & 255;
        out[7] = h.h >> 24 & 255;
      }
    }, {}], 445: [function(require2, module2, exports2) {
      var wasm = require2("./siphash24");
      var fallback = require2("./fallback");
      var assert = require2("nanoassert");
      module2.exports = siphash24;
      var BYTES = siphash24.BYTES = 8;
      var KEYBYTES = siphash24.KEYBYTES = 16;
      var mod = wasm();
      siphash24.WASM_SUPPORTED = typeof WebAssembly !== "undefined";
      siphash24.WASM_LOADED = false;
      if (mod) {
        mod.onload(function(err) {
          siphash24.WASM_LOADED = !err;
        });
      }
      function siphash24(data, key, out, noAssert) {
        if (!out)
          out = new Uint8Array(8);
        if (noAssert !== true) {
          assert(out.length >= BYTES, "output must be at least " + BYTES);
          assert(key.length >= KEYBYTES, "key must be at least " + KEYBYTES);
        }
        if (mod && mod.exports) {
          if (data.length + 24 > mod.memory.length)
            mod.realloc(data.length + 24);
          mod.memory.set(key, 8);
          mod.memory.set(data, 24);
          mod.exports.siphash(24, data.length);
          out.set(mod.memory.subarray(0, 8));
        } else {
          fallback(out, data, key);
        }
        return out;
      }
    }, { "./fallback": 444, "./siphash24": 447, "nanoassert": 446 }], 446: [function(require2, module2, exports2) {
      arguments[4][48][0].apply(exports2, arguments);
    }, { "dup": 48 }], 447: [function(require2, module2, exports2) {
      module2.exports = loadWebAssembly;
      loadWebAssembly.supported = typeof WebAssembly !== "undefined";
      function loadWebAssembly(opts) {
        if (!loadWebAssembly.supported)
          return null;
        var imp = opts && opts.imports;
        var wasm = toUint8Array("AGFzbQEAAAABBgFgAn9/AAMCAQAFBQEBCpBOBxQCBm1lbW9yeQIAB3NpcGhhc2gAAArdCAHaCAIIfgJ/QvXKzYPXrNu38wAhAkLt3pHzlszct+QAIQNC4eSV89bs2bzsACEEQvPK0cunjNmy9AAhBUEIKQMAIQdBECkDACEIIAGtQjiGIQYgAUEHcSELIAAgAWogC2shCiAFIAiFIQUgBCAHhSEEIAMgCIUhAyACIAeFIQICQANAIAAgCkYNASAAKQMAIQkgBSAJhSEFIAIgA3whAiADQg2JIQMgAyAChSEDIAJCIIkhAiAEIAV8IQQgBUIQiSEFIAUgBIUhBSACIAV8IQIgBUIViSEFIAUgAoUhBSAEIAN8IQQgA0IRiSEDIAMgBIUhAyAEQiCJIQQgAiADfCECIANCDYkhAyADIAKFIQMgAkIgiSECIAQgBXwhBCAFQhCJIQUgBSAEhSEFIAIgBXwhAiAFQhWJIQUgBSAChSEFIAQgA3whBCADQhGJIQMgAyAEhSEDIARCIIkhBCACIAmFIQIgAEEIaiEADAALCwJAAkACQAJAAkACQAJAAkAgCw4HBwYFBAMCAQALIAYgADEABkIwhoQhBgsgBiAAMQAFQiiGhCEGCyAGIAAxAARCIIaEIQYLIAYgADEAA0IYhoQhBgsgBiAAMQACQhCGhCEGCyAGIAAxAAFCCIaEIQYLIAYgADEAAIQhBgsgBSAGhSEFIAIgA3whAiADQg2JIQMgAyAChSEDIAJCIIkhAiAEIAV8IQQgBUIQiSEFIAUgBIUhBSACIAV8IQIgBUIViSEFIAUgAoUhBSAEIAN8IQQgA0IRiSEDIAMgBIUhAyAEQiCJIQQgAiADfCECIANCDYkhAyADIAKFIQMgAkIgiSECIAQgBXwhBCAFQhCJIQUgBSAEhSEFIAIgBXwhAiAFQhWJIQUgBSAChSEFIAQgA3whBCADQhGJIQMgAyAEhSEDIARCIIkhBCACIAaFIQIgBEL/AYUhBCACIAN8IQIgA0INiSEDIAMgAoUhAyACQiCJIQIgBCAFfCEEIAVCEIkhBSAFIASFIQUgAiAFfCECIAVCFYkhBSAFIAKFIQUgBCADfCEEIANCEYkhAyADIASFIQMgBEIgiSEEIAIgA3whAiADQg2JIQMgAyAChSEDIAJCIIkhAiAEIAV8IQQgBUIQiSEFIAUgBIUhBSACIAV8IQIgBUIViSEFIAUgAoUhBSAEIAN8IQQgA0IRiSEDIAMgBIUhAyAEQiCJIQQgAiADfCECIANCDYkhAyADIAKFIQMgAkIgiSECIAQgBXwhBCAFQhCJIQUgBSAEhSEFIAIgBXwhAiAFQhWJIQUgBSAChSEFIAQgA3whBCADQhGJIQMgAyAEhSEDIARCIIkhBCACIAN8IQIgA0INiSEDIAMgAoUhAyACQiCJIQIgBCAFfCEEIAVCEIkhBSAFIASFIQUgAiAFfCECIAVCFYkhBSAFIAKFIQUgBCADfCEEIANCEYkhAyADIASFIQMgBEIgiSEEQQAgAiADIAQgBYWFhTcDAAs=");
        var ready = null;
        var mod = {
          buffer: wasm,
          memory: null,
          exports: null,
          realloc,
          onload
        };
        onload(function() {
        });
        return mod;
        function realloc(size) {
          mod.exports.memory.grow(Math.max(0, Math.ceil(Math.abs(size - mod.memory.length) / 65536)));
          mod.memory = new Uint8Array(mod.exports.memory.buffer);
        }
        function onload(cb) {
          if (mod.exports)
            return cb();
          if (ready) {
            ready.then(cb.bind(null, null)).catch(cb);
            return;
          }
          try {
            if (opts && opts.async)
              throw new Error("async");
            setup({
              instance: new WebAssembly.Instance(new WebAssembly.Module(wasm), imp)
            });
          } catch (err) {
            ready = WebAssembly.instantiate(wasm, imp).then(setup);
          }
          onload(cb);
        }
        function setup(w) {
          mod.exports = w.instance.exports;
          mod.memory = mod.exports.memory && mod.exports.memory.buffer && new Uint8Array(mod.exports.memory.buffer);
        }
      }
      function toUint8Array(s) {
        if (typeof atob === "function")
          return new Uint8Array(atob(s).split("").map(charCodeAt));
        return new (require2("buffer")).Buffer(s, "base64");
      }
      function charCodeAt(c) {
        return c.charCodeAt(0);
      }
    }, {}], 448: [function(require2, module2, exports2) {
      module2.exports = {
        SocketSignalWebsocketClient: require2("./lib/client")
      };
    }, { "./lib/client": 449 }], 449: [function(require2, module2, exports2) {
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var Socket = require2("simple-websocket");
      var assert = require2("nanocustomassert");
      var WebSocket2 = require2("isomorphic-ws");
      var {
        SocketSignalClient
      } = require2("socket-signal");
      var log = require2("debug")("socket-signal:websocket-client");
      var defaultUrlProvider = (urls) => {
        var urlIndex = 0;
        return () => {
          var url = urls[urlIndex++ % urls.length];
          log("url provider", url);
          return url;
        };
      };
      var ReconnectingWebSocket = require2("reconnecting-websocket");
      if (ReconnectingWebSocket.default) {
        ReconnectingWebSocket = ReconnectingWebSocket.default;
      }
      class SocketSignalWebsocketClient extends SocketSignalClient {
        static createSocket(urlProvider) {
          var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          assert(Array.isArray(urlProvider) || typeof urlProvider === "function", "must be an array or a function");
          var {
            simpleWebsocket = {},
            reconnectingWebsocket = {}
          } = opts;
          if (Array.isArray(urlProvider)) {
            urlProvider = defaultUrlProvider(urlProvider);
          }
          if (!reconnectingWebsocket.WebSocket) {
            reconnectingWebsocket.WebSocket = WebSocket2;
          }
          var ws = new ReconnectingWebSocket(urlProvider, reconnectingWebsocket.protocols, reconnectingWebsocket);
          var socket = new Socket(_objectSpread({
            socket: ws
          }, simpleWebsocket));
          var _onopen = ws.onopen;
          var _onclose = ws.onclose;
          var _onerror = ws.onerror;
          ws.onopen = (ev) => {
            if (socket._chunk && !socket._cb) {
              socket._cb = () => {
              };
            }
            _onopen(ev);
          };
          ws.onclose = (ev) => {
            log("socket close", {
              shouldReconnect: ws._shouldReconnect,
              ev
            });
            if (ws._shouldReconnect) {
              socket.connected = false;
            } else {
              _onclose(ev);
            }
          };
          ws.onerror = (ev) => {
            log("socket error", {
              shouldReconnect: ws._shouldReconnect,
              ev
            });
            if (ws._shouldReconnect) {
              socket.connected = false;
            } else {
              _onerror(ev);
            }
          };
          return socket;
        }
        constructor(urlProvider) {
          var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          super(SocketSignalWebsocketClient.createSocket(urlProvider, opts), opts);
          var reconnected = false;
          this.socket.on("connect", () => {
            this.emit("connected", reconnected);
            reconnected = true;
          });
        }
        get connected() {
          return this.socket.readyState === this.socket.OPEN;
        }
      }
      module2.exports = SocketSignalWebsocketClient;
    }, { "debug": 119, "isomorphic-ws": 264, "nanocustomassert": 309, "reconnecting-websocket": 413, "simple-websocket": 443, "socket-signal": 450 }], 450: [function(require2, module2, exports2) {
      module2.exports = {
        SocketSignalClient: require2("./lib/client"),
        SocketSignalServer: require2("./lib/server"),
        SocketSignalServerMap: require2("./lib/server-map"),
        Peer: require2("./lib/peer"),
        SignalBatch: require2("./lib/signal-batch"),
        errors: require2("./lib/errors")
      };
    }, { "./lib/client": 451, "./lib/errors": 452, "./lib/peer": 453, "./lib/server": 455, "./lib/server-map": 454, "./lib/signal-batch": 456 }], 451: [function(require2, module2, exports2) {
      (function(Buffer, process) {
        (function() {
          function _objectWithoutProperties(source, excluded) {
            if (source == null)
              return {};
            var target = _objectWithoutPropertiesLoose(source, excluded);
            var key, i;
            if (Object.getOwnPropertySymbols) {
              var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
              for (i = 0; i < sourceSymbolKeys.length; i++) {
                key = sourceSymbolKeys[i];
                if (excluded.indexOf(key) >= 0)
                  continue;
                if (!Object.prototype.propertyIsEnumerable.call(source, key))
                  continue;
                target[key] = source[key];
              }
            }
            return target;
          }
          function _objectWithoutPropertiesLoose(source, excluded) {
            if (source == null)
              return {};
            var target = {};
            var sourceKeys = Object.keys(source);
            var key, i;
            for (i = 0; i < sourceKeys.length; i++) {
              key = sourceKeys[i];
              if (excluded.indexOf(key) >= 0)
                continue;
              target[key] = source[key];
            }
            return target;
          }
          function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
            try {
              var info = gen[key](arg);
              var value = info.value;
            } catch (error) {
              reject(error);
              return;
            }
            if (info.done) {
              resolve(value);
            } else {
              Promise.resolve(value).then(_next, _throw);
            }
          }
          function _asyncToGenerator(fn) {
            return function() {
              var self2 = this, args = arguments;
              return new Promise(function(resolve, reject) {
                var gen = fn.apply(self2, args);
                function _next(value) {
                  asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
                }
                function _throw(err) {
                  asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
                }
                _next(void 0);
              });
            };
          }
          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              if (enumerableOnly)
                symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
              keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              if (i % 2) {
                ownKeys(Object(source), true).forEach(function(key) {
                  _defineProperty(target, key, source[key]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys(Object(source)).forEach(function(key) {
                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
              }
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var crypto = require2("crypto");
          var assert = require2("nanocustomassert");
          var fastq = require2("fastq");
          var pEvent = require2("p-event");
          var nanomessagerpc = require2("nanomessage-rpc");
          var {
            NanoresourcePromise
          } = require2("nanoresource-promise/emitter");
          var Peer = require2("./peer");
          var kConnectionsQueue = Symbol("socketsignal.connectionsqueue");
          var kPeers = Symbol("socketsignal.peers");
          var kDefineActions = Symbol("socketsignal.defineactions");
          var kDefineEvents = Symbol("socketsignal.defineevents");
          var kAddPeer = Symbol("socketsignal.addpeer");
          var kCreatePeer = Symbol("socketsignal.createpeer");
          var kOnSignal = Symbol("socketsignal.onsignal");
          function worker(_ref, done) {
            var {
              peer,
              data
            } = _ref;
            this.open().then(() => {
              this.emit("peer-connecting", peer);
              return peer.open(data);
            }).then(() => done()).catch((err) => done(err));
          }
          class SocketSignalClient extends NanoresourcePromise {
            constructor(socket) {
              var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              super();
              var {
                id = crypto.randomBytes(32),
                requestTimeout = 15 * 1e3,
                queueConcurrency = 4,
                simplePeer = {},
                metadata
              } = opts;
              assert(!metadata || typeof metadata === "object", "metadata must be an object");
              this.socket = socket;
              this.rpc = nanomessagerpc(_objectSpread({
                timeout: requestTimeout
              }, nanomessagerpc.useSocket(socket)));
              this.id = id;
              this.metadata = metadata;
              this.simplePeer = simplePeer;
              this.requestTimeout = requestTimeout;
              this[kPeers] = /* @__PURE__ */ new Map();
              this[kConnectionsQueue] = fastq(this, worker, queueConcurrency);
              this[kDefineActions]();
              this[kDefineEvents]();
            }
            get peers() {
              return Array.from(this[kPeers].values());
            }
            get peersConnected() {
              return this.peers.filter((p) => p.connected);
            }
            get peersConnecting() {
              return this.peers.filter((p) => !p.connected);
            }
            getPeersByTopic(topic) {
              assert(Buffer.isBuffer(topic), "topic is required");
              return this.peers.filter((peer) => peer.topic.equals(topic));
            }
            join(topic) {
              var _this = this;
              return _asyncToGenerator(function* () {
                assert(Buffer.isBuffer(topic) && topic.length === 32, "topic must be a Buffer of 32 bytes");
                yield _this.open();
                var peers = yield _this.rpc.call("join", _this._buildMessage({
                  topic
                }));
                _this.emit("join", topic, peers);
                return peers;
              })();
            }
            leave(topic) {
              var _this2 = this;
              return _asyncToGenerator(function* () {
                assert(!topic || Buffer.isBuffer(topic) && topic.length === 32, "topic must be a Buffer of 32 bytes");
                yield _this2.open();
                yield _this2.rpc.call("leave", _this2._buildMessage({
                  topic
                }));
                _this2.emit("leave", topic);
              })();
            }
            lookup(topic) {
              var _this3 = this;
              return _asyncToGenerator(function* () {
                assert(Buffer.isBuffer(topic) && topic.length === 32, "topic must be a Buffer of 32 bytes");
                yield _this3.open();
                var peers = yield _this3.rpc.call("lookup", _this3._buildMessage({
                  topic
                }));
                _this3.emit("lookup", topic, peers);
                return peers;
              })();
            }
            connect(topic, peerId) {
              var opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
              assert(Buffer.isBuffer(topic) && topic.length === 32, "topic must be a Buffer of 32 bytes");
              assert(Buffer.isBuffer(peerId) && peerId.length === 32, "peerId must be a Buffer of 32 bytes");
              var {
                metadata: localMetadata,
                simplePeer = {}
              } = opts;
              var peer = this[kCreatePeer]({
                initiator: true,
                sessionId: crypto.randomBytes(32),
                id: peerId,
                topic,
                localMetadata,
                simplePeer
              });
              this[kAddPeer](peer);
              return peer;
            }
            onIncomingPeer(handler) {
              this._onIncomingPeer = handler;
              return this;
            }
            onOffer(handler) {
              this._onOffer = handler;
              return this;
            }
            onAnswer(handler) {
              this._onAnswer = handler;
              return this;
            }
            closeConnectionsByTopic(topic) {
              return Promise.all(this.getPeersByTopic(topic).map((peer) => new Promise((resolve) => peer.close(() => resolve()))));
            }
            _onIncomingPeer() {
              return _asyncToGenerator(function* () {
              })();
            }
            _onOffer(data) {
              return _asyncToGenerator(function* () {
              })();
            }
            _onAnswer(data) {
              return _asyncToGenerator(function* () {
              })();
            }
            _open() {
              var _this4 = this;
              return _asyncToGenerator(function* () {
                yield _this4.rpc.open();
              })();
            }
            _close() {
              var _this5 = this;
              return _asyncToGenerator(function* () {
                _this5[kConnectionsQueue].kill();
                yield _this5.rpc.close();
                yield Promise.all(_this5.peers.map((peer) => new Promise((resolve) => peer.close(() => resolve()))));
              })();
            }
            _buildMessage(data) {
              var {
                localMetadata = {}
              } = data, msg = _objectWithoutProperties(data, ["localMetadata"]);
              var metadata = this.metadata || {};
              if (localMetadata) {
                metadata = _objectSpread(_objectSpread({}, metadata), localMetadata);
              }
              return _objectSpread(_objectSpread({}, msg), {}, {
                id: this.id,
                metadata
              });
            }
            [kDefineActions]() {
              var _this6 = this;
              this.rpc.actions({
                offer: function() {
                  var _offer = _asyncToGenerator(function* (message) {
                    var result = yield _this6._onOffer(message);
                    assert(!result || typeof result === "object");
                    var peer = _this6[kCreatePeer]({
                      initiator: false,
                      sessionId: message.sessionId,
                      id: message.id,
                      topic: message.topic,
                      metadata: message.metadata,
                      localMetadata: result && result.metadata,
                      simplePeer: result && result.simplePeer
                    });
                    _this6[kAddPeer](peer, message.data);
                    return pEvent(peer, "answer", {
                      rejectionEvents: ["error", "closed"]
                    });
                  });
                  function offer(_x) {
                    return _offer.apply(this, arguments);
                  }
                  return offer;
                }()
              });
            }
            [kDefineEvents]() {
              this.rpc.on("signal", (message) => {
                var {
                  sessionId,
                  data = []
                } = message;
                var peer = this[kPeers].get(sessionId.toString("hex"));
                if (!peer || peer.destroyed)
                  return;
                data.forEach((signal) => peer.stream.signal(signal));
              });
            }
            [kAddPeer](peer, data) {
              var sessionId = peer.sessionId.toString("hex");
              this[kPeers].set(sessionId, peer);
              peer.once("close", () => {
                this[kPeers].delete(sessionId);
              });
              peer.once("error", (err) => {
                this.emit("peer-error", err, peer);
              });
              this[kConnectionsQueue].push({
                peer,
                data
              }, (err) => {
                if (err || this.closing || this.closed)
                  return process.nextTick(() => peer.destroy(err));
                this.emit("peer-connected", peer);
              });
              this.emit("peer-queue", peer);
            }
            [kCreatePeer](opts) {
              opts = Object.assign({}, opts, {
                onSignal: (peer2, batch) => this[kOnSignal](peer2, batch),
                simplePeer: Object.assign({}, this.simplePeer, opts.simplePeer),
                timeout: this.requestTimeout
              });
              var peer;
              if (typeof this.simplePeer === "function") {
                peer = this.simplePeer(Peer, opts);
              }
              peer = new Peer(opts);
              return peer;
            }
            [kOnSignal](peer, batch) {
              var _this7 = this;
              return _asyncToGenerator(function* () {
                if (peer.destroyed || peer.connected && !peer.subscribeMediaStream)
                  return;
                var payload = () => _this7._buildMessage({
                  remoteId: peer.id,
                  topic: peer.topic,
                  sessionId: peer.sessionId,
                  data: batch,
                  localMetadata: peer.localMetadata
                });
                if (!peer.connected) {
                  var type = batch[0].type;
                  if (type === "offer") {
                    var response = yield _this7.rpc.call("offer", payload());
                    yield _this7._onAnswer(response);
                    response.data.forEach((signal) => peer.stream.signal(signal));
                    peer.metadata = response.metadata;
                    return;
                  }
                  if (type === "answer") {
                    yield _this7._onIncomingPeer(peer);
                    return peer.emit("answer", payload());
                  }
                }
                yield _this7.rpc.emit("signal", payload());
              })();
            }
          }
          module2.exports = SocketSignalClient;
        }).call(this);
      }).call(this, { "isBuffer": require2("../../is-buffer/index.js") }, require2("_process"));
    }, { "../../is-buffer/index.js": 259, "./peer": 453, "_process": 361, "crypto": 117, "fastq": 198, "nanocustomassert": 309, "nanomessage-rpc": 312, "nanoresource-promise/emitter": 324, "p-event": 341 }], 452: [function(require2, module2, exports2) {
      var nanoerror = require2("nanoerror");
      function createError(code, message) {
        exports2[code] = nanoerror(code, message);
      }
      createError("ERR_ARGUMENT_INVALID", "%s");
      createError("ERR_PEER_NOT_FOUND", "peer not found: %s");
      createError("ERR_CONNECTION_CLOSED");
      createError("ERR_SIGNAL_TIMEOUT", "Timeout trying to establish a connection. SIGNALS: %j");
    }, { "nanoerror": 310 }], 453: [function(require2, module2, exports2) {
      (function(Buffer, process) {
        (function() {
          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              if (enumerableOnly)
                symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
              keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              if (i % 2) {
                ownKeys(Object(source), true).forEach(function(key) {
                  _defineProperty(target, key, source[key]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys(Object(source)).forEach(function(key) {
                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
              }
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          function _objectWithoutProperties(source, excluded) {
            if (source == null)
              return {};
            var target = _objectWithoutPropertiesLoose(source, excluded);
            var key, i;
            if (Object.getOwnPropertySymbols) {
              var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
              for (i = 0; i < sourceSymbolKeys.length; i++) {
                key = sourceSymbolKeys[i];
                if (excluded.indexOf(key) >= 0)
                  continue;
                if (!Object.prototype.propertyIsEnumerable.call(source, key))
                  continue;
                target[key] = source[key];
              }
            }
            return target;
          }
          function _objectWithoutPropertiesLoose(source, excluded) {
            if (source == null)
              return {};
            var target = {};
            var sourceKeys = Object.keys(source);
            var key, i;
            for (i = 0; i < sourceKeys.length; i++) {
              key = sourceKeys[i];
              if (excluded.indexOf(key) >= 0)
                continue;
              target[key] = source[key];
            }
            return target;
          }
          function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
            try {
              var info = gen[key](arg);
              var value = info.value;
            } catch (error) {
              reject(error);
              return;
            }
            if (info.done) {
              resolve(value);
            } else {
              Promise.resolve(value).then(_next, _throw);
            }
          }
          function _asyncToGenerator(fn) {
            return function() {
              var self2 = this, args = arguments;
              return new Promise(function(resolve, reject) {
                var gen = fn.apply(self2, args);
                function _next(value) {
                  asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
                }
                function _throw(err) {
                  asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
                }
                _next(void 0);
              });
            };
          }
          var {
            NanoresourcePromise
          } = require2("nanoresource-promise/emitter");
          var SimplePeer = require2("simple-peer");
          var assert = require2("nanocustomassert");
          var pEvent = require2("p-event");
          var eos = require2("end-of-stream");
          var SignalBatch = require2("./signal-batch");
          var {
            ERR_CONNECTION_CLOSED,
            ERR_SIGNAL_TIMEOUT
          } = require2("./errors");
          var kMetadata = Symbol("peer.metadata");
          var kLocalMetadata = Symbol("peer.localmetadata");
          var kOnSignal = Symbol("peer.onsignal");
          var kOffer = Symbol("peer.offer");
          module2.exports = class Peer extends NanoresourcePromise {
            constructor() {
              var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              super();
              var {
                onSignal,
                initiator,
                sessionId,
                id,
                topic,
                metadata,
                localMetadata,
                simplePeer = {},
                timeout
              } = opts;
              assert(onSignal);
              assert(initiator !== void 0, "initiator is required");
              assert(Buffer.isBuffer(sessionId) && sessionId.length === 32, "sessionId is required and must be a buffer of 32");
              assert(Buffer.isBuffer(id) && id.length === 32, "id is required and must be a buffer of 32");
              assert(Buffer.isBuffer(topic) && topic.length === 32, "topic must be a buffer of 32");
              assert(!metadata || typeof metadata === "object", "metadata must be an object");
              assert(!localMetadata || typeof localMetadata === "object", "localMetadata must be an object");
              this.initiator = initiator;
              this.sessionId = sessionId;
              this.id = id;
              this.topic = topic;
              this.simplePeerOptions = simplePeer;
              this.timeout = timeout;
              this.subscribeMediaStream = false;
              this.error = null;
              this.signals = [];
              this[kOnSignal] = onSignal;
              this[kOffer] = null;
              this[kMetadata] = metadata;
              this[kLocalMetadata] = localMetadata;
              this.once("error", (err) => {
                this.error = err;
              });
              this._initializeSimplePeer();
            }
            get connected() {
              return this.stream.connected;
            }
            get destroyed() {
              return this.stream.destroyed;
            }
            get metadata() {
              return this[kMetadata];
            }
            set metadata(metadata) {
              assert(!metadata || typeof metadata === "object", "metadata must be an object");
              this[kMetadata] = metadata;
              this.emit("metadata-updated", this[kMetadata]);
              return this[kMetadata];
            }
            get localMetadata() {
              return this[kLocalMetadata];
            }
            set localMetadata(metadata) {
              assert(!metadata || typeof metadata === "object", "localMetadata must be an object");
              this[kLocalMetadata] = metadata;
              this.emit("local-metadata-updated", this[kLocalMetadata]);
              return this[kLocalMetadata];
            }
            ready() {
              var _this = this;
              return _asyncToGenerator(function* () {
                if (_this.connected)
                  return;
                if (_this.destroyed) {
                  if (_this.error)
                    throw _this.error;
                  throw new ERR_CONNECTION_CLOSED();
                }
                return pEvent(_this, "connect", {
                  rejectionEvents: ["error", "close"]
                });
              })();
            }
            addStream(stream) {
              this.ready().then(() => process.nextTick(() => this._addStream(stream))).catch((err) => process.nextTick(() => this.emit("stream-error", err)));
              return this;
            }
            destroy(err) {
              this.stream.destroy(err);
            }
            open(offer) {
              if (offer)
                this[kOffer] = offer;
              return super.open();
            }
            _open() {
              var _this2 = this;
              return _asyncToGenerator(function* () {
                var timeout = setTimeout(() => {
                  _this2.destroy(new ERR_SIGNAL_TIMEOUT(_this2.signals));
                }, _this2.timeout);
                var signalBatch = new SignalBatch();
                var ready = _this2.ready();
                var onSignal = (signal) => signalBatch.add(signal);
                var clean = () => _this2.stream.removeListener("signal", onSignal);
                _this2.once("close", () => clean());
                signalBatch.onSignal((batch) => {
                  _this2.signals = [..._this2.signals, ...batch];
                  return _this2[kOnSignal](_this2, batch);
                }).onClose((err) => {
                  clean();
                  if (err)
                    process.nextTick(() => _this2.destroy(err));
                }).resolution(() => _this2.destroyed);
                _this2.stream.on("signal", onSignal);
                if (!_this2.initiator && _this2[kOffer]) {
                  _this2[kOffer].forEach((signal) => _this2.stream.signal(signal));
                }
                return ready.finally(() => {
                  clearTimeout(timeout);
                });
              })();
            }
            _close() {
              if (this.destroyed)
                return;
              process.nextTick(() => this.stream.destroy());
              return new Promise((resolve) => eos(this.stream, () => resolve()));
            }
            _initializeSimplePeer() {
              var _this$simplePeerOptio = this.simplePeerOptions, {
                streams = []
              } = _this$simplePeerOptio, opts = _objectWithoutProperties(_this$simplePeerOptio, ["streams"]);
              this.stream = new SimplePeer(_objectSpread(_objectSpread({}, opts), {}, {
                initiator: this.initiator
              }));
              this._addStream = this.stream.addStream.bind(this.stream);
              streams.forEach((stream) => this.addStream(stream));
              this.stream.close = () => process.nextTick(() => this.stream.destroy());
              var onStream = (eventStream) => this.emit("stream", eventStream);
              var onSignal = (signal) => this.emit("signal", signal);
              var onError = (err) => this.emit("error", err);
              var onConnect = () => this.emit("connect");
              var onClose = () => {
                this.stream.removeListener("stream", onStream);
                this.stream.removeListener("signal", onSignal);
                this.stream.removeListener("error", onError);
                this.stream.removeListener("connect", onConnect);
                this.close().catch(() => {
                });
                this.emit("close");
              };
              this.stream.on("stream", onStream);
              this.stream.on("signal", onSignal);
              this.stream.once("error", onError);
              this.stream.once("connect", onConnect);
              this.stream.once("close", onClose);
            }
          };
        }).call(this);
      }).call(this, { "isBuffer": require2("../../is-buffer/index.js") }, require2("_process"));
    }, { "../../is-buffer/index.js": 259, "./errors": 452, "./signal-batch": 456, "_process": 361, "end-of-stream": 187, "nanocustomassert": 309, "nanoresource-promise/emitter": 324, "p-event": 341, "simple-peer": 442 }], 454: [function(require2, module2, exports2) {
      function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator(fn) {
        return function() {
          var self2 = this, args = arguments;
          return new Promise(function(resolve, reject) {
            var gen = fn.apply(self2, args);
            function _next(value) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(void 0);
          });
        };
      }
      var SocketSignalServer = require2("./server");
      var {
        ERR_PEER_NOT_FOUND
      } = require2("./errors");
      var log = require2("debug")("socket-signal:server-map");
      class SocketSignalServerMap extends SocketSignalServer {
        constructor() {
          var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          super(opts);
          this._peersByTopic = /* @__PURE__ */ new Map();
        }
        addPeer(rpc, id, topic) {
          var topicStr = topic.toString("hex");
          var idStr = id.toString("hex");
          var peers = this._peersByTopic.get(topicStr) || /* @__PURE__ */ new Map();
          peers.set(idStr, {
            rpc,
            id
          });
          this._peersByTopic.set(topicStr, peers);
        }
        deletePeer(id, topic) {
          var idStr = id.toString("hex");
          if (!topic) {
            this._peersByTopic.forEach((peers, topic2) => {
              if (peers.delete(idStr)) {
                log("peer-leave", idStr + " from " + topic2);
              }
            });
            return;
          }
          var topicStr = topic.toString("hex");
          if (this._peersByTopic.has(topicStr) && this._peersByTopic.get(topicStr).delete(idStr)) {
            log("peer-leave", idStr + " from " + topicStr);
          }
        }
        getPeers(topic) {
          var topicStr = topic.toString("hex");
          if (!this._peersByTopic.has(topicStr))
            return [];
          return Array.from(this._peersByTopic.get(topicStr).values()).map((peer) => peer.id);
        }
        findPeer(id, topic) {
          var idStr = id.toString("hex");
          var peers = this._peersByTopic.get(topic.toString("hex"));
          if (!peers || !peers.has(idStr)) {
            throw new ERR_PEER_NOT_FOUND(idStr);
          }
          return peers.get(idStr);
        }
        _onDisconnect(rpc) {
          var _this = this;
          return _asyncToGenerator(function* () {
            var id;
            _this._peersByTopic.forEach((peers) => {
              for (var [key, peer] of peers) {
                if (peer.rpc === rpc) {
                  id = peer.id;
                  peers.delete(key);
                  break;
                }
              }
            });
            if (id) {
              log("peer-disconnected", id.toString("hex"));
            }
          })();
        }
        _onJoin(rpc, data) {
          var _this2 = this;
          return _asyncToGenerator(function* () {
            _this2.addPeer(rpc, data.id, data.topic);
            log("peer-join", data.id.toString("hex") + " in " + data.topic.toString("hex"));
            return _this2.getPeers(data.topic);
          })();
        }
        _onLeave(rpc, data) {
          var _this3 = this;
          return _asyncToGenerator(function* () {
            _this3.deletePeer(data.id, data.topic);
          })();
        }
        _onOffer(rpc, data) {
          var _this4 = this;
          return _asyncToGenerator(function* () {
            var remotePeer = _this4.findPeer(data.remoteId, data.topic);
            log("peer-offer ".concat(data.id.toString("hex"), " -> ").concat(data.remoteId.toString("hex")));
            return remotePeer.rpc.call("offer", data);
          })();
        }
        _onLookup(rpc, data) {
          var _this5 = this;
          return _asyncToGenerator(function* () {
            return _this5.getPeers(data.topic);
          })();
        }
        _onSignal(rpc, data) {
          var _this6 = this;
          return _asyncToGenerator(function* () {
            var remotePeer = _this6.findPeer(data.remoteId, data.topic);
            log("peer-signal ".concat(data.id.toString("hex"), " -> ").concat(data.remoteId.toString("hex")));
            remotePeer.rpc.emit("signal", data).catch(() => {
            });
          })();
        }
      }
      module2.exports = SocketSignalServerMap;
    }, { "./errors": 452, "./server": 455, "debug": 119 }], 455: [function(require2, module2, exports2) {
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator(fn) {
        return function() {
          var self2 = this, args = arguments;
          return new Promise(function(resolve, reject) {
            var gen = fn.apply(self2, args);
            function _next(value) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(void 0);
          });
        };
      }
      function _objectWithoutProperties(source, excluded) {
        if (source == null)
          return {};
        var target = _objectWithoutPropertiesLoose(source, excluded);
        var key, i;
        if (Object.getOwnPropertySymbols) {
          var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
          for (i = 0; i < sourceSymbolKeys.length; i++) {
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0)
              continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key))
              continue;
            target[key] = source[key];
          }
        }
        return target;
      }
      function _objectWithoutPropertiesLoose(source, excluded) {
        if (source == null)
          return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i;
        for (i = 0; i < sourceKeys.length; i++) {
          key = sourceKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          target[key] = source[key];
        }
        return target;
      }
      var crypto = require2("crypto");
      var nanomessagerpc = require2("nanomessage-rpc");
      var {
        NanoresourcePromise
      } = require2("nanoresource-promise/emitter");
      var log = require2("debug")("socketsignal:server");
      var kDefineActions = Symbol("socketsignal.defineactions");
      var kDefineEvents = Symbol("socketsignal.defineevents");
      class SocketSignalServer extends NanoresourcePromise {
        constructor() {
          var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          super();
          var {
            onConnect,
            onDisconnect,
            onJoin,
            onLeave,
            onLookup,
            onOffer,
            onSignal,
            requestTimeout = 10 * 1e3
          } = opts, rpcOpts = _objectWithoutProperties(opts, ["onConnect", "onDisconnect", "onJoin", "onLeave", "onLookup", "onOffer", "onSignal", "requestTimeout"]);
          if (onConnect)
            this._onConnect = onConnect;
          if (onDisconnect)
            this._onDisconnect = onDisconnect;
          if (onJoin)
            this._onJoin = onJoin;
          if (onLeave)
            this._onLeave = onLeave;
          if (onLookup)
            this._onLookup = onLookup;
          if (onOffer)
            this._onOffer = onOffer;
          if (onSignal)
            this._onSignal = onSignal;
          this._requestTimeout = requestTimeout;
          this._rpcOpts = rpcOpts;
          this.connections = /* @__PURE__ */ new Set();
        }
        addSocket(socket) {
          var _this = this;
          return _asyncToGenerator(function* () {
            yield _this.open();
            var rpc = nanomessagerpc(_objectSpread(_objectSpread({
              timeout: _this._requestTimeout
            }, _this._rpcOpts), nanomessagerpc.useSocket(socket)));
            _this[kDefineActions](rpc);
            _this[kDefineEvents](rpc);
            rpc.id = crypto.randomBytes(32);
            var deleteConnection = () => {
              if (_this.connections.delete(rpc)) {
                log("connection-deleted", rpc.id.toString("hex"));
                return _this._onDisconnect(rpc);
              }
            };
            rpc.ee.on("closed", deleteConnection);
            rpc.ee.on("error", (err) => _this.emit("connection-error", err, rpc));
            yield rpc.open();
            try {
              log("connection-added", rpc.id.toString("hex"));
              yield _this._onConnect(rpc);
              _this.connections.add(rpc);
            } catch (err) {
              rpc.closed().then(deleteConnection).catch(deleteConnection).finally(() => {
                _this.emit("connection-error", err, rpc);
              });
            }
            return rpc;
          })();
        }
        _open() {
          return _asyncToGenerator(function* () {
          })();
        }
        _close() {
          var _this2 = this;
          return _asyncToGenerator(function* () {
            yield Promise.all(Array.from(_this2.connections.values()).map((c) => c.close()));
          })();
        }
        _onConnect() {
          return _asyncToGenerator(function* () {
          })();
        }
        _onDisconnect() {
          return _asyncToGenerator(function* () {
          })();
        }
        _onJoin() {
          return _asyncToGenerator(function* () {
          })();
        }
        _onLeave() {
          return _asyncToGenerator(function* () {
          })();
        }
        _onLookup() {
          return _asyncToGenerator(function* () {
          })();
        }
        _onOffer() {
          return _asyncToGenerator(function* () {
          })();
        }
        _onSignal() {
          return _asyncToGenerator(function* () {
          })();
        }
        [kDefineActions](rpc) {
          var _this3 = this;
          rpc.actions({
            join: function join() {
              var data = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              return _this3._onJoin(rpc, data);
            },
            leave: function leave() {
              var data = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              return _this3._onLeave(rpc, data);
            },
            offer: function offer() {
              var data = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              return _this3._onOffer(rpc, data);
            },
            lookup: function lookup() {
              var data = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              return _this3._onLookup(rpc, data);
            }
          });
        }
        [kDefineEvents](rpc) {
          var _this4 = this;
          rpc.on("signal", /* @__PURE__ */ _asyncToGenerator(function* () {
            var data = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            try {
              yield _this4._onSignal(rpc, data);
            } catch (err) {
              log("signal error", err);
            }
          }));
        }
      }
      module2.exports = SocketSignalServer;
    }, { "crypto": 117, "debug": 119, "nanomessage-rpc": 312, "nanoresource-promise/emitter": 324 }], 456: [function(require2, module2, exports2) {
      function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator(fn) {
        return function() {
          var self2 = this, args = arguments;
          return new Promise(function(resolve, reject) {
            var gen = fn.apply(self2, args);
            function _next(value) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(void 0);
          });
        };
      }
      var pLimit = require2("p-limit");
      class SignalBatch {
        constructor() {
          this._limit = pLimit(1);
          this._cache = [];
        }
        onSignal(cb) {
          this._onSignal = (peer, type, batch) => cb && cb(peer, type, batch);
          return this;
        }
        onClose(cb) {
          this._onClose = (err) => cb && cb(err);
          return this;
        }
        resolution(cb) {
          this._resolution = () => cb && cb();
        }
        add(signal) {
          var _this = this;
          this._cache.push(signal);
          this._limit(/* @__PURE__ */ _asyncToGenerator(function* () {
            _this._limit.clearQueue();
            if (_this._cache.length === 0 || _this._resolution())
              return;
            var prev;
            var ms = 300;
            do {
              prev = _this._cache.length;
              yield new Promise((resolve) => setTimeout(resolve, ms));
              ms = 1;
            } while (prev < _this._cache.length && _this._cache.length < 4);
            var batch = _this._cache;
            _this._cache = [];
            return _this._onSignal(batch);
          })).catch((err) => {
            this._limit.clearQueue();
            this._onClose(err);
          }).finally(() => {
            if (this._resolution()) {
              this._limit.clearQueue();
              this._onClose();
            }
          });
        }
      }
      module2.exports = SignalBatch;
    }, { "p-limit": 457 }], 457: [function(require2, module2, exports2) {
      function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator(fn) {
        return function() {
          var self2 = this, args = arguments;
          return new Promise(function(resolve, reject) {
            var gen = fn.apply(self2, args);
            function _next(value) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(void 0);
          });
        };
      }
      var Queue = require2("yocto-queue");
      var pLimit = (concurrency) => {
        if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
          throw new TypeError("Expected `concurrency` to be a number from 1 and up");
        }
        var queue = new Queue();
        var activeCount = 0;
        var next = () => {
          activeCount--;
          if (queue.size > 0) {
            queue.dequeue()();
          }
        };
        var run = /* @__PURE__ */ function() {
          var _ref = _asyncToGenerator(function* (fn, resolve) {
            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              args[_key - 2] = arguments[_key];
            }
            activeCount++;
            var result = _asyncToGenerator(function* () {
              return fn(...args);
            })();
            resolve(result);
            try {
              yield result;
            } catch (_unused) {
            }
            next();
          });
          return function run2(_x, _x2) {
            return _ref.apply(this, arguments);
          };
        }();
        var enqueue = function enqueue2(fn, resolve) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }
          queue.enqueue(run.bind(null, fn, resolve, ...args));
          _asyncToGenerator(function* () {
            yield Promise.resolve();
            if (activeCount < concurrency && queue.size > 0) {
              queue.dequeue()();
            }
          })();
        };
        var generator = function generator2(fn) {
          for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            args[_key3 - 1] = arguments[_key3];
          }
          return new Promise((resolve) => {
            enqueue(fn, resolve, ...args);
          });
        };
        Object.defineProperties(generator, {
          activeCount: {
            get: () => activeCount
          },
          pendingCount: {
            get: () => queue.size
          },
          clearQueue: {
            value: () => {
              queue.clear();
            }
          }
        });
        return generator;
      };
      module2.exports = pLimit;
    }, { "yocto-queue": 541 }], 458: [function(require2, module2, exports2) {
      var {
        crypto_stream_chacha20_ietf,
        crypto_stream_chacha20_ietf_xor_ic
      } = require2("./crypto_stream_chacha20");
      var {
        crypto_verify_16
      } = require2("./crypto_verify");
      var Poly1305 = require2("./internal/poly1305");
      var assert = require2("nanoassert");
      var crypto_aead_chacha20poly1305_ietf_KEYBYTES = 32;
      var crypto_aead_chacha20poly1305_ietf_NSECBYTES = 0;
      var crypto_aead_chacha20poly1305_ietf_NPUBBYTES = 12;
      var crypto_aead_chacha20poly1305_ietf_ABYTES = 16;
      var crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX = Number.MAX_SAFE_INTEGER;
      var _pad0 = new Uint8Array(16);
      function crypto_aead_chacha20poly1305_ietf_encrypt(c, m, ad, nsec, npub, k) {
        if (ad === null)
          return crypto_aead_chacha20poly1305_ietf_encrypt(c, m, new Uint8Array(0), nsec, npub, k);
        assert(c.byteLength === m.byteLength + crypto_aead_chacha20poly1305_ietf_ABYTES, "ciphertext should be 'crypto_aead_chacha20poly1305_ietf_ABYTES' longer than message");
        assert(npub.byteLength === crypto_aead_chacha20poly1305_ietf_NPUBBYTES, "npub should be 'crypto_aead_chacha20poly1305_ietf_NPUBBYTES' long");
        assert(k.byteLength === crypto_aead_chacha20poly1305_ietf_KEYBYTES, "k should be 'crypto_aead_chacha20poly1305_ietf_KEYBYTES' long");
        assert(m.byteLength <= crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX, "message is too large");
        var ret = crypto_aead_chacha20poly1305_ietf_encrypt_detached(c.subarray(0, m.byteLength), c.subarray(m.byteLength), m, ad, nsec, npub, k);
        return m.byteLength + ret;
      }
      function crypto_aead_chacha20poly1305_ietf_encrypt_detached(c, mac, m, ad, nsec, npub, k) {
        if (ad === null)
          return crypto_aead_chacha20poly1305_ietf_encrypt(c, mac, m, new Uint8Array(0), nsec, npub);
        assert(c.byteLength === m.byteLength, "ciphertext should be same length than message");
        assert(npub.byteLength === crypto_aead_chacha20poly1305_ietf_NPUBBYTES, "npub should be 'crypto_aead_chacha20poly1305_ietf_NPUBBYTES' long");
        assert(k.byteLength === crypto_aead_chacha20poly1305_ietf_KEYBYTES, "k should be 'crypto_aead_chacha20poly1305_ietf_KEYBYTES' long");
        assert(m.byteLength <= crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX, "message is too large");
        assert(mac.byteLength <= crypto_aead_chacha20poly1305_ietf_ABYTES, "mac should be 'crypto_aead_chacha20poly1305_ietf_ABYTES' long");
        var block0 = new Uint8Array(64);
        var slen = new Uint8Array(8);
        crypto_stream_chacha20_ietf(block0, npub, k);
        var poly = new Poly1305(block0);
        block0.fill(0);
        poly.update(ad, 0, ad.byteLength);
        poly.update(_pad0, 0, 16 - ad.byteLength & 15);
        crypto_stream_chacha20_ietf_xor_ic(c, m, npub, 1, k);
        poly.update(c, 0, m.byteLength);
        poly.update(_pad0, 0, 16 - m.byteLength & 15);
        write64LE(slen, 0, ad.byteLength);
        poly.update(slen, 0, slen.byteLength);
        write64LE(slen, 0, m.byteLength);
        poly.update(slen, 0, slen.byteLength);
        poly.finish(mac, 0);
        slen.fill(0);
        return crypto_aead_chacha20poly1305_ietf_ABYTES;
      }
      function crypto_aead_chacha20poly1305_ietf_decrypt(m, nsec, c, ad, npub, k) {
        if (ad === null)
          return crypto_aead_chacha20poly1305_ietf_decrypt(m, nsec, c, new Uint8Array(0), npub, k);
        assert(m.byteLength === c.byteLength - crypto_aead_chacha20poly1305_ietf_ABYTES, "message should be 'crypto_aead_chacha20poly1305_ietf_ABYTES' shorter than ciphertext");
        assert(npub.byteLength === crypto_aead_chacha20poly1305_ietf_NPUBBYTES, "npub should be 'crypto_aead_chacha20poly1305_ietf_NPUBBYTES' long");
        assert(k.byteLength === crypto_aead_chacha20poly1305_ietf_KEYBYTES, "k should be 'crypto_aead_chacha20poly1305_ietf_KEYBYTES' long");
        assert(m.byteLength <= crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX, "message is too large");
        if (c.byteLength < crypto_aead_chacha20poly1305_ietf_ABYTES)
          throw new Error("could not verify data");
        crypto_aead_chacha20poly1305_ietf_decrypt_detached(m, nsec, c.subarray(0, c.byteLength - crypto_aead_chacha20poly1305_ietf_ABYTES), c.subarray(c.byteLength - crypto_aead_chacha20poly1305_ietf_ABYTES), ad, npub, k);
        return c.byteLength - crypto_aead_chacha20poly1305_ietf_ABYTES;
      }
      function crypto_aead_chacha20poly1305_ietf_decrypt_detached(m, nsec, c, mac, ad, npub, k) {
        if (ad === null)
          return crypto_aead_chacha20poly1305_ietf_decrypt(m, nsec, c, mac, new Uint8Array(0), npub);
        assert(c.byteLength === m.byteLength, "message should be same length than ciphertext");
        assert(npub.byteLength === crypto_aead_chacha20poly1305_ietf_NPUBBYTES, "npub should be 'crypto_aead_chacha20poly1305_ietf_NPUBBYTES' long");
        assert(k.byteLength === crypto_aead_chacha20poly1305_ietf_KEYBYTES, "k should be 'crypto_aead_chacha20poly1305_ietf_KEYBYTES' long");
        assert(m.byteLength <= crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX, "message is too large");
        assert(mac.byteLength <= crypto_aead_chacha20poly1305_ietf_ABYTES, "mac should be 'crypto_aead_chacha20poly1305_ietf_ABYTES' long");
        var block0 = new Uint8Array(64);
        var slen = new Uint8Array(8);
        var computed_mac = new Uint8Array(crypto_aead_chacha20poly1305_ietf_ABYTES);
        crypto_stream_chacha20_ietf(block0, npub, k);
        var poly = new Poly1305(block0);
        block0.fill(0);
        poly.update(ad, 0, ad.byteLength);
        poly.update(_pad0, 0, 16 - ad.byteLength & 15);
        var mlen = c.byteLength;
        poly.update(c, 0, mlen);
        poly.update(_pad0, 0, 16 - mlen & 15);
        write64LE(slen, 0, ad.byteLength);
        poly.update(slen, 0, slen.byteLength);
        write64LE(slen, 0, mlen);
        poly.update(slen, 0, slen.byteLength);
        poly.finish(computed_mac, 0);
        assert(computed_mac.byteLength === 16);
        var ret = crypto_verify_16(computed_mac, 0, mac, 0);
        computed_mac.fill(0);
        slen.fill(0);
        if (!ret) {
          m.fill(0);
          throw new Error("could not verify data");
        }
        crypto_stream_chacha20_ietf_xor_ic(m, c, npub, 1, k);
      }
      function write64LE(buf, offset, int) {
        buf.fill(0, 0, 8);
        var view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setUint32(offset, int & 4294967295, true);
        view.setUint32(offset + 4, int / 2 ** 32 & 4294967295, true);
      }
      module2.exports = {
        crypto_aead_chacha20poly1305_ietf_encrypt,
        crypto_aead_chacha20poly1305_ietf_encrypt_detached,
        crypto_aead_chacha20poly1305_ietf_decrypt,
        crypto_aead_chacha20poly1305_ietf_decrypt_detached,
        crypto_aead_chacha20poly1305_ietf_ABYTES,
        crypto_aead_chacha20poly1305_ietf_KEYBYTES,
        crypto_aead_chacha20poly1305_ietf_NPUBBYTES,
        crypto_aead_chacha20poly1305_ietf_NSECBYTES,
        crypto_aead_chacha20poly1305_ietf_MESSAGEBYTES_MAX
      };
    }, { "./crypto_stream_chacha20": 471, "./crypto_verify": 472, "./internal/poly1305": 476, "nanoassert": 308 }], 459: [function(require2, module2, exports2) {
      var {
        crypto_hash_sha512
      } = require2("./crypto_hash");
      var {
        crypto_scalarmult,
        crypto_scalarmult_base
      } = require2("./crypto_scalarmult");
      var {
        randombytes
      } = require2("./randombytes");
      var {
        crypto_generichash_batch
      } = require2("./crypto_generichash");
      var {
        crypto_secretbox_open_easy,
        crypto_secretbox_easy
      } = require2("./crypto_secretbox");
      var xsalsa20 = require2("xsalsa20");
      var assert = require2("nanoassert");
      var crypto_box_PUBLICKEYBYTES = 32;
      var crypto_box_SECRETKEYBYTES = 32;
      var crypto_box_NONCEBYTES = 24;
      var crypto_box_ZEROBYTES = 32;
      var crypto_box_BOXZEROBYTES = 16;
      var crypto_box_SEALBYTES = 48;
      var crypto_box_SEEDBYTES = 32;
      var crypto_box_BEFORENMBYTES = 32;
      module2.exports = {
        crypto_box_keypair,
        crypto_box_seed_keypair,
        crypto_box_seal,
        crypto_box_seal_open,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_box_SEALBYTES,
        crypto_box_SEEDBYTES,
        crypto_box_BEFORENMBYTES
      };
      function crypto_box_keypair(pk, sk) {
        check(pk, crypto_box_PUBLICKEYBYTES);
        check(sk, crypto_box_SECRETKEYBYTES);
        randombytes(sk, 32);
        return crypto_scalarmult_base(pk, sk);
      }
      function crypto_box_seed_keypair(pk, sk, seed) {
        assert(pk.byteLength === crypto_box_PUBLICKEYBYTES, "pk should be 'crypto_box_PUBLICKEYBYTES' bytes");
        assert(sk.byteLength === crypto_box_SECRETKEYBYTES, "sk should be 'crypto_box_SECRETKEYBYTES' bytes");
        assert(sk.byteLength === crypto_box_SEEDBYTES, "sk should be 'crypto_box_SEEDBYTES' bytes");
        var hash = new Uint8Array(64);
        crypto_hash_sha512(hash, seed, 32);
        sk.set(hash.subarray(0, 32));
        hash.fill(0);
        return crypto_scalarmult_base(pk, sk);
      }
      function crypto_box_seal(c, m, pk) {
        check(c, crypto_box_SEALBYTES + m.length);
        check(pk, crypto_box_PUBLICKEYBYTES);
        var epk = c.subarray(0, crypto_box_PUBLICKEYBYTES);
        var esk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(epk, esk);
        var n = new Uint8Array(crypto_box_NONCEBYTES);
        crypto_generichash_batch(n, [epk, pk]);
        var s = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult(s, esk, pk);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        var zero = new Uint8Array(16);
        xsalsa20.core_hsalsa20(k, zero, s, xsalsa20.SIGMA);
        crypto_secretbox_easy(c.subarray(epk.length), m, n, k);
        cleanup(esk);
      }
      function crypto_box_seal_open(m, c, pk, sk) {
        check(c, crypto_box_SEALBYTES);
        check(m, c.length - crypto_box_SEALBYTES);
        check(pk, crypto_box_PUBLICKEYBYTES);
        check(sk, crypto_box_SECRETKEYBYTES);
        var epk = c.subarray(0, crypto_box_PUBLICKEYBYTES);
        var n = new Uint8Array(crypto_box_NONCEBYTES);
        crypto_generichash_batch(n, [epk, pk]);
        var s = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult(s, sk, epk);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        var zero = new Uint8Array(16);
        xsalsa20.core_hsalsa20(k, zero, s, xsalsa20.SIGMA);
        return crypto_secretbox_open_easy(m, c.subarray(epk.length), n, k);
      }
      function check(buf, len) {
        if (!buf || len && buf.length < len)
          throw new Error("Argument must be a buffer" + (len ? " of length " + len : ""));
      }
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++) {
          arr[i] = 0;
        }
      }
    }, { "./crypto_generichash": 460, "./crypto_hash": 461, "./crypto_scalarmult": 466, "./crypto_secretbox": 467, "./randombytes": 478, "nanoassert": 308, "xsalsa20": 537 }], 460: [function(require2, module2, exports2) {
      var blake2b = require2("blake2b");
      if (new Uint16Array([1])[0] !== 1)
        throw new Error("Big endian architecture is not supported.");
      module2.exports.crypto_generichash_PRIMITIVE = "blake2b";
      module2.exports.crypto_generichash_BYTES_MIN = blake2b.BYTES_MIN;
      module2.exports.crypto_generichash_BYTES_MAX = blake2b.BYTES_MAX;
      module2.exports.crypto_generichash_BYTES = blake2b.BYTES;
      module2.exports.crypto_generichash_KEYBYTES_MIN = blake2b.KEYBYTES_MIN;
      module2.exports.crypto_generichash_KEYBYTES_MAX = blake2b.KEYBYTES_MAX;
      module2.exports.crypto_generichash_KEYBYTES = blake2b.KEYBYTES;
      module2.exports.crypto_generichash_WASM_SUPPORTED = blake2b.WASM_SUPPORTED;
      module2.exports.crypto_generichash_WASM_LOADED = false;
      module2.exports.crypto_generichash = function(output, input, key) {
        blake2b(output.length, key).update(input).final(output);
      };
      module2.exports.crypto_generichash_ready = blake2b.ready;
      module2.exports.crypto_generichash_batch = function(output, inputArray, key) {
        var ctx = blake2b(output.length, key);
        for (var i = 0; i < inputArray.length; i++) {
          ctx.update(inputArray[i]);
        }
        ctx.final(output);
      };
      module2.exports.crypto_generichash_instance = function(key, outlen) {
        if (outlen == null)
          outlen = module2.exports.crypto_generichash_BYTES;
        return blake2b(outlen, key);
      };
      blake2b.ready(function(_) {
        module2.exports.crypto_generichash_WASM_LOADED = blake2b.WASM_LOADED;
      });
    }, { "blake2b": 49 }], 461: [function(require2, module2, exports2) {
      var sha512 = require2("sha512-universal");
      var assert = require2("nanoassert");
      if (new Uint16Array([1])[0] !== 1)
        throw new Error("Big endian architecture is not supported.");
      var crypto_hash_sha512_BYTES = 64;
      var crypto_hash_BYTES = crypto_hash_sha512_BYTES;
      function crypto_hash_sha512(out, m, n) {
        assert(out.byteLength === crypto_hash_sha512_BYTES, "out must be 'crypto_hash_sha512_BYTES' bytes long");
        sha512().update(m.subarray(0, n)).digest(out);
        return 0;
      }
      function crypto_hash(out, m, n) {
        return crypto_hash_sha512(out, m, n);
      }
      module2.exports = {
        crypto_hash,
        crypto_hash_sha512,
        crypto_hash_sha512_BYTES,
        crypto_hash_BYTES
      };
    }, { "nanoassert": 308, "sha512-universal": 431 }], 462: [function(require2, module2, exports2) {
      var sha256 = require2("sha256-universal");
      var assert = require2("nanoassert");
      if (new Uint16Array([1])[0] !== 1)
        throw new Error("Big endian architecture is not supported.");
      var crypto_hash_sha256_BYTES = 32;
      function crypto_hash_sha256(out, m, n) {
        assert(out.byteLength === crypto_hash_sha256_BYTES, "out must be 'crypto_hash_sha256_BYTES' bytes long");
        sha256().update(m.subarray(0, n)).digest(out);
        return 0;
      }
      module2.exports = {
        crypto_hash_sha256,
        crypto_hash_sha256_BYTES
      };
    }, { "nanoassert": 308, "sha256-universal": 427 }], 463: [function(require2, module2, exports2) {
      var assert = require2("nanoassert");
      var randombytes_buf = require2("./randombytes").randombytes_buf;
      var blake2b = require2("blake2b");
      module2.exports.crypto_kdf_PRIMITIVE = "blake2b";
      module2.exports.crypto_kdf_BYTES_MIN = 16;
      module2.exports.crypto_kdf_BYTES_MAX = 64;
      module2.exports.crypto_kdf_CONTEXTBYTES = 8;
      module2.exports.crypto_kdf_KEYBYTES = 32;
      function STORE64_LE(dest, int) {
        var mul = 1;
        var i = 0;
        dest[0] = int & 255;
        while (++i < 8 && (mul *= 256)) {
          dest[i] = int / mul & 255;
        }
      }
      module2.exports.crypto_kdf_derive_from_key = function crypto_kdf_derive_from_key(subkey, subkey_id, ctx, key) {
        assert(subkey.length >= module2.exports.crypto_kdf_BYTES_MIN, "subkey must be at least crypto_kdf_BYTES_MIN");
        assert(subkey_id >= 0 && subkey_id <= 9007199254740991, "subkey_id must be safe integer");
        assert(ctx.length >= module2.exports.crypto_kdf_CONTEXTBYTES, "context must be at least crypto_kdf_CONTEXTBYTES");
        var ctx_padded = new Uint8Array(blake2b.PERSONALBYTES);
        var salt = new Uint8Array(blake2b.SALTBYTES);
        ctx_padded.set(ctx, 0, module2.exports.crypto_kdf_CONTEXTBYTES);
        STORE64_LE(salt, subkey_id);
        var outlen = Math.min(subkey.length, module2.exports.crypto_kdf_BYTES_MAX);
        blake2b(outlen, key.subarray(0, module2.exports.crypto_kdf_KEYBYTES), salt, ctx_padded, true).final(subkey);
      };
      module2.exports.crypto_kdf_keygen = function crypto_kdf_keygen(out) {
        assert(out.length >= module2.exports.crypto_kdf_KEYBYTES, "out.length must be crypto_kdf_KEYBYTES");
        randombytes_buf(out.subarray(0, module2.exports.crypto_kdf_KEYBYTES));
      };
    }, { "./randombytes": 478, "blake2b": 49, "nanoassert": 308 }], 464: [function(require2, module2, exports2) {
      var {
        crypto_scalarmult_base
      } = require2("./crypto_scalarmult");
      var {
        crypto_generichash
      } = require2("./crypto_generichash");
      var {
        randombytes_buf
      } = require2("./randombytes");
      var assert = require2("nanoassert");
      var crypto_kx_SEEDBYTES = 32;
      var crypto_kx_PUBLICKEYBYTES = 32;
      var crypto_kx_SECRETKEYBYTES = 32;
      function crypto_kx_keypair(pk, sk) {
        assert(pk.byteLength === crypto_kx_PUBLICKEYBYTES, "pk must be 'crypto_kx_PUBLICKEYBYTES' bytes");
        assert(sk.byteLength === crypto_kx_SECRETKEYBYTES, "sk must be 'crypto_kx_SECRETKEYBYTES' bytes");
        randombytes_buf(sk, crypto_kx_SECRETKEYBYTES);
        return crypto_scalarmult_base(pk, sk);
      }
      function crypto_kx_seed_keypair(pk, sk, seed) {
        assert(pk.byteLength === crypto_kx_PUBLICKEYBYTES, "pk must be 'crypto_kx_PUBLICKEYBYTES' bytes");
        assert(sk.byteLength === crypto_kx_SECRETKEYBYTES, "sk must be 'crypto_kx_SECRETKEYBYTES' bytes");
        assert(seed.byteLength === crypto_kx_SEEDBYTES, "seed must be 'crypto_kx_SEEDBYTES' bytes");
        crypto_generichash(sk, seed);
        return crypto_scalarmult_base(pk, sk);
      }
      module2.exports = {
        crypto_kx_keypair,
        crypto_kx_seed_keypair,
        crypto_kx_SEEDBYTES,
        crypto_kx_SECRETKEYBYTES,
        crypto_kx_PUBLICKEYBYTES
      };
    }, { "./crypto_generichash": 460, "./crypto_scalarmult": 466, "./randombytes": 478, "nanoassert": 308 }], 465: [function(require2, module2, exports2) {
      var assert = require2("nanoassert");
      var Poly1305 = require2("./internal/poly1305");
      var {
        crypto_verify_16
      } = require2("./crypto_verify");
      var crypto_onetimeauth_BYTES = 16;
      var crypto_onetimeauth_KEYBYTES = 32;
      var crypto_onetimeauth_PRIMITIVE = "poly1305";
      module2.exports = {
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_onetimeauth_BYTES,
        crypto_onetimeauth_KEYBYTES,
        crypto_onetimeauth_PRIMITIVE
      };
      function crypto_onetimeauth(mac, msg, key) {
        assert(mac.byteLength === crypto_onetimeauth_BYTES, "mac must be 'crypto_onetimeauth_BYTES' bytes");
        assert(msg.byteLength != null, "msg must be buffer");
        assert(key.byteLength === crypto_onetimeauth_KEYBYTES, "key must be 'crypto_onetimeauth_KEYBYTES' bytes");
        var s = new Poly1305(key);
        s.update(msg, 0, msg.byteLength);
        s.finish(mac, 0);
      }
      function crypto_onetimeauth_verify(mac, msg, key) {
        assert(mac.byteLength === crypto_onetimeauth_BYTES, "mac must be 'crypto_onetimeauth_BYTES' bytes");
        assert(msg.byteLength != null, "msg must be buffer");
        assert(key.byteLength === crypto_onetimeauth_KEYBYTES, "key must be 'crypto_onetimeauth_KEYBYTES' bytes");
        var tmp = new Uint8Array(16);
        crypto_onetimeauth(tmp, msg, key);
        return crypto_verify_16(mac, 0, tmp, 0);
      }
    }, { "./crypto_verify": 472, "./internal/poly1305": 476, "nanoassert": 308 }], 466: [function(require2, module2, exports2) {
      var {
        _9,
        _121665,
        gf,
        inv25519,
        pack25519,
        unpack25519,
        sel25519,
        A,
        M,
        Z,
        S
      } = require2("./internal/ed25519");
      var crypto_scalarmult_BYTES = 32;
      var crypto_scalarmult_SCALARBYTES = 32;
      module2.exports = {
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES
      };
      function crypto_scalarmult(q, n, p) {
        check(q, crypto_scalarmult_BYTES);
        check(n, crypto_scalarmult_SCALARBYTES);
        check(p, crypto_scalarmult_BYTES);
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r, i;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for (i = 0; i < 31; i++) {
          z[i] = n[i];
        }
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for (i = 0; i < 16; i++) {
          b[i] = x[i];
          d[i] = a[i] = c[i] = 0;
        }
        a[0] = d[0] = 1;
        for (i = 254; i >= 0; --i) {
          r = z[i >>> 3] >>> (i & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A(e, a, c);
          Z(a, a, c);
          A(c, b, d);
          Z(b, b, d);
          S(d, e);
          S(f, a);
          M(a, c, a);
          M(c, b, e);
          A(e, a, c);
          Z(a, a, c);
          S(b, a);
          Z(c, d, f);
          M(a, c, _121665);
          A(a, a, d);
          M(c, c, a);
          M(a, d, f);
          M(d, b, x);
          S(b, e);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i = 0; i < 16; i++) {
          x[i + 16] = a[i];
          x[i + 32] = c[i];
          x[i + 48] = b[i];
          x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function check(buf, len) {
        if (!buf || len && buf.length < len)
          throw new Error("Argument must be a buffer" + (len ? " of length " + len : ""));
      }
    }, { "./internal/ed25519": 475 }], 467: [function(require2, module2, exports2) {
      var assert = require2("nanoassert");
      var {
        crypto_stream,
        crypto_stream_xor
      } = require2("./crypto_stream");
      var {
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_onetimeauth_BYTES,
        crypto_onetimeauth_KEYBYTES
      } = require2("./crypto_onetimeauth");
      var crypto_secretbox_KEYBYTES = 32;
      var crypto_secretbox_NONCEBYTES = 24;
      var crypto_secretbox_ZEROBYTES = 32;
      var crypto_secretbox_BOXZEROBYTES = 16;
      var crypto_secretbox_MACBYTES = 16;
      module2.exports = {
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_secretbox_detached,
        crypto_secretbox_open_detached,
        crypto_secretbox_easy,
        crypto_secretbox_open_easy,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_secretbox_MACBYTES
      };
      function crypto_secretbox(c, m, n, k) {
        assert(c.byteLength === m.byteLength, "c must be 'm.byteLength' bytes");
        var mlen = m.byteLength;
        assert(mlen >= crypto_secretbox_ZEROBYTES, "mlen must be at least 'crypto_secretbox_ZEROBYTES'");
        assert(n.byteLength === crypto_secretbox_NONCEBYTES, "n must be 'crypto_secretbox_NONCEBYTES' bytes");
        assert(k.byteLength === crypto_secretbox_KEYBYTES, "k must be 'crypto_secretbox_KEYBYTES' bytes");
        crypto_stream_xor(c, m, n, k);
        crypto_onetimeauth(c.subarray(crypto_secretbox_BOXZEROBYTES, crypto_secretbox_BOXZEROBYTES + crypto_onetimeauth_BYTES), c.subarray(crypto_secretbox_BOXZEROBYTES + crypto_onetimeauth_BYTES, c.byteLength), c.subarray(0, crypto_onetimeauth_KEYBYTES));
        c.fill(0, 0, crypto_secretbox_BOXZEROBYTES);
      }
      function crypto_secretbox_open(m, c, n, k) {
        assert(c.byteLength === m.byteLength, "c must be 'm.byteLength' bytes");
        var mlen = m.byteLength;
        assert(mlen >= crypto_secretbox_ZEROBYTES, "mlen must be at least 'crypto_secretbox_ZEROBYTES'");
        assert(n.byteLength === crypto_secretbox_NONCEBYTES, "n must be 'crypto_secretbox_NONCEBYTES' bytes");
        assert(k.byteLength === crypto_secretbox_KEYBYTES, "k must be 'crypto_secretbox_KEYBYTES' bytes");
        var x = new Uint8Array(crypto_onetimeauth_KEYBYTES);
        crypto_stream(x, n, k);
        var validMac = crypto_onetimeauth_verify(c.subarray(crypto_secretbox_BOXZEROBYTES, crypto_secretbox_BOXZEROBYTES + crypto_onetimeauth_BYTES), c.subarray(crypto_secretbox_BOXZEROBYTES + crypto_onetimeauth_BYTES, c.byteLength), x);
        if (validMac === false)
          return false;
        crypto_stream_xor(m, c, n, k);
        m.fill(0, 0, 32);
        return true;
      }
      function crypto_secretbox_detached(o, mac, msg, n, k) {
        assert(o.byteLength === msg.byteLength, "o must be 'msg.byteLength' bytes");
        assert(mac.byteLength === crypto_secretbox_MACBYTES, "mac must be 'crypto_secretbox_MACBYTES' bytes");
        assert(n.byteLength === crypto_secretbox_NONCEBYTES, "n must be 'crypto_secretbox_NONCEBYTES' bytes");
        assert(k.byteLength === crypto_secretbox_KEYBYTES, "k must be 'crypto_secretbox_KEYBYTES' bytes");
        var tmp = new Uint8Array(msg.byteLength + mac.byteLength);
        crypto_secretbox_easy(tmp, msg, n, k);
        o.set(tmp.subarray(0, msg.byteLength));
        mac.set(tmp.subarray(msg.byteLength));
        return true;
      }
      function crypto_secretbox_open_detached(msg, o, mac, n, k) {
        assert(o.byteLength === msg.byteLength, "o must be 'msg.byteLength' bytes");
        assert(mac.byteLength === crypto_secretbox_MACBYTES, "mac must be 'crypto_secretbox_MACBYTES' bytes");
        assert(n.byteLength === crypto_secretbox_NONCEBYTES, "n must be 'crypto_secretbox_NONCEBYTES' bytes");
        assert(k.byteLength === crypto_secretbox_KEYBYTES, "k must be 'crypto_secretbox_KEYBYTES' bytes");
        var tmp = new Uint8Array(o.byteLength + mac.byteLength);
        tmp.set(o);
        tmp.set(mac, msg.byteLength);
        return crypto_secretbox_open_easy(msg, tmp, n, k);
      }
      function crypto_secretbox_easy(o, msg, n, k) {
        assert(o.byteLength === msg.byteLength + crypto_secretbox_MACBYTES, "o must be 'msg.byteLength + crypto_secretbox_MACBYTES' bytes");
        assert(n.byteLength === crypto_secretbox_NONCEBYTES, "n must be 'crypto_secretbox_NONCEBYTES' bytes");
        assert(k.byteLength === crypto_secretbox_KEYBYTES, "k must be 'crypto_secretbox_KEYBYTES' bytes");
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.byteLength);
        var c = new Uint8Array(m.byteLength);
        m.set(msg, crypto_secretbox_ZEROBYTES);
        crypto_secretbox(c, m, n, k);
        o.set(c.subarray(crypto_secretbox_BOXZEROBYTES));
      }
      function crypto_secretbox_open_easy(msg, box, n, k) {
        assert(box.byteLength === msg.byteLength + crypto_secretbox_MACBYTES, "box must be 'msg.byteLength + crypto_secretbox_MACBYTES' bytes");
        assert(n.byteLength === crypto_secretbox_NONCEBYTES, "n must be 'crypto_secretbox_NONCEBYTES' bytes");
        assert(k.byteLength === crypto_secretbox_KEYBYTES, "k must be 'crypto_secretbox_KEYBYTES' bytes");
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.byteLength);
        var m = new Uint8Array(c.byteLength);
        c.set(box, crypto_secretbox_BOXZEROBYTES);
        if (crypto_secretbox_open(m, c, n, k) === false)
          return false;
        msg.set(m.subarray(crypto_secretbox_ZEROBYTES));
        return true;
      }
    }, { "./crypto_onetimeauth": 465, "./crypto_stream": 470, "nanoassert": 308 }], 468: [function(require2, module2, exports2) {
      var siphash = require2("siphash24");
      if (new Uint16Array([1])[0] !== 1)
        throw new Error("Big endian architecture is not supported.");
      exports2.crypto_shorthash_PRIMITIVE = "siphash24";
      exports2.crypto_shorthash_BYTES = siphash.BYTES;
      exports2.crypto_shorthash_KEYBYTES = siphash.KEYBYTES;
      exports2.crypto_shorthash_WASM_SUPPORTED = siphash.WASM_SUPPORTED;
      exports2.crypto_shorthash_WASM_LOADED = siphash.WASM_LOADED;
      exports2.crypto_shorthash = shorthash;
      function shorthash(out, data, key, noAssert) {
        siphash(data, key, out, noAssert);
      }
    }, { "siphash24": 445 }], 469: [function(require2, module2, exports2) {
      var {
        crypto_verify_32
      } = require2("./crypto_verify");
      var {
        crypto_hash
      } = require2("./crypto_hash");
      var {
        gf,
        gf0,
        gf1,
        D,
        D2,
        X,
        Y,
        I,
        A,
        Z,
        M,
        S,
        sel25519,
        pack25519,
        inv25519,
        unpack25519
      } = require2("./internal/ed25519");
      var {
        randombytes
      } = require2("./randombytes");
      var crypto_sign_BYTES = 64;
      var crypto_sign_PUBLICKEYBYTES = 32;
      var crypto_sign_SECRETKEYBYTES = 64;
      var crypto_sign_SEEDBYTES = 32;
      module2.exports = {
        crypto_sign_keypair,
        crypto_sign_seed_keypair,
        crypto_sign,
        crypto_sign_detached,
        crypto_sign_open,
        crypto_sign_verify_detached,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES
      };
      function set25519(r, a) {
        for (var i = 0; i < 16; i++) {
          r[i] = a[i] | 0;
        }
      }
      function pow2523(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++) {
          c[a] = i[a];
        }
        for (a = 250; a >= 0; a--) {
          S(c, c);
          if (a !== 1)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++) {
          o[a] = c[a];
        }
      }
      function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M(a, a, t);
        A(b, p[0], p[1]);
        A(t, q[0], q[1]);
        M(b, b, t);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
      }
      function cswap(p, q, b) {
        var i;
        for (i = 0; i < 4; i++) {
          sel25519(p[i], q[i], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i = 255; i >= 0; --i) {
          b = s[i / 8 | 0] >> (i & 7) & 1;
          cswap(p, q, b);
          add(q, p);
          add(p, p);
          cswap(p, q, b);
        }
      }
      function scalarbase(p, s) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        check(pk, crypto_sign_PUBLICKEYBYTES);
        check(sk, crypto_sign_SECRETKEYBYTES);
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i;
        if (!seeded)
          randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i = 0; i < 32; i++) {
          sk[i + 32] = pk[i];
        }
        return 0;
      }
      function crypto_sign_seed_keypair(pk, sk, seed) {
        check(seed, crypto_sign_SEEDBYTES);
        sk.set(seed);
        return crypto_sign_keypair(pk, sk, true);
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = x[j] + 128 >> 8;
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++) {
          x[j] -= carry * L[j];
        }
        for (i = 0; i < 32; i++) {
          x[i + 1] += x[i] >> 8;
          r[i] = x[i] & 255;
        }
      }
      function reduce(r) {
        var x = new Float64Array(64);
        for (var i = 0; i < 64; i++) {
          x[i] = r[i];
        }
        for (var _i = 0; _i < 64; _i++) {
          r[_i] = 0;
        }
        modL(r, x);
      }
      function crypto_sign(sm, m, sk) {
        check(sm, crypto_sign_BYTES + m.length);
        check(m, 0);
        check(sk, crypto_sign_SECRETKEYBYTES);
        var n = m.length;
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++) {
          sm[64 + i] = m[i];
        }
        for (i = 0; i < 32; i++) {
          sm[32 + i] = d[32 + i];
        }
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i = 32; i < 64; i++) {
          sm[i] = sk[i];
        }
        crypto_hash(h, sm, n + 64);
        reduce(h);
        for (i = 0; i < 64; i++) {
          x[i] = 0;
        }
        for (i = 0; i < 32; i++) {
          x[i] = r[i];
        }
        for (i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function crypto_sign_detached(sig, m, sk) {
        var sm = new Uint8Array(m.length + crypto_sign_BYTES);
        crypto_sign(sm, m, sk);
        for (var i = 0; i < crypto_sign_BYTES; i++) {
          sig[i] = sm[i];
        }
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (!neq25519(chk, num))
          M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (!neq25519(chk, num))
          return false;
        if (par25519(r[0]) === p[31] >> 7)
          Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return true;
      }
      function crypto_sign_open(msg, sm, pk) {
        check(msg, sm.length - crypto_sign_BYTES);
        check(sm, crypto_sign_BYTES);
        check(pk, crypto_sign_PUBLICKEYBYTES);
        var n = sm.length;
        var m = new Uint8Array(sm.length);
        var i;
        var t = new Uint8Array(32), h = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        if (n < 64)
          return false;
        if (!unpackneg(q, pk))
          return false;
        for (i = 0; i < n; i++) {
          m[i] = sm[i];
        }
        for (i = 0; i < 32; i++) {
          m[i + 32] = pk[i];
        }
        crypto_hash(h, m, n);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack(t, p);
        n -= 64;
        if (!crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++) {
            m[i] = 0;
          }
          return false;
        }
        for (i = 0; i < n; i++) {
          msg[i] = sm[i + 64];
        }
        return true;
      }
      function crypto_sign_verify_detached(sig, m, pk) {
        check(sig, crypto_sign_BYTES);
        var sm = new Uint8Array(m.length + crypto_sign_BYTES);
        var i = 0;
        for (i = 0; i < crypto_sign_BYTES; i++) {
          sm[i] = sig[i];
        }
        for (i = 0; i < m.length; i++) {
          sm[i + crypto_sign_BYTES] = m[i];
        }
        return crypto_sign_open(m, sm, pk);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function check(buf, len) {
        if (!buf || len && buf.length < len)
          throw new Error("Argument must be a buffer" + (len ? " of length " + len : ""));
      }
    }, { "./crypto_hash": 461, "./crypto_verify": 472, "./internal/ed25519": 475, "./randombytes": 478 }], 470: [function(require2, module2, exports2) {
      var xsalsa20 = require2("xsalsa20");
      if (new Uint16Array([1])[0] !== 1)
        throw new Error("Big endian architecture is not supported.");
      exports2.crypto_stream_KEYBYTES = 32;
      exports2.crypto_stream_NONCEBYTES = 24;
      exports2.crypto_stream_PRIMITIVE = "xsalsa20";
      exports2.crypto_stream = function(c, nonce, key) {
        c.fill(0);
        exports2.crypto_stream_xor(c, c, nonce, key);
      };
      exports2.crypto_stream_xor = function(c, m, nonce, key) {
        var xor = xsalsa20(nonce, key);
        xor.update(m, c);
        xor.final();
      };
      exports2.crypto_stream_xor_instance = function(nonce, key) {
        return new XOR(nonce, key);
      };
      function XOR(nonce, key) {
        this._instance = xsalsa20(nonce, key);
      }
      XOR.prototype.update = function(out, inp) {
        this._instance.update(inp, out);
      };
      XOR.prototype.final = function() {
        this._instance.finalize();
        this._instance = null;
      };
    }, { "xsalsa20": 537 }], 471: [function(require2, module2, exports2) {
      var assert = require2("nanoassert");
      var Chacha20 = require2("chacha20-universal");
      if (new Uint16Array([1])[0] !== 1)
        throw new Error("Big endian architecture is not supported.");
      exports2.crypto_stream_chacha20_KEYBYTES = 32;
      exports2.crypto_stream_chacha20_NONCEBYTES = 8;
      exports2.crypto_stream_chacha20_MESSAGEBYTES_MAX = Number.MAX_SAFE_INTEGER;
      exports2.crypto_stream_chacha20_ietf_KEYBYTES = 32;
      exports2.crypto_stream_chacha20_ietf_NONCEBYTES = 12;
      exports2.crypto_stream_chacha20_ietf_MESSAGEBYTES_MAX = 2 ** 32;
      exports2.crypto_stream_chacha20 = function(c, n, k) {
        c.fill(0);
        exports2.crypto_stream_chacha20_xor(c, c, n, k);
      };
      exports2.crypto_stream_chacha20_xor = function(c, m, n, k) {
        assert(n.byteLength === exports2.crypto_stream_chacha20_NONCEBYTES, "n should be crypto_stream_chacha20_NONCEBYTES");
        assert(k.byteLength === exports2.crypto_stream_chacha20_KEYBYTES, "k should be crypto_stream_chacha20_KEYBYTES");
        var xor = new Chacha20(n, k);
        xor.update(c, m);
        xor.final();
      };
      exports2.crypto_stream_chacha20_xor_ic = function(c, m, n, ic, k) {
        assert(n.byteLength === exports2.crypto_stream_chacha20_NONCEBYTES, "n should be crypto_stream_chacha20_NONCEBYTES");
        assert(k.byteLength === exports2.crypto_stream_chacha20_KEYBYTES, "k should be crypto_stream_chacha20_KEYBYTES");
        var xor = new Chacha20(n, k, ic);
        xor.update(c, m);
        xor.final();
      };
      exports2.crypto_stream_chacha20_xor_instance = function(n, k) {
        assert(n.byteLength === exports2.crypto_stream_chacha20_NONCEBYTES, "n should be crypto_stream_chacha20_NONCEBYTES");
        assert(k.byteLength === exports2.crypto_stream_chacha20_KEYBYTES, "k should be crypto_stream_chacha20_KEYBYTES");
        return new Chacha20(n, k);
      };
      exports2.crypto_stream_chacha20_ietf = function(c, n, k) {
        c.fill(0);
        exports2.crypto_stream_chacha20_ietf_xor(c, c, n, k);
      };
      exports2.crypto_stream_chacha20_ietf_xor = function(c, m, n, k) {
        assert(n.byteLength === exports2.crypto_stream_chacha20_ietf_NONCEBYTES, "n should be crypto_stream_chacha20_ietf_NONCEBYTES");
        assert(k.byteLength === exports2.crypto_stream_chacha20_ietf_KEYBYTES, "k should be crypto_stream_chacha20_ietf_KEYBYTES");
        var xor = new Chacha20(n, k);
        xor.update(c, m);
        xor.final();
      };
      exports2.crypto_stream_chacha20_ietf_xor_ic = function(c, m, n, ic, k) {
        assert(n.byteLength === exports2.crypto_stream_chacha20_ietf_NONCEBYTES, "n should be crypto_stream_chacha20_ietf_NONCEBYTES");
        assert(k.byteLength === exports2.crypto_stream_chacha20_ietf_KEYBYTES, "k should be crypto_stream_chacha20_ietf_KEYBYTES");
        var xor = new Chacha20(n, k, ic);
        xor.update(c, m);
        xor.final();
      };
      exports2.crypto_stream_chacha20_ietf_xor_instance = function(n, k) {
        assert(n.byteLength === exports2.crypto_stream_chacha20_ietf_NONCEBYTES, "n should be crypto_stream_chacha20_ietf_NONCEBYTES");
        assert(k.byteLength === exports2.crypto_stream_chacha20_ietf_KEYBYTES, "k should be crypto_stream_chacha20_ietf_KEYBYTES");
        return new Chacha20(n, k);
      };
    }, { "chacha20-universal": 91, "nanoassert": 308 }], 472: [function(require2, module2, exports2) {
      module2.exports = {
        crypto_verify_16,
        crypto_verify_32,
        crypto_verify_64
      };
      function vn(x, xi, y, yi, n) {
        var d = 0;
        for (var i = 0; i < n; i++) {
          d |= x[xi + i] ^ y[yi + i];
        }
        return (1 & d - 1 >>> 8) - 1;
      }
      Object.defineProperty(module2.exports, "vn", {
        value: vn
      });
      function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16) === 0;
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32) === 0;
      }
      function crypto_verify_64(x, xi, y, yi) {
        return vn(x, xi, y, yi, 64) === 0;
      }
    }, {}], 473: [function(require2, module2, exports2) {
      var assert = require2("nanoassert");
      var {
        vn
      } = require2("./crypto_verify");
      function sodium_increment(n) {
        var nlen = n.byteLength;
        var c = 1;
        for (var i = 0; i < nlen; i++) {
          c += n[i];
          n[i] = c;
          c >>= 8;
        }
      }
      function sodium_memcmp(a, b) {
        assert(a.byteLength === b.byteLength, "buffers must be the same size");
        return vn(a, 0, b, 0, a.byteLength) === 0;
      }
      function sodium_is_zero(arr) {
        var d = 0;
        for (var i = 0; i < arr.length; i++) {
          d |= arr[i];
        }
        return d === 0;
      }
      module2.exports = {
        sodium_increment,
        sodium_memcmp,
        sodium_is_zero
      };
    }, { "./crypto_verify": 472, "nanoassert": 308 }], 474: [function(require2, module2, exports2) {
      forward(require2("./randombytes"));
      forward(require2("./memory"));
      forward(require2("./helpers"));
      forward(require2("./crypto_verify"));
      forward(require2("./crypto_box"));
      forward(require2("./crypto_generichash"));
      forward(require2("./crypto_hash"));
      forward(require2("./crypto_hash_sha256"));
      forward(require2("./crypto_kdf"));
      forward(require2("./crypto_kx"));
      forward(require2("./crypto_aead"));
      forward(require2("./crypto_onetimeauth"));
      forward(require2("./crypto_scalarmult"));
      forward(require2("./crypto_secretbox"));
      forward(require2("./crypto_shorthash"));
      forward(require2("./crypto_sign"));
      forward(require2("./crypto_stream"));
      forward(require2("./crypto_stream_chacha20"));
      function forward(submodule) {
        Object.keys(submodule).forEach(function(prop) {
          module2.exports[prop] = submodule[prop];
        });
      }
    }, { "./crypto_aead": 458, "./crypto_box": 459, "./crypto_generichash": 460, "./crypto_hash": 461, "./crypto_hash_sha256": 462, "./crypto_kdf": 463, "./crypto_kx": 464, "./crypto_onetimeauth": 465, "./crypto_scalarmult": 466, "./crypto_secretbox": 467, "./crypto_shorthash": 468, "./crypto_sign": 469, "./crypto_stream": 470, "./crypto_stream_chacha20": 471, "./crypto_verify": 472, "./helpers": 473, "./memory": 477, "./randombytes": 478 }], 475: [function(require2, module2, exports2) {
      if (new Uint16Array([1])[0] !== 1)
        throw new Error("Big endian architecture is not supported.");
      var gf = function gf2(init) {
        var i, r = new Float64Array(16);
        if (init)
          for (i = 0; i < init.length; i++) {
            r[i] = init[i];
          }
        return r;
      };
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function A(o, a, b) {
        for (var i = 0; i < 16; i++) {
          o[i] = a[i] + b[i];
        }
      }
      function Z(o, a, b) {
        for (var i = 0; i < 16; i++) {
          o[i] = a[i] - b[i];
        }
      }
      function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      function S(o, a) {
        M(o, a, a);
      }
      function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p[i] ^ q[i]);
          p[i] ^= t;
          q[i] ^= t;
        }
      }
      function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for (i = 0; i < 16; i++) {
          t[i] = n[i];
        }
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; i++) {
          o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        }
        o[15] &= 32767;
      }
      function inv25519(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++) {
          c[a] = i[a];
        }
        for (a = 253; a >= 0; a--) {
          S(c, c);
          if (a !== 2 && a !== 4)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++) {
          o[a] = c[a];
        }
      }
      function car25519(o) {
        var i, v, c = 1;
        for (i = 0; i < 16; i++) {
          v = o[i] + c + 65535;
          c = Math.floor(v / 65536);
          o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      module2.exports = {
        gf,
        A,
        Z,
        M,
        S,
        sel25519,
        pack25519,
        unpack25519,
        inv25519,
        gf0,
        gf1,
        _9,
        _121665,
        D,
        D2,
        X,
        Y,
        I
      };
    }, {}], 476: [function(require2, module2, exports2) {
      if (new Uint16Array([1])[0] !== 1)
        throw new Error("Big endian architecture is not supported.");
      var poly1305 = function poly13052(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f, i;
        if (this.leftover) {
          i = this.leftover;
          this.buffer[i++] = 1;
          for (; i < 16; i++) {
            this.buffer[i] = 0;
          }
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this.h[i] += c;
          c = this.h[i] >>> 13;
          this.h[i] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this.h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++) {
          g[i] &= mask;
        }
        mask = ~mask;
        for (i = 0; i < 10; i++) {
          this.h[i] = this.h[i] & mask | g[i];
        }
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i = 1; i < 8; i++) {
          f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
          this.h[i] = f & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes) {
        var i, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i = 0; i < want; i++) {
            this.buffer[this.leftover + i] = m[mpos + i];
          }
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i = 0; i < bytes; i++) {
            this.buffer[this.leftover + i] = m[mpos + i];
          }
          this.leftover += bytes;
        }
      };
      module2.exports = poly1305;
    }, {}], 477: [function(require2, module2, exports2) {
      (function(global) {
        (function() {
          var MessageChannel = global.MessageChannel;
          if (MessageChannel == null)
            ({
              MessageChannel
            } = require2("worker_threads"));
          function sodium_malloc(n) {
            return new Uint8Array(n);
          }
          var sink = new MessageChannel();
          function sodium_free(n) {
            sodium_memzero(n);
            sink.port1.postMessage(n.buffer, [n.buffer]);
          }
          function sodium_memzero(arr) {
            arr.fill(0);
          }
          module2.exports = {
            sodium_malloc,
            sodium_free,
            sodium_memzero
          };
        }).call(this);
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 478: [function(require2, module2, exports2) {
      (function(global) {
        (function() {
          var assert = require2("nanoassert");
          var randombytes = function() {
            var QUOTA = 65536;
            var crypto = global.crypto || global.msCrypto;
            function browserBytes(out, n) {
              for (var i = 0; i < n; i += QUOTA) {
                crypto.getRandomValues(new Uint8Array(out.buffer, i + out.byteOffset, Math.min(n - i, QUOTA)));
              }
            }
            function nodeBytes(out, n) {
              new Uint8Array(out.buffer, out.byteOffset, n).set(crypto.randomBytes(n));
            }
            function noImpl() {
              throw new Error("No secure random number generator available");
            }
            if (crypto && crypto.getRandomValues)
              return browserBytes;
            if (require2 != null) {
              crypto = require2("crypto");
              if (crypto && crypto.randomBytes)
                return nodeBytes;
            }
            return noImpl;
          }();
          Object.defineProperty(module2.exports, "randombytes", {
            value: randombytes
          });
          module2.exports.randombytes_buf = function(out) {
            assert(out, "out must be given");
            randombytes(out, out.byteLength);
          };
        }).call(this);
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "nanoassert": 308 }], 479: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var pager = require2("memory-pager");
          module2.exports = Bitfield;
          function Bitfield(opts) {
            if (!(this instanceof Bitfield))
              return new Bitfield(opts);
            if (!opts)
              opts = {};
            if (Buffer.isBuffer(opts))
              opts = {
                buffer: opts
              };
            this.pageOffset = opts.pageOffset || 0;
            this.pageSize = opts.pageSize || 1024;
            this.pages = opts.pages || pager(this.pageSize);
            this.byteLength = this.pages.length * this.pageSize;
            this.length = 8 * this.byteLength;
            if (!powerOfTwo(this.pageSize))
              throw new Error("The page size should be a power of two");
            this._trackUpdates = !!opts.trackUpdates;
            this._pageMask = this.pageSize - 1;
            if (opts.buffer) {
              for (var i = 0; i < opts.buffer.length; i += this.pageSize) {
                this.pages.set(i / this.pageSize, opts.buffer.slice(i, i + this.pageSize));
              }
              this.byteLength = opts.buffer.length;
              this.length = 8 * this.byteLength;
            }
          }
          Bitfield.prototype.get = function(i) {
            var o = i & 7;
            var j = (i - o) / 8;
            return !!(this.getByte(j) & 128 >> o);
          };
          Bitfield.prototype.getByte = function(i) {
            var o = i & this._pageMask;
            var j = (i - o) / this.pageSize;
            var page = this.pages.get(j, true);
            return page ? page.buffer[o + this.pageOffset] : 0;
          };
          Bitfield.prototype.set = function(i, v) {
            var o = i & 7;
            var j = (i - o) / 8;
            var b = this.getByte(j);
            return this.setByte(j, v ? b | 128 >> o : b & (255 ^ 128 >> o));
          };
          Bitfield.prototype.toBuffer = function() {
            var all = alloc(this.pages.length * this.pageSize);
            for (var i = 0; i < this.pages.length; i++) {
              var next = this.pages.get(i, true);
              var allOffset = i * this.pageSize;
              if (next)
                next.buffer.copy(all, allOffset, this.pageOffset, this.pageOffset + this.pageSize);
            }
            return all;
          };
          Bitfield.prototype.setByte = function(i, b) {
            var o = i & this._pageMask;
            var j = (i - o) / this.pageSize;
            var page = this.pages.get(j, false);
            o += this.pageOffset;
            if (page.buffer[o] === b)
              return false;
            page.buffer[o] = b;
            if (i >= this.byteLength) {
              this.byteLength = i + 1;
              this.length = this.byteLength * 8;
            }
            if (this._trackUpdates)
              this.pages.updated(page);
            return true;
          };
          function alloc(n) {
            if (Buffer.alloc)
              return Buffer.alloc(n);
            var b = new Buffer(n);
            b.fill(0);
            return b;
          }
          function powerOfTwo(x) {
            return !(x & x - 1);
          }
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82, "memory-pager": 298 }], 480: [function(require2, module2, exports2) {
      module2.exports = Stream;
      var EE = require2("events").EventEmitter;
      var inherits = require2("inherits");
      inherits(Stream, EE);
      Stream.Readable = require2("readable-stream/readable.js");
      Stream.Writable = require2("readable-stream/writable.js");
      Stream.Duplex = require2("readable-stream/duplex.js");
      Stream.Transform = require2("readable-stream/transform.js");
      Stream.PassThrough = require2("readable-stream/passthrough.js");
      Stream.Stream = Stream;
      function Stream() {
        EE.call(this);
      }
      Stream.prototype.pipe = function(dest, options) {
        var source = this;
        function ondata(chunk) {
          if (dest.writable) {
            if (false === dest.write(chunk) && source.pause) {
              source.pause();
            }
          }
        }
        source.on("data", ondata);
        function ondrain() {
          if (source.readable && source.resume) {
            source.resume();
          }
        }
        dest.on("drain", ondrain);
        if (!dest._isStdio && (!options || options.end !== false)) {
          source.on("end", onend);
          source.on("close", onclose);
        }
        var didOnEnd = false;
        function onend() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          dest.end();
        }
        function onclose() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          if (typeof dest.destroy === "function")
            dest.destroy();
        }
        function onerror(er) {
          cleanup();
          if (EE.listenerCount(this, "error") === 0) {
            throw er;
          }
        }
        source.on("error", onerror);
        dest.on("error", onerror);
        function cleanup() {
          source.removeListener("data", ondata);
          dest.removeListener("drain", ondrain);
          source.removeListener("end", onend);
          source.removeListener("close", onclose);
          source.removeListener("error", onerror);
          dest.removeListener("error", onerror);
          source.removeListener("end", cleanup);
          source.removeListener("close", cleanup);
          dest.removeListener("close", cleanup);
        }
        source.on("end", cleanup);
        source.on("close", cleanup);
        dest.on("close", cleanup);
        dest.emit("pipe", source);
        return dest;
      };
    }, { "events": 193, "inherits": 256, "readable-stream/duplex.js": 481, "readable-stream/passthrough.js": 490, "readable-stream/readable.js": 491, "readable-stream/transform.js": 492, "readable-stream/writable.js": 493 }], 481: [function(require2, module2, exports2) {
      module2.exports = require2("./lib/_stream_duplex.js");
    }, { "./lib/_stream_duplex.js": 482 }], 482: [function(require2, module2, exports2) {
      arguments[4][97][0].apply(exports2, arguments);
    }, { "./_stream_readable": 484, "./_stream_writable": 486, "core-util-is": 108, "dup": 97, "inherits": 256, "process-nextick-args": 360 }], 483: [function(require2, module2, exports2) {
      arguments[4][98][0].apply(exports2, arguments);
    }, { "./_stream_transform": 485, "core-util-is": 108, "dup": 98, "inherits": 256 }], 484: [function(require2, module2, exports2) {
      arguments[4][99][0].apply(exports2, arguments);
    }, { "../../../../util/util.js": 514, "./_stream_duplex": 482, "./internal/streams/BufferList": 487, "./internal/streams/destroy": 488, "./internal/streams/stream": 489, "_process": 361, "core-util-is": 108, "dup": 99, "events": 193, "inherits": 256, "isarray": 263, "process-nextick-args": 360, "safe-buffer": 494, "string_decoder/": 495 }], 485: [function(require2, module2, exports2) {
      arguments[4][100][0].apply(exports2, arguments);
    }, { "./_stream_duplex": 482, "core-util-is": 108, "dup": 100, "inherits": 256 }], 486: [function(require2, module2, exports2) {
      arguments[4][101][0].apply(exports2, arguments);
    }, { "./_stream_duplex": 482, "./internal/streams/destroy": 488, "./internal/streams/stream": 489, "_process": 361, "core-util-is": 108, "dup": 101, "inherits": 256, "process-nextick-args": 360, "safe-buffer": 494, "timers": 506, "util-deprecate": 511 }], 487: [function(require2, module2, exports2) {
      arguments[4][102][0].apply(exports2, arguments);
    }, { "../../../../../../util/util.js": 514, "dup": 102, "safe-buffer": 494 }], 488: [function(require2, module2, exports2) {
      arguments[4][103][0].apply(exports2, arguments);
    }, { "dup": 103, "process-nextick-args": 360 }], 489: [function(require2, module2, exports2) {
      arguments[4][104][0].apply(exports2, arguments);
    }, { "dup": 104, "events": 193 }], 490: [function(require2, module2, exports2) {
      module2.exports = require2("./readable").PassThrough;
    }, { "./readable": 491 }], 491: [function(require2, module2, exports2) {
      arguments[4][105][0].apply(exports2, arguments);
    }, { "./lib/_stream_duplex.js": 482, "./lib/_stream_passthrough.js": 483, "./lib/_stream_readable.js": 484, "./lib/_stream_transform.js": 485, "./lib/_stream_writable.js": 486, "dup": 105 }], 492: [function(require2, module2, exports2) {
      module2.exports = require2("./readable").Transform;
    }, { "./readable": 491 }], 493: [function(require2, module2, exports2) {
      module2.exports = require2("./lib/_stream_writable.js");
    }, { "./lib/_stream_writable.js": 486 }], 494: [function(require2, module2, exports2) {
      arguments[4][106][0].apply(exports2, arguments);
    }, { "buffer": 82, "dup": 106 }], 495: [function(require2, module2, exports2) {
      arguments[4][107][0].apply(exports2, arguments);
    }, { "dup": 107, "safe-buffer": 494 }], 496: [function(require2, module2, exports2) {
      var once = require2("once");
      module2.exports = function(stream, cb) {
        if (!cb)
          return stream;
        var list = [];
        cb = once(cb);
        stream.on("data", function(data) {
          list.push(data);
        });
        stream.on("end", function() {
          cb(null, list);
        });
        stream.on("close", function() {
          cb(new Error("Premature close"));
        });
        stream.on("error", cb);
        return stream;
      };
    }, { "once": 339 }], 497: [function(require2, module2, exports2) {
      module2.exports = shift;
      function shift(stream) {
        var rs = stream._readableState;
        if (!rs)
          return null;
        return rs.objectMode || typeof stream._duplexState === "number" ? stream.read() : stream.read(getStateLength(rs));
      }
      function getStateLength(state) {
        if (state.buffer.length) {
          if (state.buffer.head) {
            return state.buffer.head.data.length;
          }
          return state.buffer[0].length;
        }
        return state.length;
      }
    }, {}], 498: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              if (enumerableOnly)
                symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
              keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              if (i % 2) {
                ownKeys(Object(source), true).forEach(function(key) {
                  _defineProperty(target, key, source[key]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys(Object(source)).forEach(function(key) {
                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
              }
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var {
            EventEmitter
          } = require2("events");
          var STREAM_DESTROYED = new Error("Stream was destroyed");
          var PREMATURE_CLOSE = new Error("Premature close");
          var FIFO = require2("fast-fifo");
          var MAX = (1 << 25) - 1;
          var OPENING = 1;
          var DESTROYING = 2;
          var DESTROYED = 4;
          var NOT_OPENING = MAX ^ OPENING;
          var READ_ACTIVE = 1 << 3;
          var READ_PRIMARY = 2 << 3;
          var READ_SYNC = 4 << 3;
          var READ_QUEUED = 8 << 3;
          var READ_RESUMED = 16 << 3;
          var READ_PIPE_DRAINED = 32 << 3;
          var READ_ENDING = 64 << 3;
          var READ_EMIT_DATA = 128 << 3;
          var READ_EMIT_READABLE = 256 << 3;
          var READ_EMITTED_READABLE = 512 << 3;
          var READ_DONE = 1024 << 3;
          var READ_NEXT_TICK = 2049 << 3;
          var READ_NEEDS_PUSH = 4096 << 3;
          var READ_NOT_ACTIVE = MAX ^ READ_ACTIVE;
          var READ_NON_PRIMARY = MAX ^ READ_PRIMARY;
          var READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH);
          var READ_NOT_SYNC = MAX ^ READ_SYNC;
          var READ_PUSHED = MAX ^ READ_NEEDS_PUSH;
          var READ_PAUSED = MAX ^ READ_RESUMED;
          var READ_NOT_QUEUED = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE);
          var READ_NOT_ENDING = MAX ^ READ_ENDING;
          var READ_PIPE_NOT_DRAINED = MAX ^ (READ_RESUMED | READ_PIPE_DRAINED);
          var READ_NOT_NEXT_TICK = MAX ^ READ_NEXT_TICK;
          var WRITE_ACTIVE = 1 << 16;
          var WRITE_PRIMARY = 2 << 16;
          var WRITE_SYNC = 4 << 16;
          var WRITE_QUEUED = 8 << 16;
          var WRITE_UNDRAINED = 16 << 16;
          var WRITE_DONE = 32 << 16;
          var WRITE_EMIT_DRAIN = 64 << 16;
          var WRITE_NEXT_TICK = 129 << 16;
          var WRITE_FINISHING = 256 << 16;
          var WRITE_NOT_ACTIVE = MAX ^ WRITE_ACTIVE;
          var WRITE_NOT_SYNC = MAX ^ WRITE_SYNC;
          var WRITE_NON_PRIMARY = MAX ^ WRITE_PRIMARY;
          var WRITE_NOT_FINISHING = MAX ^ WRITE_FINISHING;
          var WRITE_DRAINED = MAX ^ WRITE_UNDRAINED;
          var WRITE_NOT_QUEUED = MAX ^ WRITE_QUEUED;
          var WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK;
          var ACTIVE = READ_ACTIVE | WRITE_ACTIVE;
          var NOT_ACTIVE = MAX ^ ACTIVE;
          var DONE = READ_DONE | WRITE_DONE;
          var DESTROY_STATUS = DESTROYING | DESTROYED;
          var OPEN_STATUS = DESTROY_STATUS | OPENING;
          var AUTO_DESTROY = DESTROY_STATUS | DONE;
          var NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY;
          var TICKING = (WRITE_NEXT_TICK | READ_NEXT_TICK) & NOT_ACTIVE;
          var ACTIVE_OR_TICKING = ACTIVE | TICKING;
          var IS_OPENING = OPEN_STATUS | TICKING;
          var READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE;
          var READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED;
          var READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED;
          var READ_ACTIVE_AND_SYNC = READ_ACTIVE | READ_SYNC;
          var READ_ACTIVE_AND_SYNC_AND_NEEDS_PUSH = READ_ACTIVE | READ_SYNC | READ_NEEDS_PUSH;
          var READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE;
          var READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED;
          var READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED;
          var READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE;
          var SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH;
          var READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE;
          var WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE;
          var WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED;
          var WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE;
          var WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE;
          var WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED;
          var WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE;
          var WRITE_ACTIVE_AND_SYNC = WRITE_ACTIVE | WRITE_SYNC;
          var WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED;
          var WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE;
          var asyncIterator = Symbol.asyncIterator || Symbol("asyncIterator");
          class WritableState {
            constructor(stream) {
              var {
                highWaterMark = 16384,
                map = null,
                mapWritable,
                byteLength,
                byteLengthWritable
              } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              this.stream = stream;
              this.queue = new FIFO();
              this.highWaterMark = highWaterMark;
              this.buffered = 0;
              this.error = null;
              this.pipeline = null;
              this.byteLength = byteLengthWritable || byteLength || defaultByteLength;
              this.map = mapWritable || map;
              this.afterWrite = afterWrite.bind(this);
            }
            get ended() {
              return (this.stream._duplexState & WRITE_DONE) !== 0;
            }
            push(data) {
              if (this.map !== null)
                data = this.map(data);
              this.buffered += this.byteLength(data);
              this.queue.push(data);
              if (this.buffered < this.highWaterMark) {
                this.stream._duplexState |= WRITE_QUEUED;
                return true;
              }
              this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED;
              return false;
            }
            shift() {
              var data = this.queue.shift();
              var stream = this.stream;
              this.buffered -= this.byteLength(data);
              if (this.buffered === 0)
                stream._duplexState &= WRITE_NOT_QUEUED;
              return data;
            }
            end(data) {
              if (typeof data === "function")
                this.stream.once("finish", data);
              else if (data !== void 0 && data !== null)
                this.push(data);
              this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY;
            }
            autoBatch(data, cb) {
              var buffer = [];
              var stream = this.stream;
              buffer.push(data);
              while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {
                buffer.push(stream._writableState.shift());
              }
              if ((stream._duplexState & OPEN_STATUS) !== 0)
                return cb(null);
              stream._writev(buffer, cb);
            }
            update() {
              var stream = this.stream;
              while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {
                var data = this.shift();
                stream._duplexState |= WRITE_ACTIVE_AND_SYNC;
                stream._write(data, this.afterWrite);
                stream._duplexState &= WRITE_NOT_SYNC;
              }
              if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0)
                this.updateNonPrimary();
            }
            updateNonPrimary() {
              var stream = this.stream;
              if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {
                stream._duplexState = (stream._duplexState | WRITE_ACTIVE) & WRITE_NOT_FINISHING;
                stream._final(afterFinal.bind(this));
                return;
              }
              if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
                if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
                  stream._duplexState |= ACTIVE;
                  stream._destroy(afterDestroy.bind(this));
                }
                return;
              }
              if ((stream._duplexState & IS_OPENING) === OPENING) {
                stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
                stream._open(afterOpen.bind(this));
              }
            }
            updateNextTick() {
              if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0)
                return;
              this.stream._duplexState |= WRITE_NEXT_TICK;
              process.nextTick(updateWriteNT, this);
            }
          }
          class ReadableState {
            constructor(stream) {
              var {
                highWaterMark = 16384,
                map = null,
                mapReadable,
                byteLength,
                byteLengthReadable
              } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              this.stream = stream;
              this.queue = new FIFO();
              this.highWaterMark = highWaterMark;
              this.buffered = 0;
              this.error = null;
              this.pipeline = null;
              this.byteLength = byteLengthReadable || byteLength || defaultByteLength;
              this.map = mapReadable || map;
              this.pipeTo = null;
              this.afterRead = afterRead.bind(this);
            }
            get ended() {
              return (this.stream._duplexState & READ_DONE) !== 0;
            }
            pipe(pipeTo, cb) {
              if (this.pipeTo !== null)
                throw new Error("Can only pipe to one destination");
              this.stream._duplexState |= READ_PIPE_DRAINED;
              this.pipeTo = pipeTo;
              this.pipeline = new Pipeline(this.stream, pipeTo, cb || null);
              if (cb)
                this.stream.on("error", noop);
              if (isStreamx(pipeTo)) {
                pipeTo._writableState.pipeline = this.pipeline;
                if (cb)
                  pipeTo.on("error", noop);
                pipeTo.on("finish", this.pipeline.finished.bind(this.pipeline));
              } else {
                var onerror = this.pipeline.done.bind(this.pipeline, pipeTo);
                var onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null);
                pipeTo.on("error", onerror);
                pipeTo.on("close", onclose);
                pipeTo.on("finish", this.pipeline.finished.bind(this.pipeline));
              }
              pipeTo.on("drain", afterDrain.bind(this));
              this.stream.emit("piping", pipeTo);
              pipeTo.emit("pipe", this.stream);
            }
            push(data) {
              var stream = this.stream;
              if (data === null) {
                this.highWaterMark = 0;
                stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED;
                return false;
              }
              if (this.map !== null)
                data = this.map(data);
              this.buffered += this.byteLength(data);
              this.queue.push(data);
              stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED;
              return this.buffered < this.highWaterMark;
            }
            shift() {
              var data = this.queue.shift();
              this.buffered -= this.byteLength(data);
              if (this.buffered === 0)
                this.stream._duplexState &= READ_NOT_QUEUED;
              return data;
            }
            unshift(data) {
              var tail;
              var pending = [];
              while ((tail = this.queue.shift()) !== void 0) {
                pending.push(tail);
              }
              this.push(data);
              for (var i = 0; i < pending.length; i++) {
                this.queue.push(pending[i]);
              }
            }
            read() {
              var stream = this.stream;
              if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {
                var data = this.shift();
                if ((stream._duplexState & READ_EMIT_DATA) !== 0)
                  stream.emit("data", data);
                if (this.pipeTo !== null && this.pipeTo.write(data) === false)
                  stream._duplexState &= READ_PIPE_NOT_DRAINED;
                return data;
              }
              return null;
            }
            drain() {
              var stream = this.stream;
              while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {
                var data = this.shift();
                if ((stream._duplexState & READ_EMIT_DATA) !== 0)
                  stream.emit("data", data);
                if (this.pipeTo !== null && this.pipeTo.write(data) === false)
                  stream._duplexState &= READ_PIPE_NOT_DRAINED;
              }
            }
            update() {
              var stream = this.stream;
              this.drain();
              while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === 0) {
                stream._duplexState |= READ_ACTIVE_AND_SYNC_AND_NEEDS_PUSH;
                stream._read(this.afterRead);
                stream._duplexState &= READ_NOT_SYNC;
                if ((stream._duplexState & READ_ACTIVE) === 0)
                  this.drain();
              }
              if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {
                stream._duplexState |= READ_EMITTED_READABLE;
                stream.emit("readable");
              }
              if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0)
                this.updateNonPrimary();
            }
            updateNonPrimary() {
              var stream = this.stream;
              if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {
                stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING;
                stream.emit("end");
                if ((stream._duplexState & AUTO_DESTROY) === DONE)
                  stream._duplexState |= DESTROYING;
                if (this.pipeTo !== null)
                  this.pipeTo.end();
              }
              if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
                if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
                  stream._duplexState |= ACTIVE;
                  stream._destroy(afterDestroy.bind(this));
                }
                return;
              }
              if ((stream._duplexState & IS_OPENING) === OPENING) {
                stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
                stream._open(afterOpen.bind(this));
              }
            }
            updateNextTick() {
              if ((this.stream._duplexState & READ_NEXT_TICK) !== 0)
                return;
              this.stream._duplexState |= READ_NEXT_TICK;
              process.nextTick(updateReadNT, this);
            }
          }
          class TransformState {
            constructor(stream) {
              this.data = null;
              this.afterTransform = afterTransform.bind(stream);
              this.afterFinal = null;
            }
          }
          class Pipeline {
            constructor(src, dst, cb) {
              this.from = src;
              this.to = dst;
              this.afterPipe = cb;
              this.error = null;
              this.pipeToFinished = false;
            }
            finished() {
              this.pipeToFinished = true;
            }
            done(stream, err) {
              if (err)
                this.error = err;
              if (stream === this.to) {
                this.to = null;
                if (this.from !== null) {
                  if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {
                    this.from.destroy(this.error || new Error("Writable stream closed prematurely"));
                  }
                  return;
                }
              }
              if (stream === this.from) {
                this.from = null;
                if (this.to !== null) {
                  if ((stream._duplexState & READ_DONE) === 0) {
                    this.to.destroy(this.error || new Error("Readable stream closed before ending"));
                  }
                  return;
                }
              }
              if (this.afterPipe !== null)
                this.afterPipe(this.error);
              this.to = this.from = this.afterPipe = null;
            }
          }
          function afterDrain() {
            this.stream._duplexState |= READ_PIPE_DRAINED;
            if ((this.stream._duplexState & READ_ACTIVE_AND_SYNC) === 0)
              this.updateNextTick();
          }
          function afterFinal(err) {
            var stream = this.stream;
            if (err)
              stream.destroy(err);
            if ((stream._duplexState & DESTROY_STATUS) === 0) {
              stream._duplexState |= WRITE_DONE;
              stream.emit("finish");
            }
            if ((stream._duplexState & AUTO_DESTROY) === DONE) {
              stream._duplexState |= DESTROYING;
            }
            stream._duplexState &= WRITE_NOT_ACTIVE;
            this.update();
          }
          function afterDestroy(err) {
            var stream = this.stream;
            if (!err && this.error !== STREAM_DESTROYED)
              err = this.error;
            if (err)
              stream.emit("error", err);
            stream._duplexState |= DESTROYED;
            stream.emit("close");
            var rs = stream._readableState;
            var ws = stream._writableState;
            if (rs !== null && rs.pipeline !== null)
              rs.pipeline.done(stream, err);
            if (ws !== null && ws.pipeline !== null)
              ws.pipeline.done(stream, err);
          }
          function afterWrite(err) {
            var stream = this.stream;
            if (err)
              stream.destroy(err);
            stream._duplexState &= WRITE_NOT_ACTIVE;
            if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {
              stream._duplexState &= WRITE_DRAINED;
              if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {
                stream.emit("drain");
              }
            }
            if ((stream._duplexState & WRITE_SYNC) === 0)
              this.update();
          }
          function afterRead(err) {
            if (err)
              this.stream.destroy(err);
            this.stream._duplexState &= READ_NOT_ACTIVE;
            if ((this.stream._duplexState & READ_SYNC) === 0)
              this.update();
          }
          function updateReadNT(rs) {
            rs.stream._duplexState &= READ_NOT_NEXT_TICK;
            rs.update();
          }
          function updateWriteNT(ws) {
            ws.stream._duplexState &= WRITE_NOT_NEXT_TICK;
            ws.update();
          }
          function afterOpen(err) {
            var stream = this.stream;
            if (err)
              stream.destroy(err);
            if ((stream._duplexState & DESTROYING) === 0) {
              if ((stream._duplexState & READ_PRIMARY_STATUS) === 0)
                stream._duplexState |= READ_PRIMARY;
              if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0)
                stream._duplexState |= WRITE_PRIMARY;
              stream.emit("open");
            }
            stream._duplexState &= NOT_ACTIVE;
            if (stream._writableState !== null) {
              stream._writableState.update();
            }
            if (stream._readableState !== null) {
              stream._readableState.update();
            }
          }
          function afterTransform(err, data) {
            if (data !== void 0 && data !== null)
              this.push(data);
            this._writableState.afterWrite(err);
          }
          class Stream extends EventEmitter {
            constructor(opts) {
              super();
              this._duplexState = 0;
              this._readableState = null;
              this._writableState = null;
              if (opts) {
                if (opts.open)
                  this._open = opts.open;
                if (opts.destroy)
                  this._destroy = opts.destroy;
                if (opts.predestroy)
                  this._predestroy = opts.predestroy;
                if (opts.signal) {
                  opts.signal.addEventListener("abort", abort.bind(this));
                }
              }
            }
            _open(cb) {
              cb(null);
            }
            _destroy(cb) {
              cb(null);
            }
            _predestroy() {
            }
            get readable() {
              return this._readableState !== null ? true : void 0;
            }
            get writable() {
              return this._writableState !== null ? true : void 0;
            }
            get destroyed() {
              return (this._duplexState & DESTROYED) !== 0;
            }
            get destroying() {
              return (this._duplexState & DESTROY_STATUS) !== 0;
            }
            destroy(err) {
              if ((this._duplexState & DESTROY_STATUS) === 0) {
                if (!err)
                  err = STREAM_DESTROYED;
                this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY;
                this._predestroy();
                if (this._readableState !== null) {
                  this._readableState.error = err;
                  this._readableState.updateNextTick();
                }
                if (this._writableState !== null) {
                  this._writableState.error = err;
                  this._writableState.updateNextTick();
                }
              }
            }
            on(name, fn) {
              if (this._readableState !== null) {
                if (name === "data") {
                  this._duplexState |= READ_EMIT_DATA | READ_RESUMED;
                  this._readableState.updateNextTick();
                }
                if (name === "readable") {
                  this._duplexState |= READ_EMIT_READABLE;
                  this._readableState.updateNextTick();
                }
              }
              if (this._writableState !== null) {
                if (name === "drain") {
                  this._duplexState |= WRITE_EMIT_DRAIN;
                  this._writableState.updateNextTick();
                }
              }
              return super.on(name, fn);
            }
          }
          class Readable extends Stream {
            constructor(opts) {
              super(opts);
              this._duplexState |= OPENING | WRITE_DONE;
              this._readableState = new ReadableState(this, opts);
              if (opts) {
                if (opts.read)
                  this._read = opts.read;
              }
            }
            _read(cb) {
              cb(null);
            }
            pipe(dest, cb) {
              this._readableState.pipe(dest, cb);
              this._readableState.updateNextTick();
              return dest;
            }
            read() {
              this._readableState.updateNextTick();
              return this._readableState.read();
            }
            push(data) {
              this._readableState.updateNextTick();
              return this._readableState.push(data);
            }
            unshift(data) {
              this._readableState.updateNextTick();
              return this._readableState.unshift(data);
            }
            resume() {
              this._duplexState |= READ_RESUMED;
              this._readableState.updateNextTick();
              return this;
            }
            pause() {
              this._duplexState &= READ_PAUSED;
              return this;
            }
            static _fromAsyncIterator(ite, opts) {
              var destroy;
              var rs = new Readable(_objectSpread(_objectSpread({}, opts), {}, {
                read(cb) {
                  ite.next().then(push).then(cb.bind(null, null)).catch(cb);
                },
                predestroy() {
                  destroy = ite.return();
                },
                destroy(cb) {
                  destroy.then(cb.bind(null, null)).catch(cb);
                }
              }));
              return rs;
              function push(data) {
                if (data.done)
                  rs.push(null);
                else
                  rs.push(data.value);
              }
            }
            static from(data, opts) {
              if (isReadStreamx(data))
                return data;
              if (data[asyncIterator])
                return this._fromAsyncIterator(data[asyncIterator](), opts);
              if (!Array.isArray(data))
                data = data === void 0 ? [] : [data];
              var i = 0;
              return new Readable(_objectSpread(_objectSpread({}, opts), {}, {
                read(cb) {
                  this.push(i === data.length ? null : data[i++]);
                  cb(null);
                }
              }));
            }
            static isBackpressured(rs) {
              return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark;
            }
            static isPaused(rs) {
              return (rs._duplexState & READ_RESUMED) === 0;
            }
            [asyncIterator]() {
              var stream = this;
              var error = null;
              var promiseResolve = null;
              var promiseReject = null;
              this.on("error", (err) => {
                error = err;
              });
              this.on("readable", onreadable);
              this.on("close", onclose);
              return {
                [asyncIterator]() {
                  return this;
                },
                next() {
                  return new Promise(function(resolve, reject) {
                    promiseResolve = resolve;
                    promiseReject = reject;
                    var data = stream.read();
                    if (data !== null)
                      ondata(data);
                    else if ((stream._duplexState & DESTROYED) !== 0)
                      ondata(null);
                  });
                },
                return() {
                  return destroy(null);
                },
                throw(err) {
                  return destroy(err);
                }
              };
              function onreadable() {
                if (promiseResolve !== null)
                  ondata(stream.read());
              }
              function onclose() {
                if (promiseResolve !== null)
                  ondata(null);
              }
              function ondata(data) {
                if (promiseReject === null)
                  return;
                if (error)
                  promiseReject(error);
                else if (data === null && (stream._duplexState & READ_DONE) === 0)
                  promiseReject(STREAM_DESTROYED);
                else
                  promiseResolve({
                    value: data,
                    done: data === null
                  });
                promiseReject = promiseResolve = null;
              }
              function destroy(err) {
                stream.destroy(err);
                return new Promise((resolve, reject) => {
                  if (stream._duplexState & DESTROYED)
                    return resolve({
                      value: void 0,
                      done: true
                    });
                  stream.once("close", function() {
                    if (err)
                      reject(err);
                    else
                      resolve({
                        value: void 0,
                        done: true
                      });
                  });
                });
              }
            }
          }
          class Writable extends Stream {
            constructor(opts) {
              super(opts);
              this._duplexState |= OPENING | READ_DONE;
              this._writableState = new WritableState(this, opts);
              if (opts) {
                if (opts.writev)
                  this._writev = opts.writev;
                if (opts.write)
                  this._write = opts.write;
                if (opts.final)
                  this._final = opts.final;
              }
            }
            _writev(batch, cb) {
              cb(null);
            }
            _write(data, cb) {
              this._writableState.autoBatch(data, cb);
            }
            _final(cb) {
              cb(null);
            }
            static isBackpressured(ws) {
              return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0;
            }
            write(data) {
              this._writableState.updateNextTick();
              return this._writableState.push(data);
            }
            end(data) {
              this._writableState.updateNextTick();
              this._writableState.end(data);
              return this;
            }
          }
          class Duplex extends Readable {
            constructor(opts) {
              super(opts);
              this._duplexState = OPENING;
              this._writableState = new WritableState(this, opts);
              if (opts) {
                if (opts.writev)
                  this._writev = opts.writev;
                if (opts.write)
                  this._write = opts.write;
                if (opts.final)
                  this._final = opts.final;
              }
            }
            _writev(batch, cb) {
              cb(null);
            }
            _write(data, cb) {
              this._writableState.autoBatch(data, cb);
            }
            _final(cb) {
              cb(null);
            }
            write(data) {
              this._writableState.updateNextTick();
              return this._writableState.push(data);
            }
            end(data) {
              this._writableState.updateNextTick();
              this._writableState.end(data);
              return this;
            }
          }
          class Transform extends Duplex {
            constructor(opts) {
              super(opts);
              this._transformState = new TransformState(this);
              if (opts) {
                if (opts.transform)
                  this._transform = opts.transform;
                if (opts.flush)
                  this._flush = opts.flush;
              }
            }
            _write(data, cb) {
              if (this._readableState.buffered >= this._readableState.highWaterMark) {
                this._transformState.data = data;
              } else {
                this._transform(data, this._transformState.afterTransform);
              }
            }
            _read(cb) {
              if (this._transformState.data !== null) {
                var data = this._transformState.data;
                this._transformState.data = null;
                cb(null);
                this._transform(data, this._transformState.afterTransform);
              } else {
                cb(null);
              }
            }
            _transform(data, cb) {
              cb(null, data);
            }
            _flush(cb) {
              cb(null);
            }
            _final(cb) {
              this._transformState.afterFinal = cb;
              this._flush(transformAfterFlush.bind(this));
            }
          }
          class PassThrough extends Transform {
          }
          function transformAfterFlush(err, data) {
            var cb = this._transformState.afterFinal;
            if (err)
              return cb(err);
            if (data !== null && data !== void 0)
              this.push(data);
            this.push(null);
            cb(null);
          }
          function pipelinePromise() {
            for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
              streams[_key] = arguments[_key];
            }
            return new Promise((resolve, reject) => {
              return pipeline(...streams, (err) => {
                if (err)
                  return reject(err);
                resolve();
              });
            });
          }
          function pipeline(stream) {
            for (var _len2 = arguments.length, streams = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              streams[_key2 - 1] = arguments[_key2];
            }
            var all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams];
            var done = all.length && typeof all[all.length - 1] === "function" ? all.pop() : null;
            if (all.length < 2)
              throw new Error("Pipeline requires at least 2 streams");
            var src = all[0];
            var dest = null;
            var error = null;
            for (var i = 1; i < all.length; i++) {
              dest = all[i];
              if (isStreamx(src)) {
                src.pipe(dest, onerror);
              } else {
                errorHandle(src, true, i > 1, onerror);
                src.pipe(dest);
              }
              src = dest;
            }
            if (done) {
              var fin = false;
              dest.on("finish", () => {
                fin = true;
              });
              dest.on("error", (err) => {
                error = error || err;
              });
              dest.on("close", () => done(error || (fin ? null : PREMATURE_CLOSE)));
            }
            return dest;
            function errorHandle(s, rd, wr, onerror2) {
              s.on("error", onerror2);
              s.on("close", onclose);
              function onclose() {
                if (rd && s._readableState && !s._readableState.ended)
                  return onerror2(PREMATURE_CLOSE);
                if (wr && s._writableState && !s._writableState.ended)
                  return onerror2(PREMATURE_CLOSE);
              }
            }
            function onerror(err) {
              if (!err || error)
                return;
              error = err;
              for (var s of all) {
                s.destroy(err);
              }
            }
          }
          function isStream(stream) {
            return !!stream._readableState || !!stream._writableState;
          }
          function isStreamx(stream) {
            return typeof stream._duplexState === "number" && isStream(stream);
          }
          function isReadStreamx(stream) {
            return isStreamx(stream) && stream.readable;
          }
          function isTypedArray(data) {
            return typeof data === "object" && data !== null && typeof data.byteLength === "number";
          }
          function defaultByteLength(data) {
            return isTypedArray(data) ? data.byteLength : 1024;
          }
          function noop() {
          }
          function abort() {
            this.destroy(new Error("Stream aborted."));
          }
          module2.exports = {
            pipeline,
            pipelinePromise,
            isStream,
            isStreamx,
            Stream,
            Writable,
            Readable,
            Duplex,
            Transform,
            PassThrough
          };
        }).call(this);
      }).call(this, require2("_process"));
    }, { "_process": 361, "events": 193, "fast-fifo": 197 }], 499: [function(require2, module2, exports2) {
      arguments[4][107][0].apply(exports2, arguments);
    }, { "dup": 107, "safe-buffer": 417 }], 500: [function(require2, module2, exports2) {
      var subdown = require2("./leveldown");
      var levelup = require2("levelup");
      var encoding = require2("encoding-down");
      module2.exports = function(db, prefix, opts) {
        if (typeof prefix === "object" && !opts)
          return module2.exports(db, null, prefix);
        if (!opts)
          opts = {};
        return levelup(encoding(subdown(db, prefix, opts), opts), opts);
      };
    }, { "./leveldown": 501, "encoding-down": 185, "levelup": 281 }], 501: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var inherits = require2("inherits");
          var abstract = require2("abstract-leveldown");
          var wrap = require2("level-option-wrap");
          var reachdown = require2("reachdown");
          var matchdown = require2("./matchdown");
          var rangeOptions = "start end gt gte lt lte".split(" ");
          var defaultClear = abstract.AbstractLevelDOWN.prototype._clear;
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var END = Buffer.from([255]);
          function concat(prefix, key, force) {
            if (typeof key === "string" && (force || key.length))
              return prefix + key;
            if (Buffer.isBuffer(key) && (force || key.length)) {
              return Buffer.concat([Buffer.from(prefix), key]);
            }
            return key;
          }
          function SubIterator(db, ite, prefix) {
            this.iterator = ite;
            this.prefix = prefix;
            abstract.AbstractIterator.call(this, db);
          }
          inherits(SubIterator, abstract.AbstractIterator);
          SubIterator.prototype._next = function(cb) {
            var self2 = this;
            this.iterator.next(function(err, key, value) {
              if (err)
                return cb(err);
              if (key)
                key = key.slice(self2.prefix.length);
              cb.apply(null, arguments);
            });
          };
          SubIterator.prototype._seek = function(key) {
            this.iterator.seek(concat(this.prefix, key));
          };
          SubIterator.prototype._end = function(cb) {
            this.iterator.end(cb);
          };
          function SubDown(db, prefix, opts) {
            if (!(this instanceof SubDown))
              return new SubDown(db, prefix, opts);
            if (typeof opts === "string")
              opts = {
                separator: opts
              };
            if (!opts)
              opts = {};
            var separator = opts.separator;
            if (!prefix)
              prefix = "";
            if (!separator)
              separator = "!";
            if (prefix[0] === separator)
              prefix = prefix.slice(1);
            if (prefix[prefix.length - 1] === separator)
              prefix = prefix.slice(0, -1);
            this.db = db;
            this.leveldown = null;
            this.ownPrefix = separator + prefix + separator;
            this.prefix = this.ownPrefix;
            this._beforeOpen = opts.open;
            var self2 = this;
            this._wrap = {
              gt: function gt(x) {
                return concat(self2.prefix, x || "", true);
              },
              lt: function lt(x) {
                if (Buffer.isBuffer(x) && !x.length)
                  x = END;
                return concat(self2.prefix, x || "\xFF");
              }
            };
            abstract.AbstractLevelDOWN.call(this);
          }
          inherits(SubDown, abstract.AbstractLevelDOWN);
          SubDown.prototype.type = "subleveldown";
          SubDown.prototype._open = function(opts, cb) {
            var self2 = this;
            this.db.open(function(err) {
              if (err)
                return cb(err);
              var subdb = reachdown(self2.db, "subleveldown");
              if (subdb && subdb.prefix) {
                self2.prefix = subdb.prefix + self2.ownPrefix;
                self2.leveldown = subdb.leveldown;
              } else {
                self2.leveldown = reachdown(self2.db, matchdown, false);
              }
              if (self2._beforeOpen)
                self2._beforeOpen(cb);
              else
                cb();
            });
          };
          SubDown.prototype._close = function(cb) {
            this.leveldown.close(cb);
          };
          SubDown.prototype._serializeKey = function(key) {
            return Buffer.isBuffer(key) ? key : String(key);
          };
          SubDown.prototype._put = function(key, value, opts, cb) {
            this.leveldown.put(concat(this.prefix, key), value, opts, cb);
          };
          SubDown.prototype._get = function(key, opts, cb) {
            this.leveldown.get(concat(this.prefix, key), opts, cb);
          };
          SubDown.prototype._del = function(key, opts, cb) {
            this.leveldown.del(concat(this.prefix, key), opts, cb);
          };
          SubDown.prototype._batch = function(operations, opts, cb) {
            for (var i = 0; i < operations.length; i++) {
              operations[i].key = concat(this.prefix, operations[i].key);
            }
            this.leveldown.batch(operations, opts, cb);
          };
          SubDown.prototype._clear = function(opts, cb) {
            if (typeof this.leveldown.clear === "function") {
              opts = addRestOptions(wrap(opts, this._wrap), opts);
              this.leveldown.clear(opts, cb);
            } else {
              defaultClear.call(this, opts, cb);
            }
          };
          function addRestOptions(target, opts) {
            for (var k in opts) {
              if (hasOwnProperty.call(opts, k) && !isRangeOption(k)) {
                target[k] = opts[k];
              }
            }
            return target;
          }
          function isRangeOption(k) {
            return rangeOptions.indexOf(k) !== -1;
          }
          function extend(xopts, opts) {
            xopts.keys = opts.keys;
            xopts.values = opts.values;
            xopts.createIfMissing = opts.createIfMissing;
            xopts.errorIfExists = opts.errorIfExists;
            xopts.keyEncoding = opts.keyEncoding;
            xopts.valueEncoding = opts.valueEncoding;
            xopts.compression = opts.compression;
            xopts.db = opts.db;
            xopts.limit = opts.limit;
            xopts.keyAsBuffer = opts.keyAsBuffer;
            xopts.valueAsBuffer = opts.valueAsBuffer;
            xopts.reverse = opts.reverse;
            xopts.fillCache = opts.fillCache;
            return xopts;
          }
          function fixRange(opts) {
            return !opts.reverse || !opts.end && !opts.start ? opts : {
              start: opts.end,
              end: opts.start
            };
          }
          SubDown.prototype._iterator = function(opts) {
            var xopts = extend(wrap(fixRange(opts), this._wrap), opts);
            return new SubIterator(this, this.leveldown.iterator(xopts), this.prefix);
          };
          module2.exports = SubDown;
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "./matchdown": 502, "abstract-leveldown": 18, "buffer": 82, "inherits": 256, "level-option-wrap": 276, "reachdown": 385 }], 502: [function(require2, module2, exports2) {
      module2.exports = function matchdown(db, type) {
        if (type === "levelup")
          return false;
        if (type === "encoding-down")
          return false;
        if (type === "deferred-leveldown")
          return false;
        return true;
      };
    }, {}], 503: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          var nextTick = nextTickArgs;
          process.nextTick(upgrade, 42);
          module2.exports = thunky;
          function thunky(fn) {
            var state = run;
            return thunk;
            function thunk(callback) {
              state(callback || noop);
            }
            function run(callback) {
              var stack = [callback];
              state = wait;
              fn(done);
              function wait(callback2) {
                stack.push(callback2);
              }
              function done(err) {
                var args = arguments;
                state = isError(err) ? run : finished;
                while (stack.length) {
                  finished(stack.shift());
                }
                function finished(callback2) {
                  nextTick(apply, callback2, args);
                }
              }
            }
          }
          function isError(err) {
            return Object.prototype.toString.call(err) === "[object Error]";
          }
          function noop() {
          }
          function apply(callback, args) {
            callback.apply(null, args);
          }
          function upgrade(val) {
            if (val === 42)
              nextTick = process.nextTick;
          }
          function nextTickArgs(fn, a, b) {
            process.nextTick(function() {
              fn(a, b);
            });
          }
        }).call(this);
      }).call(this, require2("_process"));
    }, { "_process": 361 }], 504: [function(require2, module2, exports2) {
      module2.exports = TimeOrderedSet;
      function TimeOrderedSet() {
        if (!(this instanceof TimeOrderedSet))
          return new TimeOrderedSet();
        this.oldest = null;
        this.latest = null;
        this.length = 0;
      }
      TimeOrderedSet.prototype.has = function(node) {
        return !!(node.next || node.prev) || node === this.oldest;
      };
      TimeOrderedSet.prototype.add = function(node) {
        if (this.has(node))
          this.remove(node);
        if (!this.latest && !this.oldest) {
          this.latest = this.oldest = node;
          node.prev = node.next = null;
        } else {
          this.latest.next = node;
          node.prev = this.latest;
          node.next = null;
          this.latest = node;
        }
        this.length++;
        return node;
      };
      TimeOrderedSet.prototype.remove = function(node) {
        if (!this.has(node))
          return node;
        if (this.oldest !== node && this.latest !== node) {
          node.prev.next = node.next;
          node.next.prev = node.prev;
        } else {
          if (this.oldest === node) {
            this.oldest = node.next;
            if (this.oldest)
              this.oldest.prev = null;
          }
          if (this.latest === node) {
            this.latest = node.prev;
            if (this.latest)
              this.latest.next = null;
          }
        }
        node.next = node.prev = null;
        this.length--;
        return node;
      };
      TimeOrderedSet.prototype.toArray = function(pick) {
        if (!pick)
          pick = Infinity;
        var list = [];
        var node = this.oldest;
        while (node && pick--) {
          list.push(node);
          node = node.next;
        }
        return list;
      };
    }, {}], 505: [function(require2, module2, exports2) {
      module2.exports = Timeout;
      function Timeout(ms, fn, ctx) {
        if (!(this instanceof Timeout))
          return new Timeout(ms, fn, ctx);
        this.ms = ms;
        this.ontimeout = fn;
        this.context = ctx || null;
        this.called = false;
        this._timeout = setTimeout(call, ms, this);
      }
      Timeout.prototype.refresh = function() {
        if (this.called || this.ontimeout === null)
          return;
        clearTimeout(this._timeout);
        this._timeout = setTimeout(call, this.ms, this);
      };
      Timeout.prototype.destroy = function() {
        this.ontimeout = null;
        clearTimeout(this._timeout);
      };
      function call(self2) {
        self2.called = true;
        self2.ontimeout.call(self2.context);
      }
    }, {}], 506: [function(require2, module2, exports2) {
      (function(setImmediate, clearImmediate) {
        (function() {
          var nextTick = require2("process/browser.js").nextTick;
          var apply = Function.prototype.apply;
          var slice = Array.prototype.slice;
          var immediateIds = {};
          var nextImmediateId = 0;
          exports2.setTimeout = function() {
            return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
          };
          exports2.setInterval = function() {
            return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
          };
          exports2.clearTimeout = exports2.clearInterval = function(timeout) {
            timeout.close();
          };
          function Timeout(id, clearFn) {
            this._id = id;
            this._clearFn = clearFn;
          }
          Timeout.prototype.unref = Timeout.prototype.ref = function() {
          };
          Timeout.prototype.close = function() {
            this._clearFn.call(window, this._id);
          };
          exports2.enroll = function(item, msecs) {
            clearTimeout(item._idleTimeoutId);
            item._idleTimeout = msecs;
          };
          exports2.unenroll = function(item) {
            clearTimeout(item._idleTimeoutId);
            item._idleTimeout = -1;
          };
          exports2._unrefActive = exports2.active = function(item) {
            clearTimeout(item._idleTimeoutId);
            var msecs = item._idleTimeout;
            if (msecs >= 0) {
              item._idleTimeoutId = setTimeout(function onTimeout() {
                if (item._onTimeout)
                  item._onTimeout();
              }, msecs);
            }
          };
          exports2.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
            var id = nextImmediateId++;
            var args = arguments.length < 2 ? false : slice.call(arguments, 1);
            immediateIds[id] = true;
            nextTick(function onNextTick() {
              if (immediateIds[id]) {
                if (args) {
                  fn.apply(null, args);
                } else {
                  fn.call(null);
                }
                exports2.clearImmediate(id);
              }
            });
            return id;
          };
          exports2.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
            delete immediateIds[id];
          };
        }).call(this);
      }).call(this, require2("timers").setImmediate, require2("timers").clearImmediate);
    }, { "process/browser.js": 361, "timers": 506 }], 507: [function(require2, module2, exports2) {
      var undefined$1 = void 0;
      var MAX_ARRAY_LENGTH = 1e5;
      var ECMAScript = function() {
        var opts = Object.prototype.toString, ophop = Object.prototype.hasOwnProperty;
        return {
          Class: function Class(v) {
            return opts.call(v).replace(/^\[object *|\]$/g, "");
          },
          HasProperty: function HasProperty(o, p) {
            return p in o;
          },
          HasOwnProperty: function HasOwnProperty(o, p) {
            return ophop.call(o, p);
          },
          IsCallable: function IsCallable(o) {
            return typeof o === "function";
          },
          ToInt32: function ToInt32(v) {
            return v >> 0;
          },
          ToUint32: function ToUint32(v) {
            return v >>> 0;
          }
        };
      }();
      var LN2 = Math.LN2, abs = Math.abs, floor = Math.floor, log = Math.log, min = Math.min, pow = Math.pow, round = Math.round;
      function configureProperties(obj) {
        if (getOwnPropNames && defineProp) {
          var props = getOwnPropNames(obj), i;
          for (i = 0; i < props.length; i += 1) {
            defineProp(obj, props[i], {
              value: obj[props[i]],
              writable: false,
              enumerable: false,
              configurable: false
            });
          }
        }
      }
      var defineProp;
      if (Object.defineProperty && function() {
        try {
          Object.defineProperty({}, "x", {});
          return true;
        } catch (e) {
          return false;
        }
      }()) {
        defineProp = Object.defineProperty;
      } else {
        defineProp = function defineProp2(o, p, desc) {
          if (!o === Object(o))
            throw new TypeError("Object.defineProperty called on non-object");
          if (ECMAScript.HasProperty(desc, "get") && Object.prototype.__defineGetter__) {
            Object.prototype.__defineGetter__.call(o, p, desc.get);
          }
          if (ECMAScript.HasProperty(desc, "set") && Object.prototype.__defineSetter__) {
            Object.prototype.__defineSetter__.call(o, p, desc.set);
          }
          if (ECMAScript.HasProperty(desc, "value")) {
            o[p] = desc.value;
          }
          return o;
        };
      }
      var getOwnPropNames = Object.getOwnPropertyNames || function(o) {
        if (o !== Object(o))
          throw new TypeError("Object.getOwnPropertyNames called on non-object");
        var props = [], p;
        for (p in o) {
          if (ECMAScript.HasOwnProperty(o, p)) {
            props.push(p);
          }
        }
        return props;
      };
      function makeArrayAccessors(obj) {
        if (!defineProp) {
          return;
        }
        if (obj.length > MAX_ARRAY_LENGTH)
          throw new RangeError("Array too large for polyfill");
        function makeArrayAccessor(index) {
          defineProp(obj, index, {
            "get": function get() {
              return obj._getter(index);
            },
            "set": function set(v) {
              obj._setter(index, v);
            },
            enumerable: true,
            configurable: false
          });
        }
        var i;
        for (i = 0; i < obj.length; i += 1) {
          makeArrayAccessor(i);
        }
      }
      function as_signed(value, bits) {
        var s = 32 - bits;
        return value << s >> s;
      }
      function as_unsigned(value, bits) {
        var s = 32 - bits;
        return value << s >>> s;
      }
      function packI8(n) {
        return [n & 255];
      }
      function unpackI8(bytes) {
        return as_signed(bytes[0], 8);
      }
      function packU8(n) {
        return [n & 255];
      }
      function unpackU8(bytes) {
        return as_unsigned(bytes[0], 8);
      }
      function packU8Clamped(n) {
        n = round(Number(n));
        return [n < 0 ? 0 : n > 255 ? 255 : n & 255];
      }
      function packI16(n) {
        return [n >> 8 & 255, n & 255];
      }
      function unpackI16(bytes) {
        return as_signed(bytes[0] << 8 | bytes[1], 16);
      }
      function packU16(n) {
        return [n >> 8 & 255, n & 255];
      }
      function unpackU16(bytes) {
        return as_unsigned(bytes[0] << 8 | bytes[1], 16);
      }
      function packI32(n) {
        return [n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255];
      }
      function unpackI32(bytes) {
        return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32);
      }
      function packU32(n) {
        return [n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255];
      }
      function unpackU32(bytes) {
        return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32);
      }
      function packIEEE754(v, ebits, fbits) {
        var bias = (1 << ebits - 1) - 1, s, e, f, i, bits, str, bytes;
        function roundToEven(n) {
          var w = floor(n), f2 = n - w;
          if (f2 < 0.5)
            return w;
          if (f2 > 0.5)
            return w + 1;
          return w % 2 ? w + 1 : w;
        }
        if (v !== v) {
          e = (1 << ebits) - 1;
          f = pow(2, fbits - 1);
          s = 0;
        } else if (v === Infinity || v === -Infinity) {
          e = (1 << ebits) - 1;
          f = 0;
          s = v < 0 ? 1 : 0;
        } else if (v === 0) {
          e = 0;
          f = 0;
          s = 1 / v === -Infinity ? 1 : 0;
        } else {
          s = v < 0;
          v = abs(v);
          if (v >= pow(2, 1 - bias)) {
            e = min(floor(log(v) / LN2), 1023);
            f = roundToEven(v / pow(2, e) * pow(2, fbits));
            if (f / pow(2, fbits) >= 2) {
              e = e + 1;
              f = 1;
            }
            if (e > bias) {
              e = (1 << ebits) - 1;
              f = 0;
            } else {
              e = e + bias;
              f = f - pow(2, fbits);
            }
          } else {
            e = 0;
            f = roundToEven(v / pow(2, 1 - bias - fbits));
          }
        }
        bits = [];
        for (i = fbits; i; i -= 1) {
          bits.push(f % 2 ? 1 : 0);
          f = floor(f / 2);
        }
        for (i = ebits; i; i -= 1) {
          bits.push(e % 2 ? 1 : 0);
          e = floor(e / 2);
        }
        bits.push(s ? 1 : 0);
        bits.reverse();
        str = bits.join("");
        bytes = [];
        while (str.length) {
          bytes.push(parseInt(str.substring(0, 8), 2));
          str = str.substring(8);
        }
        return bytes;
      }
      function unpackIEEE754(bytes, ebits, fbits) {
        var bits = [], i, j, b, str, bias, s, e, f;
        for (i = bytes.length; i; i -= 1) {
          b = bytes[i - 1];
          for (j = 8; j; j -= 1) {
            bits.push(b % 2 ? 1 : 0);
            b = b >> 1;
          }
        }
        bits.reverse();
        str = bits.join("");
        bias = (1 << ebits - 1) - 1;
        s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
        e = parseInt(str.substring(1, 1 + ebits), 2);
        f = parseInt(str.substring(1 + ebits), 2);
        if (e === (1 << ebits) - 1) {
          return f !== 0 ? NaN : s * Infinity;
        } else if (e > 0) {
          return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
        } else if (f !== 0) {
          return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
        } else {
          return s < 0 ? -0 : 0;
        }
      }
      function unpackF64(b) {
        return unpackIEEE754(b, 11, 52);
      }
      function packF64(v) {
        return packIEEE754(v, 11, 52);
      }
      function unpackF32(b) {
        return unpackIEEE754(b, 8, 23);
      }
      function packF32(v) {
        return packIEEE754(v, 8, 23);
      }
      (function() {
        var ArrayBuffer2 = function ArrayBuffer3(length) {
          length = ECMAScript.ToInt32(length);
          if (length < 0)
            throw new RangeError("ArrayBuffer size is not a small enough positive integer");
          this.byteLength = length;
          this._bytes = [];
          this._bytes.length = length;
          var i;
          for (i = 0; i < this.byteLength; i += 1) {
            this._bytes[i] = 0;
          }
          configureProperties(this);
        };
        exports2.ArrayBuffer = exports2.ArrayBuffer || ArrayBuffer2;
        var ArrayBufferView = function ArrayBufferView2() {
        };
        function makeConstructor(bytesPerElement, pack, unpack) {
          var _ctor;
          _ctor = function ctor(buffer, byteOffset, length) {
            var array, sequence, i, s;
            if (!arguments.length || typeof arguments[0] === "number") {
              this.length = ECMAScript.ToInt32(arguments[0]);
              if (length < 0)
                throw new RangeError("ArrayBufferView size is not a small enough positive integer");
              this.byteLength = this.length * this.BYTES_PER_ELEMENT;
              this.buffer = new ArrayBuffer2(this.byteLength);
              this.byteOffset = 0;
            } else if (typeof arguments[0] === "object" && arguments[0].constructor === _ctor) {
              array = arguments[0];
              this.length = array.length;
              this.byteLength = this.length * this.BYTES_PER_ELEMENT;
              this.buffer = new ArrayBuffer2(this.byteLength);
              this.byteOffset = 0;
              for (i = 0; i < this.length; i += 1) {
                this._setter(i, array._getter(i));
              }
            } else if (typeof arguments[0] === "object" && !(arguments[0] instanceof ArrayBuffer2 || ECMAScript.Class(arguments[0]) === "ArrayBuffer")) {
              sequence = arguments[0];
              this.length = ECMAScript.ToUint32(sequence.length);
              this.byteLength = this.length * this.BYTES_PER_ELEMENT;
              this.buffer = new ArrayBuffer2(this.byteLength);
              this.byteOffset = 0;
              for (i = 0; i < this.length; i += 1) {
                s = sequence[i];
                this._setter(i, Number(s));
              }
            } else if (typeof arguments[0] === "object" && (arguments[0] instanceof ArrayBuffer2 || ECMAScript.Class(arguments[0]) === "ArrayBuffer")) {
              this.buffer = buffer;
              this.byteOffset = ECMAScript.ToUint32(byteOffset);
              if (this.byteOffset > this.buffer.byteLength) {
                throw new RangeError("byteOffset out of range");
              }
              if (this.byteOffset % this.BYTES_PER_ELEMENT) {
                throw new RangeError("ArrayBuffer length minus the byteOffset is not a multiple of the element size.");
              }
              if (arguments.length < 3) {
                this.byteLength = this.buffer.byteLength - this.byteOffset;
                if (this.byteLength % this.BYTES_PER_ELEMENT) {
                  throw new RangeError("length of buffer minus byteOffset not a multiple of the element size");
                }
                this.length = this.byteLength / this.BYTES_PER_ELEMENT;
              } else {
                this.length = ECMAScript.ToUint32(length);
                this.byteLength = this.length * this.BYTES_PER_ELEMENT;
              }
              if (this.byteOffset + this.byteLength > this.buffer.byteLength) {
                throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
              }
            } else {
              throw new TypeError("Unexpected argument type(s)");
            }
            this.constructor = _ctor;
            configureProperties(this);
            makeArrayAccessors(this);
          };
          _ctor.prototype = new ArrayBufferView();
          _ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;
          _ctor.prototype._pack = pack;
          _ctor.prototype._unpack = unpack;
          _ctor.BYTES_PER_ELEMENT = bytesPerElement;
          _ctor.prototype._getter = function(index) {
            if (arguments.length < 1)
              throw new SyntaxError("Not enough arguments");
            index = ECMAScript.ToUint32(index);
            if (index >= this.length) {
              return undefined$1;
            }
            var bytes = [], i, o;
            for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, o += 1) {
              bytes.push(this.buffer._bytes[o]);
            }
            return this._unpack(bytes);
          };
          _ctor.prototype.get = _ctor.prototype._getter;
          _ctor.prototype._setter = function(index, value) {
            if (arguments.length < 2)
              throw new SyntaxError("Not enough arguments");
            index = ECMAScript.ToUint32(index);
            if (index >= this.length) {
              return undefined$1;
            }
            var bytes = this._pack(value), i, o;
            for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, o += 1) {
              this.buffer._bytes[o] = bytes[i];
            }
          };
          _ctor.prototype.set = function(index, value) {
            if (arguments.length < 1)
              throw new SyntaxError("Not enough arguments");
            var array, sequence, offset, len, i, s, d, byteOffset, byteLength, tmp;
            if (typeof arguments[0] === "object" && arguments[0].constructor === this.constructor) {
              array = arguments[0];
              offset = ECMAScript.ToUint32(arguments[1]);
              if (offset + array.length > this.length) {
                throw new RangeError("Offset plus length of array is out of range");
              }
              byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;
              byteLength = array.length * this.BYTES_PER_ELEMENT;
              if (array.buffer === this.buffer) {
                tmp = [];
                for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {
                  tmp[i] = array.buffer._bytes[s];
                }
                for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {
                  this.buffer._bytes[d] = tmp[i];
                }
              } else {
                for (i = 0, s = array.byteOffset, d = byteOffset; i < byteLength; i += 1, s += 1, d += 1) {
                  this.buffer._bytes[d] = array.buffer._bytes[s];
                }
              }
            } else if (typeof arguments[0] === "object" && typeof arguments[0].length !== "undefined") {
              sequence = arguments[0];
              len = ECMAScript.ToUint32(sequence.length);
              offset = ECMAScript.ToUint32(arguments[1]);
              if (offset + len > this.length) {
                throw new RangeError("Offset plus length of array is out of range");
              }
              for (i = 0; i < len; i += 1) {
                s = sequence[i];
                this._setter(offset + i, Number(s));
              }
            } else {
              throw new TypeError("Unexpected argument type(s)");
            }
          };
          _ctor.prototype.subarray = function(start, end) {
            function clamp(v, min2, max) {
              return v < min2 ? min2 : v > max ? max : v;
            }
            start = ECMAScript.ToInt32(start);
            end = ECMAScript.ToInt32(end);
            if (arguments.length < 1) {
              start = 0;
            }
            if (arguments.length < 2) {
              end = this.length;
            }
            if (start < 0) {
              start = this.length + start;
            }
            if (end < 0) {
              end = this.length + end;
            }
            start = clamp(start, 0, this.length);
            end = clamp(end, 0, this.length);
            var len = end - start;
            if (len < 0) {
              len = 0;
            }
            return new this.constructor(this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);
          };
          return _ctor;
        }
        var Int8Array2 = makeConstructor(1, packI8, unpackI8);
        var Uint8Array2 = makeConstructor(1, packU8, unpackU8);
        var Uint8ClampedArray2 = makeConstructor(1, packU8Clamped, unpackU8);
        var Int16Array2 = makeConstructor(2, packI16, unpackI16);
        var Uint16Array2 = makeConstructor(2, packU16, unpackU16);
        var Int32Array2 = makeConstructor(4, packI32, unpackI32);
        var Uint32Array2 = makeConstructor(4, packU32, unpackU32);
        var Float32Array2 = makeConstructor(4, packF32, unpackF32);
        var Float64Array2 = makeConstructor(8, packF64, unpackF64);
        exports2.Int8Array = exports2.Int8Array || Int8Array2;
        exports2.Uint8Array = exports2.Uint8Array || Uint8Array2;
        exports2.Uint8ClampedArray = exports2.Uint8ClampedArray || Uint8ClampedArray2;
        exports2.Int16Array = exports2.Int16Array || Int16Array2;
        exports2.Uint16Array = exports2.Uint16Array || Uint16Array2;
        exports2.Int32Array = exports2.Int32Array || Int32Array2;
        exports2.Uint32Array = exports2.Uint32Array || Uint32Array2;
        exports2.Float32Array = exports2.Float32Array || Float32Array2;
        exports2.Float64Array = exports2.Float64Array || Float64Array2;
      })();
      (function() {
        function r(array, index) {
          return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];
        }
        var IS_BIG_ENDIAN = function() {
          var u16array = new exports2.Uint16Array([4660]), u8array = new exports2.Uint8Array(u16array.buffer);
          return r(u8array, 0) === 18;
        }();
        var DataView2 = function DataView3(buffer, byteOffset, byteLength) {
          if (arguments.length === 0) {
            buffer = new exports2.ArrayBuffer(0);
          } else if (!(buffer instanceof exports2.ArrayBuffer || ECMAScript.Class(buffer) === "ArrayBuffer")) {
            throw new TypeError("TypeError");
          }
          this.buffer = buffer || new exports2.ArrayBuffer(0);
          this.byteOffset = ECMAScript.ToUint32(byteOffset);
          if (this.byteOffset > this.buffer.byteLength) {
            throw new RangeError("byteOffset out of range");
          }
          if (arguments.length < 3) {
            this.byteLength = this.buffer.byteLength - this.byteOffset;
          } else {
            this.byteLength = ECMAScript.ToUint32(byteLength);
          }
          if (this.byteOffset + this.byteLength > this.buffer.byteLength) {
            throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
          }
          configureProperties(this);
        };
        function makeGetter(arrayType) {
          return function(byteOffset, littleEndian) {
            byteOffset = ECMAScript.ToUint32(byteOffset);
            if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
              throw new RangeError("Array index out of range");
            }
            byteOffset += this.byteOffset;
            var uint8Array = new exports2.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT), bytes = [], i;
            for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
              bytes.push(r(uint8Array, i));
            }
            if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
              bytes.reverse();
            }
            return r(new arrayType(new exports2.Uint8Array(bytes).buffer), 0);
          };
        }
        DataView2.prototype.getUint8 = makeGetter(exports2.Uint8Array);
        DataView2.prototype.getInt8 = makeGetter(exports2.Int8Array);
        DataView2.prototype.getUint16 = makeGetter(exports2.Uint16Array);
        DataView2.prototype.getInt16 = makeGetter(exports2.Int16Array);
        DataView2.prototype.getUint32 = makeGetter(exports2.Uint32Array);
        DataView2.prototype.getInt32 = makeGetter(exports2.Int32Array);
        DataView2.prototype.getFloat32 = makeGetter(exports2.Float32Array);
        DataView2.prototype.getFloat64 = makeGetter(exports2.Float64Array);
        function makeSetter(arrayType) {
          return function(byteOffset, value, littleEndian) {
            byteOffset = ECMAScript.ToUint32(byteOffset);
            if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
              throw new RangeError("Array index out of range");
            }
            var typeArray = new arrayType([value]), byteArray = new exports2.Uint8Array(typeArray.buffer), bytes = [], i, byteView;
            for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
              bytes.push(r(byteArray, i));
            }
            if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
              bytes.reverse();
            }
            byteView = new exports2.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);
            byteView.set(bytes);
          };
        }
        DataView2.prototype.setUint8 = makeSetter(exports2.Uint8Array);
        DataView2.prototype.setInt8 = makeSetter(exports2.Int8Array);
        DataView2.prototype.setUint16 = makeSetter(exports2.Uint16Array);
        DataView2.prototype.setInt16 = makeSetter(exports2.Int16Array);
        DataView2.prototype.setUint32 = makeSetter(exports2.Uint32Array);
        DataView2.prototype.setInt32 = makeSetter(exports2.Int32Array);
        DataView2.prototype.setFloat32 = makeSetter(exports2.Float32Array);
        DataView2.prototype.setFloat64 = makeSetter(exports2.Float64Array);
        exports2.DataView = exports2.DataView || DataView2;
      })();
    }, {}], 508: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var UINT_32_MAX = Math.pow(2, 32);
          exports2.encodingLength = function() {
            return 8;
          };
          exports2.encode = function(num, buf, offset) {
            if (!buf)
              buf = Buffer.allocUnsafe(8);
            if (!offset)
              offset = 0;
            var top = Math.floor(num / UINT_32_MAX);
            var rem = num - top * UINT_32_MAX;
            buf.writeUInt32BE(top, offset);
            buf.writeUInt32BE(rem, offset + 4);
            return buf;
          };
          exports2.decode = function(buf, offset) {
            if (!offset)
              offset = 0;
            var top = buf.readUInt32BE(offset);
            var rem = buf.readUInt32BE(offset + 4);
            return top * UINT_32_MAX + rem;
          };
          exports2.encode.bytes = 8;
          exports2.decode.bytes = 8;
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82 }], 509: [function(require2, module2, exports2) {
      module2.exports = remove;
      function remove(arr, i) {
        if (i >= arr.length || i < 0)
          return;
        var last = arr.pop();
        if (i < arr.length) {
          var tmp = arr[i];
          arr[i] = last;
          return tmp;
        }
        return last;
      }
    }, {}], 510: [function(require2, module2, exports2) {
      exports2.add = add;
      exports2.has = has;
      exports2.remove = remove;
      exports2.swap = swap;
      function add(list, item) {
        if (has(list, item))
          return item;
        item._index = list.length;
        list.push(item);
        return item;
      }
      function has(list, item) {
        return item._index < list.length && list[item._index] === item;
      }
      function remove(list, item) {
        if (!has(list, item))
          return null;
        var last = list.pop();
        if (last !== item) {
          list[item._index] = last;
          last._index = item._index;
        }
        return item;
      }
      function swap(list, a, b) {
        if (!has(list, a) || !has(list, b))
          return;
        var tmp = a._index;
        a._index = b._index;
        list[a._index] = a;
        b._index = tmp;
        list[b._index] = b;
      }
    }, {}], 511: [function(require2, module2, exports2) {
      (function(global) {
        (function() {
          module2.exports = deprecate;
          function deprecate(fn, msg) {
            if (config("noDeprecation")) {
              return fn;
            }
            var warned = false;
            function deprecated() {
              if (!warned) {
                if (config("throwDeprecation")) {
                  throw new Error(msg);
                } else if (config("traceDeprecation")) {
                  console.trace(msg);
                } else {
                  console.warn(msg);
                }
                warned = true;
              }
              return fn.apply(this, arguments);
            }
            return deprecated;
          }
          function config(name) {
            try {
              if (!global.localStorage)
                return false;
            } catch (_) {
              return false;
            }
            var val = global.localStorage[name];
            if (null == val)
              return false;
            return String(val).toLowerCase() === "true";
          }
        }).call(this);
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 512: [function(require2, module2, exports2) {
      module2.exports = function isBuffer(arg) {
        return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
      };
    }, {}], 513: [function(require2, module2, exports2) {
      var isArgumentsObject = require2("is-arguments");
      var isGeneratorFunction = require2("is-generator-function");
      var whichTypedArray = require2("which-typed-array");
      var isTypedArray = require2("is-typed-array");
      function uncurryThis(f) {
        return f.call.bind(f);
      }
      var BigIntSupported = typeof BigInt !== "undefined";
      var SymbolSupported = typeof Symbol !== "undefined";
      var ObjectToString = uncurryThis(Object.prototype.toString);
      var numberValue = uncurryThis(Number.prototype.valueOf);
      var stringValue = uncurryThis(String.prototype.valueOf);
      var booleanValue = uncurryThis(Boolean.prototype.valueOf);
      if (BigIntSupported) {
        var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
      }
      if (SymbolSupported) {
        var symbolValue = uncurryThis(Symbol.prototype.valueOf);
      }
      function checkBoxedPrimitive(value, prototypeValueOf) {
        if (typeof value !== "object") {
          return false;
        }
        try {
          prototypeValueOf(value);
          return true;
        } catch (e) {
          return false;
        }
      }
      exports2.isArgumentsObject = isArgumentsObject;
      exports2.isGeneratorFunction = isGeneratorFunction;
      exports2.isTypedArray = isTypedArray;
      function isPromise(input) {
        return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
      }
      exports2.isPromise = isPromise;
      function isArrayBufferView(value) {
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          return ArrayBuffer.isView(value);
        }
        return isTypedArray(value) || isDataView(value);
      }
      exports2.isArrayBufferView = isArrayBufferView;
      function isUint8Array(value) {
        return whichTypedArray(value) === "Uint8Array";
      }
      exports2.isUint8Array = isUint8Array;
      function isUint8ClampedArray(value) {
        return whichTypedArray(value) === "Uint8ClampedArray";
      }
      exports2.isUint8ClampedArray = isUint8ClampedArray;
      function isUint16Array(value) {
        return whichTypedArray(value) === "Uint16Array";
      }
      exports2.isUint16Array = isUint16Array;
      function isUint32Array(value) {
        return whichTypedArray(value) === "Uint32Array";
      }
      exports2.isUint32Array = isUint32Array;
      function isInt8Array(value) {
        return whichTypedArray(value) === "Int8Array";
      }
      exports2.isInt8Array = isInt8Array;
      function isInt16Array(value) {
        return whichTypedArray(value) === "Int16Array";
      }
      exports2.isInt16Array = isInt16Array;
      function isInt32Array(value) {
        return whichTypedArray(value) === "Int32Array";
      }
      exports2.isInt32Array = isInt32Array;
      function isFloat32Array(value) {
        return whichTypedArray(value) === "Float32Array";
      }
      exports2.isFloat32Array = isFloat32Array;
      function isFloat64Array(value) {
        return whichTypedArray(value) === "Float64Array";
      }
      exports2.isFloat64Array = isFloat64Array;
      function isBigInt64Array(value) {
        return whichTypedArray(value) === "BigInt64Array";
      }
      exports2.isBigInt64Array = isBigInt64Array;
      function isBigUint64Array(value) {
        return whichTypedArray(value) === "BigUint64Array";
      }
      exports2.isBigUint64Array = isBigUint64Array;
      function isMapToString(value) {
        return ObjectToString(value) === "[object Map]";
      }
      isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
      function isMap(value) {
        if (typeof Map === "undefined") {
          return false;
        }
        return isMapToString.working ? isMapToString(value) : value instanceof Map;
      }
      exports2.isMap = isMap;
      function isSetToString(value) {
        return ObjectToString(value) === "[object Set]";
      }
      isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
      function isSet(value) {
        if (typeof Set === "undefined") {
          return false;
        }
        return isSetToString.working ? isSetToString(value) : value instanceof Set;
      }
      exports2.isSet = isSet;
      function isWeakMapToString(value) {
        return ObjectToString(value) === "[object WeakMap]";
      }
      isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
      function isWeakMap(value) {
        if (typeof WeakMap === "undefined") {
          return false;
        }
        return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
      }
      exports2.isWeakMap = isWeakMap;
      function isWeakSetToString(value) {
        return ObjectToString(value) === "[object WeakSet]";
      }
      isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
      function isWeakSet(value) {
        return isWeakSetToString(value);
      }
      exports2.isWeakSet = isWeakSet;
      function isArrayBufferToString(value) {
        return ObjectToString(value) === "[object ArrayBuffer]";
      }
      isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
      function isArrayBuffer(value) {
        if (typeof ArrayBuffer === "undefined") {
          return false;
        }
        return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
      }
      exports2.isArrayBuffer = isArrayBuffer;
      function isDataViewToString(value) {
        return ObjectToString(value) === "[object DataView]";
      }
      isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
      function isDataView(value) {
        if (typeof DataView === "undefined") {
          return false;
        }
        return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
      }
      exports2.isDataView = isDataView;
      function isSharedArrayBufferToString(value) {
        return ObjectToString(value) === "[object SharedArrayBuffer]";
      }
      isSharedArrayBufferToString.working = typeof SharedArrayBuffer !== "undefined" && isSharedArrayBufferToString(new SharedArrayBuffer());
      function isSharedArrayBuffer(value) {
        if (typeof SharedArrayBuffer === "undefined") {
          return false;
        }
        return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBuffer;
      }
      exports2.isSharedArrayBuffer = isSharedArrayBuffer;
      function isAsyncFunction(value) {
        return ObjectToString(value) === "[object AsyncFunction]";
      }
      exports2.isAsyncFunction = isAsyncFunction;
      function isMapIterator(value) {
        return ObjectToString(value) === "[object Map Iterator]";
      }
      exports2.isMapIterator = isMapIterator;
      function isSetIterator(value) {
        return ObjectToString(value) === "[object Set Iterator]";
      }
      exports2.isSetIterator = isSetIterator;
      function isGeneratorObject(value) {
        return ObjectToString(value) === "[object Generator]";
      }
      exports2.isGeneratorObject = isGeneratorObject;
      function isWebAssemblyCompiledModule(value) {
        return ObjectToString(value) === "[object WebAssembly.Module]";
      }
      exports2.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
      function isNumberObject(value) {
        return checkBoxedPrimitive(value, numberValue);
      }
      exports2.isNumberObject = isNumberObject;
      function isStringObject(value) {
        return checkBoxedPrimitive(value, stringValue);
      }
      exports2.isStringObject = isStringObject;
      function isBooleanObject(value) {
        return checkBoxedPrimitive(value, booleanValue);
      }
      exports2.isBooleanObject = isBooleanObject;
      function isBigIntObject(value) {
        return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
      }
      exports2.isBigIntObject = isBigIntObject;
      function isSymbolObject(value) {
        return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
      }
      exports2.isSymbolObject = isSymbolObject;
      function isBoxedPrimitive(value) {
        return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
      }
      exports2.isBoxedPrimitive = isBoxedPrimitive;
      function isAnyArrayBuffer(value) {
        return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
      }
      exports2.isAnyArrayBuffer = isAnyArrayBuffer;
      ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
        Object.defineProperty(exports2, method, {
          enumerable: false,
          value: function value() {
            throw new Error(method + " is not supported in userland");
          }
        });
      });
    }, { "is-arguments": 258, "is-generator-function": 260, "is-typed-array": 262, "which-typed-array": 533 }], 514: [function(require2, module2, exports2) {
      (function(process) {
        (function() {
          var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
            var keys = Object.keys(obj);
            var descriptors = {};
            for (var i = 0; i < keys.length; i++) {
              descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
            }
            return descriptors;
          };
          var formatRegExp = /%[sdj%]/g;
          exports2.format = function(f) {
            if (!isString(f)) {
              var objects = [];
              for (var i = 0; i < arguments.length; i++) {
                objects.push(inspect(arguments[i]));
              }
              return objects.join(" ");
            }
            var i = 1;
            var args = arguments;
            var len = args.length;
            var str = String(f).replace(formatRegExp, function(x2) {
              if (x2 === "%%")
                return "%";
              if (i >= len)
                return x2;
              switch (x2) {
                case "%s":
                  return String(args[i++]);
                case "%d":
                  return Number(args[i++]);
                case "%j":
                  try {
                    return JSON.stringify(args[i++]);
                  } catch (_) {
                    return "[Circular]";
                  }
                default:
                  return x2;
              }
            });
            for (var x = args[i]; i < len; x = args[++i]) {
              if (isNull(x) || !isObject(x)) {
                str += " " + x;
              } else {
                str += " " + inspect(x);
              }
            }
            return str;
          };
          exports2.deprecate = function(fn, msg) {
            if (typeof process !== "undefined" && process.noDeprecation === true) {
              return fn;
            }
            if (typeof process === "undefined") {
              return function() {
                return exports2.deprecate(fn, msg).apply(this, arguments);
              };
            }
            var warned = false;
            function deprecated() {
              if (!warned) {
                if (process.throwDeprecation) {
                  throw new Error(msg);
                } else if (process.traceDeprecation) {
                  console.trace(msg);
                } else {
                  console.error(msg);
                }
                warned = true;
              }
              return fn.apply(this, arguments);
            }
            return deprecated;
          };
          var debugs = {};
          var debugEnvRegex = /^$/;
          if (process.env.NODE_DEBUG) {
            var debugEnv = process.env.NODE_DEBUG;
            debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
            debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
          }
          exports2.debuglog = function(set) {
            set = set.toUpperCase();
            if (!debugs[set]) {
              if (debugEnvRegex.test(set)) {
                var pid = process.pid;
                debugs[set] = function() {
                  var msg = exports2.format.apply(exports2, arguments);
                  console.error("%s %d: %s", set, pid, msg);
                };
              } else {
                debugs[set] = function() {
                };
              }
            }
            return debugs[set];
          };
          function inspect(obj, opts) {
            var ctx = {
              seen: [],
              stylize: stylizeNoColor
            };
            if (arguments.length >= 3)
              ctx.depth = arguments[2];
            if (arguments.length >= 4)
              ctx.colors = arguments[3];
            if (isBoolean(opts)) {
              ctx.showHidden = opts;
            } else if (opts) {
              exports2._extend(ctx, opts);
            }
            if (isUndefined(ctx.showHidden))
              ctx.showHidden = false;
            if (isUndefined(ctx.depth))
              ctx.depth = 2;
            if (isUndefined(ctx.colors))
              ctx.colors = false;
            if (isUndefined(ctx.customInspect))
              ctx.customInspect = true;
            if (ctx.colors)
              ctx.stylize = stylizeWithColor;
            return formatValue(ctx, obj, ctx.depth);
          }
          exports2.inspect = inspect;
          inspect.colors = {
            "bold": [1, 22],
            "italic": [3, 23],
            "underline": [4, 24],
            "inverse": [7, 27],
            "white": [37, 39],
            "grey": [90, 39],
            "black": [30, 39],
            "blue": [34, 39],
            "cyan": [36, 39],
            "green": [32, 39],
            "magenta": [35, 39],
            "red": [31, 39],
            "yellow": [33, 39]
          };
          inspect.styles = {
            "special": "cyan",
            "number": "yellow",
            "boolean": "yellow",
            "undefined": "grey",
            "null": "bold",
            "string": "green",
            "date": "magenta",
            "regexp": "red"
          };
          function stylizeWithColor(str, styleType) {
            var style = inspect.styles[styleType];
            if (style) {
              return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
            } else {
              return str;
            }
          }
          function stylizeNoColor(str, styleType) {
            return str;
          }
          function arrayToHash(array) {
            var hash = {};
            array.forEach(function(val, idx) {
              hash[val] = true;
            });
            return hash;
          }
          function formatValue(ctx, value, recurseTimes) {
            if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports2.inspect && !(value.constructor && value.constructor.prototype === value)) {
              var ret = value.inspect(recurseTimes, ctx);
              if (!isString(ret)) {
                ret = formatValue(ctx, ret, recurseTimes);
              }
              return ret;
            }
            var primitive = formatPrimitive(ctx, value);
            if (primitive) {
              return primitive;
            }
            var keys = Object.keys(value);
            var visibleKeys = arrayToHash(keys);
            if (ctx.showHidden) {
              keys = Object.getOwnPropertyNames(value);
            }
            if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
              return formatError(value);
            }
            if (keys.length === 0) {
              if (isFunction(value)) {
                var name = value.name ? ": " + value.name : "";
                return ctx.stylize("[Function" + name + "]", "special");
              }
              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
              }
              if (isDate(value)) {
                return ctx.stylize(Date.prototype.toString.call(value), "date");
              }
              if (isError(value)) {
                return formatError(value);
              }
            }
            var base = "", array = false, braces = ["{", "}"];
            if (isArray(value)) {
              array = true;
              braces = ["[", "]"];
            }
            if (isFunction(value)) {
              var n = value.name ? ": " + value.name : "";
              base = " [Function" + n + "]";
            }
            if (isRegExp(value)) {
              base = " " + RegExp.prototype.toString.call(value);
            }
            if (isDate(value)) {
              base = " " + Date.prototype.toUTCString.call(value);
            }
            if (isError(value)) {
              base = " " + formatError(value);
            }
            if (keys.length === 0 && (!array || value.length == 0)) {
              return braces[0] + base + braces[1];
            }
            if (recurseTimes < 0) {
              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
              } else {
                return ctx.stylize("[Object]", "special");
              }
            }
            ctx.seen.push(value);
            var output;
            if (array) {
              output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
            } else {
              output = keys.map(function(key) {
                return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
              });
            }
            ctx.seen.pop();
            return reduceToSingleString(output, base, braces);
          }
          function formatPrimitive(ctx, value) {
            if (isUndefined(value))
              return ctx.stylize("undefined", "undefined");
            if (isString(value)) {
              var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return ctx.stylize(simple, "string");
            }
            if (isNumber(value))
              return ctx.stylize("" + value, "number");
            if (isBoolean(value))
              return ctx.stylize("" + value, "boolean");
            if (isNull(value))
              return ctx.stylize("null", "null");
          }
          function formatError(value) {
            return "[" + Error.prototype.toString.call(value) + "]";
          }
          function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
            var output = [];
            for (var i = 0, l = value.length; i < l; ++i) {
              if (hasOwnProperty(value, String(i))) {
                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
              } else {
                output.push("");
              }
            }
            keys.forEach(function(key) {
              if (!key.match(/^\d+$/)) {
                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
              }
            });
            return output;
          }
          function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
            var name, str, desc;
            desc = Object.getOwnPropertyDescriptor(value, key) || {
              value: value[key]
            };
            if (desc.get) {
              if (desc.set) {
                str = ctx.stylize("[Getter/Setter]", "special");
              } else {
                str = ctx.stylize("[Getter]", "special");
              }
            } else {
              if (desc.set) {
                str = ctx.stylize("[Setter]", "special");
              }
            }
            if (!hasOwnProperty(visibleKeys, key)) {
              name = "[" + key + "]";
            }
            if (!str) {
              if (ctx.seen.indexOf(desc.value) < 0) {
                if (isNull(recurseTimes)) {
                  str = formatValue(ctx, desc.value, null);
                } else {
                  str = formatValue(ctx, desc.value, recurseTimes - 1);
                }
                if (str.indexOf("\n") > -1) {
                  if (array) {
                    str = str.split("\n").map(function(line) {
                      return "  " + line;
                    }).join("\n").substr(2);
                  } else {
                    str = "\n" + str.split("\n").map(function(line) {
                      return "   " + line;
                    }).join("\n");
                  }
                }
              } else {
                str = ctx.stylize("[Circular]", "special");
              }
            }
            if (isUndefined(name)) {
              if (array && key.match(/^\d+$/)) {
                return str;
              }
              name = JSON.stringify("" + key);
              if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                name = name.substr(1, name.length - 2);
                name = ctx.stylize(name, "name");
              } else {
                name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                name = ctx.stylize(name, "string");
              }
            }
            return name + ": " + str;
          }
          function reduceToSingleString(output, base, braces) {
            var length = output.reduce(function(prev, cur) {
              if (cur.indexOf("\n") >= 0)
                ;
              return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0);
            if (length > 60) {
              return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
            }
            return braces[0] + base + " " + output.join(", ") + " " + braces[1];
          }
          exports2.types = require2("./support/types");
          function isArray(ar) {
            return Array.isArray(ar);
          }
          exports2.isArray = isArray;
          function isBoolean(arg) {
            return typeof arg === "boolean";
          }
          exports2.isBoolean = isBoolean;
          function isNull(arg) {
            return arg === null;
          }
          exports2.isNull = isNull;
          function isNullOrUndefined(arg) {
            return arg == null;
          }
          exports2.isNullOrUndefined = isNullOrUndefined;
          function isNumber(arg) {
            return typeof arg === "number";
          }
          exports2.isNumber = isNumber;
          function isString(arg) {
            return typeof arg === "string";
          }
          exports2.isString = isString;
          function isSymbol(arg) {
            return typeof arg === "symbol";
          }
          exports2.isSymbol = isSymbol;
          function isUndefined(arg) {
            return arg === void 0;
          }
          exports2.isUndefined = isUndefined;
          function isRegExp(re) {
            return isObject(re) && objectToString(re) === "[object RegExp]";
          }
          exports2.isRegExp = isRegExp;
          exports2.types.isRegExp = isRegExp;
          function isObject(arg) {
            return typeof arg === "object" && arg !== null;
          }
          exports2.isObject = isObject;
          function isDate(d) {
            return isObject(d) && objectToString(d) === "[object Date]";
          }
          exports2.isDate = isDate;
          exports2.types.isDate = isDate;
          function isError(e) {
            return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
          }
          exports2.isError = isError;
          exports2.types.isNativeError = isError;
          function isFunction(arg) {
            return typeof arg === "function";
          }
          exports2.isFunction = isFunction;
          function isPrimitive(arg) {
            return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
          }
          exports2.isPrimitive = isPrimitive;
          exports2.isBuffer = require2("./support/isBuffer");
          function objectToString(o) {
            return Object.prototype.toString.call(o);
          }
          function pad(n) {
            return n < 10 ? "0" + n.toString(10) : n.toString(10);
          }
          var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
          function timestamp() {
            var d = new Date();
            var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(":");
            return [d.getDate(), months[d.getMonth()], time].join(" ");
          }
          exports2.log = function() {
            console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
          };
          exports2.inherits = require2("inherits");
          exports2._extend = function(origin, add) {
            if (!add || !isObject(add))
              return origin;
            var keys = Object.keys(add);
            var i = keys.length;
            while (i--) {
              origin[keys[i]] = add[keys[i]];
            }
            return origin;
          };
          function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          }
          var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
          exports2.promisify = function promisify(original) {
            if (typeof original !== "function")
              throw new TypeError('The "original" argument must be of type Function');
            if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
              var fn = original[kCustomPromisifiedSymbol];
              if (typeof fn !== "function") {
                throw new TypeError('The "util.promisify.custom" argument must be of type Function');
              }
              Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                value: fn,
                enumerable: false,
                writable: false,
                configurable: true
              });
              return fn;
            }
            function fn() {
              var promiseResolve, promiseReject;
              var promise = new Promise(function(resolve, reject) {
                promiseResolve = resolve;
                promiseReject = reject;
              });
              var args = [];
              for (var i = 0; i < arguments.length; i++) {
                args.push(arguments[i]);
              }
              args.push(function(err, value) {
                if (err) {
                  promiseReject(err);
                } else {
                  promiseResolve(value);
                }
              });
              try {
                original.apply(this, args);
              } catch (err) {
                promiseReject(err);
              }
              return promise;
            }
            Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
            if (kCustomPromisifiedSymbol)
              Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                value: fn,
                enumerable: false,
                writable: false,
                configurable: true
              });
            return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
          };
          exports2.promisify.custom = kCustomPromisifiedSymbol;
          function callbackifyOnRejected(reason, cb) {
            if (!reason) {
              var newReason = new Error("Promise was rejected with a falsy value");
              newReason.reason = reason;
              reason = newReason;
            }
            return cb(reason);
          }
          function callbackify(original) {
            if (typeof original !== "function") {
              throw new TypeError('The "original" argument must be of type Function');
            }
            function callbackified() {
              var args = [];
              for (var i = 0; i < arguments.length; i++) {
                args.push(arguments[i]);
              }
              var maybeCb = args.pop();
              if (typeof maybeCb !== "function") {
                throw new TypeError("The last argument must be of type Function");
              }
              var self2 = this;
              var cb = function cb2() {
                return maybeCb.apply(self2, arguments);
              };
              original.apply(this, args).then(function(ret) {
                process.nextTick(cb.bind(null, null, ret));
              }, function(rej) {
                process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
              });
            }
            Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
            Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
            return callbackified;
          }
          exports2.callbackify = callbackify;
        }).call(this);
      }).call(this, require2("_process"));
    }, { "./support/isBuffer": 512, "./support/types": 513, "_process": 361, "inherits": 256 }], 515: [function(require2, module2, exports2) {
      arguments[4][364][0].apply(exports2, arguments);
    }, { "dup": 364 }], 516: [function(require2, module2, exports2) {
      arguments[4][42][0].apply(exports2, arguments);
    }, { "dup": 42 }], 517: [function(require2, module2, exports2) {
      arguments[4][43][0].apply(exports2, arguments);
    }, { "./decode.js": 515, "./encode.js": 516, "./length.js": 518, "dup": 43 }], 518: [function(require2, module2, exports2) {
      arguments[4][44][0].apply(exports2, arguments);
    }, { "dup": 44 }], 519: [function(require2, module2, exports2) {
      arguments[4][97][0].apply(exports2, arguments);
    }, { "./_stream_readable": 521, "./_stream_writable": 523, "core-util-is": 108, "dup": 97, "inherits": 256, "process-nextick-args": 360 }], 520: [function(require2, module2, exports2) {
      arguments[4][98][0].apply(exports2, arguments);
    }, { "./_stream_transform": 522, "core-util-is": 108, "dup": 98, "inherits": 256 }], 521: [function(require2, module2, exports2) {
      arguments[4][99][0].apply(exports2, arguments);
    }, { "../../../../util/util.js": 514, "./_stream_duplex": 519, "./internal/streams/BufferList": 524, "./internal/streams/destroy": 525, "./internal/streams/stream": 526, "_process": 361, "core-util-is": 108, "dup": 99, "events": 193, "inherits": 256, "isarray": 263, "process-nextick-args": 360, "safe-buffer": 527, "string_decoder/": 529 }], 522: [function(require2, module2, exports2) {
      arguments[4][100][0].apply(exports2, arguments);
    }, { "./_stream_duplex": 519, "core-util-is": 108, "dup": 100, "inherits": 256 }], 523: [function(require2, module2, exports2) {
      arguments[4][101][0].apply(exports2, arguments);
    }, { "./_stream_duplex": 519, "./internal/streams/destroy": 525, "./internal/streams/stream": 526, "_process": 361, "core-util-is": 108, "dup": 101, "inherits": 256, "process-nextick-args": 360, "safe-buffer": 527, "timers": 506, "util-deprecate": 511 }], 524: [function(require2, module2, exports2) {
      arguments[4][102][0].apply(exports2, arguments);
    }, { "../../../../../../util/util.js": 514, "dup": 102, "safe-buffer": 527 }], 525: [function(require2, module2, exports2) {
      arguments[4][103][0].apply(exports2, arguments);
    }, { "dup": 103, "process-nextick-args": 360 }], 526: [function(require2, module2, exports2) {
      arguments[4][104][0].apply(exports2, arguments);
    }, { "dup": 104, "events": 193 }], 527: [function(require2, module2, exports2) {
      arguments[4][106][0].apply(exports2, arguments);
    }, { "buffer": 82, "dup": 106 }], 528: [function(require2, module2, exports2) {
      arguments[4][105][0].apply(exports2, arguments);
    }, { "./lib/_stream_duplex.js": 519, "./lib/_stream_passthrough.js": 520, "./lib/_stream_readable.js": 521, "./lib/_stream_transform.js": 522, "./lib/_stream_writable.js": 523, "dup": 105 }], 529: [function(require2, module2, exports2) {
      arguments[4][107][0].apply(exports2, arguments);
    }, { "dup": 107, "safe-buffer": 530 }], 530: [function(require2, module2, exports2) {
      arguments[4][106][0].apply(exports2, arguments);
    }, { "buffer": 82, "dup": 106 }], 531: [function(require2, module2, exports2) {
      (function(process, global) {
        (function() {
          var Transform = require2("readable-stream").Transform;
          var duplexify = require2("duplexify");
          var WS = require2("ws");
          var Buffer = require2("safe-buffer").Buffer;
          module2.exports = WebSocketStream;
          function buildProxy(options, socketWrite, socketEnd) {
            var proxy = new Transform({
              objectMode: options.objectMode
            });
            proxy._write = socketWrite;
            proxy._flush = socketEnd;
            return proxy;
          }
          function WebSocketStream(target, protocols, options) {
            var stream, socket;
            var isBrowser = process.title === "browser";
            var isNative = !!global.WebSocket;
            var socketWrite = isBrowser ? socketWriteBrowser : socketWriteNode;
            if (protocols && !Array.isArray(protocols) && "object" === typeof protocols) {
              options = protocols;
              protocols = null;
              if (typeof options.protocol === "string" || Array.isArray(options.protocol)) {
                protocols = options.protocol;
              }
            }
            if (!options)
              options = {};
            if (options.objectMode === void 0) {
              options.objectMode = !(options.binary === true || options.binary === void 0);
            }
            var proxy = buildProxy(options, socketWrite, socketEnd);
            if (!options.objectMode) {
              proxy._writev = writev;
            }
            var bufferSize = options.browserBufferSize || 1024 * 512;
            var bufferTimeout = options.browserBufferTimeout || 1e3;
            if (typeof target === "object") {
              socket = target;
            } else {
              if (isNative && isBrowser) {
                socket = new WS(target, protocols);
              } else {
                socket = new WS(target, protocols, options);
              }
              socket.binaryType = "arraybuffer";
            }
            var eventListenerSupport = "undefined" === typeof socket.addEventListener;
            if (socket.readyState === socket.OPEN) {
              stream = proxy;
            } else {
              stream = stream = duplexify(void 0, void 0, options);
              if (!options.objectMode) {
                stream._writev = writev;
              }
              if (eventListenerSupport) {
                socket.addEventListener("open", onopen);
              } else {
                socket.onopen = onopen;
              }
            }
            stream.socket = socket;
            if (eventListenerSupport) {
              socket.addEventListener("close", onclose);
              socket.addEventListener("error", onerror);
              socket.addEventListener("message", onmessage);
            } else {
              socket.onclose = onclose;
              socket.onerror = onerror;
              socket.onmessage = onmessage;
            }
            proxy.on("close", destroy);
            var coerceToBuffer = !options.objectMode;
            function socketWriteNode(chunk, enc, next) {
              if (socket.readyState !== socket.OPEN) {
                next();
                return;
              }
              if (coerceToBuffer && typeof chunk === "string") {
                chunk = Buffer.from(chunk, "utf8");
              }
              socket.send(chunk, next);
            }
            function socketWriteBrowser(chunk, enc, next) {
              if (socket.bufferedAmount > bufferSize) {
                setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next);
                return;
              }
              if (coerceToBuffer && typeof chunk === "string") {
                chunk = Buffer.from(chunk, "utf8");
              }
              try {
                socket.send(chunk);
              } catch (err) {
                return next(err);
              }
              next();
            }
            function socketEnd(done) {
              socket.close();
              done();
            }
            function onopen() {
              stream.setReadable(proxy);
              stream.setWritable(proxy);
              stream.emit("connect");
            }
            function onclose() {
              stream.end();
              stream.destroy();
            }
            function onerror(err) {
              stream.destroy(err);
            }
            function onmessage(event) {
              var data = event.data;
              if (data instanceof ArrayBuffer)
                data = Buffer.from(data);
              else
                data = Buffer.from(data, "utf8");
              proxy.push(data);
            }
            function destroy() {
              socket.close();
            }
            function writev(chunks, cb) {
              var buffers = new Array(chunks.length);
              for (var i = 0; i < chunks.length; i++) {
                if (typeof chunks[i].chunk === "string") {
                  buffers[i] = Buffer.from(chunks[i], "utf8");
                } else {
                  buffers[i] = chunks[i].chunk;
                }
              }
              this._write(Buffer.concat(buffers), "binary", cb);
            }
            return stream;
          }
        }).call(this);
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "_process": 361, "duplexify": 143, "readable-stream": 528, "safe-buffer": 417, "ws": 532 }], 532: [function(require2, module2, exports2) {
      var ws = null;
      if (typeof WebSocket !== "undefined") {
        ws = WebSocket;
      } else if (typeof MozWebSocket !== "undefined") {
        ws = MozWebSocket;
      } else if (typeof window !== "undefined") {
        ws = window.WebSocket || window.MozWebSocket;
      }
      module2.exports = ws;
    }, {}], 533: [function(require2, module2, exports2) {
      (function(global) {
        (function() {
          var forEach = require2("foreach");
          var availableTypedArrays = require2("available-typed-arrays");
          var callBound = require2("call-bind/callBound");
          var $toString = callBound("Object.prototype.toString");
          var hasSymbols = require2("has-symbols")();
          var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === "symbol";
          var typedArrays = availableTypedArrays();
          var $slice = callBound("String.prototype.slice");
          var toStrTags = {};
          var gOPD = require2("es-abstract/helpers/getOwnPropertyDescriptor");
          var getPrototypeOf = Object.getPrototypeOf;
          if (hasToStringTag && gOPD && getPrototypeOf) {
            forEach(typedArrays, function(typedArray) {
              if (typeof global[typedArray] === "function") {
                var arr = new global[typedArray]();
                if (!(Symbol.toStringTag in arr)) {
                  throw new EvalError("this engine has support for Symbol.toStringTag, but " + typedArray + " does not have the property! Please report this.");
                }
                var proto = getPrototypeOf(arr);
                var descriptor = gOPD(proto, Symbol.toStringTag);
                if (!descriptor) {
                  var superProto = getPrototypeOf(proto);
                  descriptor = gOPD(superProto, Symbol.toStringTag);
                }
                toStrTags[typedArray] = descriptor.get;
              }
            });
          }
          var tryTypedArrays = function tryAllTypedArrays(value) {
            var foundName = false;
            forEach(toStrTags, function(getter, typedArray) {
              if (!foundName) {
                try {
                  var name = getter.call(value);
                  if (name === typedArray) {
                    foundName = name;
                  }
                } catch (e) {
                }
              }
            });
            return foundName;
          };
          var isTypedArray = require2("is-typed-array");
          module2.exports = function whichTypedArray(value) {
            if (!isTypedArray(value)) {
              return false;
            }
            if (!hasToStringTag) {
              return $slice($toString(value), 8, -1);
            }
            return tryTypedArrays(value);
          };
        }).call(this);
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "available-typed-arrays": 38, "call-bind/callBound": 88, "es-abstract/helpers/getOwnPropertyDescriptor": 191, "foreach": 201, "has-symbols": 207, "is-typed-array": 262 }], 534: [function(require2, module2, exports2) {
      module2.exports = wrappy;
      function wrappy(fn, cb) {
        if (fn && cb)
          return wrappy(fn)(cb);
        if (typeof fn !== "function")
          throw new TypeError("need wrapper function");
        Object.keys(fn).forEach(function(k) {
          wrapper[k] = fn[k];
        });
        return wrapper;
        function wrapper() {
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i];
          }
          var ret = fn.apply(this, args);
          var cb2 = args[args.length - 1];
          if (typeof ret === "function" && ret !== cb2) {
            Object.keys(cb2).forEach(function(k) {
              ret[k] = cb2[k];
            });
          }
          return ret;
        }
      }
    }, {}], 535: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          module2.exports = dist;
          function dist(a, b) {
            if (a.length !== b.length)
              throw new Error("Inputs should have the same length");
            var result = Buffer.allocUnsafe(a.length);
            for (var i = 0; i < a.length; i++) {
              result[i] = a[i] ^ b[i];
            }
            return result;
          }
          dist.compare = function compare(a, b) {
            if (a.length !== b.length)
              throw new Error("Inputs should have the same length");
            for (var i = 0; i < a.length; i++) {
              if (a[i] === b[i])
                continue;
              return a[i] < b[i] ? -1 : 1;
            }
            return 0;
          };
          dist.gt = function gt(a, b) {
            return dist.compare(a, b) === 1;
          };
          dist.lt = function lt(a, b) {
            return dist.compare(a, b) === -1;
          };
          dist.eq = function eq(a, b) {
            return dist.compare(a, b) === 0;
          };
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82 }], 536: [function(require2, module2, exports2) {
      var xsalsa20 = require2("xsalsa20");
      module2.exports = class XORJS {
        constructor(nonce, key) {
          this.instance = xsalsa20(nonce, key);
        }
        update(out, message) {
          this.instance.update(message, out);
        }
        final() {
          this.instance.finalize();
        }
      };
    }, { "xsalsa20": 537 }], 537: [function(require2, module2, exports2) {
      var xsalsa20 = require2("./xsalsa20")();
      var SIGMA = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      var head = 144;
      var top = head;
      var free = [];
      module2.exports = XSalsa20;
      XSalsa20.NONCEBYTES = 24;
      XSalsa20.KEYBYTES = 32;
      XSalsa20.core_hsalsa20 = core_hsalsa20;
      XSalsa20.SIGMA = SIGMA;
      function XSalsa20(nonce, key) {
        if (!(this instanceof XSalsa20))
          return new XSalsa20(nonce, key);
        if (!nonce || nonce.length < 24)
          throw new Error("nonce must be at least 24 bytes");
        if (!key || key.length < 32)
          throw new Error("key must be at least 32 bytes");
        this._xor = xsalsa20 && xsalsa20.exports ? new WASM(nonce, key) : new Fallback(nonce, key);
      }
      XSalsa20.prototype.update = function(input, output) {
        if (!input)
          throw new Error("input must be Uint8Array or Buffer");
        if (!output)
          output = new Uint8Array(input.length);
        if (input.length)
          this._xor.update(input, output);
        return output;
      };
      XSalsa20.prototype.final = XSalsa20.prototype.finalize = function() {
        this._xor.finalize();
        this._xor = null;
      };
      function WASM(nonce, key) {
        if (!free.length) {
          free.push(head);
          head += 64;
        }
        this._pointer = free.pop();
        this._nonce = this._pointer + 8;
        this._key = this._nonce + 24;
        this._overflow = 0;
        xsalsa20.memory.fill(0, this._pointer, this._pointer + 8);
        xsalsa20.memory.set(nonce, this._nonce);
        xsalsa20.memory.set(key, this._key);
      }
      WASM.prototype.update = function(input, output) {
        var len = this._overflow + input.length;
        var start = head + this._overflow;
        top = head + len;
        if (top >= xsalsa20.memory.length)
          xsalsa20.realloc(top);
        xsalsa20.memory.set(input, start);
        xsalsa20.exports.xsalsa20_xor(this._pointer, head, head, len, this._nonce, this._key);
        output.set(xsalsa20.memory.subarray(start, head + len));
        this._overflow = len & 63;
      };
      WASM.prototype.finalize = function() {
        xsalsa20.memory.fill(0, this._pointer, this._key + 32);
        if (top > head) {
          xsalsa20.memory.fill(0, head, top);
          top = 0;
        }
        free.push(this._pointer);
      };
      function Fallback(nonce, key) {
        this._s = new Uint8Array(32);
        this._z = new Uint8Array(16);
        this._overflow = 0;
        core_hsalsa20(this._s, nonce, key, SIGMA);
        for (var i = 0; i < 8; i++) {
          this._z[i] = nonce[i + 16];
        }
      }
      Fallback.prototype.update = function(input, output) {
        var x = new Uint8Array(64);
        var u = 0;
        var i = this._overflow;
        var b = input.length + this._overflow;
        var z = this._z;
        var mpos = -this._overflow;
        var cpos = -this._overflow;
        while (b >= 64) {
          core_salsa20(x, z, this._s, SIGMA);
          for (; i < 64; i++) {
            output[cpos + i] = input[mpos + i] ^ x[i];
          }
          u = 1;
          for (i = 8; i < 16; i++) {
            u += z[i] & 255 | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
          i = 0;
        }
        if (b > 0) {
          core_salsa20(x, z, this._s, SIGMA);
          for (; i < b; i++) {
            output[cpos + i] = input[mpos + i] ^ x[i];
          }
        }
        this._overflow = b & 63;
      };
      Fallback.prototype.finalize = function() {
        this._s.fill(0);
        this._z.fill(0);
      };
      function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 25;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 23;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 19;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 14;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 25;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 23;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 19;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 14;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 25;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 23;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 19;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 14;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 25;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 23;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 19;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 14;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 25;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 23;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 19;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 14;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 25;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 23;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 19;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 14;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 25;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 23;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 19;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 14;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 25;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 23;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 19;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 14;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x1 >>> 0 & 255;
        o[5] = x1 >>> 8 & 255;
        o[6] = x1 >>> 16 & 255;
        o[7] = x1 >>> 24 & 255;
        o[8] = x2 >>> 0 & 255;
        o[9] = x2 >>> 8 & 255;
        o[10] = x2 >>> 16 & 255;
        o[11] = x2 >>> 24 & 255;
        o[12] = x3 >>> 0 & 255;
        o[13] = x3 >>> 8 & 255;
        o[14] = x3 >>> 16 & 255;
        o[15] = x3 >>> 24 & 255;
        o[16] = x4 >>> 0 & 255;
        o[17] = x4 >>> 8 & 255;
        o[18] = x4 >>> 16 & 255;
        o[19] = x4 >>> 24 & 255;
        o[20] = x5 >>> 0 & 255;
        o[21] = x5 >>> 8 & 255;
        o[22] = x5 >>> 16 & 255;
        o[23] = x5 >>> 24 & 255;
        o[24] = x6 >>> 0 & 255;
        o[25] = x6 >>> 8 & 255;
        o[26] = x6 >>> 16 & 255;
        o[27] = x6 >>> 24 & 255;
        o[28] = x7 >>> 0 & 255;
        o[29] = x7 >>> 8 & 255;
        o[30] = x7 >>> 16 & 255;
        o[31] = x7 >>> 24 & 255;
        o[32] = x8 >>> 0 & 255;
        o[33] = x8 >>> 8 & 255;
        o[34] = x8 >>> 16 & 255;
        o[35] = x8 >>> 24 & 255;
        o[36] = x9 >>> 0 & 255;
        o[37] = x9 >>> 8 & 255;
        o[38] = x9 >>> 16 & 255;
        o[39] = x9 >>> 24 & 255;
        o[40] = x10 >>> 0 & 255;
        o[41] = x10 >>> 8 & 255;
        o[42] = x10 >>> 16 & 255;
        o[43] = x10 >>> 24 & 255;
        o[44] = x11 >>> 0 & 255;
        o[45] = x11 >>> 8 & 255;
        o[46] = x11 >>> 16 & 255;
        o[47] = x11 >>> 24 & 255;
        o[48] = x12 >>> 0 & 255;
        o[49] = x12 >>> 8 & 255;
        o[50] = x12 >>> 16 & 255;
        o[51] = x12 >>> 24 & 255;
        o[52] = x13 >>> 0 & 255;
        o[53] = x13 >>> 8 & 255;
        o[54] = x13 >>> 16 & 255;
        o[55] = x13 >>> 24 & 255;
        o[56] = x14 >>> 0 & 255;
        o[57] = x14 >>> 8 & 255;
        o[58] = x14 >>> 16 & 255;
        o[59] = x14 >>> 24 & 255;
        o[60] = x15 >>> 0 & 255;
        o[61] = x15 >>> 8 & 255;
        o[62] = x15 >>> 16 & 255;
        o[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 25;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 23;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 19;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 14;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 25;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 23;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 19;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 14;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 25;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 23;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 19;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 14;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 25;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 23;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 19;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 14;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 25;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 23;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 19;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 14;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 25;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 23;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 19;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 14;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 25;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 23;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 19;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 14;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 25;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 23;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 19;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 14;
        }
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x5 >>> 0 & 255;
        o[5] = x5 >>> 8 & 255;
        o[6] = x5 >>> 16 & 255;
        o[7] = x5 >>> 24 & 255;
        o[8] = x10 >>> 0 & 255;
        o[9] = x10 >>> 8 & 255;
        o[10] = x10 >>> 16 & 255;
        o[11] = x10 >>> 24 & 255;
        o[12] = x15 >>> 0 & 255;
        o[13] = x15 >>> 8 & 255;
        o[14] = x15 >>> 16 & 255;
        o[15] = x15 >>> 24 & 255;
        o[16] = x6 >>> 0 & 255;
        o[17] = x6 >>> 8 & 255;
        o[18] = x6 >>> 16 & 255;
        o[19] = x6 >>> 24 & 255;
        o[20] = x7 >>> 0 & 255;
        o[21] = x7 >>> 8 & 255;
        o[22] = x7 >>> 16 & 255;
        o[23] = x7 >>> 24 & 255;
        o[24] = x8 >>> 0 & 255;
        o[25] = x8 >>> 8 & 255;
        o[26] = x8 >>> 16 & 255;
        o[27] = x8 >>> 24 & 255;
        o[28] = x9 >>> 0 & 255;
        o[29] = x9 >>> 8 & 255;
        o[30] = x9 >>> 16 & 255;
        o[31] = x9 >>> 24 & 255;
      }
    }, { "./xsalsa20": 538 }], 538: [function(require2, module2, exports2) {
      module2.exports = loadWebAssembly;
      loadWebAssembly.supported = typeof WebAssembly !== "undefined";
      function loadWebAssembly(opts) {
        if (!loadWebAssembly.supported)
          return null;
        var imp = opts && opts.imports;
        var wasm = toUint8Array("AGFzbQEAAAABGgNgBn9/f39/fwBgBn9/f39+fwF+YAN/f38AAwcGAAEBAgICBQUBAQroBwcoAwZtZW1vcnkCAAx4c2Fsc2EyMF94b3IAAAxjb3JlX3NhbHNhMjAABArqEQYYACAAIAEgAiADIAQgACkDACAFEAE3AwALPQBB8AAgAyAFEAMgACABIAIgA0EQaiAEQfAAEAJB8ABCADcDAEH4AEIANwMAQYABQgA3AwBBiAFCADcDAAuHBQEBfyACQQBGBEBCAA8LQdAAIAUpAwA3AwBB2AAgBUEIaikDADcDAEHgACAFQRBqKQMANwMAQegAIAVBGGopAwA3AwBBACADKQMANwMAQQggBDcDAAJAA0AgAkHAAEkNAUEQQQBB0AAQBSAAIAEpAwBBECkDAIU3AwAgAEEIaiABQQhqKQMAQRgpAwCFNwMAIABBEGogAUEQaikDAEEgKQMAhTcDACAAQRhqIAFBGGopAwBBKCkDAIU3AwAgAEEgaiABQSBqKQMAQTApAwCFNwMAIABBKGogAUEoaikDAEE4KQMAhTcDACAAQTBqIAFBMGopAwBBwAApAwCFNwMAIABBOGogAUE4aikDAEHIACkDAIU3AwBBCEEIKQMAQgF8NwMAIABBwABqIQAgAUHAAGohASACQcAAayECDAALC0EIKQMAIQQgAkEASwRAQRBBAEHQABAFAkACQAJAAkACQAJAAkACQCACQQhuDgcHBgUEAwIBAAsgAEE4aiABQThqKQMAQcgAKQMAhTcDAAsgAEEwaiABQTBqKQMAQcAAKQMAhTcDAAsgAEEoaiABQShqKQMAQTgpAwCFNwMACyAAQSBqIAFBIGopAwBBMCkDAIU3AwALIABBGGogAUEYaikDAEEoKQMAhTcDAAsgAEEQaiABQRBqKQMAQSApAwCFNwMACyAAQQhqIAFBCGopAwBBGCkDAIU3AwALIAAgASkDAEEQKQMAhTcDAAtBEEIANwMAQRhCADcDAEEgQgA3AwBBKEIANwMAQTBCADcDAEE4QgA3AwBBwABCADcDAEHIAEIANwMAQdAAQgA3AwBB2ABCADcDAEHgAEIANwMAQegAQgA3AwAgBA8LnQUBEX9B5fDBiwYhA0HuyIGZAyEIQbLaiMsHIQ1B9MqB2QYhEiACKAIAIQQgAkEEaigCACEFIAJBCGooAgAhBiACQQxqKAIAIQcgAkEQaigCACEOIAJBFGooAgAhDyACQRhqKAIAIRAgAkEcaigCACERIAEoAgAhCSABQQRqKAIAIQogAUEIaigCACELIAFBDGooAgAhDEEUIRMCQANAIBNBAEYNASAHIAMgD2pBB3dzIQcgCyAHIANqQQl3cyELIA8gCyAHakENd3MhDyADIA8gC2pBEndzIQMgDCAIIARqQQd3cyEMIBAgDCAIakEJd3MhECAEIBAgDGpBDXdzIQQgCCAEIBBqQRJ3cyEIIBEgDSAJakEHd3MhESAFIBEgDWpBCXdzIQUgCSAFIBFqQQ13cyEJIA0gCSAFakESd3MhDSAGIBIgDmpBB3dzIQYgCiAGIBJqQQl3cyEKIA4gCiAGakENd3MhDiASIA4gCmpBEndzIRIgBCADIAZqQQd3cyEEIAUgBCADakEJd3MhBSAGIAUgBGpBDXdzIQYgAyAGIAVqQRJ3cyEDIAkgCCAHakEHd3MhCSAKIAkgCGpBCXdzIQogByAKIAlqQQ13cyEHIAggByAKakESd3MhCCAOIA0gDGpBB3dzIQ4gCyAOIA1qQQl3cyELIAwgCyAOakENd3MhDCANIAwgC2pBEndzIQ0gDyASIBFqQQd3cyEPIBAgDyASakEJd3MhECARIBAgD2pBDXdzIREgEiARIBBqQRJ3cyESIBNBAmshEwwACwsgACADNgIAIABBBGogCDYCACAAQQhqIA02AgAgAEEMaiASNgIAIABBEGogCTYCACAAQRRqIAo2AgAgAEEYaiALNgIAIABBHGogDDYCAAsKACAAIAEgAhAFC90GASF/QeXwwYsGIQNB7siBmQMhCEGy2ojLByENQfTKgdkGIRIgAigCACEEIAJBBGooAgAhBSACQQhqKAIAIQYgAkEMaigCACEHIAJBEGooAgAhDiACQRRqKAIAIQ8gAkEYaigCACEQIAJBHGooAgAhESABKAIAIQkgAUEEaigCACEKIAFBCGooAgAhCyABQQxqKAIAIQwgAyETIAQhFCAFIRUgBiEWIAchFyAIIRggCSEZIAohGiALIRsgDCEcIA0hHSAOIR4gDyEfIBAhICARISEgEiEiQRQhIwJAA0AgI0EARg0BIAcgAyAPakEHd3MhByALIAcgA2pBCXdzIQsgDyALIAdqQQ13cyEPIAMgDyALakESd3MhAyAMIAggBGpBB3dzIQwgECAMIAhqQQl3cyEQIAQgECAMakENd3MhBCAIIAQgEGpBEndzIQggESANIAlqQQd3cyERIAUgESANakEJd3MhBSAJIAUgEWpBDXdzIQkgDSAJIAVqQRJ3cyENIAYgEiAOakEHd3MhBiAKIAYgEmpBCXdzIQogDiAKIAZqQQ13cyEOIBIgDiAKakESd3MhEiAEIAMgBmpBB3dzIQQgBSAEIANqQQl3cyEFIAYgBSAEakENd3MhBiADIAYgBWpBEndzIQMgCSAIIAdqQQd3cyEJIAogCSAIakEJd3MhCiAHIAogCWpBDXdzIQcgCCAHIApqQRJ3cyEIIA4gDSAMakEHd3MhDiALIA4gDWpBCXdzIQsgDCALIA5qQQ13cyEMIA0gDCALakESd3MhDSAPIBIgEWpBB3dzIQ8gECAPIBJqQQl3cyEQIBEgECAPakENd3MhESASIBEgEGpBEndzIRIgI0ECayEjDAALCyAAIAMgE2o2AgAgAEEEaiAEIBRqNgIAIABBCGogBSAVajYCACAAQQxqIAYgFmo2AgAgAEEQaiAHIBdqNgIAIABBFGogCCAYajYCACAAQRhqIAkgGWo2AgAgAEEcaiAKIBpqNgIAIABBIGogCyAbajYCACAAQSRqIAwgHGo2AgAgAEEoaiANIB1qNgIAIABBLGogDiAeajYCACAAQTBqIA8gH2o2AgAgAEE0aiAQICBqNgIAIABBOGogESAhajYCACAAQTxqIBIgImo2AgAL");
        var ready = null;
        var mod = {
          buffer: wasm,
          memory: null,
          exports: null,
          realloc,
          onload
        };
        onload(function() {
        });
        return mod;
        function realloc(size) {
          mod.exports.memory.grow(Math.ceil(Math.abs(size - mod.memory.length) / 65536));
          mod.memory = new Uint8Array(mod.exports.memory.buffer);
        }
        function onload(cb) {
          if (mod.exports)
            return cb();
          if (ready) {
            ready.then(cb.bind(null, null)).catch(cb);
            return;
          }
          try {
            if (opts && opts.async)
              throw new Error("async");
            setup({
              instance: new WebAssembly.Instance(new WebAssembly.Module(wasm), imp)
            });
          } catch (err) {
            ready = WebAssembly.instantiate(wasm, imp).then(setup);
          }
          onload(cb);
        }
        function setup(w) {
          mod.exports = w.instance.exports;
          mod.memory = mod.exports.memory && mod.exports.memory.buffer && new Uint8Array(mod.exports.memory.buffer);
        }
      }
      function toUint8Array(s) {
        if (typeof atob === "function")
          return new Uint8Array(atob(s).split("").map(charCodeAt));
        return new (require2("buffer")).Buffer(s, "base64");
      }
      function charCodeAt(c) {
        return c.charCodeAt(0);
      }
    }, {}], 539: [function(require2, module2, exports2) {
      module2.exports = extend;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }
    }, {}], 540: [function(require2, module2, exports2) {
      module2.exports = extend;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function extend(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }
    }, {}], 541: [function(require2, module2, exports2) {
      class Node {
        constructor(value) {
          this.value = value;
          this.next = void 0;
        }
      }
      class Queue {
        constructor() {
          this.clear();
        }
        enqueue(value) {
          var node = new Node(value);
          if (this._head) {
            this._tail.next = node;
            this._tail = node;
          } else {
            this._head = node;
            this._tail = node;
          }
          this._size++;
        }
        dequeue() {
          var current = this._head;
          if (!current) {
            return;
          }
          this._head = this._head.next;
          this._size--;
          return current.value;
        }
        clear() {
          this._head = void 0;
          this._tail = void 0;
          this._size = 0;
        }
        get size() {
          return this._size;
        }
        *[Symbol.iterator]() {
          var current = this._head;
          while (current) {
            yield current.value;
            current = current.next;
          }
        }
      }
      module2.exports = Queue;
    }, {}], 542: [function(require2, module2, exports2) {
      (function(process, Buffer) {
        (function() {
          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              if (enumerableOnly)
                symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
              keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              if (i % 2) {
                ownKeys(Object(source), true).forEach(function(key) {
                  _defineProperty(target, key, source[key]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys(Object(source)).forEach(function(key) {
                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
              }
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
            try {
              var info = gen[key](arg);
              var value = info.value;
            } catch (error) {
              reject(error);
              return;
            }
            if (info.done) {
              resolve(value);
            } else {
              Promise.resolve(value).then(_next, _throw);
            }
          }
          function _asyncToGenerator(fn) {
            return function() {
              var self2 = this, args = arguments;
              return new Promise(function(resolve, reject) {
                var gen = fn.apply(self2, args);
                function _next(value) {
                  asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
                }
                function _throw(err) {
                  asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
                }
                _next(void 0);
              });
            };
          }
          var path = require2("path");
          if (!path.posix)
            path.posix = path;
          var Corestore = require2("corestore");
          var SwarmNetworker = require2("@corestore/networker");
          var Multifeed = require2("hypermultifeed");
          var MultifeedNetworker = require2("hypermultifeed/networker");
          var kappa = require2("kappa-core");
          var list = require2("@DougAnderson444/kappa-view-list");
          var memdb = require2("level-mem");
          var RAM = require2("random-access-memory");
          var RAI = require2("@DougAnderson444/random-access-idb");
          var hcrypto = require2("hypercore-crypto");
          var sodium = require2("sodium-universal");
          var EventEmitter = require2("events");
          var utils = require2("./utils.js");
          var DEFAULT_APPLICATION_NAME = "hypnsapplication";
          var DEFAULT_SWARM_OPTS = {
            extensions: [],
            preferredPort: 42666
          };
          var isBrowser = process.title === "browser";
          function getNewStorage(name) {
            if (isBrowser) {
              return RAI(name);
            } else {
              return name;
            }
          }
          class HyPNS {
            constructor() {
              var _this = this;
              var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              this.applicationName = opts.applicationName || DEFAULT_APPLICATION_NAME;
              this._storage = opts.persist === false ? RAM : getNewStorage(this.applicationName);
              this.store = opts.corestore || new Corestore(this._storage, opts.corestoreOpts);
              this.instances = /* @__PURE__ */ new Map();
              this.swarmOpts = opts.swarmOpts;
              this.opts = {
                staticNoiseKey: opts.staticNoiseKey || false
              };
              this.initialized = false;
              var closeHandler = /* @__PURE__ */ function() {
                var _ref = _asyncToGenerator(function* () {
                  console.log("Shutting down...");
                  yield _this.close();
                  process.exit();
                });
                return function closeHandler2() {
                  return _ref.apply(this, arguments);
                };
              }();
              process.on("SIGINT", closeHandler);
              process.on("SIGTERM", closeHandler);
            }
            get corestore() {
              return new Promise((resolve) => {
                this.store.ready().then(resolve(this.store));
              });
            }
            init() {
              var _this2 = this;
              return _asyncToGenerator(function* () {
                if (_this2.initialized)
                  return;
                yield _this2.store.ready();
                var swarmOpts = _this2.swarmOpts || {};
                if (_this2.opts.staticNoiseKey) {
                  var noiseSeed = _this2.store.inner._deriveSecret(_this2.applicationName, "replication-keypair");
                  var keyPair = {
                    publicKey: Buffer.alloc(sodium.crypto_scalarmult_BYTES),
                    secretKey: Buffer.alloc(sodium.crypto_scalarmult_SCALARBYTES)
                  };
                  sodium.crypto_kx_seed_keypair(keyPair.publicKey, keyPair.secretKey, noiseSeed);
                  Object.assign(swarmOpts, {
                    keyPair
                  }, DEFAULT_SWARM_OPTS);
                }
                _this2.swarmNetworker = new SwarmNetworker(_this2.store, swarmOpts);
                _this2.swarmNetworker.listen();
                _this2.initialized = true;
              })();
            }
            open(opts) {
              var _this3 = this;
              return _asyncToGenerator(function* () {
                if (!_this3.swarmNetworker)
                  yield _this3.init();
                if (!_this3.network)
                  _this3.network = new MultifeedNetworker(_this3.swarmNetworker);
                if (opts && opts.keypair && opts.keypair.publicKey && _this3.instances.has(opts.keypair.publicKey) && !opts.wallet) {
                  return _this3.instances.get(opts.keypair.publicKey);
                }
                var instance = new HyPNSInstance(_objectSpread(_objectSpread({}, opts), _this3));
                _this3.instances.set(instance.publicKey, instance);
                return _this3.instances.get(instance.publicKey);
              })();
            }
            close() {
              var _this4 = this;
              return _asyncToGenerator(function* () {
                _this4.store.close();
                if (_this4.swarmNetworker)
                  yield _this4.swarmNetworker.close();
              })();
            }
            getDeviceSeed() {
              var _arguments = arguments, _this5 = this;
              return _asyncToGenerator(function* () {
                var nameSpace = _arguments.length > 0 && _arguments[0] !== void 0 ? _arguments[0] : "device-seed";
                yield _this5.store.ready();
                var noiseSeed = _this5.store.inner._deriveSecret(_this5.applicationName, nameSpace);
                return noiseSeed;
              })();
            }
            getKeypair(seed) {
              var _this6 = this;
              return _asyncToGenerator(function* () {
                seed = seed || (yield _this6.getDeviceSeed());
                var keyPair = {
                  publicKey: Buffer.alloc(sodium.crypto_sign_PUBLICKEYBYTES),
                  secretKey: Buffer.alloc(sodium.crypto_sign_SECRETKEYBYTES)
                };
                sodium.crypto_sign_seed_keypair(keyPair.publicKey, keyPair.secretKey, seed);
                return keyPair;
              })();
            }
            deriveKeypair(context, subkeyNumber, origSeed) {
              var _this7 = this;
              return _asyncToGenerator(function* () {
                origSeed = origSeed || (yield _this7.getDeviceSeed());
                var newSeed = Buffer.alloc(sodium.crypto_sign_SEEDBYTES);
                var ctx = Buffer.alloc(sodium.crypto_kdf_CONTEXTBYTES);
                ctx.write(context);
                sodium.crypto_kdf_derive_from_key(newSeed, subkeyNumber, ctx, origSeed);
                return _this7.getKeypair(newSeed);
              })();
            }
          }
          class HyPNSInstance extends EventEmitter {
            constructor() {
              var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              super();
              if (!opts.keypair || !opts.keypair.publicKey || !opts.keypair.publicKey === null || Buffer.byteLength(opts.keypair.publicKey, "hex") !== sodium.crypto_sign_PUBLICKEYBYTES) {
                opts.keypair = hcrypto.keyPair();
              }
              if (opts.wallet)
                this.wallet = opts.wallet;
              this._keypair = opts.keypair || {};
              this.store = opts.temp ? new Corestore(RAM, opts.corestoreOpts) : opts.store;
              this.network = opts.network;
              this.latest = null;
              this.writable = false;
              this.publish = null;
              this.setMaxListeners(0);
            }
            ready() {
              var _this8 = this;
              return _asyncToGenerator(function* () {
                return new Promise(/* @__PURE__ */ function() {
                  var _ref2 = _asyncToGenerator(function* (resolve, reject) {
                    var self2 = _this8;
                    if (!!_this8.wallet) {
                      var pk = yield _this8.wallet.getPublicKey();
                      _this8._keypair.publicKey = Buffer.from(pk).toString("hex");
                    }
                    _this8.key = _this8._keypair.publicKey;
                    _this8.multi = new Multifeed(_this8.store, {
                      rootKey: _this8._keypair.publicKey,
                      valueEncoding: "json"
                    });
                    _this8.network.swarm(_this8.multi);
                    _this8.multi.ready(/* @__PURE__ */ function() {
                      var _ref3 = _asyncToGenerator(function* (err) {
                        if (err)
                          throw Error("Multifeed not ready");
                        _this8.core = kappa(_this8.store, {
                          multifeed: _this8.multi
                        });
                        var timestampView = list(memdb(), (msg, next) => {
                          var valid = msg.value && msg.value.payload && msg.value.timestamp && typeof msg.value.timestamp === "string" && _this8.verify(Buffer.from(utils.hashIt(JSON.stringify(msg.value.payload) + "." + msg.value.timestamp), "utf8"), Buffer.from(msg.value.signature, "hex"));
                          if (valid) {
                            next(null, [msg.value.timestamp]);
                          } else {
                            next();
                          }
                        });
                        if (_this8.core.feeds().length > 0) {
                          yield new Promise((resolve2, reject2) => {
                            _this8.core.feeds()[0].ready(() => {
                              resolve2();
                            });
                          });
                        }
                        _this8.core.use("pointer", timestampView);
                        _this8.core.api.pointer.tail(1, (msgs) => {
                          _this8.latest = msgs[0].value.payload;
                          _this8.emit("update", msgs[0].value.payload);
                        });
                        _this8.readLatest = /* @__PURE__ */ _asyncToGenerator(function* () {
                          var limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
                          return new Promise((resolve2, reject2) => {
                            var _this8$core, _this8$core$api;
                            if (!((_this8$core = _this8.core) !== null && _this8$core !== void 0 && (_this8$core$api = _this8$core.api) !== null && _this8$core$api !== void 0 && _this8$core$api.pointer))
                              resolve2(false);
                            _this8.core.api.pointer.read({
                              limit,
                              reverse: true
                            }, (err2, msgs) => {
                              if (err2)
                                console.error(err2);
                              if (msgs.length > 0) {
                                _this8.latest = msgs[0].value.payload;
                                resolve2(msgs);
                              } else {
                                resolve2(false);
                              }
                            });
                          });
                        });
                        _this8.core.ready(/* @__PURE__ */ function() {
                          var _ref5 = _asyncToGenerator(function* (err2) {
                            if (err2)
                              throw Error("Core not ready");
                            _this8.readLatest();
                            var writable = yield _this8.writeEnabled();
                            if (writable) {
                              _this8.core.writer("kappa-local", /* @__PURE__ */ function() {
                                var _ref6 = _asyncToGenerator(function* (err3, feed) {
                                  if (err3)
                                    reject(err3);
                                  function pub(_x7) {
                                    return _pub.apply(this, arguments);
                                  }
                                  function _pub() {
                                    _pub = _asyncToGenerator(function* (payload) {
                                      var timestamp = new Date().toISOString();
                                      var dataToSign = Buffer.from(utils.hashIt(JSON.stringify(payload) + "." + timestamp), "utf8");
                                      var signature;
                                      if (!!self2.wallet) {
                                        signature = yield self2.wallet.ed25519.sign(dataToSign);
                                        signature = Buffer.from(signature);
                                      } else {
                                        signature = hcrypto.sign(
                                          dataToSign,
                                          Buffer.from(self2._keypair.secretKey, "hex")
                                        );
                                      }
                                      var objPub = {
                                        payload,
                                        signature: signature.toString("hex"),
                                        timestamp
                                      };
                                      this.append(objPub);
                                      return objPub;
                                    });
                                    return _pub.apply(this, arguments);
                                  }
                                  _this8.publish = yield pub.bind(feed);
                                  feed.ready(() => {
                                    _this8.writable = true;
                                    resolve(_this8);
                                  });
                                });
                                return function(_x5, _x6) {
                                  return _ref6.apply(this, arguments);
                                };
                              }());
                            } else {
                              resolve(_this8);
                            }
                          });
                          return function(_x4) {
                            return _ref5.apply(this, arguments);
                          };
                        }());
                      });
                      return function(_x3) {
                        return _ref3.apply(this, arguments);
                      };
                    }());
                  });
                  return function(_x, _x2) {
                    return _ref2.apply(this, arguments);
                  };
                }());
              })();
            }
            close() {
              var _this9 = this;
              return _asyncToGenerator(function* () {
                _this9.multi.close();
              })();
            }
            writeEnabled() {
              var _this10 = this;
              return _asyncToGenerator(function* () {
                var message = Buffer.from("any msg will do", "utf8");
                var signature;
                if (_this10.wallet) {
                  var pk = yield _this10.wallet.getPublicKey();
                  return !!pk;
                } else {
                  if (!_this10._keypair.secretKey || Buffer.byteLength(_this10._keypair.secretKey, "hex") !== sodium.crypto_sign_SECRETKEYBYTES) {
                    return false;
                  }
                  signature = Buffer.allocUnsafe(sodium.crypto_sign_BYTES);
                  sodium.crypto_sign_detached(signature, message, Buffer.from(_this10._keypair.secretKey, "hex"));
                }
                return sodium.crypto_sign_verify_detached(signature, message, Buffer.from(_this10._keypair.publicKey, "hex"));
              })();
            }
            get publicKey() {
              return this._keypair.publicKey;
            }
            verify(message, signature) {
              return hcrypto.verify(message, signature, Buffer.from(this._keypair.publicKey, "hex"));
            }
          }
          module2.exports = HyPNS;
        }).call(this);
      }).call(this, require2("_process"), require2("buffer").Buffer);
    }, { "./utils.js": 543, "@DougAnderson444/kappa-view-list": 1, "@DougAnderson444/random-access-idb": 3, "@corestore/networker": 6, "_process": 361, "buffer": 82, "corestore": 109, "events": 193, "hypercore-crypto": 227, "hypermultifeed": 238, "hypermultifeed/networker": 240, "kappa-core": 265, "level-mem": 275, "path": 352, "random-access-memory": 380, "sodium-universal": 474 }], 543: [function(require2, module2, exports2) {
      (function(Buffer) {
        (function() {
          var sodium = require2("sodium-universal");
          module2.exports.hashIt = function(data) {
            var dataBuffer = Buffer.from(data);
            var hash = Buffer.allocUnsafe(sodium.crypto_generichash_BYTES);
            sodium.crypto_generichash(hash, dataBuffer);
            return hash;
          };
        }).call(this);
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 82, "sodium-universal": 474 }] }, {}, [542])(542);
  });
})(hypnsBundle$2);
const hypnsBundle = /* @__PURE__ */ getDefaultExportFromCjs(hypnsBundle$2.exports);
const hypnsBundle$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: hypnsBundle
}, [hypnsBundle$2.exports]);
export {
  hypnsBundle$1 as h
};
//# sourceMappingURL=hypns-bundle-4f2fbde4.js.map
